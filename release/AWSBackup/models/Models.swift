// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BackupClientTypes.AdvancedBackupSetting: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, backupoptions0) in backupOptions {
                try backupOptionsContainer.encode(backupoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
    }
}

extension BackupClientTypes.AdvancedBackupSetting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdvancedBackupSetting(backupOptions: \(Swift.String(describing: backupOptions)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension BackupClientTypes {
    /// A list of backup options for each resource type.
    public struct AdvancedBackupSetting: Swift.Equatable {
        /// Specifies the backup option for a selected resource. This option is only available for Windows VSS backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. The WindowsVSS option is not enabled by default. If you specify an invalid option, you get an InvalidParameterValueException exception. For more information about Windows VSS backups, see [Creating a VSS-Enabled Windows Backup](https://docs.aws.amazon.com/aws-backup/latest/devguide/windows-backups.html).
        public var backupOptions: [Swift.String:Swift.String]?
        /// Specifies an object containing resource type and backup options. The only supported resource type is Amazon EC2 instances with Windows Volume Shadow Copy Service (VSS). For a CloudFormation example, see the [sample CloudFormation template to enable Windows VSS](https://docs.aws.amazon.com/aws-backup/latest/devguide/integrate-cloudformation-with-aws-backup.html) in the Backup User Guide. Valid values: EC2.
        public var resourceType: Swift.String?

        public init (
            backupOptions: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }
    }

}

extension AlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlreadyExistsException(arn: \(Swift.String(describing: arn)), code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension AlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.code = output.code
            self.context = output.context
            self.creatorRequestId = output.creatorRequestId
            self.message = output.message
            self.type = output.type
        } else {
            self.arn = nil
            self.code = nil
            self.context = nil
            self.creatorRequestId = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The required resource already exists.
public struct AlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    ///
    public var arn: Swift.String?
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    ///
    public var creatorRequestId: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        arn: Swift.String? = nil,
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.arn = arn
        self.code = code
        self.context = context
        self.creatorRequestId = creatorRequestId
        self.message = message
        self.type = type
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let creatorRequestId: Swift.String?
    public let arn: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case code = "Code"
        case context = "Context"
        case creatorRequestId = "CreatorRequestId"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.BackupJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupJobId = "BackupJobId"
        case backupOptions = "BackupOptions"
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupType = "BackupType"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case bytesTransferred = "BytesTransferred"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case expectedCompletionDate = "ExpectedCompletionDate"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case startBy = "StartBy"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupJobId = backupJobId {
            try encodeContainer.encode(backupJobId, forKey: .backupJobId)
        }
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, backupoptions0) in backupOptions {
                try backupOptionsContainer.encode(backupoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let backupSizeInBytes = backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let backupType = backupType {
            try encodeContainer.encode(backupType, forKey: .backupType)
        }
        if let backupVaultArn = backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let bytesTransferred = bytesTransferred {
            try encodeContainer.encode(bytesTransferred, forKey: .bytesTransferred)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate.timeIntervalSince1970, forKey: .completionDate)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let expectedCompletionDate = expectedCompletionDate {
            try encodeContainer.encode(expectedCompletionDate.timeIntervalSince1970, forKey: .expectedCompletionDate)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let percentDone = percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let startBy = startBy {
            try encodeContainer.encode(startBy.timeIntervalSince1970, forKey: .startBy)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let backupJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let expectedCompletionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expectedCompletionDate)
        expectedCompletionDate = expectedCompletionDateDecoded
        let startByDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startBy)
        startBy = startByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
        let backupTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupType)
        backupType = backupTypeDecoded
    }
}

extension BackupClientTypes.BackupJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupJob(accountId: \(Swift.String(describing: accountId)), backupJobId: \(Swift.String(describing: backupJobId)), backupOptions: \(Swift.String(describing: backupOptions)), backupSizeInBytes: \(Swift.String(describing: backupSizeInBytes)), backupType: \(Swift.String(describing: backupType)), backupVaultArn: \(Swift.String(describing: backupVaultArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), bytesTransferred: \(Swift.String(describing: bytesTransferred)), completionDate: \(Swift.String(describing: completionDate)), createdBy: \(Swift.String(describing: createdBy)), creationDate: \(Swift.String(describing: creationDate)), expectedCompletionDate: \(Swift.String(describing: expectedCompletionDate)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), percentDone: \(Swift.String(describing: percentDone)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)), startBy: \(Swift.String(describing: startBy)), state: \(Swift.String(describing: state)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension BackupClientTypes {
    /// Contains detailed information about a backup job.
    public struct BackupJob: Swift.Equatable {
        /// The account ID that owns the backup job.
        public var accountId: Swift.String?
        /// Uniquely identifies a request to Backup to back up a resource.
        public var backupJobId: Swift.String?
        /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS":"disabled" to create a regular backup. If you specify an invalid option, you get an InvalidParameterValueException exception.
        public var backupOptions: [Swift.String:Swift.String]?
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int?
        /// Represents the type of backup for a backup job.
        public var backupType: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The size in bytes transferred to a backup vault at the time that the job status was queried.
        public var bytesTransferred: Swift.Int?
        /// The date and time a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The date and time a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var expectedCompletionDate: ClientRuntime.Date?
        /// Specifies the IAM role ARN used to create the target recovery point. IAM roles other than the default role must include either AWSBackup or AwsBackup in the role name. For example, arn:aws:iam::123456789012:role/AWSBackupRDSAccess. Role names without those strings lack permissions to perform backup jobs.
        public var iamRoleArn: Swift.String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public var percentDone: Swift.String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var startBy: ClientRuntime.Date?
        /// The current state of a resource recovery point.
        public var state: BackupClientTypes.BackupJobState?
        /// A detailed message explaining the status of the job to back up a resource.
        public var statusMessage: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            backupJobId: Swift.String? = nil,
            backupOptions: [Swift.String:Swift.String]? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            backupType: Swift.String? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            bytesTransferred: Swift.Int? = nil,
            completionDate: ClientRuntime.Date? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: ClientRuntime.Date? = nil,
            expectedCompletionDate: ClientRuntime.Date? = nil,
            iamRoleArn: Swift.String? = nil,
            percentDone: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            startBy: ClientRuntime.Date? = nil,
            state: BackupClientTypes.BackupJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupJobId = backupJobId
            self.backupOptions = backupOptions
            self.backupSizeInBytes = backupSizeInBytes
            self.backupType = backupType
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.bytesTransferred = bytesTransferred
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.expectedCompletionDate = expectedCompletionDate
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.startBy = startBy
            self.state = state
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes {
    public enum BackupJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case aborting
        case completed
        case created
        case expired
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupJobState] {
            return [
                .aborted,
                .aborting,
                .completed,
                .created,
                .expired,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .aborting: return "ABORTING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupJobState(rawValue: rawValue) ?? BackupJobState.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.BackupPlan: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanName = "BackupPlanName"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsettings0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsettings0)
            }
        }
        if let backupPlanName = backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for backuprules0 in rules {
                try rulesContainer.encode(backuprules0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let rulesContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupRule?].self, forKey: .rules)
        var rulesDecoded0:[BackupClientTypes.BackupRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [BackupClientTypes.BackupRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupClientTypes.BackupPlan: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupPlan(advancedBackupSettings: \(Swift.String(describing: advancedBackupSettings)), backupPlanName: \(Swift.String(describing: backupPlanName)), rules: \(Swift.String(describing: rules)))"}
}

extension BackupClientTypes {
    /// Contains an optional backup plan display name and an array of BackupRule objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task and can back up a different selection of Amazon Web Services resources.
    public struct BackupPlan: Swift.Equatable {
        /// Contains a list of BackupOptions for each resource type.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        /// This member is required.
        public var rules: [BackupClientTypes.BackupRule]?

        public init (
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanName: Swift.String? = nil,
            rules: [BackupClientTypes.BackupRule]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }
    }

}

extension BackupClientTypes.BackupPlanInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanName = "BackupPlanName"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsettings0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsettings0)
            }
        }
        if let backupPlanName = backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for backuprulesinput0 in rules {
                try rulesContainer.encode(backuprulesinput0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let rulesContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupRuleInput?].self, forKey: .rules)
        var rulesDecoded0:[BackupClientTypes.BackupRuleInput]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [BackupClientTypes.BackupRuleInput]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupClientTypes.BackupPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupPlanInput(advancedBackupSettings: \(Swift.String(describing: advancedBackupSettings)), backupPlanName: \(Swift.String(describing: backupPlanName)), rules: \(Swift.String(describing: rules)))"}
}

extension BackupClientTypes {
    /// Contains an optional backup plan display name and an array of BackupRule objects, each of which specifies a backup rule. Each rule in a backup plan is a separate scheduled task.
    public struct BackupPlanInput: Swift.Equatable {
        /// Specifies a list of BackupOptions for each resource type. These settings are only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// The display name of a backup plan. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        /// This member is required.
        public var rules: [BackupClientTypes.BackupRuleInput]?

        public init (
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanName: Swift.String? = nil,
            rules: [BackupClientTypes.BackupRuleInput]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.rules = rules
        }
    }

}

extension BackupClientTypes.BackupPlanTemplatesListMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateId = "BackupPlanTemplateId"
        case backupPlanTemplateName = "BackupPlanTemplateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanTemplateId = backupPlanTemplateId {
            try encodeContainer.encode(backupPlanTemplateId, forKey: .backupPlanTemplateId)
        }
        if let backupPlanTemplateName = backupPlanTemplateName {
            try encodeContainer.encode(backupPlanTemplateName, forKey: .backupPlanTemplateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateId)
        backupPlanTemplateId = backupPlanTemplateIdDecoded
        let backupPlanTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateName)
        backupPlanTemplateName = backupPlanTemplateNameDecoded
    }
}

extension BackupClientTypes.BackupPlanTemplatesListMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupPlanTemplatesListMember(backupPlanTemplateId: \(Swift.String(describing: backupPlanTemplateId)), backupPlanTemplateName: \(Swift.String(describing: backupPlanTemplateName)))"}
}

extension BackupClientTypes {
    /// An object specifying metadata associated with a backup plan template.
    public struct BackupPlanTemplatesListMember: Swift.Equatable {
        /// Uniquely identifies a stored backup plan template.
        public var backupPlanTemplateId: Swift.String?
        /// The optional display name of a backup plan template.
        public var backupPlanTemplateName: Swift.String?

        public init (
            backupPlanTemplateId: Swift.String? = nil,
            backupPlanTemplateName: Swift.String? = nil
        )
        {
            self.backupPlanTemplateId = backupPlanTemplateId
            self.backupPlanTemplateName = backupPlanTemplateName
        }
    }

}

extension BackupClientTypes.BackupPlansListMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case backupPlanName = "BackupPlanName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case deletionDate = "DeletionDate"
        case lastExecutionDate = "LastExecutionDate"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for advancedbackupsettings0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(advancedbackupsettings0)
            }
        }
        if let backupPlanArn = backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let backupPlanName = backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let deletionDate = deletionDate {
            try encodeContainer.encode(deletionDate.timeIntervalSince1970, forKey: .deletionDate)
        }
        if let lastExecutionDate = lastExecutionDate {
            try encodeContainer.encode(lastExecutionDate.timeIntervalSince1970, forKey: .lastExecutionDate)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension BackupClientTypes.BackupPlansListMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupPlansListMember(advancedBackupSettings: \(Swift.String(describing: advancedBackupSettings)), backupPlanArn: \(Swift.String(describing: backupPlanArn)), backupPlanId: \(Swift.String(describing: backupPlanId)), backupPlanName: \(Swift.String(describing: backupPlanName)), creationDate: \(Swift.String(describing: creationDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), deletionDate: \(Swift.String(describing: deletionDate)), lastExecutionDate: \(Swift.String(describing: lastExecutionDate)), versionId: \(Swift.String(describing: versionId)))"}
}

extension BackupClientTypes {
    /// Contains metadata about a backup plan.
    public struct BackupPlansListMember: Swift.Equatable {
        /// Contains a list of BackupOptions for a resource type.
        public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// The display name of a saved backup plan.
        public var backupPlanName: Swift.String?
        /// The date and time a resource backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var deletionDate: ClientRuntime.Date?
        /// The last time a job to back up resources was run with this rule. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastExecutionDate: ClientRuntime.Date?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public var versionId: Swift.String?

        public init (
            advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            deletionDate: ClientRuntime.Date? = nil,
            lastExecutionDate: ClientRuntime.Date? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanName = backupPlanName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.deletionDate = deletionDate
            self.lastExecutionDate = lastExecutionDate
            self.versionId = versionId
        }
    }

}

extension BackupClientTypes.BackupRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionWindowMinutes = "CompletionWindowMinutes"
        case copyActions = "CopyActions"
        case enableContinuousBackup = "EnableContinuousBackup"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case ruleId = "RuleId"
        case ruleName = "RuleName"
        case scheduleExpression = "ScheduleExpression"
        case startWindowMinutes = "StartWindowMinutes"
        case targetBackupVaultName = "TargetBackupVaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionWindowMinutes = completionWindowMinutes {
            try encodeContainer.encode(completionWindowMinutes, forKey: .completionWindowMinutes)
        }
        if let copyActions = copyActions {
            var copyActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyActions)
            for copyactions0 in copyActions {
                try copyActionsContainer.encode(copyactions0)
            }
        }
        if let enableContinuousBackup = enableContinuousBackup {
            try encodeContainer.encode(enableContinuousBackup, forKey: .enableContinuousBackup)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let startWindowMinutes = startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
        if let targetBackupVaultName = targetBackupVaultName {
            try encodeContainer.encode(targetBackupVaultName, forKey: .targetBackupVaultName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let targetBackupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBackupVaultName)
        targetBackupVaultName = targetBackupVaultNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completionWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completionWindowMinutes)
        completionWindowMinutes = completionWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let copyActionsContainer = try containerValues.decodeIfPresent([BackupClientTypes.CopyAction?].self, forKey: .copyActions)
        var copyActionsDecoded0:[BackupClientTypes.CopyAction]? = nil
        if let copyActionsContainer = copyActionsContainer {
            copyActionsDecoded0 = [BackupClientTypes.CopyAction]()
            for structure0 in copyActionsContainer {
                if let structure0 = structure0 {
                    copyActionsDecoded0?.append(structure0)
                }
            }
        }
        copyActions = copyActionsDecoded0
        let enableContinuousBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableContinuousBackup)
        enableContinuousBackup = enableContinuousBackupDecoded
    }
}

extension BackupClientTypes.BackupRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupRule(completionWindowMinutes: \(Swift.String(describing: completionWindowMinutes)), copyActions: \(Swift.String(describing: copyActions)), enableContinuousBackup: \(Swift.String(describing: enableContinuousBackup)), lifecycle: \(Swift.String(describing: lifecycle)), recoveryPointTags: \(Swift.String(describing: recoveryPointTags)), ruleId: \(Swift.String(describing: ruleId)), ruleName: \(Swift.String(describing: ruleName)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), targetBackupVaultName: \(Swift.String(describing: targetBackupVaultName)))"}
}

extension BackupClientTypes {
    /// Specifies a scheduled task used to back up a selection of resources.
    public struct BackupRule: Swift.Equatable {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public var completionWindowMinutes: Swift.Int?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public var copyActions: [BackupClientTypes.CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public var enableContinuousBackup: Swift.Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// An array of key-value pair strings that are assigned to resources that are associated with this rule when restored from backup.
        public var recoveryPointTags: [Swift.String:Swift.String]?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public var ruleId: Swift.String?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var ruleName: Swift.String?
        /// A cron expression in UTC specifying when Backup initiates a backup job. For more information about Amazon Web Services cron expressions, see [Schedule Expressions for Rules](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html) in the Amazon CloudWatch Events User Guide.. Two examples of Amazon Web Services cron expressions are  15 * ? * * * (take a backup every hour at 15 minutes past the hour) and 0 12 * * ? * (take a backup every day at 12 noon UTC). For a table of examples, click the preceding link and scroll down the page.
        public var scheduleExpression: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional.
        public var startWindowMinutes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        /// This member is required.
        public var targetBackupVaultName: Swift.String?

        public init (
            completionWindowMinutes: Swift.Int? = nil,
            copyActions: [BackupClientTypes.CopyAction]? = nil,
            enableContinuousBackup: Swift.Bool? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            recoveryPointTags: [Swift.String:Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            startWindowMinutes: Swift.Int? = nil,
            targetBackupVaultName: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }
    }

}

extension BackupClientTypes.BackupRuleInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionWindowMinutes = "CompletionWindowMinutes"
        case copyActions = "CopyActions"
        case enableContinuousBackup = "EnableContinuousBackup"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case ruleName = "RuleName"
        case scheduleExpression = "ScheduleExpression"
        case startWindowMinutes = "StartWindowMinutes"
        case targetBackupVaultName = "TargetBackupVaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionWindowMinutes = completionWindowMinutes {
            try encodeContainer.encode(completionWindowMinutes, forKey: .completionWindowMinutes)
        }
        if let copyActions = copyActions {
            var copyActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyActions)
            for copyactions0 in copyActions {
                try copyActionsContainer.encode(copyactions0)
            }
        }
        if let enableContinuousBackup = enableContinuousBackup {
            try encodeContainer.encode(enableContinuousBackup, forKey: .enableContinuousBackup)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let startWindowMinutes = startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
        if let targetBackupVaultName = targetBackupVaultName {
            try encodeContainer.encode(targetBackupVaultName, forKey: .targetBackupVaultName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let targetBackupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBackupVaultName)
        targetBackupVaultName = targetBackupVaultNameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completionWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completionWindowMinutes)
        completionWindowMinutes = completionWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let copyActionsContainer = try containerValues.decodeIfPresent([BackupClientTypes.CopyAction?].self, forKey: .copyActions)
        var copyActionsDecoded0:[BackupClientTypes.CopyAction]? = nil
        if let copyActionsContainer = copyActionsContainer {
            copyActionsDecoded0 = [BackupClientTypes.CopyAction]()
            for structure0 in copyActionsContainer {
                if let structure0 = structure0 {
                    copyActionsDecoded0?.append(structure0)
                }
            }
        }
        copyActions = copyActionsDecoded0
        let enableContinuousBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableContinuousBackup)
        enableContinuousBackup = enableContinuousBackupDecoded
    }
}

extension BackupClientTypes.BackupRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupRuleInput(completionWindowMinutes: \(Swift.String(describing: completionWindowMinutes)), copyActions: \(Swift.String(describing: copyActions)), enableContinuousBackup: \(Swift.String(describing: enableContinuousBackup)), lifecycle: \(Swift.String(describing: lifecycle)), recoveryPointTags: \(Swift.String(describing: recoveryPointTags)), ruleName: \(Swift.String(describing: ruleName)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)), targetBackupVaultName: \(Swift.String(describing: targetBackupVaultName)))"}
}

extension BackupClientTypes {
    /// Specifies a scheduled task used to back up a selection of resources.
    public struct BackupRuleInput: Swift.Equatable {
        /// A value in minutes after a backup job is successfully started before it must be completed or it will be canceled by Backup. This value is optional.
        public var completionWindowMinutes: Swift.Int?
        /// An array of CopyAction objects, which contains the details of the copy operation.
        public var copyActions: [BackupClientTypes.CopyAction]?
        /// Specifies whether Backup creates continuous backups. True causes Backup to create continuous backups capable of point-in-time restore (PITR). False (or not specified) causes Backup to create snapshot backups.
        public var enableContinuousBackup: Swift.Bool?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.
        public var recoveryPointTags: [Swift.String:Swift.String]?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var ruleName: Swift.String?
        /// A CRON expression in UTC specifying when Backup initiates a backup job.
        public var scheduleExpression: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional.
        public var startWindowMinutes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        /// This member is required.
        public var targetBackupVaultName: Swift.String?

        public init (
            completionWindowMinutes: Swift.Int? = nil,
            copyActions: [BackupClientTypes.CopyAction]? = nil,
            enableContinuousBackup: Swift.Bool? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            recoveryPointTags: [Swift.String:Swift.String]? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            startWindowMinutes: Swift.Int? = nil,
            targetBackupVaultName: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.recoveryPointTags = recoveryPointTags
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVaultName = targetBackupVaultName
        }
    }

}

extension BackupClientTypes.BackupSelection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditions = "Conditions"
        case iamRoleArn = "IamRoleArn"
        case listOfTags = "ListOfTags"
        case notResources = "NotResources"
        case resources = "Resources"
        case selectionName = "SelectionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditions = conditions {
            try encodeContainer.encode(conditions, forKey: .conditions)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let listOfTags = listOfTags {
            var listOfTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listOfTags)
            for listoftags0 in listOfTags {
                try listOfTagsContainer.encode(listoftags0)
            }
        }
        if let notResources = notResources {
            var notResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notResources)
            for resourcearns0 in notResources {
                try notResourcesContainer.encode(resourcearns0)
            }
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resourcearns0 in resources {
                try resourcesContainer.encode(resourcearns0)
            }
        }
        if let selectionName = selectionName {
            try encodeContainer.encode(selectionName, forKey: .selectionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionName)
        selectionName = selectionNameDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let listOfTagsContainer = try containerValues.decodeIfPresent([BackupClientTypes.Condition?].self, forKey: .listOfTags)
        var listOfTagsDecoded0:[BackupClientTypes.Condition]? = nil
        if let listOfTagsContainer = listOfTagsContainer {
            listOfTagsDecoded0 = [BackupClientTypes.Condition]()
            for structure0 in listOfTagsContainer {
                if let structure0 = structure0 {
                    listOfTagsDecoded0?.append(structure0)
                }
            }
        }
        listOfTags = listOfTagsDecoded0
        let notResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notResources)
        var notResourcesDecoded0:[Swift.String]? = nil
        if let notResourcesContainer = notResourcesContainer {
            notResourcesDecoded0 = [Swift.String]()
            for string0 in notResourcesContainer {
                if let string0 = string0 {
                    notResourcesDecoded0?.append(string0)
                }
            }
        }
        notResources = notResourcesDecoded0
        let conditionsDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Conditions.self, forKey: .conditions)
        conditions = conditionsDecoded
    }
}

extension BackupClientTypes.BackupSelection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupSelection(conditions: \(Swift.String(describing: conditions)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), listOfTags: \(Swift.String(describing: listOfTags)), notResources: \(Swift.String(describing: notResources)), resources: \(Swift.String(describing: resources)), selectionName: \(Swift.String(describing: selectionName)))"}
}

extension BackupClientTypes {
    /// Used to specify a set of resources to a backup plan.
    public struct BackupSelection: Swift.Equatable {
        /// A list of conditions that you define to assign resources to your backup plans using tags. For example, "StringEquals": {"Department": "accounting". Condition operators are case sensitive. Conditions differs from ListOfTags as follows:
        ///
        /// * When you specify more than one condition, you only assign the resources that match ALL conditions (using AND logic).
        ///
        /// * Conditions supports StringEquals, StringLike, StringNotEquals, and StringNotLike. ListOfTags only supports StringEquals.
        public var conditions: BackupClientTypes.Conditions?
        /// The ARN of the IAM role that Backup uses to authenticate when backing up the target resource; for example, arn:aws:iam::123456789012:role/S3Access.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// A list of conditions that you define to assign resources to your backup plans using tags. For example, "StringEquals": {"Department": "accounting". Condition operators are case sensitive. ListOfTags differs from Conditions as follows:
        ///
        /// * When you specify more than one condition, you assign all resources that match AT LEAST ONE condition (using OR logic).
        ///
        /// * ListOfTags only supports StringEquals. Conditions supports StringEquals, StringLike, StringNotEquals, and StringNotLike.
        public var listOfTags: [BackupClientTypes.Condition]?
        /// A list of Amazon Resource Names (ARNs) to exclude from a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to exclude many resources from a backup plan, consider a different resource selection strategy, such as assigning only one or a few resource types or refining your resource selection using tags.
        public var notResources: [Swift.String]?
        /// A list of Amazon Resource Names (ARNs) to assign to a backup plan. The maximum number of ARNs is 500 without wildcards, or 30 ARNs with wildcards. If you need to assign many resources to a backup plan, consider a different resource selection strategy, such as assigning all resources of a resource type or refining your resource selection using tags.
        public var resources: [Swift.String]?
        /// The display name of a resource selection document. Must contain 1 to 50 alphanumeric or '-_.' characters.
        /// This member is required.
        public var selectionName: Swift.String?

        public init (
            conditions: BackupClientTypes.Conditions? = nil,
            iamRoleArn: Swift.String? = nil,
            listOfTags: [BackupClientTypes.Condition]? = nil,
            notResources: [Swift.String]? = nil,
            resources: [Swift.String]? = nil,
            selectionName: Swift.String? = nil
        )
        {
            self.conditions = conditions
            self.iamRoleArn = iamRoleArn
            self.listOfTags = listOfTags
            self.notResources = notResources
            self.resources = resources
            self.selectionName = selectionName
        }
    }

}

extension BackupClientTypes.BackupSelectionsListMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case iamRoleArn = "IamRoleArn"
        case selectionId = "SelectionId"
        case selectionName = "SelectionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanId = backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let selectionId = selectionId {
            try encodeContainer.encode(selectionId, forKey: .selectionId)
        }
        if let selectionName = selectionName {
            try encodeContainer.encode(selectionName, forKey: .selectionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let selectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionName)
        selectionName = selectionNameDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension BackupClientTypes.BackupSelectionsListMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupSelectionsListMember(backupPlanId: \(Swift.String(describing: backupPlanId)), creationDate: \(Swift.String(describing: creationDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), selectionId: \(Swift.String(describing: selectionId)), selectionName: \(Swift.String(describing: selectionName)))"}
}

extension BackupClientTypes {
    /// Contains metadata about a BackupSelection object.
    public struct BackupSelectionsListMember: Swift.Equatable {
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// Specifies the IAM role Amazon Resource Name (ARN) to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// Uniquely identifies a request to assign a set of resources to a backup plan.
        public var selectionId: Swift.String?
        /// The display name of a resource selection document.
        public var selectionName: Swift.String?

        public init (
            backupPlanId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            selectionId: Swift.String? = nil,
            selectionName: Swift.String? = nil
        )
        {
            self.backupPlanId = backupPlanId
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.iamRoleArn = iamRoleArn
            self.selectionId = selectionId
            self.selectionName = selectionName
        }
    }

}

extension BackupClientTypes {
    public enum BackupVaultEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupJobCompleted
        case backupJobExpired
        case backupJobFailed
        case backupJobStarted
        case backupJobSuccessful
        case backupPlanCreated
        case backupPlanModified
        case copyJobFailed
        case copyJobStarted
        case copyJobSuccessful
        case recoveryPointModified
        case restoreJobCompleted
        case restoreJobFailed
        case restoreJobStarted
        case restoreJobSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupVaultEvent] {
            return [
                .backupJobCompleted,
                .backupJobExpired,
                .backupJobFailed,
                .backupJobStarted,
                .backupJobSuccessful,
                .backupPlanCreated,
                .backupPlanModified,
                .copyJobFailed,
                .copyJobStarted,
                .copyJobSuccessful,
                .recoveryPointModified,
                .restoreJobCompleted,
                .restoreJobFailed,
                .restoreJobStarted,
                .restoreJobSuccessful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupJobCompleted: return "BACKUP_JOB_COMPLETED"
            case .backupJobExpired: return "BACKUP_JOB_EXPIRED"
            case .backupJobFailed: return "BACKUP_JOB_FAILED"
            case .backupJobStarted: return "BACKUP_JOB_STARTED"
            case .backupJobSuccessful: return "BACKUP_JOB_SUCCESSFUL"
            case .backupPlanCreated: return "BACKUP_PLAN_CREATED"
            case .backupPlanModified: return "BACKUP_PLAN_MODIFIED"
            case .copyJobFailed: return "COPY_JOB_FAILED"
            case .copyJobStarted: return "COPY_JOB_STARTED"
            case .copyJobSuccessful: return "COPY_JOB_SUCCESSFUL"
            case .recoveryPointModified: return "RECOVERY_POINT_MODIFIED"
            case .restoreJobCompleted: return "RESTORE_JOB_COMPLETED"
            case .restoreJobFailed: return "RESTORE_JOB_FAILED"
            case .restoreJobStarted: return "RESTORE_JOB_STARTED"
            case .restoreJobSuccessful: return "RESTORE_JOB_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupVaultEvent(rawValue: rawValue) ?? BackupVaultEvent.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.BackupVaultListMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
        case lockDate = "LockDate"
        case locked = "Locked"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
        case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultArn = backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let lockDate = lockDate {
            try encodeContainer.encode(lockDate.timeIntervalSince1970, forKey: .lockDate)
        }
        if let locked = locked {
            try encodeContainer.encode(locked, forKey: .locked)
        }
        if let maxRetentionDays = maxRetentionDays {
            try encodeContainer.encode(maxRetentionDays, forKey: .maxRetentionDays)
        }
        if let minRetentionDays = minRetentionDays {
            try encodeContainer.encode(minRetentionDays, forKey: .minRetentionDays)
        }
        if numberOfRecoveryPoints != 0 {
            try encodeContainer.encode(numberOfRecoveryPoints, forKey: .numberOfRecoveryPoints)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let numberOfRecoveryPointsDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfRecoveryPoints)
        numberOfRecoveryPoints = numberOfRecoveryPointsDecoded
        let lockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .locked)
        locked = lockedDecoded
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
        let lockDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lockDate)
        lockDate = lockDateDecoded
    }
}

extension BackupClientTypes.BackupVaultListMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupVaultListMember(backupVaultArn: \(Swift.String(describing: backupVaultArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), creationDate: \(Swift.String(describing: creationDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), lockDate: \(Swift.String(describing: lockDate)), locked: \(Swift.String(describing: locked)), maxRetentionDays: \(Swift.String(describing: maxRetentionDays)), minRetentionDays: \(Swift.String(describing: minRetentionDays)), numberOfRecoveryPoints: \(Swift.String(describing: numberOfRecoveryPoints)))"}
}

extension BackupClientTypes {
    /// Contains metadata about a backup vault.
    public struct BackupVaultListMember: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The date and time a resource backup is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
        public var creatorRequestId: Swift.String?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public var encryptionKeyArn: Swift.String?
        /// The date and time when Backup Vault Lock configuration becomes immutable, meaning it cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lockDate: ClientRuntime.Date?
        /// A Boolean value that indicates whether Backup Vault Lock applies to the selected backup vault. If true, Vault Lock prevents delete and update operations on the recovery points in the selected vault.
        public var locked: Swift.Bool?
        /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public var maxRetentionDays: Swift.Int?
        /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
        public var minRetentionDays: Swift.Int?
        /// The number of recovery points that are stored in a backup vault.
        public var numberOfRecoveryPoints: Swift.Int

        public init (
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            lockDate: ClientRuntime.Date? = nil,
            locked: Swift.Bool? = nil,
            maxRetentionDays: Swift.Int? = nil,
            minRetentionDays: Swift.Int? = nil,
            numberOfRecoveryPoints: Swift.Int = 0
        )
        {
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.creatorRequestId = creatorRequestId
            self.encryptionKeyArn = encryptionKeyArn
            self.lockDate = lockDate
            self.locked = locked
            self.maxRetentionDays = maxRetentionDays
            self.minRetentionDays = minRetentionDays
            self.numberOfRecoveryPoints = numberOfRecoveryPoints
        }
    }

}

extension BackupClientTypes.CalculatedLifecycle: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAt = "DeleteAt"
        case moveToColdStorageAt = "MoveToColdStorageAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAt = deleteAt {
            try encodeContainer.encode(deleteAt.timeIntervalSince1970, forKey: .deleteAt)
        }
        if let moveToColdStorageAt = moveToColdStorageAt {
            try encodeContainer.encode(moveToColdStorageAt.timeIntervalSince1970, forKey: .moveToColdStorageAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moveToColdStorageAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .moveToColdStorageAt)
        moveToColdStorageAt = moveToColdStorageAtDecoded
        let deleteAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deleteAt)
        deleteAt = deleteAtDecoded
    }
}

extension BackupClientTypes.CalculatedLifecycle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculatedLifecycle(deleteAt: \(Swift.String(describing: deleteAt)), moveToColdStorageAt: \(Swift.String(describing: moveToColdStorageAt)))"}
}

extension BackupClientTypes {
    /// Contains DeleteAt and MoveToColdStorageAt timestamps, which are used to specify a lifecycle for a recovery point. The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
    public struct CalculatedLifecycle: Swift.Equatable {
        /// A timestamp that specifies when to delete a recovery point.
        public var deleteAt: ClientRuntime.Date?
        /// A timestamp that specifies when to transition a recovery point to cold storage.
        public var moveToColdStorageAt: ClientRuntime.Date?

        public init (
            deleteAt: ClientRuntime.Date? = nil,
            moveToColdStorageAt: ClientRuntime.Date? = nil
        )
        {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }
    }

}

extension BackupClientTypes.Condition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionKey = "ConditionKey"
        case conditionType = "ConditionType"
        case conditionValue = "ConditionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionKey = conditionKey {
            try encodeContainer.encode(conditionKey, forKey: .conditionKey)
        }
        if let conditionType = conditionType {
            try encodeContainer.encode(conditionType.rawValue, forKey: .conditionType)
        }
        if let conditionValue = conditionValue {
            try encodeContainer.encode(conditionValue, forKey: .conditionValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionTypeDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ConditionType.self, forKey: .conditionType)
        conditionType = conditionTypeDecoded
        let conditionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionKey)
        conditionKey = conditionKeyDecoded
        let conditionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionValue)
        conditionValue = conditionValueDecoded
    }
}

extension BackupClientTypes.Condition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Condition(conditionKey: \(Swift.String(describing: conditionKey)), conditionType: \(Swift.String(describing: conditionType)), conditionValue: \(Swift.String(describing: conditionValue)))"}
}

extension BackupClientTypes {
    /// Contains an array of triplets made up of a condition type (such as StringEquals), a key, and a value. Used to filter resources using their tags and assign them to a backup plan. Case sensitive.
    public struct Condition: Swift.Equatable {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        /// This member is required.
        public var conditionKey: Swift.String?
        /// An operation applied to a key-value pair used to assign resources to your backup plan. Condition only supports StringEquals. For more flexible assignment options, incluidng StringLike and the ability to exclude resources from your backup plan, use Conditions (with an "s" on the end) for your [BackupSelection](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_BackupSelection.html).
        /// This member is required.
        public var conditionType: BackupClientTypes.ConditionType?
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        /// This member is required.
        public var conditionValue: Swift.String?

        public init (
            conditionKey: Swift.String? = nil,
            conditionType: BackupClientTypes.ConditionType? = nil,
            conditionValue: Swift.String? = nil
        )
        {
            self.conditionKey = conditionKey
            self.conditionType = conditionType
            self.conditionValue = conditionValue
        }
    }

}

extension BackupClientTypes.ConditionParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionKey = "ConditionKey"
        case conditionValue = "ConditionValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionKey = conditionKey {
            try encodeContainer.encode(conditionKey, forKey: .conditionKey)
        }
        if let conditionValue = conditionValue {
            try encodeContainer.encode(conditionValue, forKey: .conditionValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionKey)
        conditionKey = conditionKeyDecoded
        let conditionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conditionValue)
        conditionValue = conditionValueDecoded
    }
}

extension BackupClientTypes.ConditionParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionParameter(conditionKey: \(Swift.String(describing: conditionKey)), conditionValue: \(Swift.String(describing: conditionValue)))"}
}

extension BackupClientTypes {
    /// Includes information about tags you define to assign tagged resources to a backup plan.
    public struct ConditionParameter: Swift.Equatable {
        /// The key in a key-value pair. For example, in the tag Department: Accounting, Department is the key.
        public var conditionKey: Swift.String?
        /// The value in a key-value pair. For example, in the tag Department: Accounting, Accounting is the value.
        public var conditionValue: Swift.String?

        public init (
            conditionKey: Swift.String? = nil,
            conditionValue: Swift.String? = nil
        )
        {
            self.conditionKey = conditionKey
            self.conditionValue = conditionValue
        }
    }

}

extension BackupClientTypes {
    public enum ConditionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stringequals
        case sdkUnknown(Swift.String)

        public static var allCases: [ConditionType] {
            return [
                .stringequals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stringequals: return "STRINGEQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConditionType(rawValue: rawValue) ?? ConditionType.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.Conditions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stringEquals = "StringEquals"
        case stringLike = "StringLike"
        case stringNotEquals = "StringNotEquals"
        case stringNotLike = "StringNotLike"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stringEquals = stringEquals {
            var stringEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringEquals)
            for conditionparameters0 in stringEquals {
                try stringEqualsContainer.encode(conditionparameters0)
            }
        }
        if let stringLike = stringLike {
            var stringLikeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringLike)
            for conditionparameters0 in stringLike {
                try stringLikeContainer.encode(conditionparameters0)
            }
        }
        if let stringNotEquals = stringNotEquals {
            var stringNotEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringNotEquals)
            for conditionparameters0 in stringNotEquals {
                try stringNotEqualsContainer.encode(conditionparameters0)
            }
        }
        if let stringNotLike = stringNotLike {
            var stringNotLikeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringNotLike)
            for conditionparameters0 in stringNotLike {
                try stringNotLikeContainer.encode(conditionparameters0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringEqualsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringEquals)
        var stringEqualsDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringEqualsContainer = stringEqualsContainer {
            stringEqualsDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringEqualsContainer {
                if let structure0 = structure0 {
                    stringEqualsDecoded0?.append(structure0)
                }
            }
        }
        stringEquals = stringEqualsDecoded0
        let stringNotEqualsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringNotEquals)
        var stringNotEqualsDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringNotEqualsContainer = stringNotEqualsContainer {
            stringNotEqualsDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringNotEqualsContainer {
                if let structure0 = structure0 {
                    stringNotEqualsDecoded0?.append(structure0)
                }
            }
        }
        stringNotEquals = stringNotEqualsDecoded0
        let stringLikeContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringLike)
        var stringLikeDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringLikeContainer = stringLikeContainer {
            stringLikeDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringLikeContainer {
                if let structure0 = structure0 {
                    stringLikeDecoded0?.append(structure0)
                }
            }
        }
        stringLike = stringLikeDecoded0
        let stringNotLikeContainer = try containerValues.decodeIfPresent([BackupClientTypes.ConditionParameter?].self, forKey: .stringNotLike)
        var stringNotLikeDecoded0:[BackupClientTypes.ConditionParameter]? = nil
        if let stringNotLikeContainer = stringNotLikeContainer {
            stringNotLikeDecoded0 = [BackupClientTypes.ConditionParameter]()
            for structure0 in stringNotLikeContainer {
                if let structure0 = structure0 {
                    stringNotLikeDecoded0?.append(structure0)
                }
            }
        }
        stringNotLike = stringNotLikeDecoded0
    }
}

extension BackupClientTypes.Conditions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Conditions(stringEquals: \(Swift.String(describing: stringEquals)), stringLike: \(Swift.String(describing: stringLike)), stringNotEquals: \(Swift.String(describing: stringNotEquals)), stringNotLike: \(Swift.String(describing: stringNotLike)))"}
}

extension BackupClientTypes {
    /// Contains information about which resources to include or exclude from a backup plan using their tags. Conditions are case sensitive.
    public struct Conditions: Swift.Equatable {
        /// Filters the values of your tagged resources for only those resources that you tagged with the same value. Also called "exact matching."
        public var stringEquals: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for matching tag values with the use of a wildcard character (*) anywhere in the string. For example, "prod*" or "*rod*" matches the tag value "production".
        public var stringLike: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for only those resources that you tagged that do not have the same value. Also called "negated matching."
        public var stringNotEquals: [BackupClientTypes.ConditionParameter]?
        /// Filters the values of your tagged resources for non-matching tag values with the use of a wildcard character (*) anywhere in the string.
        public var stringNotLike: [BackupClientTypes.ConditionParameter]?

        public init (
            stringEquals: [BackupClientTypes.ConditionParameter]? = nil,
            stringLike: [BackupClientTypes.ConditionParameter]? = nil,
            stringNotEquals: [BackupClientTypes.ConditionParameter]? = nil,
            stringNotLike: [BackupClientTypes.ConditionParameter]? = nil
        )
        {
            self.stringEquals = stringEquals
            self.stringLike = stringLike
            self.stringNotEquals = stringNotEquals
            self.stringNotLike = stringNotLike
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Backup can't perform the action that you requested until it finishes performing a previous action. Try again later.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.ControlInputParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension BackupClientTypes.ControlInputParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ControlInputParameter(parameterName: \(Swift.String(describing: parameterName)), parameterValue: \(Swift.String(describing: parameterValue)))"}
}

extension BackupClientTypes {
    /// A list of parameters for a control. A control can have zero, one, or more than one parameter. An example of a control with two parameters is: "backup plan frequency is at least daily and the retention period is at least 1 year". The first parameter is daily. The second parameter is 1 year.
    public struct ControlInputParameter: Swift.Equatable {
        /// The name of a parameter, for example, BackupPlanFrequency.
        public var parameterName: Swift.String?
        /// The value of parameter, for example, hourly.
        public var parameterValue: Swift.String?

        public init (
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }

}

extension BackupClientTypes.ControlScope: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceResourceIds = "ComplianceResourceIds"
        case complianceResourceTypes = "ComplianceResourceTypes"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceResourceIds = complianceResourceIds {
            var complianceResourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceResourceIds)
            for complianceresourceidlist0 in complianceResourceIds {
                try complianceResourceIdsContainer.encode(complianceresourceidlist0)
            }
        }
        if let complianceResourceTypes = complianceResourceTypes {
            var complianceResourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceResourceTypes)
            for resourcetypelist0 in complianceResourceTypes {
                try complianceResourceTypesContainer.encode(resourcetypelist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, stringmap0) in tags {
                try tagsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceResourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .complianceResourceIds)
        var complianceResourceIdsDecoded0:[Swift.String]? = nil
        if let complianceResourceIdsContainer = complianceResourceIdsContainer {
            complianceResourceIdsDecoded0 = [Swift.String]()
            for string0 in complianceResourceIdsContainer {
                if let string0 = string0 {
                    complianceResourceIdsDecoded0?.append(string0)
                }
            }
        }
        complianceResourceIds = complianceResourceIdsDecoded0
        let complianceResourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .complianceResourceTypes)
        var complianceResourceTypesDecoded0:[Swift.String]? = nil
        if let complianceResourceTypesContainer = complianceResourceTypesContainer {
            complianceResourceTypesDecoded0 = [Swift.String]()
            for string0 in complianceResourceTypesContainer {
                if let string0 = string0 {
                    complianceResourceTypesDecoded0?.append(string0)
                }
            }
        }
        complianceResourceTypes = complianceResourceTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BackupClientTypes.ControlScope: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ControlScope(complianceResourceIds: \(Swift.String(describing: complianceResourceIds)), complianceResourceTypes: \(Swift.String(describing: complianceResourceTypes)), tags: \(Swift.String(describing: tags)))"}
}

extension BackupClientTypes {
    /// A framework consists of one or more controls. Each control has its own control scope. The control scope can include one or more resource types, a combination of a tag key and value, or a combination of one resource type and one resource ID. If no scope is specified, evaluations for the rule are triggered when any resource in your recording group changes in configuration. To set a control scope that includes all of a particular resource, leave the ControlScope empty or do not pass it when calling CreateFramework.
    public struct ControlScope: Swift.Equatable {
        /// The ID of the only Amazon Web Services resource that you want your control scope to contain.
        public var complianceResourceIds: [Swift.String]?
        /// Describes whether the control scope includes one or more types of resources, such as EFS or RDS.
        public var complianceResourceTypes: [Swift.String]?
        /// The tag key-value pair applied to those Amazon Web Services resources that you want to trigger an evaluation for a rule. A maximum of one key-value pair can be provided. The tag value is optional, but it cannot be an empty string. The structure to assign a tag is: [{"Key":"string","Value":"string"}].
        public var tags: [Swift.String:Swift.String]?

        public init (
            complianceResourceIds: [Swift.String]? = nil,
            complianceResourceTypes: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.complianceResourceIds = complianceResourceIds
            self.complianceResourceTypes = complianceResourceTypes
            self.tags = tags
        }
    }

}

extension BackupClientTypes.CopyAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBackupVaultArn = destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
    }
}

extension BackupClientTypes.CopyAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyAction(destinationBackupVaultArn: \(Swift.String(describing: destinationBackupVaultArn)), lifecycle: \(Swift.String(describing: lifecycle)))"}
}

extension BackupClientTypes {
    /// The details of the copy operation.
    public struct CopyAction: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup. For example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        /// This member is required.
        public var destinationBackupVaultArn: Swift.String?
        /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
        public var lifecycle: BackupClientTypes.Lifecycle?

        public init (
            destinationBackupVaultArn: Swift.String? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil
        )
        {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }
    }

}

extension BackupClientTypes.CopyJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case copyJobId = "CopyJobId"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case destinationRecoveryPointArn = "DestinationRecoveryPointArn"
        case iamRoleArn = "IamRoleArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case sourceRecoveryPointArn = "SourceRecoveryPointArn"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupSizeInBytes = backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate.timeIntervalSince1970, forKey: .completionDate)
        }
        if let copyJobId = copyJobId {
            try encodeContainer.encode(copyJobId, forKey: .copyJobId)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let destinationBackupVaultArn = destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let destinationRecoveryPointArn = destinationRecoveryPointArn {
            try encodeContainer.encode(destinationRecoveryPointArn, forKey: .destinationRecoveryPointArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceBackupVaultArn = sourceBackupVaultArn {
            try encodeContainer.encode(sourceBackupVaultArn, forKey: .sourceBackupVaultArn)
        }
        if let sourceRecoveryPointArn = sourceRecoveryPointArn {
            try encodeContainer.encode(sourceRecoveryPointArn, forKey: .sourceRecoveryPointArn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let copyJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyJobId)
        copyJobId = copyJobIdDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let sourceRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRecoveryPointArn)
        sourceRecoveryPointArn = sourceRecoveryPointArnDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
        let destinationRecoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRecoveryPointArn)
        destinationRecoveryPointArn = destinationRecoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CopyJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension BackupClientTypes.CopyJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyJob(accountId: \(Swift.String(describing: accountId)), backupSizeInBytes: \(Swift.String(describing: backupSizeInBytes)), completionDate: \(Swift.String(describing: completionDate)), copyJobId: \(Swift.String(describing: copyJobId)), createdBy: \(Swift.String(describing: createdBy)), creationDate: \(Swift.String(describing: creationDate)), destinationBackupVaultArn: \(Swift.String(describing: destinationBackupVaultArn)), destinationRecoveryPointArn: \(Swift.String(describing: destinationRecoveryPointArn)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)), sourceBackupVaultArn: \(Swift.String(describing: sourceBackupVaultArn)), sourceRecoveryPointArn: \(Swift.String(describing: sourceRecoveryPointArn)), state: \(Swift.String(describing: state)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension BackupClientTypes {
    /// Contains detailed information about a copy job.
    public struct CopyJob: Swift.Equatable {
        /// The account ID that owns the copy job.
        public var accountId: Swift.String?
        /// The size, in bytes, of a copy job.
        public var backupSizeInBytes: Swift.Int?
        /// The date and time a copy job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// Uniquely identifies a copy job.
        public var copyJobId: Swift.String?
        /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a destination copy vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var destinationBackupVaultArn: Swift.String?
        /// An ARN that uniquely identifies a destination recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var destinationRecoveryPointArn: Swift.String?
        /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// The Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public var resourceArn: Swift.String?
        /// The type of Amazon Web Services resource to be copied; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
        public var resourceType: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a source copy vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var sourceBackupVaultArn: Swift.String?
        /// An ARN that uniquely identifies a source recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var sourceRecoveryPointArn: Swift.String?
        /// The current state of a copy job.
        public var state: BackupClientTypes.CopyJobState?
        /// A detailed message explaining the status of the job to copy a resource.
        public var statusMessage: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            completionDate: ClientRuntime.Date? = nil,
            copyJobId: Swift.String? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: ClientRuntime.Date? = nil,
            destinationBackupVaultArn: Swift.String? = nil,
            destinationRecoveryPointArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            sourceRecoveryPointArn: Swift.String? = nil,
            state: BackupClientTypes.CopyJobState? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.copyJobId = copyJobId
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.destinationRecoveryPointArn = destinationRecoveryPointArn
            self.iamRoleArn = iamRoleArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.sourceRecoveryPointArn = sourceRecoveryPointArn
            self.state = state
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes {
    public enum CopyJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case created
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyJobState] {
            return [
                .completed,
                .created,
                .failed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CopyJobState(rawValue: rawValue) ?? CopyJobState.sdkUnknown(rawValue)
        }
    }
}

public struct CreateBackupPlanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupPlanOutputError>
}

extension CreateBackupPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupPlanInput(backupPlan: \(Swift.String(describing: backupPlan)), backupPlanTags: \(Swift.String(describing: backupPlanTags)), creatorRequestId: \(Swift.String(describing: creatorRequestId)))"}
}

extension CreateBackupPlanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
        case backupPlanTags = "BackupPlanTags"
        case creatorRequestId = "CreatorRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlan = backupPlan {
            try encodeContainer.encode(backupPlan, forKey: .backupPlan)
        }
        if let backupPlanTags = backupPlanTags {
            var backupPlanTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupPlanTags)
            for (dictKey0, tags0) in backupPlanTags {
                try backupPlanTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
    }
}

public struct CreateBackupPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupPlanOutputError>
}

public struct CreateBackupPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupPlanOutputError>
}

public struct CreateBackupPlanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupPlanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateBackupPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBackupPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupPlanOutputError>
}

public struct CreateBackupPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupPlanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateBackupPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/backup/plans"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBackupPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupPlanOutputError>
}

public struct CreateBackupPlanInput: Swift.Equatable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    /// This member is required.
    public var backupPlan: BackupClientTypes.BackupPlanInput?
    /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair. The specified tags are assigned to all backups created with this plan.
    public var backupPlanTags: [Swift.String:Swift.String]?
    /// Identifies the request and allows failed requests to be retried without the risk of running the operation twice. If the request includes a CreatorRequestId that matches an existing backup plan, that plan is returned. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?

    public init (
        backupPlan: BackupClientTypes.BackupPlanInput? = nil,
        backupPlanTags: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanTags = backupPlanTags
        self.creatorRequestId = creatorRequestId
    }
}

struct CreateBackupPlanInputBody: Swift.Equatable {
    public let backupPlan: BackupClientTypes.BackupPlanInput?
    public let backupPlanTags: [Swift.String:Swift.String]?
    public let creatorRequestId: Swift.String?
}

extension CreateBackupPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
        case backupPlanTags = "BackupPlanTags"
        case creatorRequestId = "CreatorRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlanInput.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
        let backupPlanTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupPlanTags)
        var backupPlanTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupPlanTagsContainer = backupPlanTagsContainer {
            backupPlanTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in backupPlanTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    backupPlanTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        backupPlanTags = backupPlanTagsDecoded0
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupPlanOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupPlanOutputResponse(advancedBackupSettings: \(Swift.String(describing: advancedBackupSettings)), backupPlanArn: \(Swift.String(describing: backupPlanArn)), backupPlanId: \(Swift.String(describing: backupPlanId)), creationDate: \(Swift.String(describing: creationDate)), versionId: \(Swift.String(describing: versionId)))"}
}

extension CreateBackupPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.versionId = nil
        }
    }
}

public struct CreateBackupPlanOutputResponse: Swift.Equatable {
    /// A list of BackupOptions settings for a resource type. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
    public var versionId: Swift.String?

    public init (
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

struct CreateBackupPlanOutputResponseBody: Swift.Equatable {
    public let backupPlanId: Swift.String?
    public let backupPlanArn: Swift.String?
    public let creationDate: ClientRuntime.Date?
    public let versionId: Swift.String?
    public let advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
}

extension CreateBackupPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

public struct CreateBackupSelectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupSelectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupSelectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupSelectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupSelectionOutputError>
}

extension CreateBackupSelectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupSelectionInput(backupPlanId: \(Swift.String(describing: backupPlanId)), backupSelection: \(Swift.String(describing: backupSelection)), creatorRequestId: \(Swift.String(describing: creatorRequestId)))"}
}

extension CreateBackupSelectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSelection = "BackupSelection"
        case creatorRequestId = "CreatorRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSelection = backupSelection {
            try encodeContainer.encode(backupSelection, forKey: .backupSelection)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
    }
}

public struct CreateBackupSelectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupSelectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupSelectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupSelectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupSelectionOutputError>
}

public struct CreateBackupSelectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupSelectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupSelectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupSelectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupSelectionOutputError>
}

public struct CreateBackupSelectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupSelectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateBackupSelectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBackupSelectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupSelectionOutputError>
}

public struct CreateBackupSelectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupSelectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateBackupSelectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanId = input.backupPlanId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBackupSelectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupSelectionOutputError>
}

public struct CreateBackupSelectionInput: Swift.Equatable {
    /// Uniquely identifies the backup plan to be associated with the selection of resources.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Specifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var backupSelection: BackupClientTypes.BackupSelection?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        backupSelection: BackupClientTypes.BackupSelection? = nil,
        creatorRequestId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creatorRequestId = creatorRequestId
    }
}

struct CreateBackupSelectionInputBody: Swift.Equatable {
    public let backupSelection: BackupClientTypes.BackupSelection?
    public let creatorRequestId: Swift.String?
}

extension CreateBackupSelectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSelection = "BackupSelection"
        case creatorRequestId = "CreatorRequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupSelection.self, forKey: .backupSelection)
        backupSelection = backupSelectionDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupSelectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupSelectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupSelectionOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupSelectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupSelectionOutputResponse(backupPlanId: \(Swift.String(describing: backupPlanId)), creationDate: \(Swift.String(describing: creationDate)), selectionId: \(Swift.String(describing: selectionId)))"}
}

extension CreateBackupSelectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBackupSelectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.selectionId = output.selectionId
        } else {
            self.backupPlanId = nil
            self.creationDate = nil
            self.selectionId = nil
        }
    }
}

public struct CreateBackupSelectionOutputResponse: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    public var selectionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.selectionId = selectionId
    }
}

struct CreateBackupSelectionOutputResponseBody: Swift.Equatable {
    public let selectionId: Swift.String?
    public let backupPlanId: Swift.String?
    public let creationDate: ClientRuntime.Date?
}

extension CreateBackupSelectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case selectionId = "SelectionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct CreateBackupVaultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupVaultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupVaultOutputError>
}

extension CreateBackupVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupVaultInput(backupVaultName: \(Swift.String(describing: backupVaultName)), backupVaultTags: \(Swift.String(describing: backupVaultTags)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)))"}
}

extension CreateBackupVaultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultTags = backupVaultTags {
            var backupVaultTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupVaultTags)
            for (dictKey0, tags0) in backupVaultTags {
                try backupVaultTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
    }
}

public struct CreateBackupVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupVaultOutputError>
}

public struct CreateBackupVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupVaultOutputError>
}

public struct CreateBackupVaultInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupVaultInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateBackupVaultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBackupVaultInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupVaultOutputError>
}

public struct CreateBackupVaultInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupVaultInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateBackupVaultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBackupVaultInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupVaultOutputError>
}

public struct CreateBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// Metadata that you can assign to help organize the resources that you create. Each tag is a key-value pair.
    public var backupVaultTags: [Swift.String:Swift.String]?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice. This parameter is optional. If used, this parameter must contain 1 to 50 alphanumeric or '-_.' characters.
    public var creatorRequestId: Swift.String?
    /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        backupVaultTags: [Swift.String:Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.backupVaultTags = backupVaultTags
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
    }
}

struct CreateBackupVaultInputBody: Swift.Equatable {
    public let backupVaultTags: [Swift.String:Swift.String]?
    public let encryptionKeyArn: Swift.String?
    public let creatorRequestId: Swift.String?
}

extension CreateBackupVaultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultTags = "BackupVaultTags"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupVaultTags)
        var backupVaultTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupVaultTagsContainer = backupVaultTagsContainer {
            backupVaultTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in backupVaultTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    backupVaultTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        backupVaultTags = backupVaultTagsDecoded0
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension CreateBackupVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupVaultOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupVaultOutputResponse(backupVaultArn: \(Swift.String(describing: backupVaultArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), creationDate: \(Swift.String(describing: creationDate)))"}
}

extension CreateBackupVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBackupVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.creationDate = output.creationDate
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.creationDate = nil
        }
    }
}

public struct CreateBackupVaultOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?

    public init (
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
    }
}

struct CreateBackupVaultOutputResponseBody: Swift.Equatable {
    public let backupVaultName: Swift.String?
    public let backupVaultArn: Swift.String?
    public let creationDate: ClientRuntime.Date?
}

extension CreateBackupVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct CreateFrameworkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFrameworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFrameworkOutputError>
}

extension CreateFrameworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFrameworkInput(frameworkControls: \(Swift.String(describing: frameworkControls)), frameworkDescription: \(Swift.String(describing: frameworkDescription)), frameworkName: \(Swift.String(describing: frameworkName)), frameworkTags: \(Swift.String(describing: frameworkTags)), idempotencyToken: \(Swift.String(describing: idempotencyToken)))"}
}

extension CreateFrameworkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case frameworkTags = "FrameworkTags"
        case idempotencyToken = "IdempotencyToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameworkControls = frameworkControls {
            var frameworkControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameworkControls)
            for frameworkcontrols0 in frameworkControls {
                try frameworkControlsContainer.encode(frameworkcontrols0)
            }
        }
        if let frameworkDescription = frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let frameworkName = frameworkName {
            try encodeContainer.encode(frameworkName, forKey: .frameworkName)
        }
        if let frameworkTags = frameworkTags {
            var frameworkTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .frameworkTags)
            for (dictKey0, stringmap0) in frameworkTags {
                try frameworkTagsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

public struct CreateFrameworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFrameworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFrameworkOutputError>
}

public struct CreateFrameworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFrameworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFrameworkOutputError>
}

public struct CreateFrameworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFrameworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateFrameworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFrameworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFrameworkOutputError>
}

public struct CreateFrameworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFrameworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateFrameworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/audit/frameworks"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFrameworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFrameworkOutputError>
}

public struct CreateFrameworkInput: Swift.Equatable {
    /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    /// This member is required.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework with a maximum of 1,024 characters.
    public var frameworkDescription: Swift.String?
    /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var frameworkName: Swift.String?
    /// Metadata that you can assign to help organize the frameworks that you create. Each tag is a key-value pair.
    public var frameworkTags: [Swift.String:Swift.String]?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init (
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        frameworkTags: [Swift.String:Swift.String]? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.frameworkTags = frameworkTags
        self.idempotencyToken = idempotencyToken
    }
}

struct CreateFrameworkInputBody: Swift.Equatable {
    public let frameworkName: Swift.String?
    public let frameworkDescription: Swift.String?
    public let frameworkControls: [BackupClientTypes.FrameworkControl]?
    public let idempotencyToken: Swift.String?
    public let frameworkTags: [Swift.String:Swift.String]?
}

extension CreateFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case frameworkTags = "FrameworkTags"
        case idempotencyToken = "IdempotencyToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let frameworkControlsContainer = try containerValues.decodeIfPresent([BackupClientTypes.FrameworkControl?].self, forKey: .frameworkControls)
        var frameworkControlsDecoded0:[BackupClientTypes.FrameworkControl]? = nil
        if let frameworkControlsContainer = frameworkControlsContainer {
            frameworkControlsDecoded0 = [BackupClientTypes.FrameworkControl]()
            for structure0 in frameworkControlsContainer {
                if let structure0 = structure0 {
                    frameworkControlsDecoded0?.append(structure0)
                }
            }
        }
        frameworkControls = frameworkControlsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let frameworkTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .frameworkTags)
        var frameworkTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let frameworkTagsContainer = frameworkTagsContainer {
            frameworkTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in frameworkTagsContainer {
                if let string0 = string0 {
                    frameworkTagsDecoded0?[key0] = string0
                }
            }
        }
        frameworkTags = frameworkTagsDecoded0
    }
}

extension CreateFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFrameworkOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFrameworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFrameworkOutputResponse(frameworkArn: \(Swift.String(describing: frameworkArn)), frameworkName: \(Swift.String(describing: frameworkName)))"}
}

extension CreateFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.frameworkArn = output.frameworkArn
            self.frameworkName = output.frameworkName
        } else {
            self.frameworkArn = nil
            self.frameworkName = nil
        }
    }
}

public struct CreateFrameworkOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// The unique name of the framework. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    public var frameworkName: Swift.String?

    public init (
        frameworkArn: Swift.String? = nil,
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkArn = frameworkArn
        self.frameworkName = frameworkName
    }
}

struct CreateFrameworkOutputResponseBody: Swift.Equatable {
    public let frameworkName: Swift.String?
    public let frameworkArn: Swift.String?
}

extension CreateFrameworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkArn = "FrameworkArn"
        case frameworkName = "FrameworkName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
    }
}

public struct CreateReportPlanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReportPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReportPlanOutputError>
}

extension CreateReportPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReportPlanInput(idempotencyToken: \(Swift.String(describing: idempotencyToken)), reportDeliveryChannel: \(Swift.String(describing: reportDeliveryChannel)), reportPlanDescription: \(Swift.String(describing: reportPlanDescription)), reportPlanName: \(Swift.String(describing: reportPlanName)), reportPlanTags: \(Swift.String(describing: reportPlanTags)), reportSetting: \(Swift.String(describing: reportSetting)))"}
}

extension CreateReportPlanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportPlanName = "ReportPlanName"
        case reportPlanTags = "ReportPlanTags"
        case reportSetting = "ReportSetting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let reportDeliveryChannel = reportDeliveryChannel {
            try encodeContainer.encode(reportDeliveryChannel, forKey: .reportDeliveryChannel)
        }
        if let reportPlanDescription = reportPlanDescription {
            try encodeContainer.encode(reportPlanDescription, forKey: .reportPlanDescription)
        }
        if let reportPlanName = reportPlanName {
            try encodeContainer.encode(reportPlanName, forKey: .reportPlanName)
        }
        if let reportPlanTags = reportPlanTags {
            var reportPlanTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .reportPlanTags)
            for (dictKey0, stringmap0) in reportPlanTags {
                try reportPlanTagsContainer.encode(stringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let reportSetting = reportSetting {
            try encodeContainer.encode(reportSetting, forKey: .reportSetting)
        }
    }
}

public struct CreateReportPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReportPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReportPlanOutputError>
}

public struct CreateReportPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReportPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReportPlanOutputError>
}

public struct CreateReportPlanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReportPlanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateReportPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateReportPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReportPlanOutputError>
}

public struct CreateReportPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReportPlanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateReportPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/audit/report-plans"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateReportPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReportPlanOutputError>
}

public struct CreateReportPlanInput: Swift.Equatable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to CreateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    /// This member is required.
    public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    /// An optional description of the report plan with a maximum of 1,024 characters.
    public var reportPlanDescription: Swift.String?
    /// The unique name of the report plan. The name must be between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var reportPlanName: Swift.String?
    /// Metadata that you can assign to help organize the report plans that you create. Each tag is a key-value pair.
    public var reportPlanTags: [Swift.String:Swift.String]?
    /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
    /// This member is required.
    public var reportSetting: BackupClientTypes.ReportSetting?

    public init (
        idempotencyToken: Swift.String? = nil,
        reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
        reportPlanDescription: Swift.String? = nil,
        reportPlanName: Swift.String? = nil,
        reportPlanTags: [Swift.String:Swift.String]? = nil,
        reportSetting: BackupClientTypes.ReportSetting? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportDeliveryChannel = reportDeliveryChannel
        self.reportPlanDescription = reportPlanDescription
        self.reportPlanName = reportPlanName
        self.reportPlanTags = reportPlanTags
        self.reportSetting = reportSetting
    }
}

struct CreateReportPlanInputBody: Swift.Equatable {
    public let reportPlanName: Swift.String?
    public let reportPlanDescription: Swift.String?
    public let reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    public let reportSetting: BackupClientTypes.ReportSetting?
    public let reportPlanTags: [Swift.String:Swift.String]?
    public let idempotencyToken: Swift.String?
}

extension CreateReportPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportPlanName = "ReportPlanName"
        case reportPlanTags = "ReportPlanTags"
        case reportSetting = "ReportSetting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanDescription)
        reportPlanDescription = reportPlanDescriptionDecoded
        let reportDeliveryChannelDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDeliveryChannel.self, forKey: .reportDeliveryChannel)
        reportDeliveryChannel = reportDeliveryChannelDecoded
        let reportSettingDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportSetting.self, forKey: .reportSetting)
        reportSetting = reportSettingDecoded
        let reportPlanTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .reportPlanTags)
        var reportPlanTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let reportPlanTagsContainer = reportPlanTagsContainer {
            reportPlanTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in reportPlanTagsContainer {
                if let string0 = string0 {
                    reportPlanTagsDecoded0?[key0] = string0
                }
            }
        }
        reportPlanTags = reportPlanTagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateReportPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReportPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReportPlanOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReportPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReportPlanOutputResponse(creationTime: \(Swift.String(describing: creationTime)), reportPlanArn: \(Swift.String(describing: reportPlanArn)), reportPlanName: \(Swift.String(describing: reportPlanName)))"}
}

extension CreateReportPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateReportPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.reportPlanArn = output.reportPlanArn
            self.reportPlanName = output.reportPlanName
        } else {
            self.creationTime = nil
            self.reportPlanArn = nil
            self.reportPlanName = nil
        }
    }
}

public struct CreateReportPlanOutputResponse: Swift.Equatable {
    /// The date and time a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var reportPlanArn: Swift.String?
    /// The unique name of the report plan.
    public var reportPlanName: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        reportPlanArn: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.reportPlanArn = reportPlanArn
        self.reportPlanName = reportPlanName
    }
}

struct CreateReportPlanOutputResponseBody: Swift.Equatable {
    public let reportPlanName: Swift.String?
    public let reportPlanArn: Swift.String?
    public let creationTime: ClientRuntime.Date?
}

extension CreateReportPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case reportPlanArn = "ReportPlanArn"
        case reportPlanName = "ReportPlanName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension DeleteBackupPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupPlanInput(backupPlanId: \(Swift.String(describing: backupPlanId)))"}
}

extension DeleteBackupPlanInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteBackupPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupPlanOutputError>
}

public struct DeleteBackupPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupPlanOutputError>
}

public struct DeleteBackupPlanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupPlanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupPlanOutputError>
}

public struct DeleteBackupPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupPlanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanId = input.backupPlanId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/plans/\(backupPlanId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupPlanOutputError>
}

public struct DeleteBackupPlanInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

struct DeleteBackupPlanInputBody: Swift.Equatable {
}

extension DeleteBackupPlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupPlanOutputResponse(backupPlanArn: \(Swift.String(describing: backupPlanArn)), backupPlanId: \(Swift.String(describing: backupPlanId)), deletionDate: \(Swift.String(describing: deletionDate)), versionId: \(Swift.String(describing: versionId)))"}
}

extension DeleteBackupPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.deletionDate = output.deletionDate
            self.versionId = output.versionId
        } else {
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.deletionDate = nil
            self.versionId = nil
        }
    }
}

public struct DeleteBackupPlanOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var deletionDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init (
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        deletionDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.deletionDate = deletionDate
        self.versionId = versionId
    }
}

struct DeleteBackupPlanOutputResponseBody: Swift.Equatable {
    public let backupPlanId: Swift.String?
    public let backupPlanArn: Swift.String?
    public let deletionDate: ClientRuntime.Date?
    public let versionId: Swift.String?
}

extension DeleteBackupPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case deletionDate = "DeletionDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension DeleteBackupSelectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupSelectionInput(backupPlanId: \(Swift.String(describing: backupPlanId)), selectionId: \(Swift.String(describing: selectionId)))"}
}

extension DeleteBackupSelectionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteBackupSelectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupSelectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupSelectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupSelectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupSelectionOutputError>
}

public struct DeleteBackupSelectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupSelectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupSelectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupSelectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupSelectionOutputError>
}

public struct DeleteBackupSelectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupSelectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupSelectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupSelectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupSelectionOutputError>
}

public struct DeleteBackupSelectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupSelectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupSelectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanId = input.backupPlanId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanId is nil and needs a value for the path of this operation"))))
        }
        guard let selectionId = input.selectionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("selectionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections/\(selectionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupSelectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupSelectionOutputError>
}

public struct DeleteBackupSelectionInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var selectionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

struct DeleteBackupSelectionInputBody: Swift.Equatable {
}

extension DeleteBackupSelectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupSelectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupSelectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupSelectionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupSelectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupSelectionOutputResponse()"}
}

extension DeleteBackupSelectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupSelectionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteBackupSelectionOutputResponseBody: Swift.Equatable {
}

extension DeleteBackupSelectionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupVaultAccessPolicyInput(backupVaultName: \(Swift.String(describing: backupVaultName)))"}
}

extension DeleteBackupVaultAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteBackupVaultAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultAccessPolicyOutputError>
}

public struct DeleteBackupVaultAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultAccessPolicyOutputError>
}

public struct DeleteBackupVaultAccessPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultAccessPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupVaultAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupVaultAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultAccessPolicyOutputError>
}

public struct DeleteBackupVaultAccessPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultAccessPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupVaultAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupVaultAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultAccessPolicyOutputError>
}

public struct DeleteBackupVaultAccessPolicyInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultAccessPolicyInputBody: Swift.Equatable {
}

extension DeleteBackupVaultAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupVaultAccessPolicyOutputResponse()"}
}

extension DeleteBackupVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultAccessPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteBackupVaultAccessPolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteBackupVaultAccessPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupVaultInput(backupVaultName: \(Swift.String(describing: backupVaultName)))"}
}

extension DeleteBackupVaultInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteBackupVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultOutputError>
}

public struct DeleteBackupVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultOutputError>
}

public struct DeleteBackupVaultInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupVaultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupVaultInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultOutputError>
}

public struct DeleteBackupVaultInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupVaultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupVaultInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultOutputError>
}

public struct DeleteBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultInputBody: Swift.Equatable {
}

extension DeleteBackupVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultLockConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupVaultLockConfigurationInput(backupVaultName: \(Swift.String(describing: backupVaultName)))"}
}

extension DeleteBackupVaultLockConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteBackupVaultLockConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultLockConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupVaultLockConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupVaultLockConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultLockConfigurationOutputError>
}

public struct DeleteBackupVaultLockConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultLockConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupVaultLockConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupVaultLockConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultLockConfigurationOutputError>
}

public struct DeleteBackupVaultLockConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultLockConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupVaultLockConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupVaultLockConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultLockConfigurationOutputError>
}

public struct DeleteBackupVaultLockConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultLockConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupVaultLockConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/vault-lock"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupVaultLockConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultLockConfigurationOutputError>
}

public struct DeleteBackupVaultLockConfigurationInput: Swift.Equatable {
    /// The name of the backup vault from which to delete Backup Vault Lock.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultLockConfigurationInputBody: Swift.Equatable {
}

extension DeleteBackupVaultLockConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultLockConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultLockConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupVaultLockConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultLockConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupVaultLockConfigurationOutputResponse()"}
}

extension DeleteBackupVaultLockConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultLockConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteBackupVaultLockConfigurationOutputResponseBody: Swift.Equatable {
}

extension DeleteBackupVaultLockConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultNotificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupVaultNotificationsInput(backupVaultName: \(Swift.String(describing: backupVaultName)))"}
}

extension DeleteBackupVaultNotificationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteBackupVaultNotificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultNotificationsOutputError>
}

public struct DeleteBackupVaultNotificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultNotificationsOutputError>
}

public struct DeleteBackupVaultNotificationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultNotificationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupVaultNotificationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupVaultNotificationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultNotificationsOutputError>
}

public struct DeleteBackupVaultNotificationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupVaultNotificationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteBackupVaultNotificationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBackupVaultNotificationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupVaultNotificationsOutputError>
}

public struct DeleteBackupVaultNotificationsInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DeleteBackupVaultNotificationsInputBody: Swift.Equatable {
}

extension DeleteBackupVaultNotificationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultNotificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupVaultNotificationsOutputResponse()"}
}

extension DeleteBackupVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultNotificationsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteBackupVaultNotificationsOutputResponseBody: Swift.Equatable {
}

extension DeleteBackupVaultNotificationsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackupVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupVaultOutputResponse()"}
}

extension DeleteBackupVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupVaultOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteBackupVaultOutputResponseBody: Swift.Equatable {
}

extension DeleteBackupVaultOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFrameworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFrameworkInput(frameworkName: \(Swift.String(describing: frameworkName)))"}
}

extension DeleteFrameworkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFrameworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFrameworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFrameworkOutputError>
}

public struct DeleteFrameworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFrameworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFrameworkOutputError>
}

public struct DeleteFrameworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFrameworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFrameworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFrameworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFrameworkOutputError>
}

public struct DeleteFrameworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFrameworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFrameworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let frameworkName = input.frameworkName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("frameworkName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFrameworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFrameworkOutputError>
}

public struct DeleteFrameworkInput: Swift.Equatable {
    /// The unique name of a framework.
    /// This member is required.
    public var frameworkName: Swift.String?

    public init (
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkName = frameworkName
    }
}

struct DeleteFrameworkInputBody: Swift.Equatable {
}

extension DeleteFrameworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFrameworkOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFrameworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFrameworkOutputResponse()"}
}

extension DeleteFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFrameworkOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFrameworkOutputResponseBody: Swift.Equatable {
}

extension DeleteFrameworkOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecoveryPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecoveryPointInput(backupVaultName: \(Swift.String(describing: backupVaultName)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)))"}
}

extension DeleteRecoveryPointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRecoveryPointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecoveryPointOutputError>
}

public struct DeleteRecoveryPointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecoveryPointOutputError>
}

public struct DeleteRecoveryPointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecoveryPointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRecoveryPointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRecoveryPointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecoveryPointOutputError>
}

public struct DeleteRecoveryPointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecoveryPointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRecoveryPointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        guard let recoveryPointArn = input.recoveryPointArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("recoveryPointArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRecoveryPointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecoveryPointOutputError>
}

public struct DeleteRecoveryPointInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DeleteRecoveryPointInputBody: Swift.Equatable {
}

extension DeleteRecoveryPointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case invalidResourceStateException(InvalidResourceStateException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecoveryPointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecoveryPointOutputResponse()"}
}

extension DeleteRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecoveryPointOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRecoveryPointOutputResponseBody: Swift.Equatable {
}

extension DeleteRecoveryPointOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReportPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReportPlanInput(reportPlanName: \(Swift.String(describing: reportPlanName)))"}
}

extension DeleteReportPlanInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteReportPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReportPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReportPlanOutputError>
}

public struct DeleteReportPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReportPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReportPlanOutputError>
}

public struct DeleteReportPlanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReportPlanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteReportPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteReportPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReportPlanOutputError>
}

public struct DeleteReportPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReportPlanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteReportPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let reportPlanName = input.reportPlanName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("reportPlanName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteReportPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReportPlanOutputError>
}

public struct DeleteReportPlanInput: Swift.Equatable {
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init (
        reportPlanName: Swift.String? = nil
    )
    {
        self.reportPlanName = reportPlanName
    }
}

struct DeleteReportPlanInputBody: Swift.Equatable {
}

extension DeleteReportPlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReportPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReportPlanOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReportPlanOutputResponse()"}
}

extension DeleteReportPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReportPlanOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteReportPlanOutputResponseBody: Swift.Equatable {
}

extension DeleteReportPlanOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DependencyFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DependencyFailureException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension DependencyFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DependencyFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A dependent Amazon Web Services service or resource returned an error to the Backup service, and the action cannot be completed.
public struct DependencyFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct DependencyFailureExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension DependencyFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension DescribeBackupJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupJobInput(backupJobId: \(Swift.String(describing: backupJobId)))"}
}

extension DescribeBackupJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeBackupJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupJobOutputError>
}

public struct DescribeBackupJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupJobOutputError>
}

public struct DescribeBackupJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeBackupJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBackupJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupJobOutputError>
}

public struct DescribeBackupJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeBackupJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupJobId = input.backupJobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupJobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-jobs/\(backupJobId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBackupJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupJobOutputError>
}

public struct DescribeBackupJobInput: Swift.Equatable {
    /// Uniquely identifies a request to Backup to back up a resource.
    /// This member is required.
    public var backupJobId: Swift.String?

    public init (
        backupJobId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

struct DescribeBackupJobInputBody: Swift.Equatable {
}

extension DescribeBackupJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBackupJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyFailureException" : self = .dependencyFailureException(try DependencyFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupJobOutputError: Swift.Error, Swift.Equatable {
    case dependencyFailureException(DependencyFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupJobOutputResponse(accountId: \(Swift.String(describing: accountId)), backupJobId: \(Swift.String(describing: backupJobId)), backupOptions: \(Swift.String(describing: backupOptions)), backupSizeInBytes: \(Swift.String(describing: backupSizeInBytes)), backupType: \(Swift.String(describing: backupType)), backupVaultArn: \(Swift.String(describing: backupVaultArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), bytesTransferred: \(Swift.String(describing: bytesTransferred)), completionDate: \(Swift.String(describing: completionDate)), createdBy: \(Swift.String(describing: createdBy)), creationDate: \(Swift.String(describing: creationDate)), expectedCompletionDate: \(Swift.String(describing: expectedCompletionDate)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), percentDone: \(Swift.String(describing: percentDone)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)), startBy: \(Swift.String(describing: startBy)), state: \(Swift.String(describing: state)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension DescribeBackupJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBackupJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.backupJobId = output.backupJobId
            self.backupOptions = output.backupOptions
            self.backupSizeInBytes = output.backupSizeInBytes
            self.backupType = output.backupType
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.bytesTransferred = output.bytesTransferred
            self.completionDate = output.completionDate
            self.createdBy = output.createdBy
            self.creationDate = output.creationDate
            self.expectedCompletionDate = output.expectedCompletionDate
            self.iamRoleArn = output.iamRoleArn
            self.percentDone = output.percentDone
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceArn = output.resourceArn
            self.resourceType = output.resourceType
            self.startBy = output.startBy
            self.state = output.state
            self.statusMessage = output.statusMessage
        } else {
            self.accountId = nil
            self.backupJobId = nil
            self.backupOptions = nil
            self.backupSizeInBytes = nil
            self.backupType = nil
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.bytesTransferred = nil
            self.completionDate = nil
            self.createdBy = nil
            self.creationDate = nil
            self.expectedCompletionDate = nil
            self.iamRoleArn = nil
            self.percentDone = nil
            self.recoveryPointArn = nil
            self.resourceArn = nil
            self.resourceType = nil
            self.startBy = nil
            self.state = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeBackupJobOutputResponse: Swift.Equatable {
    /// Returns the account ID that owns the backup job.
    public var accountId: Swift.String?
    /// Uniquely identifies a request to Backup to back up a resource.
    public var backupJobId: Swift.String?
    /// Represents the options specified as part of backup plan or on-demand backup job.
    public var backupOptions: [Swift.String:Swift.String]?
    /// The size, in bytes, of a backup.
    public var backupSizeInBytes: Swift.Int?
    /// Represents the actual backup type selected for a backup job. For example, if a successful Windows Volume Shadow Copy Service (VSS) backup was taken, BackupType returns "WindowsVSS". If BackupType is empty, then the backup type was a regular backup.
    public var backupType: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The size in bytes transferred to a backup vault at the time that the job status was queried.
    public var bytesTransferred: Swift.Int?
    /// The date and time that a job to create a backup job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: ClientRuntime.Date?
    /// Contains identifying information about the creation of a backup job, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
    public var createdBy: BackupClientTypes.RecoveryPointCreator?
    /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// The date and time that a job to back up resources is expected to be completed, in Unix format and Coordinated Universal Time (UTC). The value of ExpectedCompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var expectedCompletionDate: ClientRuntime.Date?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
    public var percentDone: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// The type of Amazon Web Services resource to be backed up; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// Specifies the time in Unix format and Coordinated Universal Time (UTC) when a backup job must be started before it is canceled. The value is calculated by adding the start window to the scheduled time. So if the scheduled time were 6:00 PM and the start window is 2 hours, the StartBy time would be 8:00 PM on the date specified. The value of StartBy is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var startBy: ClientRuntime.Date?
    /// The current state of a resource recovery point.
    public var state: BackupClientTypes.BackupJobState?
    /// A detailed message explaining the status of the job to back up a resource.
    public var statusMessage: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        backupJobId: Swift.String? = nil,
        backupOptions: [Swift.String:Swift.String]? = nil,
        backupSizeInBytes: Swift.Int? = nil,
        backupType: Swift.String? = nil,
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        bytesTransferred: Swift.Int? = nil,
        completionDate: ClientRuntime.Date? = nil,
        createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
        creationDate: ClientRuntime.Date? = nil,
        expectedCompletionDate: ClientRuntime.Date? = nil,
        iamRoleArn: Swift.String? = nil,
        percentDone: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        startBy: ClientRuntime.Date? = nil,
        state: BackupClientTypes.BackupJobState? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.backupJobId = backupJobId
        self.backupOptions = backupOptions
        self.backupSizeInBytes = backupSizeInBytes
        self.backupType = backupType
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.bytesTransferred = bytesTransferred
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.expectedCompletionDate = expectedCompletionDate
        self.iamRoleArn = iamRoleArn
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
        self.startBy = startBy
        self.state = state
        self.statusMessage = statusMessage
    }
}

struct DescribeBackupJobOutputResponseBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let backupJobId: Swift.String?
    public let backupVaultName: Swift.String?
    public let backupVaultArn: Swift.String?
    public let recoveryPointArn: Swift.String?
    public let resourceArn: Swift.String?
    public let creationDate: ClientRuntime.Date?
    public let completionDate: ClientRuntime.Date?
    public let state: BackupClientTypes.BackupJobState?
    public let statusMessage: Swift.String?
    public let percentDone: Swift.String?
    public let backupSizeInBytes: Swift.Int?
    public let iamRoleArn: Swift.String?
    public let createdBy: BackupClientTypes.RecoveryPointCreator?
    public let resourceType: Swift.String?
    public let bytesTransferred: Swift.Int?
    public let expectedCompletionDate: ClientRuntime.Date?
    public let startBy: ClientRuntime.Date?
    public let backupOptions: [Swift.String:Swift.String]?
    public let backupType: Swift.String?
}

extension DescribeBackupJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupJobId = "BackupJobId"
        case backupOptions = "BackupOptions"
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupType = "BackupType"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case bytesTransferred = "BytesTransferred"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case expectedCompletionDate = "ExpectedCompletionDate"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case startBy = "StartBy"
        case state = "State"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let backupJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let stateDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let expectedCompletionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expectedCompletionDate)
        expectedCompletionDate = expectedCompletionDateDecoded
        let startByDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startBy)
        startBy = startByDecoded
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
        let backupTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupType)
        backupType = backupTypeDecoded
    }
}

extension DescribeBackupVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupVaultInput(backupVaultName: \(Swift.String(describing: backupVaultName)))"}
}

extension DescribeBackupVaultInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeBackupVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupVaultOutputError>
}

public struct DescribeBackupVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupVaultOutputError>
}

public struct DescribeBackupVaultInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupVaultInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeBackupVaultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBackupVaultInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupVaultOutputError>
}

public struct DescribeBackupVaultInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupVaultInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeBackupVaultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBackupVaultInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupVaultOutputError>
}

public struct DescribeBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct DescribeBackupVaultInputBody: Swift.Equatable {
}

extension DescribeBackupVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBackupVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupVaultOutputResponse(backupVaultArn: \(Swift.String(describing: backupVaultArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), creationDate: \(Swift.String(describing: creationDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), lockDate: \(Swift.String(describing: lockDate)), locked: \(Swift.String(describing: locked)), maxRetentionDays: \(Swift.String(describing: maxRetentionDays)), minRetentionDays: \(Swift.String(describing: minRetentionDays)), numberOfRecoveryPoints: \(Swift.String(describing: numberOfRecoveryPoints)))"}
}

extension DescribeBackupVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBackupVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.encryptionKeyArn = output.encryptionKeyArn
            self.lockDate = output.lockDate
            self.locked = output.locked
            self.maxRetentionDays = output.maxRetentionDays
            self.minRetentionDays = output.minRetentionDays
            self.numberOfRecoveryPoints = output.numberOfRecoveryPoints
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.encryptionKeyArn = nil
            self.lockDate = nil
            self.locked = nil
            self.maxRetentionDays = nil
            self.minRetentionDays = nil
            self.numberOfRecoveryPoints = 0
        }
    }
}

public struct DescribeBackupVaultOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The date and time that a backup vault is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?
    /// The date and time when Backup Vault Lock configuration cannot be changed or deleted. If you applied Vault Lock to your vault without specifying a lock date, you can change any of your Vault Lock settings, or delete Vault Lock from the vault entirely, at any time. This value is in Unix format, Coordinated Universal Time (UTC), and accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lockDate: ClientRuntime.Date?
    /// A Boolean that indicates whether Backup Vault Lock is currently protecting the backup vault. True means that Vault Lock causes delete or update operations on the recovery points stored in the vault to fail.
    public var locked: Swift.Bool?
    /// The Backup Vault Lock setting that specifies the maximum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a maximum retention period on the recovery points in the vault (allowing indefinite storage). If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
    public var maxRetentionDays: Swift.Int?
    /// The Backup Vault Lock setting that specifies the minimum retention period that the vault retains its recovery points. If this parameter is not specified, Vault Lock does not enforce a minimum retention period. If specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already stored in the vault prior to Vault Lock are not affected.
    public var minRetentionDays: Swift.Int?
    /// The number of recovery points that are stored in a backup vault.
    public var numberOfRecoveryPoints: Swift.Int

    public init (
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        encryptionKeyArn: Swift.String? = nil,
        lockDate: ClientRuntime.Date? = nil,
        locked: Swift.Bool? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil,
        numberOfRecoveryPoints: Swift.Int = 0
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.encryptionKeyArn = encryptionKeyArn
        self.lockDate = lockDate
        self.locked = locked
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
        self.numberOfRecoveryPoints = numberOfRecoveryPoints
    }
}

struct DescribeBackupVaultOutputResponseBody: Swift.Equatable {
    public let backupVaultName: Swift.String?
    public let backupVaultArn: Swift.String?
    public let encryptionKeyArn: Swift.String?
    public let creationDate: ClientRuntime.Date?
    public let creatorRequestId: Swift.String?
    public let numberOfRecoveryPoints: Swift.Int
    public let locked: Swift.Bool?
    public let minRetentionDays: Swift.Int?
    public let maxRetentionDays: Swift.Int?
    public let lockDate: ClientRuntime.Date?
}

extension DescribeBackupVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case encryptionKeyArn = "EncryptionKeyArn"
        case lockDate = "LockDate"
        case locked = "Locked"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
        case numberOfRecoveryPoints = "NumberOfRecoveryPoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let numberOfRecoveryPointsDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfRecoveryPoints)
        numberOfRecoveryPoints = numberOfRecoveryPointsDecoded
        let lockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .locked)
        locked = lockedDecoded
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
        let lockDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lockDate)
        lockDate = lockDateDecoded
    }
}

extension DescribeCopyJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCopyJobInput(copyJobId: \(Swift.String(describing: copyJobId)))"}
}

extension DescribeCopyJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeCopyJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCopyJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCopyJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCopyJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCopyJobOutputError>
}

public struct DescribeCopyJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCopyJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCopyJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCopyJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCopyJobOutputError>
}

public struct DescribeCopyJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCopyJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeCopyJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCopyJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCopyJobOutputError>
}

public struct DescribeCopyJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCopyJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeCopyJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let copyJobId = input.copyJobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("copyJobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/copy-jobs/\(copyJobId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCopyJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCopyJobOutputError>
}

public struct DescribeCopyJobInput: Swift.Equatable {
    /// Uniquely identifies a copy job.
    /// This member is required.
    public var copyJobId: Swift.String?

    public init (
        copyJobId: Swift.String? = nil
    )
    {
        self.copyJobId = copyJobId
    }
}

struct DescribeCopyJobInputBody: Swift.Equatable {
}

extension DescribeCopyJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCopyJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCopyJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCopyJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCopyJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCopyJobOutputResponse(copyJob: \(Swift.String(describing: copyJob)))"}
}

extension DescribeCopyJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCopyJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyJob = output.copyJob
        } else {
            self.copyJob = nil
        }
    }
}

public struct DescribeCopyJobOutputResponse: Swift.Equatable {
    /// Contains detailed information about a copy job.
    public var copyJob: BackupClientTypes.CopyJob?

    public init (
        copyJob: BackupClientTypes.CopyJob? = nil
    )
    {
        self.copyJob = copyJob
    }
}

struct DescribeCopyJobOutputResponseBody: Swift.Equatable {
    public let copyJob: BackupClientTypes.CopyJob?
}

extension DescribeCopyJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyJob = "CopyJob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CopyJob.self, forKey: .copyJob)
        copyJob = copyJobDecoded
    }
}

extension DescribeFrameworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFrameworkInput(frameworkName: \(Swift.String(describing: frameworkName)))"}
}

extension DescribeFrameworkInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeFrameworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFrameworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFrameworkOutputError>
}

public struct DescribeFrameworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFrameworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFrameworkOutputError>
}

public struct DescribeFrameworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFrameworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeFrameworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFrameworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFrameworkOutputError>
}

public struct DescribeFrameworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFrameworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeFrameworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let frameworkName = input.frameworkName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("frameworkName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFrameworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFrameworkOutputError>
}

public struct DescribeFrameworkInput: Swift.Equatable {
    /// The unique name of a framework.
    /// This member is required.
    public var frameworkName: Swift.String?

    public init (
        frameworkName: Swift.String? = nil
    )
    {
        self.frameworkName = frameworkName
    }
}

struct DescribeFrameworkInputBody: Swift.Equatable {
}

extension DescribeFrameworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFrameworkOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFrameworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFrameworkOutputResponse(creationTime: \(Swift.String(describing: creationTime)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), frameworkArn: \(Swift.String(describing: frameworkArn)), frameworkControls: \(Swift.String(describing: frameworkControls)), frameworkDescription: \(Swift.String(describing: frameworkDescription)), frameworkName: \(Swift.String(describing: frameworkName)), frameworkStatus: \(Swift.String(describing: frameworkStatus)), idempotencyToken: \(Swift.String(describing: idempotencyToken)))"}
}

extension DescribeFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.deploymentStatus = output.deploymentStatus
            self.frameworkArn = output.frameworkArn
            self.frameworkControls = output.frameworkControls
            self.frameworkDescription = output.frameworkDescription
            self.frameworkName = output.frameworkName
            self.frameworkStatus = output.frameworkStatus
            self.idempotencyToken = output.idempotencyToken
        } else {
            self.creationTime = nil
            self.deploymentStatus = nil
            self.frameworkArn = nil
            self.frameworkControls = nil
            self.frameworkDescription = nil
            self.frameworkName = nil
            self.frameworkStatus = nil
            self.idempotencyToken = nil
        }
    }
}

public struct DescribeFrameworkOutputResponse: Swift.Equatable {
    /// The date and time that a framework is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: ClientRuntime.Date?
    /// The deployment status of a framework. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
    public var deploymentStatus: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework.
    public var frameworkDescription: Swift.String?
    /// The unique name of a framework.
    public var frameworkName: Swift.String?
    /// A framework consists of one or more controls. Each control governs a resource, such as backup plans, backup selections, backup vaults, or recovery points. You can also turn Config recording on or off for each resource. The statuses are:
    ///
    /// * ACTIVE when recording is turned on for all resources governed by the framework.
    ///
    /// * PARTIALLY_ACTIVE when recording is turned off for at least one resource governed by the framework.
    ///
    /// * INACTIVE when recording is turned off for all resources governed by the framework.
    ///
    /// * UNAVAILABLE when Backup is unable to validate recording status at this time.
    public var frameworkStatus: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to DescribeFrameworkOutput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        deploymentStatus: Swift.String? = nil,
        frameworkArn: Swift.String? = nil,
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        frameworkStatus: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.deploymentStatus = deploymentStatus
        self.frameworkArn = frameworkArn
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.frameworkStatus = frameworkStatus
        self.idempotencyToken = idempotencyToken
    }
}

struct DescribeFrameworkOutputResponseBody: Swift.Equatable {
    public let frameworkName: Swift.String?
    public let frameworkArn: Swift.String?
    public let frameworkDescription: Swift.String?
    public let frameworkControls: [BackupClientTypes.FrameworkControl]?
    public let creationTime: ClientRuntime.Date?
    public let deploymentStatus: Swift.String?
    public let frameworkStatus: Swift.String?
    public let idempotencyToken: Swift.String?
}

extension DescribeFrameworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case deploymentStatus = "DeploymentStatus"
        case frameworkArn = "FrameworkArn"
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case frameworkStatus = "FrameworkStatus"
        case idempotencyToken = "IdempotencyToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let frameworkControlsContainer = try containerValues.decodeIfPresent([BackupClientTypes.FrameworkControl?].self, forKey: .frameworkControls)
        var frameworkControlsDecoded0:[BackupClientTypes.FrameworkControl]? = nil
        if let frameworkControlsContainer = frameworkControlsContainer {
            frameworkControlsDecoded0 = [BackupClientTypes.FrameworkControl]()
            for structure0 in frameworkControlsContainer {
                if let structure0 = structure0 {
                    frameworkControlsDecoded0?.append(structure0)
                }
            }
        }
        frameworkControls = frameworkControlsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let frameworkStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkStatus)
        frameworkStatus = frameworkStatusDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension DescribeGlobalSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGlobalSettingsInput()"}
}

extension DescribeGlobalSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeGlobalSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalSettingsOutputError>
}

public struct DescribeGlobalSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalSettingsOutputError>
}

public struct DescribeGlobalSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeGlobalSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGlobalSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalSettingsOutputError>
}

public struct DescribeGlobalSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGlobalSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeGlobalSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/global-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGlobalSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGlobalSettingsOutputError>
}

public struct DescribeGlobalSettingsInput: Swift.Equatable {

    public init() {}
}

struct DescribeGlobalSettingsInputBody: Swift.Equatable {
}

extension DescribeGlobalSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGlobalSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGlobalSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGlobalSettingsOutputError: Swift.Error, Swift.Equatable {
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGlobalSettingsOutputResponse(globalSettings: \(Swift.String(describing: globalSettings)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)))"}
}

extension DescribeGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGlobalSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.globalSettings = output.globalSettings
            self.lastUpdateTime = output.lastUpdateTime
        } else {
            self.globalSettings = nil
            self.lastUpdateTime = nil
        }
    }
}

public struct DescribeGlobalSettingsOutputResponse: Swift.Equatable {
    /// The status of the flag isCrossAccountBackupEnabled.
    public var globalSettings: [Swift.String:Swift.String]?
    /// The date and time that the flag isCrossAccountBackupEnabled was last updated. This update is in Unix format and Coordinated Universal Time (UTC). The value of LastUpdateTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastUpdateTime: ClientRuntime.Date?

    public init (
        globalSettings: [Swift.String:Swift.String]? = nil,
        lastUpdateTime: ClientRuntime.Date? = nil
    )
    {
        self.globalSettings = globalSettings
        self.lastUpdateTime = lastUpdateTime
    }
}

struct DescribeGlobalSettingsOutputResponseBody: Swift.Equatable {
    public let globalSettings: [Swift.String:Swift.String]?
    public let lastUpdateTime: ClientRuntime.Date?
}

extension DescribeGlobalSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSettings = "GlobalSettings"
        case lastUpdateTime = "LastUpdateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSettingsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .globalSettings)
        var globalSettingsDecoded0: [Swift.String:Swift.String]? = nil
        if let globalSettingsContainer = globalSettingsContainer {
            globalSettingsDecoded0 = [Swift.String:Swift.String]()
            for (key0, globalsettingsvalue0) in globalSettingsContainer {
                if let globalsettingsvalue0 = globalsettingsvalue0 {
                    globalSettingsDecoded0?[key0] = globalsettingsvalue0
                }
            }
        }
        globalSettings = globalSettingsDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension DescribeProtectedResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProtectedResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension DescribeProtectedResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeProtectedResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProtectedResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProtectedResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProtectedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProtectedResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProtectedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProtectedResourceOutputError>
}

public struct DescribeProtectedResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProtectedResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProtectedResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProtectedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProtectedResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProtectedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProtectedResourceOutputError>
}

public struct DescribeProtectedResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProtectedResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeProtectedResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProtectedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProtectedResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProtectedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProtectedResourceOutputError>
}

public struct DescribeProtectedResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProtectedResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeProtectedResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProtectedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/resources/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProtectedResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProtectedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProtectedResourceOutputError>
}

public struct DescribeProtectedResourceInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DescribeProtectedResourceInputBody: Swift.Equatable {
}

extension DescribeProtectedResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProtectedResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProtectedResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProtectedResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProtectedResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProtectedResourceOutputResponse(lastBackupTime: \(Swift.String(describing: lastBackupTime)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension DescribeProtectedResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProtectedResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastBackupTime = output.lastBackupTime
            self.resourceArn = output.resourceArn
            self.resourceType = output.resourceType
        } else {
            self.lastBackupTime = nil
            self.resourceArn = nil
            self.resourceType = nil
        }
    }
}

public struct DescribeProtectedResourceOutputResponse: Swift.Equatable {
    /// The date and time that a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastBackupTime: ClientRuntime.Date?
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon EBS volume or an Amazon RDS database.
    public var resourceType: Swift.String?

    public init (
        lastBackupTime: ClientRuntime.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.lastBackupTime = lastBackupTime
        self.resourceArn = resourceArn
        self.resourceType = resourceType
    }
}

struct DescribeProtectedResourceOutputResponseBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let resourceType: Swift.String?
    public let lastBackupTime: ClientRuntime.Date?
}

extension DescribeProtectedResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastBackupTime = "LastBackupTime"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastBackupTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastBackupTime)
        lastBackupTime = lastBackupTimeDecoded
    }
}

extension DescribeRecoveryPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRecoveryPointInput(backupVaultName: \(Swift.String(describing: backupVaultName)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)))"}
}

extension DescribeRecoveryPointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeRecoveryPointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecoveryPointOutputError>
}

public struct DescribeRecoveryPointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecoveryPointOutputError>
}

public struct DescribeRecoveryPointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecoveryPointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeRecoveryPointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRecoveryPointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecoveryPointOutputError>
}

public struct DescribeRecoveryPointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecoveryPointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeRecoveryPointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        guard let recoveryPointArn = input.recoveryPointArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("recoveryPointArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRecoveryPointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecoveryPointOutputError>
}

public struct DescribeRecoveryPointInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DescribeRecoveryPointInputBody: Swift.Equatable {
}

extension DescribeRecoveryPointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecoveryPointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRecoveryPointOutputResponse(backupSizeInBytes: \(Swift.String(describing: backupSizeInBytes)), backupVaultArn: \(Swift.String(describing: backupVaultArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), calculatedLifecycle: \(Swift.String(describing: calculatedLifecycle)), completionDate: \(Swift.String(describing: completionDate)), createdBy: \(Swift.String(describing: createdBy)), creationDate: \(Swift.String(describing: creationDate)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), isEncrypted: \(Swift.String(describing: isEncrypted)), lastRestoreTime: \(Swift.String(describing: lastRestoreTime)), lifecycle: \(Swift.String(describing: lifecycle)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)), sourceBackupVaultArn: \(Swift.String(describing: sourceBackupVaultArn)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), storageClass: \(Swift.String(describing: storageClass)))"}
}

extension DescribeRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRecoveryPointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupSizeInBytes = output.backupSizeInBytes
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.calculatedLifecycle = output.calculatedLifecycle
            self.completionDate = output.completionDate
            self.createdBy = output.createdBy
            self.creationDate = output.creationDate
            self.encryptionKeyArn = output.encryptionKeyArn
            self.iamRoleArn = output.iamRoleArn
            self.isEncrypted = output.isEncrypted
            self.lastRestoreTime = output.lastRestoreTime
            self.lifecycle = output.lifecycle
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceArn = output.resourceArn
            self.resourceType = output.resourceType
            self.sourceBackupVaultArn = output.sourceBackupVaultArn
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storageClass = output.storageClass
        } else {
            self.backupSizeInBytes = nil
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.calculatedLifecycle = nil
            self.completionDate = nil
            self.createdBy = nil
            self.creationDate = nil
            self.encryptionKeyArn = nil
            self.iamRoleArn = nil
            self.isEncrypted = false
            self.lastRestoreTime = nil
            self.lifecycle = nil
            self.recoveryPointArn = nil
            self.resourceArn = nil
            self.resourceType = nil
            self.sourceBackupVaultArn = nil
            self.status = nil
            self.statusMessage = nil
            self.storageClass = nil
        }
    }
}

public struct DescribeRecoveryPointOutputResponse: Swift.Equatable {
    /// The size, in bytes, of a backup.
    public var backupSizeInBytes: Swift.Int?
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
    public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    /// The date and time that a job to create a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: ClientRuntime.Date?
    /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan used to create it.
    public var createdBy: BackupClientTypes.RecoveryPointCreator?
    /// The date and time that a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// The server-side encryption key used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    public var encryptionKeyArn: Swift.String?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
    public var isEncrypted: Swift.Bool
    /// The date and time that a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastRestoreTime: ClientRuntime.Date?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups that are transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// An ARN that uniquely identifies a saved resource. The format of the ARN depends on the resource type.
    public var resourceArn: Swift.String?
    /// The type of Amazon Web Services resource to save as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database.
    public var resourceType: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies the source vault where the resource was originally backed up in; for example, arn:aws:backup:us-east-1:123456789012:vault:BackupVault. If the recovery is restored to the same Amazon Web Services account or Region, this value will be null.
    public var sourceBackupVaultArn: Swift.String?
    /// A status code specifying the state of the recovery point. PARTIAL status indicates Backup could not create the recovery point before the backup window closed. To increase your backup plan window using the API, see [UpdateBackupPlan](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_UpdateBackupPlan.html). You can also increase your backup plan window using the Console by choosing and editing your backup plan. EXPIRED status indicates that the recovery point has exceeded its retention period, but Backup lacks permission or is otherwise unable to delete it. To manually delete these recovery points, see [ Step 3: Delete the recovery points](https://docs.aws.amazon.com/aws-backup/latest/devguide/gs-cleanup-resources.html#cleanup-backups) in the Clean up resources section of Getting started.
    public var status: BackupClientTypes.RecoveryPointStatus?
    /// A status message explaining the reason for the recovery point deletion failure.
    public var statusMessage: Swift.String?
    /// Specifies the storage class of the recovery point. Valid values are WARM or COLD.
    public var storageClass: BackupClientTypes.StorageClass?

    public init (
        backupSizeInBytes: Swift.Int? = nil,
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
        completionDate: ClientRuntime.Date? = nil,
        createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
        creationDate: ClientRuntime.Date? = nil,
        encryptionKeyArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        isEncrypted: Swift.Bool = false,
        lastRestoreTime: ClientRuntime.Date? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        sourceBackupVaultArn: Swift.String? = nil,
        status: BackupClientTypes.RecoveryPointStatus? = nil,
        statusMessage: Swift.String? = nil,
        storageClass: BackupClientTypes.StorageClass? = nil
    )
    {
        self.backupSizeInBytes = backupSizeInBytes
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.calculatedLifecycle = calculatedLifecycle
        self.completionDate = completionDate
        self.createdBy = createdBy
        self.creationDate = creationDate
        self.encryptionKeyArn = encryptionKeyArn
        self.iamRoleArn = iamRoleArn
        self.isEncrypted = isEncrypted
        self.lastRestoreTime = lastRestoreTime
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
        self.resourceArn = resourceArn
        self.resourceType = resourceType
        self.sourceBackupVaultArn = sourceBackupVaultArn
        self.status = status
        self.statusMessage = statusMessage
        self.storageClass = storageClass
    }
}

struct DescribeRecoveryPointOutputResponseBody: Swift.Equatable {
    public let recoveryPointArn: Swift.String?
    public let backupVaultName: Swift.String?
    public let backupVaultArn: Swift.String?
    public let sourceBackupVaultArn: Swift.String?
    public let resourceArn: Swift.String?
    public let resourceType: Swift.String?
    public let createdBy: BackupClientTypes.RecoveryPointCreator?
    public let iamRoleArn: Swift.String?
    public let status: BackupClientTypes.RecoveryPointStatus?
    public let statusMessage: Swift.String?
    public let creationDate: ClientRuntime.Date?
    public let completionDate: ClientRuntime.Date?
    public let backupSizeInBytes: Swift.Int?
    public let calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    public let lifecycle: BackupClientTypes.Lifecycle?
    public let encryptionKeyArn: Swift.String?
    public let isEncrypted: Swift.Bool
    public let storageClass: BackupClientTypes.StorageClass?
    public let lastRestoreTime: ClientRuntime.Date?
}

extension DescribeRecoveryPointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case calculatedLifecycle = "CalculatedLifecycle"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case iamRoleArn = "IamRoleArn"
        case isEncrypted = "IsEncrypted"
        case lastRestoreTime = "LastRestoreTime"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case storageClass = "StorageClass"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let isEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isEncrypted)
        isEncrypted = isEncryptedDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(BackupClientTypes.StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let lastRestoreTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastRestoreTime)
        lastRestoreTime = lastRestoreTimeDecoded
    }
}

extension DescribeRegionSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRegionSettingsInput()"}
}

extension DescribeRegionSettingsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeRegionSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRegionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRegionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegionSettingsOutputError>
}

public struct DescribeRegionSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRegionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRegionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegionSettingsOutputError>
}

public struct DescribeRegionSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegionSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeRegionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRegionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegionSettingsOutputError>
}

public struct DescribeRegionSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegionSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeRegionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/account-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRegionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegionSettingsOutputError>
}

public struct DescribeRegionSettingsInput: Swift.Equatable {

    public init() {}
}

struct DescribeRegionSettingsInputBody: Swift.Equatable {
}

extension DescribeRegionSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRegionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRegionSettingsOutputError: Swift.Error, Swift.Equatable {
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegionSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRegionSettingsOutputResponse(resourceTypeManagementPreference: \(Swift.String(describing: resourceTypeManagementPreference)), resourceTypeOptInPreference: \(Swift.String(describing: resourceTypeOptInPreference)))"}
}

extension DescribeRegionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRegionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceTypeManagementPreference = output.resourceTypeManagementPreference
            self.resourceTypeOptInPreference = output.resourceTypeOptInPreference
        } else {
            self.resourceTypeManagementPreference = nil
            self.resourceTypeOptInPreference = nil
        }
    }
}

public struct DescribeRegionSettingsOutputResponse: Swift.Equatable {
    /// Returns whether a DynamoDB recovery point was taken using [ Backup's advanced DynamoDB backup features](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html).
    public var resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
    /// Returns a list of all services along with the opt-in preferences in the Region.
    public var resourceTypeOptInPreference: [Swift.String:Swift.Bool]?

    public init (
        resourceTypeManagementPreference: [Swift.String:Swift.Bool]? = nil,
        resourceTypeOptInPreference: [Swift.String:Swift.Bool]? = nil
    )
    {
        self.resourceTypeManagementPreference = resourceTypeManagementPreference
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

struct DescribeRegionSettingsOutputResponseBody: Swift.Equatable {
    public let resourceTypeOptInPreference: [Swift.String:Swift.Bool]?
    public let resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
}

extension DescribeRegionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeOptInPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeOptInPreference)
        var resourceTypeOptInPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeOptInPreferenceContainer = resourceTypeOptInPreferenceContainer {
            resourceTypeOptInPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeOptInPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeOptInPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeOptInPreference = resourceTypeOptInPreferenceDecoded0
        let resourceTypeManagementPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeManagementPreference)
        var resourceTypeManagementPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeManagementPreferenceContainer = resourceTypeManagementPreferenceContainer {
            resourceTypeManagementPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeManagementPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeManagementPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeManagementPreference = resourceTypeManagementPreferenceDecoded0
    }
}

extension DescribeReportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReportJobInput(reportJobId: \(Swift.String(describing: reportJobId)))"}
}

extension DescribeReportJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeReportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReportJobOutputError>
}

public struct DescribeReportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReportJobOutputError>
}

public struct DescribeReportJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReportJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeReportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeReportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReportJobOutputError>
}

public struct DescribeReportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReportJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeReportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let reportJobId = input.reportJobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("reportJobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/audit/report-jobs/\(reportJobId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeReportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReportJobOutputError>
}

public struct DescribeReportJobInput: Swift.Equatable {
    /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
    /// This member is required.
    public var reportJobId: Swift.String?

    public init (
        reportJobId: Swift.String? = nil
    )
    {
        self.reportJobId = reportJobId
    }
}

struct DescribeReportJobInputBody: Swift.Equatable {
}

extension DescribeReportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReportJobOutputError: Swift.Error, Swift.Equatable {
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReportJobOutputResponse(reportJob: \(Swift.String(describing: reportJob)))"}
}

extension DescribeReportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportJob = output.reportJob
        } else {
            self.reportJob = nil
        }
    }
}

public struct DescribeReportJobOutputResponse: Swift.Equatable {
    /// A list of information about a report job, including its completion and creation times, report destination, unique report job ID, Amazon Resource Name (ARN), report template, status, and status message.
    public var reportJob: BackupClientTypes.ReportJob?

    public init (
        reportJob: BackupClientTypes.ReportJob? = nil
    )
    {
        self.reportJob = reportJob
    }
}

struct DescribeReportJobOutputResponseBody: Swift.Equatable {
    public let reportJob: BackupClientTypes.ReportJob?
}

extension DescribeReportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportJob = "ReportJob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportJob.self, forKey: .reportJob)
        reportJob = reportJobDecoded
    }
}

extension DescribeReportPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReportPlanInput(reportPlanName: \(Swift.String(describing: reportPlanName)))"}
}

extension DescribeReportPlanInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeReportPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReportPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReportPlanOutputError>
}

public struct DescribeReportPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReportPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReportPlanOutputError>
}

public struct DescribeReportPlanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReportPlanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeReportPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeReportPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReportPlanOutputError>
}

public struct DescribeReportPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeReportPlanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeReportPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let reportPlanName = input.reportPlanName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("reportPlanName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeReportPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeReportPlanOutputError>
}

public struct DescribeReportPlanInput: Swift.Equatable {
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init (
        reportPlanName: Swift.String? = nil
    )
    {
        self.reportPlanName = reportPlanName
    }
}

struct DescribeReportPlanInputBody: Swift.Equatable {
}

extension DescribeReportPlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReportPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReportPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReportPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReportPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeReportPlanOutputResponse(reportPlan: \(Swift.String(describing: reportPlan)))"}
}

extension DescribeReportPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReportPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportPlan = output.reportPlan
        } else {
            self.reportPlan = nil
        }
    }
}

public struct DescribeReportPlanOutputResponse: Swift.Equatable {
    /// Returns details about the report plan that is specified by its name. These details include the report plan's Amazon Resource Name (ARN), description, settings, delivery channel, deployment status, creation time, and last attempted and successful run times.
    public var reportPlan: BackupClientTypes.ReportPlan?

    public init (
        reportPlan: BackupClientTypes.ReportPlan? = nil
    )
    {
        self.reportPlan = reportPlan
    }
}

struct DescribeReportPlanOutputResponseBody: Swift.Equatable {
    public let reportPlan: BackupClientTypes.ReportPlan?
}

extension DescribeReportPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportPlan = "ReportPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportPlan.self, forKey: .reportPlan)
        reportPlan = reportPlanDecoded
    }
}

extension DescribeRestoreJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRestoreJobInput(restoreJobId: \(Swift.String(describing: restoreJobId)))"}
}

extension DescribeRestoreJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeRestoreJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRestoreJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRestoreJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRestoreJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRestoreJobOutputError>
}

public struct DescribeRestoreJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRestoreJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRestoreJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRestoreJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRestoreJobOutputError>
}

public struct DescribeRestoreJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRestoreJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeRestoreJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRestoreJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRestoreJobOutputError>
}

public struct DescribeRestoreJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRestoreJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeRestoreJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let restoreJobId = input.restoreJobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("restoreJobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/restore-jobs/\(restoreJobId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRestoreJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRestoreJobOutputError>
}

public struct DescribeRestoreJobInput: Swift.Equatable {
    /// Uniquely identifies the job that restores a recovery point.
    /// This member is required.
    public var restoreJobId: Swift.String?

    public init (
        restoreJobId: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

struct DescribeRestoreJobInputBody: Swift.Equatable {
}

extension DescribeRestoreJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRestoreJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRestoreJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DependencyFailureException" : self = .dependencyFailureException(try DependencyFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRestoreJobOutputError: Swift.Error, Swift.Equatable {
    case dependencyFailureException(DependencyFailureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRestoreJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRestoreJobOutputResponse(accountId: \(Swift.String(describing: accountId)), backupSizeInBytes: \(Swift.String(describing: backupSizeInBytes)), completionDate: \(Swift.String(describing: completionDate)), createdResourceArn: \(Swift.String(describing: createdResourceArn)), creationDate: \(Swift.String(describing: creationDate)), expectedCompletionTimeMinutes: \(Swift.String(describing: expectedCompletionTimeMinutes)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), percentDone: \(Swift.String(describing: percentDone)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceType: \(Swift.String(describing: resourceType)), restoreJobId: \(Swift.String(describing: restoreJobId)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension DescribeRestoreJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRestoreJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.backupSizeInBytes = output.backupSizeInBytes
            self.completionDate = output.completionDate
            self.createdResourceArn = output.createdResourceArn
            self.creationDate = output.creationDate
            self.expectedCompletionTimeMinutes = output.expectedCompletionTimeMinutes
            self.iamRoleArn = output.iamRoleArn
            self.percentDone = output.percentDone
            self.recoveryPointArn = output.recoveryPointArn
            self.resourceType = output.resourceType
            self.restoreJobId = output.restoreJobId
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.accountId = nil
            self.backupSizeInBytes = nil
            self.completionDate = nil
            self.createdResourceArn = nil
            self.creationDate = nil
            self.expectedCompletionTimeMinutes = nil
            self.iamRoleArn = nil
            self.percentDone = nil
            self.recoveryPointArn = nil
            self.resourceType = nil
            self.restoreJobId = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribeRestoreJobOutputResponse: Swift.Equatable {
    /// Returns the account ID that owns the restore job.
    public var accountId: Swift.String?
    /// The size, in bytes, of the restored resource.
    public var backupSizeInBytes: Swift.Int?
    /// The date and time that a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var completionDate: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource whose recovery point is being restored. The format of the ARN depends on the resource type of the backed-up resource.
    public var createdResourceArn: Swift.String?
    /// The date and time that a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// The amount of time in minutes that a job restoring a recovery point is expected to take.
    public var expectedCompletionTimeMinutes: Swift.Int?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    public var iamRoleArn: Swift.String?
    /// Contains an estimated percentage that is complete of a job at the time the job status was queried.
    public var percentDone: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// Returns metadata associated with a restore job listed by resource type.
    public var resourceType: Swift.String?
    /// Uniquely identifies the job that restores a recovery point.
    public var restoreJobId: Swift.String?
    /// Status code specifying the state of the job that is initiated by Backup to restore a recovery point.
    public var status: BackupClientTypes.RestoreJobStatus?
    /// A message showing the status of a job to restore a recovery point.
    public var statusMessage: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        backupSizeInBytes: Swift.Int? = nil,
        completionDate: ClientRuntime.Date? = nil,
        createdResourceArn: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        expectedCompletionTimeMinutes: Swift.Int? = nil,
        iamRoleArn: Swift.String? = nil,
        percentDone: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        restoreJobId: Swift.String? = nil,
        status: BackupClientTypes.RestoreJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.backupSizeInBytes = backupSizeInBytes
        self.completionDate = completionDate
        self.createdResourceArn = createdResourceArn
        self.creationDate = creationDate
        self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
        self.iamRoleArn = iamRoleArn
        self.percentDone = percentDone
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
        self.restoreJobId = restoreJobId
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct DescribeRestoreJobOutputResponseBody: Swift.Equatable {
    public let accountId: Swift.String?
    public let restoreJobId: Swift.String?
    public let recoveryPointArn: Swift.String?
    public let creationDate: ClientRuntime.Date?
    public let completionDate: ClientRuntime.Date?
    public let status: BackupClientTypes.RestoreJobStatus?
    public let statusMessage: Swift.String?
    public let percentDone: Swift.String?
    public let backupSizeInBytes: Swift.Int?
    public let iamRoleArn: Swift.String?
    public let expectedCompletionTimeMinutes: Swift.Int?
    public let createdResourceArn: Swift.String?
    public let resourceType: Swift.String?
}

extension DescribeRestoreJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case createdResourceArn = "CreatedResourceArn"
        case creationDate = "CreationDate"
        case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
        case restoreJobId = "RestoreJobId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RestoreJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let expectedCompletionTimeMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedCompletionTimeMinutes)
        expectedCompletionTimeMinutes = expectedCompletionTimeMinutesDecoded
        let createdResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdResourceArn)
        createdResourceArn = createdResourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DisassociateRecoveryPointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateRecoveryPointInput(backupVaultName: \(Swift.String(describing: backupVaultName)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)))"}
}

extension DisassociateRecoveryPointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateRecoveryPointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateRecoveryPointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateRecoveryPointOutputError>
}

public struct DisassociateRecoveryPointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateRecoveryPointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateRecoveryPointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateRecoveryPointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateRecoveryPointOutputError>
}

public struct DisassociateRecoveryPointInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateRecoveryPointInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateRecoveryPointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateRecoveryPointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateRecoveryPointOutputError>
}

public struct DisassociateRecoveryPointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateRecoveryPointInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateRecoveryPointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateRecoveryPointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        guard let recoveryPointArn = input.recoveryPointArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("recoveryPointArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/disassociate"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateRecoveryPointInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateRecoveryPointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateRecoveryPointOutputError>
}

public struct DisassociateRecoveryPointInput: Swift.Equatable {
    /// The unique name of an Backup vault.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies an Backup recovery point.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct DisassociateRecoveryPointInputBody: Swift.Equatable {
}

extension DisassociateRecoveryPointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateRecoveryPointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRecoveryPointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceStateException" : self = .invalidResourceStateException(try InvalidResourceStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateRecoveryPointOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case invalidResourceStateException(InvalidResourceStateException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRecoveryPointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateRecoveryPointOutputResponse()"}
}

extension DisassociateRecoveryPointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateRecoveryPointOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateRecoveryPointOutputResponseBody: Swift.Equatable {
}

extension DisassociateRecoveryPointOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportBackupPlanTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportBackupPlanTemplateInput(backupPlanId: \(Swift.String(describing: backupPlanId)))"}
}

extension ExportBackupPlanTemplateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ExportBackupPlanTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportBackupPlanTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportBackupPlanTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportBackupPlanTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportBackupPlanTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportBackupPlanTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportBackupPlanTemplateOutputError>
}

public struct ExportBackupPlanTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportBackupPlanTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportBackupPlanTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportBackupPlanTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportBackupPlanTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportBackupPlanTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportBackupPlanTemplateOutputError>
}

public struct ExportBackupPlanTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportBackupPlanTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ExportBackupPlanTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportBackupPlanTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExportBackupPlanTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExportBackupPlanTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportBackupPlanTemplateOutputError>
}

public struct ExportBackupPlanTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportBackupPlanTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ExportBackupPlanTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportBackupPlanTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanId = input.backupPlanId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/plans/\(backupPlanId.urlPercentEncoding())/toTemplate"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExportBackupPlanTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExportBackupPlanTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportBackupPlanTemplateOutputError>
}

public struct ExportBackupPlanTemplateInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
    }
}

struct ExportBackupPlanTemplateInputBody: Swift.Equatable {
}

extension ExportBackupPlanTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportBackupPlanTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportBackupPlanTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportBackupPlanTemplateOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportBackupPlanTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportBackupPlanTemplateOutputResponse(backupPlanTemplateJson: \(Swift.String(describing: backupPlanTemplateJson)))"}
}

extension ExportBackupPlanTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExportBackupPlanTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanTemplateJson = output.backupPlanTemplateJson
        } else {
            self.backupPlanTemplateJson = nil
        }
    }
}

public struct ExportBackupPlanTemplateOutputResponse: Swift.Equatable {
    /// The body of a backup plan template in JSON format. This is a signed JSON document that cannot be modified before being passed to GetBackupPlanFromJSON.
    public var backupPlanTemplateJson: Swift.String?

    public init (
        backupPlanTemplateJson: Swift.String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

struct ExportBackupPlanTemplateOutputResponseBody: Swift.Equatable {
    public let backupPlanTemplateJson: Swift.String?
}

extension ExportBackupPlanTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateJson)
        backupPlanTemplateJson = backupPlanTemplateJsonDecoded
    }
}

extension BackupClientTypes.Framework: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case deploymentStatus = "DeploymentStatus"
        case frameworkArn = "FrameworkArn"
        case frameworkDescription = "FrameworkDescription"
        case frameworkName = "FrameworkName"
        case numberOfControls = "NumberOfControls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let frameworkArn = frameworkArn {
            try encodeContainer.encode(frameworkArn, forKey: .frameworkArn)
        }
        if let frameworkDescription = frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let frameworkName = frameworkName {
            try encodeContainer.encode(frameworkName, forKey: .frameworkName)
        }
        if numberOfControls != 0 {
            try encodeContainer.encode(numberOfControls, forKey: .numberOfControls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let numberOfControlsDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfControls)
        numberOfControls = numberOfControlsDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
    }
}

extension BackupClientTypes.Framework: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Framework(creationTime: \(Swift.String(describing: creationTime)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), frameworkArn: \(Swift.String(describing: frameworkArn)), frameworkDescription: \(Swift.String(describing: frameworkDescription)), frameworkName: \(Swift.String(describing: frameworkName)), numberOfControls: \(Swift.String(describing: numberOfControls)))"}
}

extension BackupClientTypes {
    /// Contains detailed information about a framework. Frameworks contain controls, which evaluate and report on your backup events and resources. Frameworks generate daily compliance results.
    public struct Framework: Swift.Equatable {
        /// The date and time that a framework is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationTime: ClientRuntime.Date?
        /// The deployment status of a framework. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED | FAILED
        public var deploymentStatus: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var frameworkArn: Swift.String?
        /// An optional description of the framework with a maximum 1,024 characters.
        public var frameworkDescription: Swift.String?
        /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public var frameworkName: Swift.String?
        /// The number of controls contained by the framework.
        public var numberOfControls: Swift.Int

        public init (
            creationTime: ClientRuntime.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            frameworkArn: Swift.String? = nil,
            frameworkDescription: Swift.String? = nil,
            frameworkName: Swift.String? = nil,
            numberOfControls: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.frameworkArn = frameworkArn
            self.frameworkDescription = frameworkDescription
            self.frameworkName = frameworkName
            self.numberOfControls = numberOfControls
        }
    }

}

extension BackupClientTypes.FrameworkControl: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlInputParameters = "ControlInputParameters"
        case controlName = "ControlName"
        case controlScope = "ControlScope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlInputParameters = controlInputParameters {
            var controlInputParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlInputParameters)
            for controlinputparameters0 in controlInputParameters {
                try controlInputParametersContainer.encode(controlinputparameters0)
            }
        }
        if let controlName = controlName {
            try encodeContainer.encode(controlName, forKey: .controlName)
        }
        if let controlScope = controlScope {
            try encodeContainer.encode(controlScope, forKey: .controlScope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlName)
        controlName = controlNameDecoded
        let controlInputParametersContainer = try containerValues.decodeIfPresent([BackupClientTypes.ControlInputParameter?].self, forKey: .controlInputParameters)
        var controlInputParametersDecoded0:[BackupClientTypes.ControlInputParameter]? = nil
        if let controlInputParametersContainer = controlInputParametersContainer {
            controlInputParametersDecoded0 = [BackupClientTypes.ControlInputParameter]()
            for structure0 in controlInputParametersContainer {
                if let structure0 = structure0 {
                    controlInputParametersDecoded0?.append(structure0)
                }
            }
        }
        controlInputParameters = controlInputParametersDecoded0
        let controlScopeDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ControlScope.self, forKey: .controlScope)
        controlScope = controlScopeDecoded
    }
}

extension BackupClientTypes.FrameworkControl: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FrameworkControl(controlInputParameters: \(Swift.String(describing: controlInputParameters)), controlName: \(Swift.String(describing: controlName)), controlScope: \(Swift.String(describing: controlScope)))"}
}

extension BackupClientTypes {
    /// Contains detailed information about all of the controls of a framework. Each framework must contain at least one control.
    public struct FrameworkControl: Swift.Equatable {
        /// A list of ParameterName and ParameterValue pairs.
        public var controlInputParameters: [BackupClientTypes.ControlInputParameter]?
        /// The name of a control. This name is between 1 and 256 characters.
        /// This member is required.
        public var controlName: Swift.String?
        /// The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans. For more information, see ControlScope.
        public var controlScope: BackupClientTypes.ControlScope?

        public init (
            controlInputParameters: [BackupClientTypes.ControlInputParameter]? = nil,
            controlName: Swift.String? = nil,
            controlScope: BackupClientTypes.ControlScope? = nil
        )
        {
            self.controlInputParameters = controlInputParameters
            self.controlName = controlName
            self.controlScope = controlScope
        }
    }

}

public struct GetBackupPlanFromJSONInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanFromJSONInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupPlanFromJSONInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupPlanFromJSONInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanFromJSONOutputError>
}

extension GetBackupPlanFromJSONInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupPlanFromJSONInput(backupPlanTemplateJson: \(Swift.String(describing: backupPlanTemplateJson)))"}
}

extension GetBackupPlanFromJSONInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanTemplateJson = backupPlanTemplateJson {
            try encodeContainer.encode(backupPlanTemplateJson, forKey: .backupPlanTemplateJson)
        }
    }
}

public struct GetBackupPlanFromJSONInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanFromJSONInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupPlanFromJSONInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupPlanFromJSONInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanFromJSONOutputError>
}

public struct GetBackupPlanFromJSONInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanFromJSONInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupPlanFromJSONInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupPlanFromJSONInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanFromJSONOutputError>
}

public struct GetBackupPlanFromJSONInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanFromJSONInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBackupPlanFromJSONInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupPlanFromJSONInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanFromJSONOutputError>
}

public struct GetBackupPlanFromJSONInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanFromJSONInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBackupPlanFromJSONInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/backup/template/json/toPlan"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupPlanFromJSONInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanFromJSONOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanFromJSONOutputError>
}

public struct GetBackupPlanFromJSONInput: Swift.Equatable {
    /// A customer-supplied backup plan document in JSON format.
    /// This member is required.
    public var backupPlanTemplateJson: Swift.String?

    public init (
        backupPlanTemplateJson: Swift.String? = nil
    )
    {
        self.backupPlanTemplateJson = backupPlanTemplateJson
    }
}

struct GetBackupPlanFromJSONInputBody: Swift.Equatable {
    public let backupPlanTemplateJson: Swift.String?
}

extension GetBackupPlanFromJSONInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplateJson = "BackupPlanTemplateJson"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanTemplateJsonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanTemplateJson)
        backupPlanTemplateJson = backupPlanTemplateJsonDecoded
    }
}

extension GetBackupPlanFromJSONOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupPlanFromJSONOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupPlanFromJSONOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupPlanFromJSONOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupPlanFromJSONOutputResponse(backupPlan: \(Swift.String(describing: backupPlan)))"}
}

extension GetBackupPlanFromJSONOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackupPlanFromJSONOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlan = output.backupPlan
        } else {
            self.backupPlan = nil
        }
    }
}

public struct GetBackupPlanFromJSONOutputResponse: Swift.Equatable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    public var backupPlan: BackupClientTypes.BackupPlan?

    public init (
        backupPlan: BackupClientTypes.BackupPlan? = nil
    )
    {
        self.backupPlan = backupPlan
    }
}

struct GetBackupPlanFromJSONOutputResponseBody: Swift.Equatable {
    public let backupPlan: BackupClientTypes.BackupPlan?
}

extension GetBackupPlanFromJSONOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlan.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
    }
}

extension GetBackupPlanFromTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupPlanFromTemplateInput(backupPlanTemplateId: \(Swift.String(describing: backupPlanTemplateId)))"}
}

extension GetBackupPlanFromTemplateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBackupPlanFromTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanFromTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupPlanFromTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupPlanFromTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanFromTemplateOutputError>
}

public struct GetBackupPlanFromTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanFromTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupPlanFromTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupPlanFromTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanFromTemplateOutputError>
}

public struct GetBackupPlanFromTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanFromTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBackupPlanFromTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupPlanFromTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanFromTemplateOutputError>
}

public struct GetBackupPlanFromTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanFromTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBackupPlanFromTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanFromTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanTemplateId = input.backupPlanTemplateId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanTemplateId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/template/plans/\(backupPlanTemplateId.urlPercentEncoding())/toPlan"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupPlanFromTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanFromTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanFromTemplateOutputError>
}

public struct GetBackupPlanFromTemplateInput: Swift.Equatable {
    /// Uniquely identifies a stored backup plan template.
    /// This member is required.
    public var backupPlanTemplateId: Swift.String?

    public init (
        backupPlanTemplateId: Swift.String? = nil
    )
    {
        self.backupPlanTemplateId = backupPlanTemplateId
    }
}

struct GetBackupPlanFromTemplateInputBody: Swift.Equatable {
}

extension GetBackupPlanFromTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupPlanFromTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupPlanFromTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupPlanFromTemplateOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupPlanFromTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupPlanFromTemplateOutputResponse(backupPlanDocument: \(Swift.String(describing: backupPlanDocument)))"}
}

extension GetBackupPlanFromTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackupPlanFromTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanDocument = output.backupPlanDocument
        } else {
            self.backupPlanDocument = nil
        }
    }
}

public struct GetBackupPlanFromTemplateOutputResponse: Swift.Equatable {
    /// Returns the body of a backup plan based on the target template, including the name, rules, and backup vault of the plan.
    public var backupPlanDocument: BackupClientTypes.BackupPlan?

    public init (
        backupPlanDocument: BackupClientTypes.BackupPlan? = nil
    )
    {
        self.backupPlanDocument = backupPlanDocument
    }
}

struct GetBackupPlanFromTemplateOutputResponseBody: Swift.Equatable {
    public let backupPlanDocument: BackupClientTypes.BackupPlan?
}

extension GetBackupPlanFromTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanDocument = "BackupPlanDocument"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDocumentDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlan.self, forKey: .backupPlanDocument)
        backupPlanDocument = backupPlanDocumentDecoded
    }
}

extension GetBackupPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupPlanInput(backupPlanId: \(Swift.String(describing: backupPlanId)), versionId: \(Swift.String(describing: versionId)))"}
}

extension GetBackupPlanInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBackupPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanOutputError>
}

public struct GetBackupPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let versionId = input.operationInput.versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            input.builder.withQueryItem(versionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanOutputError>
}

public struct GetBackupPlanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBackupPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanOutputError>
}

public struct GetBackupPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupPlanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBackupPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanId = input.backupPlanId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/plans/\(backupPlanId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupPlanOutputError>
}

public struct GetBackupPlanInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.versionId = versionId
    }
}

struct GetBackupPlanInputBody: Swift.Equatable {
}

extension GetBackupPlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupPlanOutputResponse(advancedBackupSettings: \(Swift.String(describing: advancedBackupSettings)), backupPlan: \(Swift.String(describing: backupPlan)), backupPlanArn: \(Swift.String(describing: backupPlanArn)), backupPlanId: \(Swift.String(describing: backupPlanId)), creationDate: \(Swift.String(describing: creationDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), deletionDate: \(Swift.String(describing: deletionDate)), lastExecutionDate: \(Swift.String(describing: lastExecutionDate)), versionId: \(Swift.String(describing: versionId)))"}
}

extension GetBackupPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlan = output.backupPlan
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.deletionDate = output.deletionDate
            self.lastExecutionDate = output.lastExecutionDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlan = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.deletionDate = nil
            self.lastExecutionDate = nil
            self.versionId = nil
        }
    }
}

public struct GetBackupPlanOutputResponse: Swift.Equatable {
    /// Contains a list of BackupOptions for each resource type. The list is populated only if the advanced option is set for the backup plan.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    public var backupPlan: BackupClientTypes.BackupPlan?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time that a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// The date and time that a backup plan is deleted, in Unix format and Coordinated Universal Time (UTC). The value of DeletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var deletionDate: ClientRuntime.Date?
    /// The last time a job to back up resources was run with this backup plan. A date and time, in Unix format and Coordinated Universal Time (UTC). The value of LastExecutionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var lastExecutionDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
    public var versionId: Swift.String?

    public init (
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlan: BackupClientTypes.BackupPlan? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        deletionDate: ClientRuntime.Date? = nil,
        lastExecutionDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlan = backupPlan
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.deletionDate = deletionDate
        self.lastExecutionDate = lastExecutionDate
        self.versionId = versionId
    }
}

struct GetBackupPlanOutputResponseBody: Swift.Equatable {
    public let backupPlan: BackupClientTypes.BackupPlan?
    public let backupPlanId: Swift.String?
    public let backupPlanArn: Swift.String?
    public let versionId: Swift.String?
    public let creatorRequestId: Swift.String?
    public let creationDate: ClientRuntime.Date?
    public let deletionDate: ClientRuntime.Date?
    public let lastExecutionDate: ClientRuntime.Date?
    public let advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
}

extension GetBackupPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlan = "BackupPlan"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case deletionDate = "DeletionDate"
        case lastExecutionDate = "LastExecutionDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlan.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let deletionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deletionDate)
        deletionDate = deletionDateDecoded
        let lastExecutionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastExecutionDate)
        lastExecutionDate = lastExecutionDateDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

extension GetBackupSelectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupSelectionInput(backupPlanId: \(Swift.String(describing: backupPlanId)), selectionId: \(Swift.String(describing: selectionId)))"}
}

extension GetBackupSelectionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBackupSelectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupSelectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupSelectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupSelectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupSelectionOutputError>
}

public struct GetBackupSelectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupSelectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupSelectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupSelectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupSelectionOutputError>
}

public struct GetBackupSelectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupSelectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBackupSelectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupSelectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupSelectionOutputError>
}

public struct GetBackupSelectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupSelectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBackupSelectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupSelectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanId = input.backupPlanId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanId is nil and needs a value for the path of this operation"))))
        }
        guard let selectionId = input.selectionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("selectionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections/\(selectionId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupSelectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupSelectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupSelectionOutputError>
}

public struct GetBackupSelectionInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    /// This member is required.
    public var selectionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.selectionId = selectionId
    }
}

struct GetBackupSelectionInputBody: Swift.Equatable {
}

extension GetBackupSelectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupSelectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupSelectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupSelectionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupSelectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupSelectionOutputResponse(backupPlanId: \(Swift.String(describing: backupPlanId)), backupSelection: \(Swift.String(describing: backupSelection)), creationDate: \(Swift.String(describing: creationDate)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), selectionId: \(Swift.String(describing: selectionId)))"}
}

extension GetBackupSelectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackupSelectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanId = output.backupPlanId
            self.backupSelection = output.backupSelection
            self.creationDate = output.creationDate
            self.creatorRequestId = output.creatorRequestId
            self.selectionId = output.selectionId
        } else {
            self.backupPlanId = nil
            self.backupSelection = nil
            self.creationDate = nil
            self.creatorRequestId = nil
            self.selectionId = nil
        }
    }
}

public struct GetBackupSelectionOutputResponse: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// Specifies the body of a request to assign a set of resources to a backup plan.
    public var backupSelection: BackupClientTypes.BackupSelection?
    /// The date and time a backup selection is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// A unique string that identifies the request and allows failed requests to be retried without the risk of running the operation twice.
    public var creatorRequestId: Swift.String?
    /// Uniquely identifies the body of a request to assign a set of resources to a backup plan.
    public var selectionId: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        backupSelection: BackupClientTypes.BackupSelection? = nil,
        creationDate: ClientRuntime.Date? = nil,
        creatorRequestId: Swift.String? = nil,
        selectionId: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.backupSelection = backupSelection
        self.creationDate = creationDate
        self.creatorRequestId = creatorRequestId
        self.selectionId = selectionId
    }
}

struct GetBackupSelectionOutputResponseBody: Swift.Equatable {
    public let backupSelection: BackupClientTypes.BackupSelection?
    public let selectionId: Swift.String?
    public let backupPlanId: Swift.String?
    public let creationDate: ClientRuntime.Date?
    public let creatorRequestId: Swift.String?
}

extension GetBackupSelectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanId = "BackupPlanId"
        case backupSelection = "BackupSelection"
        case creationDate = "CreationDate"
        case creatorRequestId = "CreatorRequestId"
        case selectionId = "SelectionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupSelectionDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupSelection.self, forKey: .backupSelection)
        backupSelection = backupSelectionDecoded
        let selectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionId)
        selectionId = selectionIdDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
    }
}

extension GetBackupVaultAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupVaultAccessPolicyInput(backupVaultName: \(Swift.String(describing: backupVaultName)))"}
}

extension GetBackupVaultAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBackupVaultAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupVaultAccessPolicyOutputError>
}

public struct GetBackupVaultAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupVaultAccessPolicyOutputError>
}

public struct GetBackupVaultAccessPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupVaultAccessPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBackupVaultAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupVaultAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupVaultAccessPolicyOutputError>
}

public struct GetBackupVaultAccessPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupVaultAccessPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBackupVaultAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupVaultAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupVaultAccessPolicyOutputError>
}

public struct GetBackupVaultAccessPolicyInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct GetBackupVaultAccessPolicyInputBody: Swift.Equatable {
}

extension GetBackupVaultAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupVaultAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupVaultAccessPolicyOutputResponse(backupVaultArn: \(Swift.String(describing: backupVaultArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), policy: \(Swift.String(describing: policy)))"}
}

extension GetBackupVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackupVaultAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultName = output.backupVaultName
            self.policy = output.policy
        } else {
            self.backupVaultArn = nil
            self.backupVaultName = nil
            self.policy = nil
        }
    }
}

public struct GetBackupVaultAccessPolicyOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// The backup vault access policy document in JSON format.
    public var policy: Swift.String?

    public init (
        backupVaultArn: Swift.String? = nil,
        backupVaultName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

struct GetBackupVaultAccessPolicyOutputResponseBody: Swift.Equatable {
    public let backupVaultName: Swift.String?
    public let backupVaultArn: Swift.String?
    public let policy: Swift.String?
}

extension GetBackupVaultAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetBackupVaultNotificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupVaultNotificationsInput(backupVaultName: \(Swift.String(describing: backupVaultName)))"}
}

extension GetBackupVaultNotificationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBackupVaultNotificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupVaultNotificationsOutputError>
}

public struct GetBackupVaultNotificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackupVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupVaultNotificationsOutputError>
}

public struct GetBackupVaultNotificationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupVaultNotificationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetBackupVaultNotificationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupVaultNotificationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupVaultNotificationsOutputError>
}

public struct GetBackupVaultNotificationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackupVaultNotificationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetBackupVaultNotificationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetBackupVaultNotificationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackupVaultNotificationsOutputError>
}

public struct GetBackupVaultNotificationsInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
    }
}

struct GetBackupVaultNotificationsInputBody: Swift.Equatable {
}

extension GetBackupVaultNotificationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackupVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackupVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackupVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackupVaultNotificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackupVaultNotificationsOutputResponse(backupVaultArn: \(Swift.String(describing: backupVaultArn)), backupVaultEvents: \(Swift.String(describing: backupVaultEvents)), backupVaultName: \(Swift.String(describing: backupVaultName)), sNSTopicArn: \(Swift.String(describing: sNSTopicArn)))"}
}

extension GetBackupVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackupVaultNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.backupVaultEvents = output.backupVaultEvents
            self.backupVaultName = output.backupVaultName
            self.sNSTopicArn = output.sNSTopicArn
        } else {
            self.backupVaultArn = nil
            self.backupVaultEvents = nil
            self.backupVaultName = nil
            self.sNSTopicArn = nil
        }
    }
}

public struct GetBackupVaultNotificationsOutputResponse: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// An array of events that indicate the status of jobs to back up resources to the backup vault.
    public var backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var backupVaultName: Swift.String?
    /// An ARN that uniquely identifies an Amazon Simple Notification Service (Amazon SNS) topic; for example, arn:aws:sns:us-west-2:111122223333:MyTopic.
    public var sNSTopicArn: Swift.String?

    public init (
        backupVaultArn: Swift.String? = nil,
        backupVaultEvents: [BackupClientTypes.BackupVaultEvent]? = nil,
        backupVaultName: Swift.String? = nil,
        sNSTopicArn: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.sNSTopicArn = sNSTopicArn
    }
}

struct GetBackupVaultNotificationsOutputResponseBody: Swift.Equatable {
    public let backupVaultName: Swift.String?
    public let backupVaultArn: Swift.String?
    public let sNSTopicArn: Swift.String?
    public let backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
}

extension GetBackupVaultNotificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case backupVaultEvents = "BackupVaultEvents"
        case backupVaultName = "BackupVaultName"
        case sNSTopicArn = "SNSTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sNSTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNSTopicArn)
        sNSTopicArn = sNSTopicArnDecoded
        let backupVaultEventsContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupVaultEvent?].self, forKey: .backupVaultEvents)
        var backupVaultEventsDecoded0:[BackupClientTypes.BackupVaultEvent]? = nil
        if let backupVaultEventsContainer = backupVaultEventsContainer {
            backupVaultEventsDecoded0 = [BackupClientTypes.BackupVaultEvent]()
            for string0 in backupVaultEventsContainer {
                if let string0 = string0 {
                    backupVaultEventsDecoded0?.append(string0)
                }
            }
        }
        backupVaultEvents = backupVaultEventsDecoded0
    }
}

extension GetRecoveryPointRestoreMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecoveryPointRestoreMetadataInput(backupVaultName: \(Swift.String(describing: backupVaultName)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)))"}
}

extension GetRecoveryPointRestoreMetadataInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRecoveryPointRestoreMetadataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecoveryPointRestoreMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecoveryPointRestoreMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecoveryPointRestoreMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecoveryPointRestoreMetadataOutputError>
}

public struct GetRecoveryPointRestoreMetadataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecoveryPointRestoreMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecoveryPointRestoreMetadataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecoveryPointRestoreMetadataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecoveryPointRestoreMetadataOutputError>
}

public struct GetRecoveryPointRestoreMetadataInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecoveryPointRestoreMetadataInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetRecoveryPointRestoreMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRecoveryPointRestoreMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecoveryPointRestoreMetadataOutputError>
}

public struct GetRecoveryPointRestoreMetadataInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecoveryPointRestoreMetadataInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetRecoveryPointRestoreMetadataInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        guard let recoveryPointArn = input.recoveryPointArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("recoveryPointArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())/restore-metadata"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRecoveryPointRestoreMetadataInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecoveryPointRestoreMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecoveryPointRestoreMetadataOutputError>
}

public struct GetRecoveryPointRestoreMetadataInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.recoveryPointArn = recoveryPointArn
    }
}

struct GetRecoveryPointRestoreMetadataInputBody: Swift.Equatable {
}

extension GetRecoveryPointRestoreMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecoveryPointRestoreMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecoveryPointRestoreMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecoveryPointRestoreMetadataOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecoveryPointRestoreMetadataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecoveryPointRestoreMetadataOutputResponse(backupVaultArn: \(Swift.String(describing: backupVaultArn)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), restoreMetadata: \(Swift.String(describing: restoreMetadata)))"}
}

extension GetRecoveryPointRestoreMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecoveryPointRestoreMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.recoveryPointArn = output.recoveryPointArn
            self.restoreMetadata = output.restoreMetadata
        } else {
            self.backupVaultArn = nil
            self.recoveryPointArn = nil
            self.restoreMetadata = nil
        }
    }
}

public struct GetRecoveryPointRestoreMetadataOutputResponse: Swift.Equatable {
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?
    /// The set of metadata key-value pairs that describe the original configuration of the backed-up resource. These values vary depending on the service that is being restored.
    public var restoreMetadata: [Swift.String:Swift.String]?

    public init (
        backupVaultArn: Swift.String? = nil,
        recoveryPointArn: Swift.String? = nil,
        restoreMetadata: [Swift.String:Swift.String]? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.recoveryPointArn = recoveryPointArn
        self.restoreMetadata = restoreMetadata
    }
}

struct GetRecoveryPointRestoreMetadataOutputResponseBody: Swift.Equatable {
    public let backupVaultArn: Swift.String?
    public let recoveryPointArn: Swift.String?
    public let restoreMetadata: [Swift.String:Swift.String]?
}

extension GetRecoveryPointRestoreMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case recoveryPointArn = "RecoveryPointArn"
        case restoreMetadata = "RestoreMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let restoreMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .restoreMetadata)
        var restoreMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let restoreMetadataContainer = restoreMetadataContainer {
            restoreMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in restoreMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    restoreMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        restoreMetadata = restoreMetadataDecoded0
    }
}

extension GetSupportedResourceTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSupportedResourceTypesInput()"}
}

extension GetSupportedResourceTypesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSupportedResourceTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSupportedResourceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSupportedResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSupportedResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSupportedResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSupportedResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSupportedResourceTypesOutputError>
}

public struct GetSupportedResourceTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSupportedResourceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSupportedResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSupportedResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSupportedResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSupportedResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSupportedResourceTypesOutputError>
}

public struct GetSupportedResourceTypesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSupportedResourceTypesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetSupportedResourceTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSupportedResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSupportedResourceTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSupportedResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSupportedResourceTypesOutputError>
}

public struct GetSupportedResourceTypesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSupportedResourceTypesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetSupportedResourceTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSupportedResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/supported-resource-types"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSupportedResourceTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSupportedResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSupportedResourceTypesOutputError>
}

public struct GetSupportedResourceTypesInput: Swift.Equatable {

    public init() {}
}

struct GetSupportedResourceTypesInputBody: Swift.Equatable {
}

extension GetSupportedResourceTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSupportedResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSupportedResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSupportedResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSupportedResourceTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSupportedResourceTypesOutputResponse(resourceTypes: \(Swift.String(describing: resourceTypes)))"}
}

extension GetSupportedResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSupportedResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceTypes = output.resourceTypes
        } else {
            self.resourceTypes = nil
        }
    }
}

public struct GetSupportedResourceTypesOutputResponse: Swift.Equatable {
    /// Contains a string with the supported Amazon Web Services resource types:
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * FSX for Amazon FSx
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Storage Gateway for Storage Gateway
    public var resourceTypes: [Swift.String]?

    public init (
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.resourceTypes = resourceTypes
    }
}

struct GetSupportedResourceTypesOutputResponseBody: Swift.Equatable {
    public let resourceTypes: [Swift.String]?
}

extension GetSupportedResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypes = "ResourceTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension InvalidParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterValueException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that something is wrong with a parameter's value. For example, the value is out of range.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that something is wrong with the input to the request. For example, a parameter is of the wrong type.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension InvalidResourceStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResourceStateException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension InvalidResourceStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Backup is already performing an action on this recovery point. It can't perform the action you requested until the first action finishes. Try again later.
public struct InvalidResourceStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct InvalidResourceStateExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension InvalidResourceStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.Lifecycle: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAfterDays = "DeleteAfterDays"
        case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAfterDays = deleteAfterDays {
            try encodeContainer.encode(deleteAfterDays, forKey: .deleteAfterDays)
        }
        if let moveToColdStorageAfterDays = moveToColdStorageAfterDays {
            try encodeContainer.encode(moveToColdStorageAfterDays, forKey: .moveToColdStorageAfterDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moveToColdStorageAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .moveToColdStorageAfterDays)
        moveToColdStorageAfterDays = moveToColdStorageAfterDaysDecoded
        let deleteAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deleteAfterDays)
        deleteAfterDays = deleteAfterDaysDecoded
    }
}

extension BackupClientTypes.Lifecycle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Lifecycle(deleteAfterDays: \(Swift.String(describing: deleteAfterDays)), moveToColdStorageAfterDays: \(Swift.String(describing: moveToColdStorageAfterDays)))"}
}

extension BackupClientTypes {
    /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
    public struct Lifecycle: Swift.Equatable {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public var deleteAfterDays: Swift.Int?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAfterDays: Swift.Int?

        public init (
            deleteAfterDays: Swift.Int? = nil,
            moveToColdStorageAfterDays: Swift.Int? = nil
        )
        {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit in the request has been exceeded; for example, a maximum number of items allowed in a request.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension ListBackupJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupJobsInput(byAccountId: \(Swift.String(describing: byAccountId)), byBackupVaultName: \(Swift.String(describing: byBackupVaultName)), byCreatedAfter: \(Swift.String(describing: byCreatedAfter)), byCreatedBefore: \(Swift.String(describing: byCreatedBefore)), byResourceArn: \(Swift.String(describing: byResourceArn)), byResourceType: \(Swift.String(describing: byResourceType)), byState: \(Swift.String(describing: byState)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupJobsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBackupJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupJobsOutputError>
}

public struct ListBackupJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let byCreatedBefore = input.operationInput.byCreatedBefore {
            let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(byCreatedBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedBeforeQueryItem)
        }
        if let byResourceType = input.operationInput.byResourceType {
            let byResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
            input.builder.withQueryItem(byResourceTypeQueryItem)
        }
        if let byBackupVaultName = input.operationInput.byBackupVaultName {
            let byBackupVaultNameQueryItem = ClientRuntime.URLQueryItem(name: "backupVaultName".urlPercentEncoding(), value: Swift.String(byBackupVaultName).urlPercentEncoding())
            input.builder.withQueryItem(byBackupVaultNameQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let byResourceArn = input.operationInput.byResourceArn {
            let byResourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
            input.builder.withQueryItem(byResourceArnQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let byState = input.operationInput.byState {
            let byStateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(byState.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(byStateQueryItem)
        }
        if let byAccountId = input.operationInput.byAccountId {
            let byAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
            input.builder.withQueryItem(byAccountIdQueryItem)
        }
        if let byCreatedAfter = input.operationInput.byCreatedAfter {
            let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(byCreatedAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupJobsOutputError>
}

public struct ListBackupJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListBackupJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupJobsOutputError>
}

public struct ListBackupJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListBackupJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/backup-jobs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupJobsOutputError>
}

public struct ListBackupJobsInput: Swift.Equatable {
    /// The account ID to list the jobs from. Returns only backup jobs associated with the specified account ID. If used from an Organizations management account, passing * returns all jobs across the organization.
    public var byAccountId: Swift.String?
    /// Returns only backup jobs that will be stored in the specified backup vault. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    public var byBackupVaultName: Swift.String?
    /// Returns only backup jobs that were created after the specified date.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only backup jobs that were created before the specified date.
    public var byCreatedBefore: ClientRuntime.Date?
    /// Returns only backup jobs that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only backup jobs for the specified resources:
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * Storage Gateway for Storage Gateway
    public var byResourceType: Swift.String?
    /// Returns only backup jobs that are in the specified state.
    public var byState: BackupClientTypes.BackupJobState?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        byAccountId: Swift.String? = nil,
        byBackupVaultName: Swift.String? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        byState: BackupClientTypes.BackupJobState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byBackupVaultName = byBackupVaultName
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupJobsInputBody: Swift.Equatable {
}

extension ListBackupJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupJobsOutputResponse(backupJobs: \(Swift.String(describing: backupJobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBackupJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupJobs = output.backupJobs
            self.nextToken = output.nextToken
        } else {
            self.backupJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupJobsOutputResponse: Swift.Equatable {
    /// An array of structures containing metadata about your backup jobs returned in JSON format.
    public var backupJobs: [BackupClientTypes.BackupJob]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupJobs: [BackupClientTypes.BackupJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupJobs = backupJobs
        self.nextToken = nextToken
    }
}

struct ListBackupJobsOutputResponseBody: Swift.Equatable {
    public let backupJobs: [BackupClientTypes.BackupJob]?
    public let nextToken: Swift.String?
}

extension ListBackupJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupJobs = "BackupJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupJob?].self, forKey: .backupJobs)
        var backupJobsDecoded0:[BackupClientTypes.BackupJob]? = nil
        if let backupJobsContainer = backupJobsContainer {
            backupJobsDecoded0 = [BackupClientTypes.BackupJob]()
            for structure0 in backupJobsContainer {
                if let structure0 = structure0 {
                    backupJobsDecoded0?.append(structure0)
                }
            }
        }
        backupJobs = backupJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBackupPlanTemplatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupPlanTemplatesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupPlanTemplatesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBackupPlanTemplatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlanTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupPlanTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlanTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupPlanTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlanTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlanTemplatesOutputError>
}

public struct ListBackupPlanTemplatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlanTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupPlanTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlanTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupPlanTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlanTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlanTemplatesOutputError>
}

public struct ListBackupPlanTemplatesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlanTemplatesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListBackupPlanTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlanTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupPlanTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlanTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlanTemplatesOutputError>
}

public struct ListBackupPlanTemplatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlanTemplatesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListBackupPlanTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlanTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/backup/template/plans"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupPlanTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlanTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlanTemplatesOutputError>
}

public struct ListBackupPlanTemplatesInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlanTemplatesInputBody: Swift.Equatable {
}

extension ListBackupPlanTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupPlanTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupPlanTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupPlanTemplatesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupPlanTemplatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupPlanTemplatesOutputResponse(backupPlanTemplatesList: \(Swift.String(describing: backupPlanTemplatesList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupPlanTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBackupPlanTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanTemplatesList = output.backupPlanTemplatesList
            self.nextToken = output.nextToken
        } else {
            self.backupPlanTemplatesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlanTemplatesOutputResponse: Swift.Equatable {
    /// An array of template list items containing metadata about your saved templates.
    public var backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanTemplatesList = backupPlanTemplatesList
        self.nextToken = nextToken
    }
}

struct ListBackupPlanTemplatesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let backupPlanTemplatesList: [BackupClientTypes.BackupPlanTemplatesListMember]?
}

extension ListBackupPlanTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanTemplatesList = "BackupPlanTemplatesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlanTemplatesListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupPlanTemplatesListMember?].self, forKey: .backupPlanTemplatesList)
        var backupPlanTemplatesListDecoded0:[BackupClientTypes.BackupPlanTemplatesListMember]? = nil
        if let backupPlanTemplatesListContainer = backupPlanTemplatesListContainer {
            backupPlanTemplatesListDecoded0 = [BackupClientTypes.BackupPlanTemplatesListMember]()
            for structure0 in backupPlanTemplatesListContainer {
                if let structure0 = structure0 {
                    backupPlanTemplatesListDecoded0?.append(structure0)
                }
            }
        }
        backupPlanTemplatesList = backupPlanTemplatesListDecoded0
    }
}

extension ListBackupPlanVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupPlanVersionsInput(backupPlanId: \(Swift.String(describing: backupPlanId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupPlanVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBackupPlanVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlanVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupPlanVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlanVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupPlanVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlanVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlanVersionsOutputError>
}

public struct ListBackupPlanVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlanVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupPlanVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlanVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupPlanVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlanVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlanVersionsOutputError>
}

public struct ListBackupPlanVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlanVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListBackupPlanVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlanVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupPlanVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlanVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlanVersionsOutputError>
}

public struct ListBackupPlanVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlanVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListBackupPlanVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlanVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanId = input.backupPlanId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/plans/\(backupPlanId.urlPercentEncoding())/versions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupPlanVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlanVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlanVersionsOutputError>
}

public struct ListBackupPlanVersionsInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlanVersionsInputBody: Swift.Equatable {
}

extension ListBackupPlanVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupPlanVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupPlanVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupPlanVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupPlanVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupPlanVersionsOutputResponse(backupPlanVersionsList: \(Swift.String(describing: backupPlanVersionsList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupPlanVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBackupPlanVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlanVersionsList = output.backupPlanVersionsList
            self.nextToken = output.nextToken
        } else {
            self.backupPlanVersionsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlanVersionsOutputResponse: Swift.Equatable {
    /// An array of version list items containing metadata about your backup plans.
    public var backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanVersionsList = backupPlanVersionsList
        self.nextToken = nextToken
    }
}

struct ListBackupPlanVersionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let backupPlanVersionsList: [BackupClientTypes.BackupPlansListMember]?
}

extension ListBackupPlanVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanVersionsList = "BackupPlanVersionsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlanVersionsListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupPlansListMember?].self, forKey: .backupPlanVersionsList)
        var backupPlanVersionsListDecoded0:[BackupClientTypes.BackupPlansListMember]? = nil
        if let backupPlanVersionsListContainer = backupPlanVersionsListContainer {
            backupPlanVersionsListDecoded0 = [BackupClientTypes.BackupPlansListMember]()
            for structure0 in backupPlanVersionsListContainer {
                if let structure0 = structure0 {
                    backupPlanVersionsListDecoded0?.append(structure0)
                }
            }
        }
        backupPlanVersionsList = backupPlanVersionsListDecoded0
    }
}

extension ListBackupPlansInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupPlansInput(includeDeleted: \(Swift.String(describing: includeDeleted)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupPlansInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBackupPlansInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupPlansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupPlansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlansOutputError>
}

public struct ListBackupPlansInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupPlansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let includeDeleted = input.operationInput.includeDeleted {
            let includeDeletedQueryItem = ClientRuntime.URLQueryItem(name: "includeDeleted".urlPercentEncoding(), value: Swift.String(includeDeleted).urlPercentEncoding())
            input.builder.withQueryItem(includeDeletedQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupPlansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlansOutputError>
}

public struct ListBackupPlansInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlansInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListBackupPlansInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupPlansInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlansOutputError>
}

public struct ListBackupPlansInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupPlansInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListBackupPlansInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/backup/plans"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupPlansInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupPlansOutputError>
}

public struct ListBackupPlansInput: Swift.Equatable {
    /// A Boolean value with a default value of FALSE that returns deleted backup plans when set to TRUE.
    public var includeDeleted: Swift.Bool?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        includeDeleted: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeDeleted = includeDeleted
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupPlansInputBody: Swift.Equatable {
}

extension ListBackupPlansInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupPlansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupPlansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupPlansOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupPlansOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupPlansOutputResponse(backupPlansList: \(Swift.String(describing: backupPlansList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupPlansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBackupPlansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupPlansList = output.backupPlansList
            self.nextToken = output.nextToken
        } else {
            self.backupPlansList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupPlansOutputResponse: Swift.Equatable {
    /// An array of backup plan list items containing metadata about your saved backup plans.
    public var backupPlansList: [BackupClientTypes.BackupPlansListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlansList: [BackupClientTypes.BackupPlansListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlansList = backupPlansList
        self.nextToken = nextToken
    }
}

struct ListBackupPlansOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let backupPlansList: [BackupClientTypes.BackupPlansListMember]?
}

extension ListBackupPlansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlansList = "BackupPlansList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupPlansListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupPlansListMember?].self, forKey: .backupPlansList)
        var backupPlansListDecoded0:[BackupClientTypes.BackupPlansListMember]? = nil
        if let backupPlansListContainer = backupPlansListContainer {
            backupPlansListDecoded0 = [BackupClientTypes.BackupPlansListMember]()
            for structure0 in backupPlansListContainer {
                if let structure0 = structure0 {
                    backupPlansListDecoded0?.append(structure0)
                }
            }
        }
        backupPlansList = backupPlansListDecoded0
    }
}

extension ListBackupSelectionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupSelectionsInput(backupPlanId: \(Swift.String(describing: backupPlanId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupSelectionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBackupSelectionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupSelectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupSelectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupSelectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupSelectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupSelectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupSelectionsOutputError>
}

public struct ListBackupSelectionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupSelectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupSelectionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupSelectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupSelectionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupSelectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupSelectionsOutputError>
}

public struct ListBackupSelectionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupSelectionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListBackupSelectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupSelectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupSelectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupSelectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupSelectionsOutputError>
}

public struct ListBackupSelectionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupSelectionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListBackupSelectionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupSelectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanId = input.backupPlanId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/plans/\(backupPlanId.urlPercentEncoding())/selections"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupSelectionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupSelectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupSelectionsOutputError>
}

public struct ListBackupSelectionsInput: Swift.Equatable {
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupPlanId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupPlanId = backupPlanId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupSelectionsInputBody: Swift.Equatable {
}

extension ListBackupSelectionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupSelectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupSelectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupSelectionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupSelectionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupSelectionsOutputResponse(backupSelectionsList: \(Swift.String(describing: backupSelectionsList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupSelectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBackupSelectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupSelectionsList = output.backupSelectionsList
            self.nextToken = output.nextToken
        } else {
            self.backupSelectionsList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupSelectionsOutputResponse: Swift.Equatable {
    /// An array of backup selection list items containing metadata about each resource in the list.
    public var backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupSelectionsList = backupSelectionsList
        self.nextToken = nextToken
    }
}

struct ListBackupSelectionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let backupSelectionsList: [BackupClientTypes.BackupSelectionsListMember]?
}

extension ListBackupSelectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSelectionsList = "BackupSelectionsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let backupSelectionsListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupSelectionsListMember?].self, forKey: .backupSelectionsList)
        var backupSelectionsListDecoded0:[BackupClientTypes.BackupSelectionsListMember]? = nil
        if let backupSelectionsListContainer = backupSelectionsListContainer {
            backupSelectionsListDecoded0 = [BackupClientTypes.BackupSelectionsListMember]()
            for structure0 in backupSelectionsListContainer {
                if let structure0 = structure0 {
                    backupSelectionsListDecoded0?.append(structure0)
                }
            }
        }
        backupSelectionsList = backupSelectionsListDecoded0
    }
}

extension ListBackupVaultsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupVaultsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupVaultsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBackupVaultsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupVaultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupVaultsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupVaultsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupVaultsOutputError>
}

public struct ListBackupVaultsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupVaultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackupVaultsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackupVaultsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupVaultsOutputError>
}

public struct ListBackupVaultsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupVaultsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListBackupVaultsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupVaultsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupVaultsOutputError>
}

public struct ListBackupVaultsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackupVaultsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListBackupVaultsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackupVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/backup-vaults"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBackupVaultsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackupVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackupVaultsOutputError>
}

public struct ListBackupVaultsInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBackupVaultsInputBody: Swift.Equatable {
}

extension ListBackupVaultsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBackupVaultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackupVaultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackupVaultsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackupVaultsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackupVaultsOutputResponse(backupVaultList: \(Swift.String(describing: backupVaultList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackupVaultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBackupVaultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultList = output.backupVaultList
            self.nextToken = output.nextToken
        } else {
            self.backupVaultList = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackupVaultsOutputResponse: Swift.Equatable {
    /// An array of backup vault list members containing vault metadata, including Amazon Resource Name (ARN), display name, creation date, number of saved recovery points, and encryption information if the resources saved in the backup vault are encrypted.
    public var backupVaultList: [BackupClientTypes.BackupVaultListMember]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupVaultList: [BackupClientTypes.BackupVaultListMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultList = backupVaultList
        self.nextToken = nextToken
    }
}

struct ListBackupVaultsOutputResponseBody: Swift.Equatable {
    public let backupVaultList: [BackupClientTypes.BackupVaultListMember]?
    public let nextToken: Swift.String?
}

extension ListBackupVaultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultList = "BackupVaultList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultListContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupVaultListMember?].self, forKey: .backupVaultList)
        var backupVaultListDecoded0:[BackupClientTypes.BackupVaultListMember]? = nil
        if let backupVaultListContainer = backupVaultListContainer {
            backupVaultListDecoded0 = [BackupClientTypes.BackupVaultListMember]()
            for structure0 in backupVaultListContainer {
                if let structure0 = structure0 {
                    backupVaultListDecoded0?.append(structure0)
                }
            }
        }
        backupVaultList = backupVaultListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCopyJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCopyJobsInput(byAccountId: \(Swift.String(describing: byAccountId)), byCreatedAfter: \(Swift.String(describing: byCreatedAfter)), byCreatedBefore: \(Swift.String(describing: byCreatedBefore)), byDestinationVaultArn: \(Swift.String(describing: byDestinationVaultArn)), byResourceArn: \(Swift.String(describing: byResourceArn)), byResourceType: \(Swift.String(describing: byResourceType)), byState: \(Swift.String(describing: byState)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCopyJobsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCopyJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCopyJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCopyJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCopyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCopyJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCopyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCopyJobsOutputError>
}

public struct ListCopyJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCopyJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCopyJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCopyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let byCreatedBefore = input.operationInput.byCreatedBefore {
            let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(byCreatedBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedBeforeQueryItem)
        }
        if let byResourceType = input.operationInput.byResourceType {
            let byResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
            input.builder.withQueryItem(byResourceTypeQueryItem)
        }
        if let byDestinationVaultArn = input.operationInput.byDestinationVaultArn {
            let byDestinationVaultArnQueryItem = ClientRuntime.URLQueryItem(name: "destinationVaultArn".urlPercentEncoding(), value: Swift.String(byDestinationVaultArn).urlPercentEncoding())
            input.builder.withQueryItem(byDestinationVaultArnQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let byResourceArn = input.operationInput.byResourceArn {
            let byResourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
            input.builder.withQueryItem(byResourceArnQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let byState = input.operationInput.byState {
            let byStateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(byState.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(byStateQueryItem)
        }
        if let byAccountId = input.operationInput.byAccountId {
            let byAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
            input.builder.withQueryItem(byAccountIdQueryItem)
        }
        if let byCreatedAfter = input.operationInput.byCreatedAfter {
            let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(byCreatedAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCopyJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCopyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCopyJobsOutputError>
}

public struct ListCopyJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCopyJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCopyJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCopyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCopyJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCopyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCopyJobsOutputError>
}

public struct ListCopyJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCopyJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCopyJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCopyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/copy-jobs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCopyJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCopyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCopyJobsOutputError>
}

public struct ListCopyJobsInput: Swift.Equatable {
    /// The account ID to list the jobs from. Returns only copy jobs associated with the specified account ID.
    public var byAccountId: Swift.String?
    /// Returns only copy jobs that were created after the specified date.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only copy jobs that were created before the specified date.
    public var byCreatedBefore: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a source backup vault to copy from; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var byDestinationVaultArn: Swift.String?
    /// Returns only copy jobs that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only backup jobs for the specified resources:
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * Storage Gateway for Storage Gateway
    public var byResourceType: Swift.String?
    /// Returns only copy jobs that are in the specified state.
    public var byState: BackupClientTypes.CopyJobState?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        byAccountId: Swift.String? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byDestinationVaultArn: Swift.String? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        byState: BackupClientTypes.CopyJobState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byDestinationVaultArn = byDestinationVaultArn
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.byState = byState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCopyJobsInputBody: Swift.Equatable {
}

extension ListCopyJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCopyJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCopyJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCopyJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCopyJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCopyJobsOutputResponse(copyJobs: \(Swift.String(describing: copyJobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCopyJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCopyJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyJobs = output.copyJobs
            self.nextToken = output.nextToken
        } else {
            self.copyJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListCopyJobsOutputResponse: Swift.Equatable {
    /// An array of structures containing metadata about your copy jobs returned in JSON format.
    public var copyJobs: [BackupClientTypes.CopyJob]?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        copyJobs: [BackupClientTypes.CopyJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.copyJobs = copyJobs
        self.nextToken = nextToken
    }
}

struct ListCopyJobsOutputResponseBody: Swift.Equatable {
    public let copyJobs: [BackupClientTypes.CopyJob]?
    public let nextToken: Swift.String?
}

extension ListCopyJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyJobs = "CopyJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.CopyJob?].self, forKey: .copyJobs)
        var copyJobsDecoded0:[BackupClientTypes.CopyJob]? = nil
        if let copyJobsContainer = copyJobsContainer {
            copyJobsDecoded0 = [BackupClientTypes.CopyJob]()
            for structure0 in copyJobsContainer {
                if let structure0 = structure0 {
                    copyJobsDecoded0?.append(structure0)
                }
            }
        }
        copyJobs = copyJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFrameworksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFrameworksInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFrameworksInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFrameworksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFrameworksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFrameworksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFrameworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFrameworksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFrameworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFrameworksOutputError>
}

public struct ListFrameworksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFrameworksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFrameworksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFrameworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFrameworksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFrameworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFrameworksOutputError>
}

public struct ListFrameworksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFrameworksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFrameworksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFrameworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFrameworksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFrameworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFrameworksOutputError>
}

public struct ListFrameworksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFrameworksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFrameworksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFrameworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/audit/frameworks"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFrameworksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFrameworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFrameworksOutputError>
}

public struct ListFrameworksInput: Swift.Equatable {
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFrameworksInputBody: Swift.Equatable {
}

extension ListFrameworksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFrameworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFrameworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFrameworksOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFrameworksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFrameworksOutputResponse(frameworks: \(Swift.String(describing: frameworks)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFrameworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFrameworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.frameworks = output.frameworks
            self.nextToken = output.nextToken
        } else {
            self.frameworks = nil
            self.nextToken = nil
        }
    }
}

public struct ListFrameworksOutputResponse: Swift.Equatable {
    /// A list of frameworks with details for each framework, including the framework name, Amazon Resource Name (ARN), description, number of controls, creation time, and deployment status.
    public var frameworks: [BackupClientTypes.Framework]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        frameworks: [BackupClientTypes.Framework]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.frameworks = frameworks
        self.nextToken = nextToken
    }
}

struct ListFrameworksOutputResponseBody: Swift.Equatable {
    public let frameworks: [BackupClientTypes.Framework]?
    public let nextToken: Swift.String?
}

extension ListFrameworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworks = "Frameworks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworksContainer = try containerValues.decodeIfPresent([BackupClientTypes.Framework?].self, forKey: .frameworks)
        var frameworksDecoded0:[BackupClientTypes.Framework]? = nil
        if let frameworksContainer = frameworksContainer {
            frameworksDecoded0 = [BackupClientTypes.Framework]()
            for structure0 in frameworksContainer {
                if let structure0 = structure0 {
                    frameworksDecoded0?.append(structure0)
                }
            }
        }
        frameworks = frameworksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProtectedResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProtectedResourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListProtectedResourcesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProtectedResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProtectedResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProtectedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProtectedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProtectedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProtectedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProtectedResourcesOutputError>
}

public struct ListProtectedResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProtectedResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProtectedResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProtectedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProtectedResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProtectedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProtectedResourcesOutputError>
}

public struct ListProtectedResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProtectedResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListProtectedResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProtectedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProtectedResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProtectedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProtectedResourcesOutputError>
}

public struct ListProtectedResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProtectedResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListProtectedResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProtectedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/resources"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProtectedResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProtectedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProtectedResourcesOutputError>
}

public struct ListProtectedResourcesInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectedResourcesInputBody: Swift.Equatable {
}

extension ListProtectedResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProtectedResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtectedResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProtectedResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtectedResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProtectedResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), results: \(Swift.String(describing: results)))"}
}

extension ListProtectedResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProtectedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct ListProtectedResourcesOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of resources successfully backed up by Backup including the time the resource was saved, an Amazon Resource Name (ARN) of the resource, and a resource type.
    public var results: [BackupClientTypes.ProtectedResource]?

    public init (
        nextToken: Swift.String? = nil,
        results: [BackupClientTypes.ProtectedResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct ListProtectedResourcesOutputResponseBody: Swift.Equatable {
    public let results: [BackupClientTypes.ProtectedResource]?
    public let nextToken: Swift.String?
}

extension ListProtectedResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case results = "Results"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ProtectedResource?].self, forKey: .results)
        var resultsDecoded0:[BackupClientTypes.ProtectedResource]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [BackupClientTypes.ProtectedResource]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecoveryPointsByBackupVaultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecoveryPointsByBackupVaultInput(backupVaultName: \(Swift.String(describing: backupVaultName)), byBackupPlanId: \(Swift.String(describing: byBackupPlanId)), byCreatedAfter: \(Swift.String(describing: byCreatedAfter)), byCreatedBefore: \(Swift.String(describing: byCreatedBefore)), byResourceArn: \(Swift.String(describing: byResourceArn)), byResourceType: \(Swift.String(describing: byResourceType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRecoveryPointsByBackupVaultInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRecoveryPointsByBackupVaultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryPointsByBackupVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecoveryPointsByBackupVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecoveryPointsByBackupVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryPointsByBackupVaultOutputError>
}

public struct ListRecoveryPointsByBackupVaultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryPointsByBackupVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecoveryPointsByBackupVaultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let byResourceType = input.operationInput.byResourceType {
            let byResourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(byResourceType).urlPercentEncoding())
            input.builder.withQueryItem(byResourceTypeQueryItem)
        }
        if let byCreatedBefore = input.operationInput.byCreatedBefore {
            let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(byCreatedBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedBeforeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let byResourceArn = input.operationInput.byResourceArn {
            let byResourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(byResourceArn).urlPercentEncoding())
            input.builder.withQueryItem(byResourceArnQueryItem)
        }
        if let byBackupPlanId = input.operationInput.byBackupPlanId {
            let byBackupPlanIdQueryItem = ClientRuntime.URLQueryItem(name: "backupPlanId".urlPercentEncoding(), value: Swift.String(byBackupPlanId).urlPercentEncoding())
            input.builder.withQueryItem(byBackupPlanIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let byCreatedAfter = input.operationInput.byCreatedAfter {
            let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(byCreatedAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedAfterQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecoveryPointsByBackupVaultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryPointsByBackupVaultOutputError>
}

public struct ListRecoveryPointsByBackupVaultInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryPointsByBackupVaultInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRecoveryPointsByBackupVaultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecoveryPointsByBackupVaultInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryPointsByBackupVaultOutputError>
}

public struct ListRecoveryPointsByBackupVaultInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryPointsByBackupVaultInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRecoveryPointsByBackupVaultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecoveryPointsByBackupVaultInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryPointsByBackupVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryPointsByBackupVaultOutputError>
}

public struct ListRecoveryPointsByBackupVaultInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens. Backup vault name might not be available when a supported service creates the backup.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// Returns only recovery points that match the specified backup plan ID.
    public var byBackupPlanId: Swift.String?
    /// Returns only recovery points that were created after the specified timestamp.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only recovery points that were created before the specified timestamp.
    public var byCreatedBefore: ClientRuntime.Date?
    /// Returns only recovery points that match the specified resource Amazon Resource Name (ARN).
    public var byResourceArn: Swift.String?
    /// Returns only recovery points that match the specified resource type.
    public var byResourceType: Swift.String?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        byBackupPlanId: Swift.String? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byResourceArn: Swift.String? = nil,
        byResourceType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.byBackupPlanId = byBackupPlanId
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byResourceArn = byResourceArn
        self.byResourceType = byResourceType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecoveryPointsByBackupVaultInputBody: Swift.Equatable {
}

extension ListRecoveryPointsByBackupVaultInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryPointsByBackupVaultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecoveryPointsByBackupVaultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecoveryPointsByBackupVaultOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecoveryPointsByBackupVaultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecoveryPointsByBackupVaultOutputResponse(nextToken: \(Swift.String(describing: nextToken)), recoveryPoints: \(Swift.String(describing: recoveryPoints)))"}
}

extension ListRecoveryPointsByBackupVaultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecoveryPointsByBackupVaultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByBackupVaultOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about recovery points saved in a backup vault.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]?

    public init (
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByBackupVaultOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let recoveryPoints: [BackupClientTypes.RecoveryPointByBackupVault]?
}

extension ListRecoveryPointsByBackupVaultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryPointsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RecoveryPointByBackupVault?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[BackupClientTypes.RecoveryPointByBackupVault]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [BackupClientTypes.RecoveryPointByBackupVault]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
    }
}

extension ListRecoveryPointsByResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecoveryPointsByResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListRecoveryPointsByResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRecoveryPointsByResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryPointsByResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecoveryPointsByResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryPointsByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecoveryPointsByResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryPointsByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryPointsByResourceOutputError>
}

public struct ListRecoveryPointsByResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryPointsByResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecoveryPointsByResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryPointsByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecoveryPointsByResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryPointsByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryPointsByResourceOutputError>
}

public struct ListRecoveryPointsByResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryPointsByResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRecoveryPointsByResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryPointsByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecoveryPointsByResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryPointsByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryPointsByResourceOutputError>
}

public struct ListRecoveryPointsByResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryPointsByResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRecoveryPointsByResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryPointsByResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/resources/\(resourceArn.urlPercentEncoding())/recovery-points"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecoveryPointsByResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryPointsByResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryPointsByResourceOutputError>
}

public struct ListRecoveryPointsByResourceInput: Swift.Equatable {
    /// The maximum number of items to be returned. Amazon RDS requires a value of at least 20.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListRecoveryPointsByResourceInputBody: Swift.Equatable {
}

extension ListRecoveryPointsByResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryPointsByResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecoveryPointsByResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecoveryPointsByResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecoveryPointsByResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecoveryPointsByResourceOutputResponse(nextToken: \(Swift.String(describing: nextToken)), recoveryPoints: \(Swift.String(describing: recoveryPoints)))"}
}

extension ListRecoveryPointsByResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecoveryPointsByResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryPoints = output.recoveryPoints
        } else {
            self.nextToken = nil
            self.recoveryPoints = nil
        }
    }
}

public struct ListRecoveryPointsByResourceOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about recovery points of the specified resource type. Only Amazon EFS and Amazon EC2 recovery points return BackupVaultName.
    public var recoveryPoints: [BackupClientTypes.RecoveryPointByResource]?

    public init (
        nextToken: Swift.String? = nil,
        recoveryPoints: [BackupClientTypes.RecoveryPointByResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

struct ListRecoveryPointsByResourceOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let recoveryPoints: [BackupClientTypes.RecoveryPointByResource]?
}

extension ListRecoveryPointsByResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recoveryPoints = "RecoveryPoints"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryPointsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RecoveryPointByResource?].self, forKey: .recoveryPoints)
        var recoveryPointsDecoded0:[BackupClientTypes.RecoveryPointByResource]? = nil
        if let recoveryPointsContainer = recoveryPointsContainer {
            recoveryPointsDecoded0 = [BackupClientTypes.RecoveryPointByResource]()
            for structure0 in recoveryPointsContainer {
                if let structure0 = structure0 {
                    recoveryPointsDecoded0?.append(structure0)
                }
            }
        }
        recoveryPoints = recoveryPointsDecoded0
    }
}

extension ListReportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReportJobsInput(byCreationAfter: \(Swift.String(describing: byCreationAfter)), byCreationBefore: \(Swift.String(describing: byCreationBefore)), byReportPlanName: \(Swift.String(describing: byReportPlanName)), byStatus: \(Swift.String(describing: byStatus)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListReportJobsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListReportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportJobsOutputError>
}

public struct ListReportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let byReportPlanName = input.operationInput.byReportPlanName {
            let byReportPlanNameQueryItem = ClientRuntime.URLQueryItem(name: "ReportPlanName".urlPercentEncoding(), value: Swift.String(byReportPlanName).urlPercentEncoding())
            input.builder.withQueryItem(byReportPlanNameQueryItem)
        }
        if let byCreationAfter = input.operationInput.byCreationAfter {
            let byCreationAfterQueryItem = ClientRuntime.URLQueryItem(name: "CreationAfter".urlPercentEncoding(), value: Swift.String(byCreationAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreationAfterQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let byStatus = input.operationInput.byStatus {
            let byStatusQueryItem = ClientRuntime.URLQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(byStatus).urlPercentEncoding())
            input.builder.withQueryItem(byStatusQueryItem)
        }
        if let byCreationBefore = input.operationInput.byCreationBefore {
            let byCreationBeforeQueryItem = ClientRuntime.URLQueryItem(name: "CreationBefore".urlPercentEncoding(), value: Swift.String(byCreationBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreationBeforeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportJobsOutputError>
}

public struct ListReportJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListReportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListReportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportJobsOutputError>
}

public struct ListReportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListReportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/audit/report-jobs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListReportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportJobsOutputError>
}

public struct ListReportJobsInput: Swift.Equatable {
    /// Returns only report jobs that were created after the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
    public var byCreationAfter: ClientRuntime.Date?
    /// Returns only report jobs that were created before the date and time specified in Unix format and Coordinated Universal Time (UTC). For example, the value 1516925490 represents Friday, January 26, 2018 12:11:30 AM.
    public var byCreationBefore: ClientRuntime.Date?
    /// Returns only report jobs with the specified report plan name.
    public var byReportPlanName: Swift.String?
    /// Returns only report jobs that are in the specified status. The statuses are: CREATED | RUNNING | COMPLETED | FAILED
    public var byStatus: Swift.String?
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        byCreationAfter: ClientRuntime.Date? = nil,
        byCreationBefore: ClientRuntime.Date? = nil,
        byReportPlanName: Swift.String? = nil,
        byStatus: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byCreationAfter = byCreationAfter
        self.byCreationBefore = byCreationBefore
        self.byReportPlanName = byReportPlanName
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportJobsInputBody: Swift.Equatable {
}

extension ListReportJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListReportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReportJobsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), reportJobs: \(Swift.String(describing: reportJobs)))"}
}

extension ListReportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportJobs = output.reportJobs
        } else {
            self.nextToken = nil
            self.reportJobs = nil
        }
    }
}

public struct ListReportJobsOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Details about your report jobs in JSON format.
    public var reportJobs: [BackupClientTypes.ReportJob]?

    public init (
        nextToken: Swift.String? = nil,
        reportJobs: [BackupClientTypes.ReportJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportJobs = reportJobs
    }
}

struct ListReportJobsOutputResponseBody: Swift.Equatable {
    public let reportJobs: [BackupClientTypes.ReportJob]?
    public let nextToken: Swift.String?
}

extension ListReportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportJobs = "ReportJobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.ReportJob?].self, forKey: .reportJobs)
        var reportJobsDecoded0:[BackupClientTypes.ReportJob]? = nil
        if let reportJobsContainer = reportJobsContainer {
            reportJobsDecoded0 = [BackupClientTypes.ReportJob]()
            for structure0 in reportJobsContainer {
                if let structure0 = structure0 {
                    reportJobsDecoded0?.append(structure0)
                }
            }
        }
        reportJobs = reportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReportPlansInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReportPlansInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListReportPlansInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListReportPlansInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportPlansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReportPlansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReportPlansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportPlansOutputError>
}

public struct ListReportPlansInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportPlansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReportPlansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReportPlansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportPlansOutputError>
}

public struct ListReportPlansInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportPlansInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListReportPlansInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListReportPlansInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportPlansOutputError>
}

public struct ListReportPlansInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReportPlansInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListReportPlansInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReportPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/audit/report-plans"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListReportPlansInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListReportPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReportPlansOutputError>
}

public struct ListReportPlansInput: Swift.Equatable {
    /// The number of desired results from 1 to 1000. Optional. If unspecified, the query will return 1 MB of data.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportPlansInputBody: Swift.Equatable {
}

extension ListReportPlansInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListReportPlansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportPlansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReportPlansOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportPlansOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReportPlansOutputResponse(nextToken: \(Swift.String(describing: nextToken)), reportPlans: \(Swift.String(describing: reportPlans)))"}
}

extension ListReportPlansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReportPlansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportPlans = output.reportPlans
        } else {
            self.nextToken = nil
            self.reportPlans = nil
        }
    }
}

public struct ListReportPlansOutputResponse: Swift.Equatable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// A list of your report plans with detailed information for each plan. This information includes the Amazon Resource Name (ARN), report plan name, description, settings, delivery channel, deployment status, creation time, and last times the report plan attempted to and successfully ran.
    public var reportPlans: [BackupClientTypes.ReportPlan]?

    public init (
        nextToken: Swift.String? = nil,
        reportPlans: [BackupClientTypes.ReportPlan]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportPlans = reportPlans
    }
}

struct ListReportPlansOutputResponseBody: Swift.Equatable {
    public let reportPlans: [BackupClientTypes.ReportPlan]?
    public let nextToken: Swift.String?
}

extension ListReportPlansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reportPlans = "ReportPlans"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlansContainer = try containerValues.decodeIfPresent([BackupClientTypes.ReportPlan?].self, forKey: .reportPlans)
        var reportPlansDecoded0:[BackupClientTypes.ReportPlan]? = nil
        if let reportPlansContainer = reportPlansContainer {
            reportPlansDecoded0 = [BackupClientTypes.ReportPlan]()
            for structure0 in reportPlansContainer {
                if let structure0 = structure0 {
                    reportPlansDecoded0?.append(structure0)
                }
            }
        }
        reportPlans = reportPlansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRestoreJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRestoreJobsInput(byAccountId: \(Swift.String(describing: byAccountId)), byCreatedAfter: \(Swift.String(describing: byCreatedAfter)), byCreatedBefore: \(Swift.String(describing: byCreatedBefore)), byStatus: \(Swift.String(describing: byStatus)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRestoreJobsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRestoreJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRestoreJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRestoreJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRestoreJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRestoreJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRestoreJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRestoreJobsOutputError>
}

public struct ListRestoreJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRestoreJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRestoreJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRestoreJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let byCreatedBefore = input.operationInput.byCreatedBefore {
            let byCreatedBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(byCreatedBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedBeforeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let byAccountId = input.operationInput.byAccountId {
            let byAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "accountId".urlPercentEncoding(), value: Swift.String(byAccountId).urlPercentEncoding())
            input.builder.withQueryItem(byAccountIdQueryItem)
        }
        if let byCreatedAfter = input.operationInput.byCreatedAfter {
            let byCreatedAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(byCreatedAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(byCreatedAfterQueryItem)
        }
        if let byStatus = input.operationInput.byStatus {
            let byStatusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(byStatus.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(byStatusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRestoreJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRestoreJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRestoreJobsOutputError>
}

public struct ListRestoreJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRestoreJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListRestoreJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRestoreJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRestoreJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRestoreJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRestoreJobsOutputError>
}

public struct ListRestoreJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRestoreJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListRestoreJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRestoreJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/restore-jobs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRestoreJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRestoreJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRestoreJobsOutputError>
}

public struct ListRestoreJobsInput: Swift.Equatable {
    /// The account ID to list the jobs from. Returns only restore jobs associated with the specified account ID.
    public var byAccountId: Swift.String?
    /// Returns only restore jobs that were created after the specified date.
    public var byCreatedAfter: ClientRuntime.Date?
    /// Returns only restore jobs that were created before the specified date.
    public var byCreatedBefore: ClientRuntime.Date?
    /// Returns only restore jobs associated with the specified job status.
    public var byStatus: BackupClientTypes.RestoreJobStatus?
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?

    public init (
        byAccountId: Swift.String? = nil,
        byCreatedAfter: ClientRuntime.Date? = nil,
        byCreatedBefore: ClientRuntime.Date? = nil,
        byStatus: BackupClientTypes.RestoreJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.byAccountId = byAccountId
        self.byCreatedAfter = byCreatedAfter
        self.byCreatedBefore = byCreatedBefore
        self.byStatus = byStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRestoreJobsInputBody: Swift.Equatable {
}

extension ListRestoreJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRestoreJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRestoreJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRestoreJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRestoreJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRestoreJobsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), restoreJobs: \(Swift.String(describing: restoreJobs)))"}
}

extension ListRestoreJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRestoreJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.restoreJobs = output.restoreJobs
        } else {
            self.nextToken = nil
            self.restoreJobs = nil
        }
    }
}

public struct ListRestoreJobsOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An array of objects that contain detailed information about jobs to restore saved resources.
    public var restoreJobs: [BackupClientTypes.RestoreJobsListMember]?

    public init (
        nextToken: Swift.String? = nil,
        restoreJobs: [BackupClientTypes.RestoreJobsListMember]? = nil
    )
    {
        self.nextToken = nextToken
        self.restoreJobs = restoreJobs
    }
}

struct ListRestoreJobsOutputResponseBody: Swift.Equatable {
    public let restoreJobs: [BackupClientTypes.RestoreJobsListMember]?
    public let nextToken: Swift.String?
}

extension ListRestoreJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case restoreJobs = "RestoreJobs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreJobsContainer = try containerValues.decodeIfPresent([BackupClientTypes.RestoreJobsListMember?].self, forKey: .restoreJobs)
        var restoreJobsDecoded0:[BackupClientTypes.RestoreJobsListMember]? = nil
        if let restoreJobsContainer = restoreJobsContainer {
            restoreJobsDecoded0 = [BackupClientTypes.RestoreJobsListMember]()
            for structure0 in restoreJobsContainer {
                if let structure0 = structure0 {
                    restoreJobsDecoded0?.append(structure0)
                }
            }
        }
        restoreJobs = restoreJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Swift.Equatable {
    /// The maximum number of items to be returned.
    public var maxResults: Swift.Int?
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the type of resource. Valid targets for ListTags are recovery points, backup plans, and backup vaults.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// The next item following a partial list of returned items. For example, if a request is made to return maxResults number of items, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
    public var nextToken: Swift.String?
    /// To help organize your resources, you can assign your own metadata to the resources you create. Each tag is a key-value pair.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MissingParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MissingParameterValueException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension MissingParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MissingParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that a required parameter is missing.
public struct MissingParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct MissingParameterValueExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension MissingParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes.ProtectedResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastBackupTime = "LastBackupTime"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastBackupTime = lastBackupTime {
            try encodeContainer.encode(lastBackupTime.timeIntervalSince1970, forKey: .lastBackupTime)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let lastBackupTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastBackupTime)
        lastBackupTime = lastBackupTimeDecoded
    }
}

extension BackupClientTypes.ProtectedResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProtectedResource(lastBackupTime: \(Swift.String(describing: lastBackupTime)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension BackupClientTypes {
    /// A structure that contains information about a backed-up resource.
    public struct ProtectedResource: Swift.Equatable {
        /// The date and time a resource was last backed up, in Unix format and Coordinated Universal Time (UTC). The value of LastBackupTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastBackupTime: ClientRuntime.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// The type of Amazon Web Services resource; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?

        public init (
            lastBackupTime: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.lastBackupTime = lastBackupTime
            self.resourceArn = resourceArn
            self.resourceType = resourceType
        }
    }

}

public struct PutBackupVaultAccessPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultAccessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultAccessPolicyOutputError>
}

extension PutBackupVaultAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutBackupVaultAccessPolicyInput(backupVaultName: \(Swift.String(describing: backupVaultName)), policy: \(Swift.String(describing: policy)))"}
}

extension PutBackupVaultAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutBackupVaultAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultAccessPolicyOutputError>
}

public struct PutBackupVaultAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupVaultAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultAccessPolicyOutputError>
}

public struct PutBackupVaultAccessPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultAccessPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutBackupVaultAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutBackupVaultAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultAccessPolicyOutputError>
}

public struct PutBackupVaultAccessPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultAccessPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutBackupVaultAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/access-policy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutBackupVaultAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultAccessPolicyOutputError>
}

public struct PutBackupVaultAccessPolicyInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The backup vault access policy document in JSON format.
    public var policy: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.policy = policy
    }
}

struct PutBackupVaultAccessPolicyInputBody: Swift.Equatable {
    public let policy: Swift.String?
}

extension PutBackupVaultAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutBackupVaultAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupVaultAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBackupVaultAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupVaultAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutBackupVaultAccessPolicyOutputResponse()"}
}

extension PutBackupVaultAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBackupVaultAccessPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutBackupVaultAccessPolicyOutputResponseBody: Swift.Equatable {
}

extension PutBackupVaultAccessPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutBackupVaultLockConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultLockConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupVaultLockConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupVaultLockConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultLockConfigurationOutputError>
}

extension PutBackupVaultLockConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutBackupVaultLockConfigurationInput(backupVaultName: \(Swift.String(describing: backupVaultName)), changeableForDays: \(Swift.String(describing: changeableForDays)), maxRetentionDays: \(Swift.String(describing: maxRetentionDays)), minRetentionDays: \(Swift.String(describing: minRetentionDays)))"}
}

extension PutBackupVaultLockConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeableForDays = "ChangeableForDays"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeableForDays = changeableForDays {
            try encodeContainer.encode(changeableForDays, forKey: .changeableForDays)
        }
        if let maxRetentionDays = maxRetentionDays {
            try encodeContainer.encode(maxRetentionDays, forKey: .maxRetentionDays)
        }
        if let minRetentionDays = minRetentionDays {
            try encodeContainer.encode(minRetentionDays, forKey: .minRetentionDays)
        }
    }
}

public struct PutBackupVaultLockConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultLockConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupVaultLockConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupVaultLockConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultLockConfigurationOutputError>
}

public struct PutBackupVaultLockConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultLockConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupVaultLockConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupVaultLockConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultLockConfigurationOutputError>
}

public struct PutBackupVaultLockConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultLockConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutBackupVaultLockConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutBackupVaultLockConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultLockConfigurationOutputError>
}

public struct PutBackupVaultLockConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultLockConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutBackupVaultLockConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/vault-lock"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutBackupVaultLockConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultLockConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultLockConfigurationOutputError>
}

public struct PutBackupVaultLockConfigurationInput: Swift.Equatable {
    /// The Backup Vault Lock configuration that specifies the name of the backup vault it protects.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The Backup Vault Lock configuration that specifies the number of days before the lock date. For example, setting ChangeableForDays to 30 on Jan. 1, 2022 at 8pm UTC will set the lock date to Jan. 31, 2022 at 8pm UTC. Backup enforces a 72-hour cooling-off period before Vault Lock takes effect and becomes immutable. Therefore, you must set ChangeableForDays to 3 or greater. Before the lock date, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration. On and after the lock date, the Vault Lock becomes immutable and cannot be changed or deleted. If this parameter is not specified, you can delete Vault Lock from the vault using DeleteBackupVaultLockConfiguration or change the Vault Lock configuration using PutBackupVaultLockConfiguration at any time.
    public var changeableForDays: Swift.Int?
    /// The Backup Vault Lock configuration that specifies the maximum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to destroy certain data after retaining it for four years (1460 days). If this parameter is not included, Vault Lock does not enforce a maximum retention period on the recovery points in the vault. If this parameter is included without a value, Vault Lock will not enforce a maximum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or shorter than the maximum retention period. If the job's retention period is longer than that maximum retention period, then the vault fails the backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already saved in the vault prior to Vault Lock are not affected.
    public var maxRetentionDays: Swift.Int?
    /// The Backup Vault Lock configuration that specifies the minimum retention period that the vault retains its recovery points. This setting can be useful if, for example, your organization's policies require you to retain certain data for at least seven years (2555 days). If this parameter is not specified, Vault Lock will not enforce a minimum retention period. If this parameter is specified, any backup or copy job to the vault must have a lifecycle policy with a retention period equal to or longer than the minimum retention period. If the job's retention period is shorter than that minimum retention period, then the vault fails that backup or copy job, and you should either modify your lifecycle settings or use a different vault. Recovery points already saved in the vault prior to Vault Lock are not affected.
    public var minRetentionDays: Swift.Int?

    public init (
        backupVaultName: Swift.String? = nil,
        changeableForDays: Swift.Int? = nil,
        maxRetentionDays: Swift.Int? = nil,
        minRetentionDays: Swift.Int? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.changeableForDays = changeableForDays
        self.maxRetentionDays = maxRetentionDays
        self.minRetentionDays = minRetentionDays
    }
}

struct PutBackupVaultLockConfigurationInputBody: Swift.Equatable {
    public let minRetentionDays: Swift.Int?
    public let maxRetentionDays: Swift.Int?
    public let changeableForDays: Swift.Int?
}

extension PutBackupVaultLockConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeableForDays = "ChangeableForDays"
        case maxRetentionDays = "MaxRetentionDays"
        case minRetentionDays = "MinRetentionDays"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minRetentionDays)
        minRetentionDays = minRetentionDaysDecoded
        let maxRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRetentionDays)
        maxRetentionDays = maxRetentionDaysDecoded
        let changeableForDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .changeableForDays)
        changeableForDays = changeableForDaysDecoded
    }
}

extension PutBackupVaultLockConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupVaultLockConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBackupVaultLockConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupVaultLockConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutBackupVaultLockConfigurationOutputResponse()"}
}

extension PutBackupVaultLockConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBackupVaultLockConfigurationOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutBackupVaultLockConfigurationOutputResponseBody: Swift.Equatable {
}

extension PutBackupVaultLockConfigurationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutBackupVaultNotificationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultNotificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultNotificationsOutputError>
}

extension PutBackupVaultNotificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutBackupVaultNotificationsInput(backupVaultEvents: \(Swift.String(describing: backupVaultEvents)), backupVaultName: \(Swift.String(describing: backupVaultName)), sNSTopicArn: \(Swift.String(describing: sNSTopicArn)))"}
}

extension PutBackupVaultNotificationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultEvents = "BackupVaultEvents"
        case sNSTopicArn = "SNSTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultEvents = backupVaultEvents {
            var backupVaultEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backupVaultEvents)
            for backupvaultevents0 in backupVaultEvents {
                try backupVaultEventsContainer.encode(backupvaultevents0.rawValue)
            }
        }
        if let sNSTopicArn = sNSTopicArn {
            try encodeContainer.encode(sNSTopicArn, forKey: .sNSTopicArn)
        }
    }
}

public struct PutBackupVaultNotificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultNotificationsOutputError>
}

public struct PutBackupVaultNotificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutBackupVaultNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutBackupVaultNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultNotificationsOutputError>
}

public struct PutBackupVaultNotificationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultNotificationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutBackupVaultNotificationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutBackupVaultNotificationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultNotificationsOutputError>
}

public struct PutBackupVaultNotificationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutBackupVaultNotificationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutBackupVaultNotificationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/notification-configuration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutBackupVaultNotificationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutBackupVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutBackupVaultNotificationsOutputError>
}

public struct PutBackupVaultNotificationsInput: Swift.Equatable {
    /// An array of events that indicate the status of jobs to back up resources to the backup vault. For common use cases and code samples, see [Using Amazon SNS to track Backup events](https://docs.aws.amazon.com/aws-backup/latest/devguide/sns-notifications.html). The following events are supported:
    ///
    /// * BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED
    ///
    /// * COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED
    ///
    /// * RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED | RECOVERY_POINT_MODIFIED
    ///
    ///
    /// Ignore the list below because it includes deprecated events. Refer to the list above.
    /// This member is required.
    public var backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The Amazon Resource Name (ARN) that specifies the topic for a backup vault’s events; for example, arn:aws:sns:us-west-2:111122223333:MyVaultTopic.
    /// This member is required.
    public var sNSTopicArn: Swift.String?

    public init (
        backupVaultEvents: [BackupClientTypes.BackupVaultEvent]? = nil,
        backupVaultName: Swift.String? = nil,
        sNSTopicArn: Swift.String? = nil
    )
    {
        self.backupVaultEvents = backupVaultEvents
        self.backupVaultName = backupVaultName
        self.sNSTopicArn = sNSTopicArn
    }
}

struct PutBackupVaultNotificationsInputBody: Swift.Equatable {
    public let sNSTopicArn: Swift.String?
    public let backupVaultEvents: [BackupClientTypes.BackupVaultEvent]?
}

extension PutBackupVaultNotificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultEvents = "BackupVaultEvents"
        case sNSTopicArn = "SNSTopicArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sNSTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sNSTopicArn)
        sNSTopicArn = sNSTopicArnDecoded
        let backupVaultEventsContainer = try containerValues.decodeIfPresent([BackupClientTypes.BackupVaultEvent?].self, forKey: .backupVaultEvents)
        var backupVaultEventsDecoded0:[BackupClientTypes.BackupVaultEvent]? = nil
        if let backupVaultEventsContainer = backupVaultEventsContainer {
            backupVaultEventsDecoded0 = [BackupClientTypes.BackupVaultEvent]()
            for string0 in backupVaultEventsContainer {
                if let string0 = string0 {
                    backupVaultEventsDecoded0?.append(string0)
                }
            }
        }
        backupVaultEvents = backupVaultEventsDecoded0
    }
}

extension PutBackupVaultNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutBackupVaultNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutBackupVaultNotificationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutBackupVaultNotificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutBackupVaultNotificationsOutputResponse()"}
}

extension PutBackupVaultNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutBackupVaultNotificationsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutBackupVaultNotificationsOutputResponseBody: Swift.Equatable {
}

extension PutBackupVaultNotificationsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension BackupClientTypes.RecoveryPointByBackupVault: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case calculatedLifecycle = "CalculatedLifecycle"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case iamRoleArn = "IamRoleArn"
        case isEncrypted = "IsEncrypted"
        case lastRestoreTime = "LastRestoreTime"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSizeInBytes = backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let backupVaultArn = backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let calculatedLifecycle = calculatedLifecycle {
            try encodeContainer.encode(calculatedLifecycle, forKey: .calculatedLifecycle)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate.timeIntervalSince1970, forKey: .completionDate)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if isEncrypted != false {
            try encodeContainer.encode(isEncrypted, forKey: .isEncrypted)
        }
        if let lastRestoreTime = lastRestoreTime {
            try encodeContainer.encode(lastRestoreTime.timeIntervalSince1970, forKey: .lastRestoreTime)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceBackupVaultArn = sourceBackupVaultArn {
            try encodeContainer.encode(sourceBackupVaultArn, forKey: .sourceBackupVaultArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointCreator.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let isEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isEncrypted)
        isEncrypted = isEncryptedDecoded
        let lastRestoreTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastRestoreTime)
        lastRestoreTime = lastRestoreTimeDecoded
    }
}

extension BackupClientTypes.RecoveryPointByBackupVault: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecoveryPointByBackupVault(backupSizeInBytes: \(Swift.String(describing: backupSizeInBytes)), backupVaultArn: \(Swift.String(describing: backupVaultArn)), backupVaultName: \(Swift.String(describing: backupVaultName)), calculatedLifecycle: \(Swift.String(describing: calculatedLifecycle)), completionDate: \(Swift.String(describing: completionDate)), createdBy: \(Swift.String(describing: createdBy)), creationDate: \(Swift.String(describing: creationDate)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), isEncrypted: \(Swift.String(describing: isEncrypted)), lastRestoreTime: \(Swift.String(describing: lastRestoreTime)), lifecycle: \(Swift.String(describing: lifecycle)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceArn: \(Swift.String(describing: resourceArn)), resourceType: \(Swift.String(describing: resourceType)), sourceBackupVaultArn: \(Swift.String(describing: sourceBackupVaultArn)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension BackupClientTypes {
    /// Contains detailed information about the recovery points stored in a backup vault.
    public struct RecoveryPointByBackupVault: Swift.Equatable {
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int?
        /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public var createdBy: BackupClientTypes.RecoveryPointCreator?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public var encryptionKeyArn: Swift.String?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public var isEncrypted: Swift.Bool
        /// The date and time a recovery point was last restored, in Unix format and Coordinated Universal Time (UTC). The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastRestoreTime: ClientRuntime.Date?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
        public var lifecycle: BackupClientTypes.Lifecycle?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// The type of Amazon Web Services resource saved as a recovery point; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// The backup vault where the recovery point was originally copied from. If the recovery point is restored to the same account this value will be null.
        public var sourceBackupVaultArn: Swift.String?
        /// A status code specifying the state of the recovery point.
        public var status: BackupClientTypes.RecoveryPointStatus?
        /// A message explaining the reason of the recovery point deletion failure.
        public var statusMessage: Swift.String?

        public init (
            backupSizeInBytes: Swift.Int? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
            completionDate: ClientRuntime.Date? = nil,
            createdBy: BackupClientTypes.RecoveryPointCreator? = nil,
            creationDate: ClientRuntime.Date? = nil,
            encryptionKeyArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            isEncrypted: Swift.Bool = false,
            lastRestoreTime: ClientRuntime.Date? = nil,
            lifecycle: BackupClientTypes.Lifecycle? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            status: BackupClientTypes.RecoveryPointStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes.RecoveryPointByResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeBytes = "BackupSizeBytes"
        case backupVaultName = "BackupVaultName"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case recoveryPointArn = "RecoveryPointArn"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupSizeBytes = backupSizeBytes {
            try encodeContainer.encode(backupSizeBytes, forKey: .backupSizeBytes)
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let encryptionKeyArn = encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RecoveryPointStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let backupSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeBytes)
        backupSizeBytes = backupSizeBytesDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
    }
}

extension BackupClientTypes.RecoveryPointByResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecoveryPointByResource(backupSizeBytes: \(Swift.String(describing: backupSizeBytes)), backupVaultName: \(Swift.String(describing: backupVaultName)), creationDate: \(Swift.String(describing: creationDate)), encryptionKeyArn: \(Swift.String(describing: encryptionKeyArn)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension BackupClientTypes {
    /// Contains detailed information about a saved recovery point.
    public struct RecoveryPointByResource: Swift.Equatable {
        /// The size, in bytes, of a backup.
        public var backupSizeBytes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The date and time a recovery point is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The server-side encryption key that is used to protect your backups; for example, arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public var encryptionKeyArn: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// A status code specifying the state of the recovery point.
        public var status: BackupClientTypes.RecoveryPointStatus?
        /// A message explaining the reason of the recovery point deletion failure.
        public var statusMessage: Swift.String?

        public init (
            backupSizeBytes: Swift.Int? = nil,
            backupVaultName: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            encryptionKeyArn: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            status: BackupClientTypes.RecoveryPointStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.backupSizeBytes = backupSizeBytes
            self.backupVaultName = backupVaultName
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.recoveryPointArn = recoveryPointArn
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes.RecoveryPointCreator: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case backupPlanVersion = "BackupPlanVersion"
        case backupRuleId = "BackupRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanArn = backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let backupPlanVersion = backupPlanVersion {
            try encodeContainer.encode(backupPlanVersion, forKey: .backupPlanVersion)
        }
        if let backupRuleId = backupRuleId {
            try encodeContainer.encode(backupRuleId, forKey: .backupRuleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanVersion)
        backupPlanVersion = backupPlanVersionDecoded
        let backupRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupRuleId)
        backupRuleId = backupRuleIdDecoded
    }
}

extension BackupClientTypes.RecoveryPointCreator: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecoveryPointCreator(backupPlanArn: \(Swift.String(describing: backupPlanArn)), backupPlanId: \(Swift.String(describing: backupPlanId)), backupPlanVersion: \(Swift.String(describing: backupPlanVersion)), backupRuleId: \(Swift.String(describing: backupRuleId)))"}
}

extension BackupClientTypes {
    /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
    public struct RecoveryPointCreator: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// Version IDs are unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. They cannot be edited.
        public var backupPlanVersion: Swift.String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public var backupRuleId: Swift.String?

        public init (
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanVersion: Swift.String? = nil,
            backupRuleId: Swift.String? = nil
        )
        {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }
    }

}

extension BackupClientTypes {
    public enum RecoveryPointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case deleting
        case expired
        case partial
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryPointStatus] {
            return [
                .completed,
                .deleting,
                .expired,
                .partial,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleting: return "DELETING"
            case .expired: return "EXPIRED"
            case .partial: return "PARTIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryPointStatus(rawValue: rawValue) ?? RecoveryPointStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.ReportDeliveryChannel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formats = "Formats"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formats = formats {
            var formatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .formats)
            for formatlist0 in formats {
                try formatsContainer.encode(formatlist0)
            }
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .formats)
        var formatsDecoded0:[Swift.String]? = nil
        if let formatsContainer = formatsContainer {
            formatsDecoded0 = [Swift.String]()
            for string0 in formatsContainer {
                if let string0 = string0 {
                    formatsDecoded0?.append(string0)
                }
            }
        }
        formats = formatsDecoded0
    }
}

extension BackupClientTypes.ReportDeliveryChannel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportDeliveryChannel(formats: \(Swift.String(describing: formats)), s3BucketName: \(Swift.String(describing: s3BucketName)), s3KeyPrefix: \(Swift.String(describing: s3KeyPrefix)))"}
}

extension BackupClientTypes {
    /// Contains information from your report plan about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    public struct ReportDeliveryChannel: Swift.Equatable {
        /// A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
        public var formats: [Swift.String]?
        /// The unique name of the S3 bucket that receives your reports.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// The prefix for where Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
        public var s3KeyPrefix: Swift.String?

        public init (
            formats: [Swift.String]? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.formats = formats
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension BackupClientTypes.ReportDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case s3Keys = "S3Keys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for stringlist0 in s3Keys {
                try s3KeysContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[Swift.String]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [Swift.String]()
            for string0 in s3KeysContainer {
                if let string0 = string0 {
                    s3KeysDecoded0?.append(string0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
    }
}

extension BackupClientTypes.ReportDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportDestination(s3BucketName: \(Swift.String(describing: s3BucketName)), s3Keys: \(Swift.String(describing: s3Keys)))"}
}

extension BackupClientTypes {
    /// Contains information from your report job about your report destination.
    public struct ReportDestination: Swift.Equatable {
        /// The unique name of the Amazon S3 bucket that receives your reports.
        public var s3BucketName: Swift.String?
        /// The object key that uniquely identifies your reports in your S3 bucket.
        public var s3Keys: [Swift.String]?

        public init (
            s3BucketName: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3Keys = s3Keys
        }
    }

}

extension BackupClientTypes.ReportJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime = "CompletionTime"
        case creationTime = "CreationTime"
        case reportDestination = "ReportDestination"
        case reportJobId = "ReportJobId"
        case reportPlanArn = "ReportPlanArn"
        case reportTemplate = "ReportTemplate"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = completionTime {
            try encodeContainer.encode(completionTime.timeIntervalSince1970, forKey: .completionTime)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let reportDestination = reportDestination {
            try encodeContainer.encode(reportDestination, forKey: .reportDestination)
        }
        if let reportJobId = reportJobId {
            try encodeContainer.encode(reportJobId, forKey: .reportJobId)
        }
        if let reportPlanArn = reportPlanArn {
            try encodeContainer.encode(reportPlanArn, forKey: .reportPlanArn)
        }
        if let reportTemplate = reportTemplate {
            try encodeContainer.encode(reportTemplate, forKey: .reportTemplate)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportJobId)
        reportJobId = reportJobIdDecoded
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let reportTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportTemplate)
        reportTemplate = reportTemplateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let reportDestinationDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDestination.self, forKey: .reportDestination)
        reportDestination = reportDestinationDecoded
    }
}

extension BackupClientTypes.ReportJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportJob(completionTime: \(Swift.String(describing: completionTime)), creationTime: \(Swift.String(describing: creationTime)), reportDestination: \(Swift.String(describing: reportDestination)), reportJobId: \(Swift.String(describing: reportJobId)), reportPlanArn: \(Swift.String(describing: reportPlanArn)), reportTemplate: \(Swift.String(describing: reportTemplate)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension BackupClientTypes {
    /// Contains detailed information about a report job. A report job compiles a report based on a report plan and publishes it to Amazon S3.
    public struct ReportJob: Swift.Equatable {
        /// The date and time that a report job is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionTime: ClientRuntime.Date?
        /// The date and time that a report job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationTime: ClientRuntime.Date?
        /// The S3 bucket name and S3 keys for the destination where the report job publishes the report.
        public var reportDestination: BackupClientTypes.ReportDestination?
        /// The identifier for a report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. Report job IDs cannot be edited.
        public var reportJobId: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var reportPlanArn: Swift.String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        public var reportTemplate: Swift.String?
        /// The status of a report job. The statuses are: CREATED | RUNNING | COMPLETED | FAILEDCOMPLETED means that the report is available for your review at your designated destination. If the status is FAILED, review the StatusMessage for the reason.
        public var status: Swift.String?
        /// A message explaining the status of the report job.
        public var statusMessage: Swift.String?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            reportDestination: BackupClientTypes.ReportDestination? = nil,
            reportJobId: Swift.String? = nil,
            reportPlanArn: Swift.String? = nil,
            reportTemplate: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.reportDestination = reportDestination
            self.reportJobId = reportJobId
            self.reportPlanArn = reportPlanArn
            self.reportTemplate = reportTemplate
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension BackupClientTypes.ReportPlan: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case deploymentStatus = "DeploymentStatus"
        case lastAttemptedExecutionTime = "LastAttemptedExecutionTime"
        case lastSuccessfulExecutionTime = "LastSuccessfulExecutionTime"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanArn = "ReportPlanArn"
        case reportPlanDescription = "ReportPlanDescription"
        case reportPlanName = "ReportPlanName"
        case reportSetting = "ReportSetting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let deploymentStatus = deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let lastAttemptedExecutionTime = lastAttemptedExecutionTime {
            try encodeContainer.encode(lastAttemptedExecutionTime.timeIntervalSince1970, forKey: .lastAttemptedExecutionTime)
        }
        if let lastSuccessfulExecutionTime = lastSuccessfulExecutionTime {
            try encodeContainer.encode(lastSuccessfulExecutionTime.timeIntervalSince1970, forKey: .lastSuccessfulExecutionTime)
        }
        if let reportDeliveryChannel = reportDeliveryChannel {
            try encodeContainer.encode(reportDeliveryChannel, forKey: .reportDeliveryChannel)
        }
        if let reportPlanArn = reportPlanArn {
            try encodeContainer.encode(reportPlanArn, forKey: .reportPlanArn)
        }
        if let reportPlanDescription = reportPlanDescription {
            try encodeContainer.encode(reportPlanDescription, forKey: .reportPlanDescription)
        }
        if let reportPlanName = reportPlanName {
            try encodeContainer.encode(reportPlanName, forKey: .reportPlanName)
        }
        if let reportSetting = reportSetting {
            try encodeContainer.encode(reportSetting, forKey: .reportSetting)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanDescription)
        reportPlanDescription = reportPlanDescriptionDecoded
        let reportSettingDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportSetting.self, forKey: .reportSetting)
        reportSetting = reportSettingDecoded
        let reportDeliveryChannelDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDeliveryChannel.self, forKey: .reportDeliveryChannel)
        reportDeliveryChannel = reportDeliveryChannelDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastAttemptedExecutionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAttemptedExecutionTime)
        lastAttemptedExecutionTime = lastAttemptedExecutionTimeDecoded
        let lastSuccessfulExecutionTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastSuccessfulExecutionTime)
        lastSuccessfulExecutionTime = lastSuccessfulExecutionTimeDecoded
    }
}

extension BackupClientTypes.ReportPlan: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportPlan(creationTime: \(Swift.String(describing: creationTime)), deploymentStatus: \(Swift.String(describing: deploymentStatus)), lastAttemptedExecutionTime: \(Swift.String(describing: lastAttemptedExecutionTime)), lastSuccessfulExecutionTime: \(Swift.String(describing: lastSuccessfulExecutionTime)), reportDeliveryChannel: \(Swift.String(describing: reportDeliveryChannel)), reportPlanArn: \(Swift.String(describing: reportPlanArn)), reportPlanDescription: \(Swift.String(describing: reportPlanDescription)), reportPlanName: \(Swift.String(describing: reportPlanName)), reportSetting: \(Swift.String(describing: reportSetting)))"}
}

extension BackupClientTypes {
    /// Contains detailed information about a report plan.
    public struct ReportPlan: Swift.Equatable {
        /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationTime: ClientRuntime.Date?
        /// The deployment status of a report plan. The statuses are: CREATE_IN_PROGRESS | UPDATE_IN_PROGRESS | DELETE_IN_PROGRESS | COMPLETED
        public var deploymentStatus: Swift.String?
        /// The date and time that a report job associated with this report plan last attempted to run, in Unix format and Coordinated Universal Time (UTC). The value of LastAttemptedExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastAttemptedExecutionTime: ClientRuntime.Date?
        /// The date and time that a report job associated with this report plan last successfully ran, in Unix format and Coordinated Universal Time (UTC). The value of LastSuccessfulExecutionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastSuccessfulExecutionTime: ClientRuntime.Date?
        /// Contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
        public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var reportPlanArn: Swift.String?
        /// An optional description of the report plan with a maximum 1,024 characters.
        public var reportPlanDescription: Swift.String?
        /// The unique name of the report plan. This name is between 1 and 256 characters starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
        public var reportPlanName: Swift.String?
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
        public var reportSetting: BackupClientTypes.ReportSetting?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            lastAttemptedExecutionTime: ClientRuntime.Date? = nil,
            lastSuccessfulExecutionTime: ClientRuntime.Date? = nil,
            reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
            reportPlanArn: Swift.String? = nil,
            reportPlanDescription: Swift.String? = nil,
            reportPlanName: Swift.String? = nil,
            reportSetting: BackupClientTypes.ReportSetting? = nil
        )
        {
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.lastAttemptedExecutionTime = lastAttemptedExecutionTime
            self.lastSuccessfulExecutionTime = lastSuccessfulExecutionTime
            self.reportDeliveryChannel = reportDeliveryChannel
            self.reportPlanArn = reportPlanArn
            self.reportPlanDescription = reportPlanDescription
            self.reportPlanName = reportPlanName
            self.reportSetting = reportSetting
        }
    }

}

extension BackupClientTypes.ReportSetting: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkArns = "FrameworkArns"
        case numberOfFrameworks = "NumberOfFrameworks"
        case reportTemplate = "ReportTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameworkArns = frameworkArns {
            var frameworkArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameworkArns)
            for stringlist0 in frameworkArns {
                try frameworkArnsContainer.encode(stringlist0)
            }
        }
        if numberOfFrameworks != 0 {
            try encodeContainer.encode(numberOfFrameworks, forKey: .numberOfFrameworks)
        }
        if let reportTemplate = reportTemplate {
            try encodeContainer.encode(reportTemplate, forKey: .reportTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportTemplate)
        reportTemplate = reportTemplateDecoded
        let frameworkArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .frameworkArns)
        var frameworkArnsDecoded0:[Swift.String]? = nil
        if let frameworkArnsContainer = frameworkArnsContainer {
            frameworkArnsDecoded0 = [Swift.String]()
            for string0 in frameworkArnsContainer {
                if let string0 = string0 {
                    frameworkArnsDecoded0?.append(string0)
                }
            }
        }
        frameworkArns = frameworkArnsDecoded0
        let numberOfFrameworksDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfFrameworks)
        numberOfFrameworks = numberOfFrameworksDecoded
    }
}

extension BackupClientTypes.ReportSetting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReportSetting(frameworkArns: \(Swift.String(describing: frameworkArns)), numberOfFrameworks: \(Swift.String(describing: numberOfFrameworks)), reportTemplate: \(Swift.String(describing: reportTemplate)))"}
}

extension BackupClientTypes {
    /// Contains detailed information about a report setting.
    public struct ReportSetting: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) of the frameworks a report covers.
        public var frameworkArns: [Swift.String]?
        /// The number of frameworks a report covers.
        public var numberOfFrameworks: Swift.Int
        /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT
        /// This member is required.
        public var reportTemplate: Swift.String?

        public init (
            frameworkArns: [Swift.String]? = nil,
            numberOfFrameworks: Swift.Int = 0,
            reportTemplate: Swift.String? = nil
        )
        {
            self.frameworkArns = frameworkArns
            self.numberOfFrameworks = numberOfFrameworks
            self.reportTemplate = reportTemplate
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource that is required for the action doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

extension BackupClientTypes {
    public enum RestoreJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aborted
        case completed
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [RestoreJobStatus] {
            return [
                .aborted,
                .completed,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RestoreJobStatus(rawValue: rawValue) ?? RestoreJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension BackupClientTypes.RestoreJobsListMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case backupSizeInBytes = "BackupSizeInBytes"
        case completionDate = "CompletionDate"
        case createdResourceArn = "CreatedResourceArn"
        case creationDate = "CreationDate"
        case expectedCompletionTimeMinutes = "ExpectedCompletionTimeMinutes"
        case iamRoleArn = "IamRoleArn"
        case percentDone = "PercentDone"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
        case restoreJobId = "RestoreJobId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let backupSizeInBytes = backupSizeInBytes {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate.timeIntervalSince1970, forKey: .completionDate)
        }
        if let createdResourceArn = createdResourceArn {
            try encodeContainer.encode(createdResourceArn, forKey: .createdResourceArn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let expectedCompletionTimeMinutes = expectedCompletionTimeMinutes {
            try encodeContainer.encode(expectedCompletionTimeMinutes, forKey: .expectedCompletionTimeMinutes)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let percentDone = percentDone {
            try encodeContainer.encode(percentDone, forKey: .percentDone)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let restoreJobId = restoreJobId {
            try encodeContainer.encode(restoreJobId, forKey: .restoreJobId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupClientTypes.RestoreJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let percentDoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentDone)
        percentDone = percentDoneDecoded
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes)
        backupSizeInBytes = backupSizeInBytesDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let expectedCompletionTimeMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expectedCompletionTimeMinutes)
        expectedCompletionTimeMinutes = expectedCompletionTimeMinutesDecoded
        let createdResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdResourceArn)
        createdResourceArn = createdResourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension BackupClientTypes.RestoreJobsListMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreJobsListMember(accountId: \(Swift.String(describing: accountId)), backupSizeInBytes: \(Swift.String(describing: backupSizeInBytes)), completionDate: \(Swift.String(describing: completionDate)), createdResourceArn: \(Swift.String(describing: createdResourceArn)), creationDate: \(Swift.String(describing: creationDate)), expectedCompletionTimeMinutes: \(Swift.String(describing: expectedCompletionTimeMinutes)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), percentDone: \(Swift.String(describing: percentDone)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceType: \(Swift.String(describing: resourceType)), restoreJobId: \(Swift.String(describing: restoreJobId)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension BackupClientTypes {
    /// Contains metadata about a restore job.
    public struct RestoreJobsListMember: Swift.Equatable {
        /// The account ID that owns the restore job.
        public var accountId: Swift.String?
        /// The size, in bytes, of the restored resource.
        public var backupSizeInBytes: Swift.Int?
        /// The date and time a job to restore a recovery point is completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: ClientRuntime.Date?
        /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var createdResourceArn: Swift.String?
        /// The date and time a restore job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: ClientRuntime.Date?
        /// The amount of time in minutes that a job restoring a recovery point is expected to take.
        public var expectedCompletionTimeMinutes: Swift.Int?
        /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
        public var iamRoleArn: Swift.String?
        /// Contains an estimated percentage complete of a job at the time the job status was queried.
        public var percentDone: Swift.String?
        /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
        public var recoveryPointArn: Swift.String?
        /// The resource type of the listed restore jobs; for example, an Amazon Elastic Block Store (Amazon EBS) volume or an Amazon Relational Database Service (Amazon RDS) database. For Windows Volume Shadow Copy Service (VSS) backups, the only supported resource type is Amazon EC2.
        public var resourceType: Swift.String?
        /// Uniquely identifies the job that restores a recovery point.
        public var restoreJobId: Swift.String?
        /// A status code specifying the state of the job initiated by Backup to restore a recovery point.
        public var status: BackupClientTypes.RestoreJobStatus?
        /// A detailed message explaining the status of the job to restore a recovery point.
        public var statusMessage: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            backupSizeInBytes: Swift.Int? = nil,
            completionDate: ClientRuntime.Date? = nil,
            createdResourceArn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            expectedCompletionTimeMinutes: Swift.Int? = nil,
            iamRoleArn: Swift.String? = nil,
            percentDone: Swift.String? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            restoreJobId: Swift.String? = nil,
            status: BackupClientTypes.RestoreJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.backupSizeInBytes = backupSizeInBytes
            self.completionDate = completionDate
            self.createdResourceArn = createdResourceArn
            self.creationDate = creationDate
            self.expectedCompletionTimeMinutes = expectedCompletionTimeMinutes
            self.iamRoleArn = iamRoleArn
            self.percentDone = percentDone
            self.recoveryPointArn = recoveryPointArn
            self.resourceType = resourceType
            self.restoreJobId = restoreJobId
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to a temporary failure of the server.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    ///
    public var context: Swift.String?
    public var message: Swift.String?
    ///
    public var type: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: Swift.String? = nil,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
        self.type = type
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
    public let type: Swift.String?
    public let context: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case context = "Context"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
    }
}

public struct StartBackupJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartBackupJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartBackupJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartBackupJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartBackupJobOutputError>
}

extension StartBackupJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartBackupJobInput(backupOptions: \(Swift.String(describing: backupOptions)), backupVaultName: \(Swift.String(describing: backupVaultName)), completeWindowMinutes: \(Swift.String(describing: completeWindowMinutes)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), lifecycle: \(Swift.String(describing: lifecycle)), recoveryPointTags: \(Swift.String(describing: recoveryPointTags)), resourceArn: \(Swift.String(describing: resourceArn)), startWindowMinutes: \(Swift.String(describing: startWindowMinutes)))"}
}

extension StartBackupJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case backupVaultName = "BackupVaultName"
        case completeWindowMinutes = "CompleteWindowMinutes"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case resourceArn = "ResourceArn"
        case startWindowMinutes = "StartWindowMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, backupoptions0) in backupOptions {
                try backupOptionsContainer.encode(backupoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let backupVaultName = backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let completeWindowMinutes = completeWindowMinutes {
            try encodeContainer.encode(completeWindowMinutes, forKey: .completeWindowMinutes)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointTags = recoveryPointTags {
            var recoveryPointTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .recoveryPointTags)
            for (dictKey0, tags0) in recoveryPointTags {
                try recoveryPointTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startWindowMinutes = startWindowMinutes {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
    }
}

public struct StartBackupJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartBackupJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartBackupJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartBackupJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartBackupJobOutputError>
}

public struct StartBackupJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartBackupJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartBackupJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartBackupJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartBackupJobOutputError>
}

public struct StartBackupJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartBackupJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartBackupJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartBackupJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartBackupJobOutputError>
}

public struct StartBackupJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartBackupJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartBackupJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/backup-jobs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartBackupJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartBackupJobOutputError>
}

public struct StartBackupJobInput: Swift.Equatable {
    /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values: Set to "WindowsVSS":"enabled" to enable the WindowsVSS backup option and create a Windows VSS backup. Set to "WindowsVSS""disabled" to create a regular backup. The WindowsVSS option is not enabled by default.
    public var backupOptions: [Swift.String:Swift.String]?
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// A value in minutes during which a successfully started backup must complete, or else AWS Backup will cancel the job. This value is optional. This value begins counting down from when the backup was scheduled. It does not add additional time for StartWindowMinutes, or if the backup started later than scheduled.
    public var completeWindowMinutes: Swift.Int?
    /// Specifies the IAM role ARN used to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartBackupJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup will transition and expire backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// To help organize your resources, you can assign your own metadata to the resources that you create. Each tag is a key-value pair.
    public var recoveryPointTags: [Swift.String:Swift.String]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully. This value is optional, and the default is 8 hours.
    public var startWindowMinutes: Swift.Int?

    public init (
        backupOptions: [Swift.String:Swift.String]? = nil,
        backupVaultName: Swift.String? = nil,
        completeWindowMinutes: Swift.Int? = nil,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointTags: [Swift.String:Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        startWindowMinutes: Swift.Int? = nil
    )
    {
        self.backupOptions = backupOptions
        self.backupVaultName = backupVaultName
        self.completeWindowMinutes = completeWindowMinutes
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointTags = recoveryPointTags
        self.resourceArn = resourceArn
        self.startWindowMinutes = startWindowMinutes
    }
}

struct StartBackupJobInputBody: Swift.Equatable {
    public let backupVaultName: Swift.String?
    public let resourceArn: Swift.String?
    public let iamRoleArn: Swift.String?
    public let idempotencyToken: Swift.String?
    public let startWindowMinutes: Swift.Int?
    public let completeWindowMinutes: Swift.Int?
    public let lifecycle: BackupClientTypes.Lifecycle?
    public let recoveryPointTags: [Swift.String:Swift.String]?
    public let backupOptions: [Swift.String:Swift.String]?
}

extension StartBackupJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case backupVaultName = "BackupVaultName"
        case completeWindowMinutes = "CompleteWindowMinutes"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointTags = "RecoveryPointTags"
        case resourceArn = "ResourceArn"
        case startWindowMinutes = "StartWindowMinutes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes)
        startWindowMinutes = startWindowMinutesDecoded
        let completeWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completeWindowMinutes)
        completeWindowMinutes = completeWindowMinutesDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .recoveryPointTags)
        var recoveryPointTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let recoveryPointTagsContainer = recoveryPointTagsContainer {
            recoveryPointTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in recoveryPointTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    recoveryPointTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        recoveryPointTags = recoveryPointTagsDecoded0
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, backupoptionvalue0) in backupOptionsContainer {
                if let backupoptionvalue0 = backupoptionvalue0 {
                    backupOptionsDecoded0?[key0] = backupoptionvalue0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
    }
}

extension StartBackupJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartBackupJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartBackupJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartBackupJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartBackupJobOutputResponse(backupJobId: \(Swift.String(describing: backupJobId)), creationDate: \(Swift.String(describing: creationDate)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)))"}
}

extension StartBackupJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartBackupJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupJobId = output.backupJobId
            self.creationDate = output.creationDate
            self.recoveryPointArn = output.recoveryPointArn
        } else {
            self.backupJobId = nil
            self.creationDate = nil
            self.recoveryPointArn = nil
        }
    }
}

public struct StartBackupJobOutputResponse: Swift.Equatable {
    /// Uniquely identifies a request to Backup to back up a resource.
    public var backupJobId: Swift.String?
    /// The date and time that a backup job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?

    public init (
        backupJobId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
        self.creationDate = creationDate
        self.recoveryPointArn = recoveryPointArn
    }
}

struct StartBackupJobOutputResponseBody: Swift.Equatable {
    public let backupJobId: Swift.String?
    public let recoveryPointArn: Swift.String?
    public let creationDate: ClientRuntime.Date?
}

extension StartBackupJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupJobId = "BackupJobId"
        case creationDate = "CreationDate"
        case recoveryPointArn = "RecoveryPointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupJobId)
        backupJobId = backupJobIdDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct StartCopyJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartCopyJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartCopyJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartCopyJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartCopyJobOutputError>
}

extension StartCopyJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartCopyJobInput(destinationBackupVaultArn: \(Swift.String(describing: destinationBackupVaultArn)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), lifecycle: \(Swift.String(describing: lifecycle)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), sourceBackupVaultName: \(Swift.String(describing: sourceBackupVaultName)))"}
}

extension StartCopyJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case sourceBackupVaultName = "SourceBackupVaultName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBackupVaultArn = destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let sourceBackupVaultName = sourceBackupVaultName {
            try encodeContainer.encode(sourceBackupVaultName, forKey: .sourceBackupVaultName)
        }
    }
}

public struct StartCopyJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartCopyJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartCopyJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartCopyJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartCopyJobOutputError>
}

public struct StartCopyJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartCopyJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartCopyJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartCopyJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartCopyJobOutputError>
}

public struct StartCopyJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartCopyJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartCopyJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartCopyJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartCopyJobOutputError>
}

public struct StartCopyJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartCopyJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartCopyJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartCopyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/copy-jobs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartCopyJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartCopyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartCopyJobOutputError>
}

public struct StartCopyJobInput: Swift.Equatable {
    /// An Amazon Resource Name (ARN) that uniquely identifies a destination backup vault to copy to; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    /// This member is required.
    public var destinationBackupVaultArn: Swift.String?
    /// Specifies the IAM role ARN used to copy the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartCopyJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, on the console, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An ARN that uniquely identifies a recovery point to use for the copy job; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?
    /// The name of a logical source container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var sourceBackupVaultName: Swift.String?

    public init (
        destinationBackupVaultArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil,
        sourceBackupVaultName: Swift.String? = nil
    )
    {
        self.destinationBackupVaultArn = destinationBackupVaultArn
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
        self.sourceBackupVaultName = sourceBackupVaultName
    }
}

struct StartCopyJobInputBody: Swift.Equatable {
    public let recoveryPointArn: Swift.String?
    public let sourceBackupVaultName: Swift.String?
    public let destinationBackupVaultArn: Swift.String?
    public let iamRoleArn: Swift.String?
    public let idempotencyToken: Swift.String?
    public let lifecycle: BackupClientTypes.Lifecycle?
}

extension StartCopyJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case sourceBackupVaultName = "SourceBackupVaultName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let sourceBackupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultName)
        sourceBackupVaultName = sourceBackupVaultNameDecoded
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension StartCopyJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCopyJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCopyJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCopyJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartCopyJobOutputResponse(copyJobId: \(Swift.String(describing: copyJobId)), creationDate: \(Swift.String(describing: creationDate)))"}
}

extension StartCopyJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartCopyJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyJobId = output.copyJobId
            self.creationDate = output.creationDate
        } else {
            self.copyJobId = nil
            self.creationDate = nil
        }
    }
}

public struct StartCopyJobOutputResponse: Swift.Equatable {
    /// Uniquely identifies a copy job.
    public var copyJobId: Swift.String?
    /// The date and time that a copy job is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?

    public init (
        copyJobId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil
    )
    {
        self.copyJobId = copyJobId
        self.creationDate = creationDate
    }
}

struct StartCopyJobOutputResponseBody: Swift.Equatable {
    public let copyJobId: Swift.String?
    public let creationDate: ClientRuntime.Date?
}

extension StartCopyJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyJobId = "CopyJobId"
        case creationDate = "CreationDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyJobId)
        copyJobId = copyJobIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

public struct StartReportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReportJobOutputError>
}

extension StartReportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReportJobInput(idempotencyToken: \(Swift.String(describing: idempotencyToken)), reportPlanName: \(Swift.String(describing: reportPlanName)))"}
}

extension StartReportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

public struct StartReportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReportJobOutputError>
}

public struct StartReportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartReportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartReportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartReportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReportJobOutputError>
}

public struct StartReportJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReportJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartReportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartReportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartReportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReportJobOutputError>
}

public struct StartReportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartReportJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartReportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartReportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let reportPlanName = input.reportPlanName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("reportPlanName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/audit/report-jobs/\(reportPlanName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartReportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartReportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartReportJobOutputError>
}

public struct StartReportJobInput: Swift.Equatable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartReportJobInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// The unique name of a report plan.
    /// This member is required.
    public var reportPlanName: Swift.String?

    public init (
        idempotencyToken: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportPlanName = reportPlanName
    }
}

struct StartReportJobInputBody: Swift.Equatable {
    public let idempotencyToken: Swift.String?
}

extension StartReportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension StartReportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReportJobOutputResponse(reportJobId: \(Swift.String(describing: reportJobId)))"}
}

extension StartReportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartReportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportJobId = output.reportJobId
        } else {
            self.reportJobId = nil
        }
    }
}

public struct StartReportJobOutputResponse: Swift.Equatable {
    /// The identifier of the report job. A unique, randomly generated, Unicode, UTF-8 encoded string that is at most 1,024 bytes long. The report job ID cannot be edited.
    public var reportJobId: Swift.String?

    public init (
        reportJobId: Swift.String? = nil
    )
    {
        self.reportJobId = reportJobId
    }
}

struct StartReportJobOutputResponseBody: Swift.Equatable {
    public let reportJobId: Swift.String?
}

extension StartReportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportJobId = "ReportJobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportJobId)
        reportJobId = reportJobIdDecoded
    }
}

public struct StartRestoreJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRestoreJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartRestoreJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartRestoreJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRestoreJobOutputError>
}

extension StartRestoreJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRestoreJobInput(iamRoleArn: \(Swift.String(describing: iamRoleArn)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), metadata: \(Swift.String(describing: metadata)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension StartRestoreJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case metadata = "Metadata"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let recoveryPointArn = recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct StartRestoreJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRestoreJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartRestoreJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartRestoreJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRestoreJobOutputError>
}

public struct StartRestoreJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRestoreJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartRestoreJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartRestoreJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRestoreJobOutputError>
}

public struct StartRestoreJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRestoreJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartRestoreJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartRestoreJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRestoreJobOutputError>
}

public struct StartRestoreJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartRestoreJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartRestoreJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/restore-jobs"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartRestoreJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartRestoreJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartRestoreJobOutputError>
}

public struct StartRestoreJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the IAM role that Backup uses to create the target recovery point; for example, arn:aws:iam::123456789012:role/S3Access.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to StartRestoreJob. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A set of metadata key-value pairs. Contains information, such as a resource name, required to restore a recovery point. You can get configuration metadata about a resource at the time it was backed up by calling GetRecoveryPointRestoreMetadata. However, values in addition to those provided by GetRecoveryPointRestoreMetadata might be required to restore a resource. For example, you might need to provide a new resource name if the original already exists. You need to specify specific metadata to restore an Amazon Elastic File System (Amazon EFS) instance:
    ///
    /// * file-system-id: The ID of the Amazon EFS file system that is backed up by Backup. Returned in GetRecoveryPointRestoreMetadata.
    ///
    /// * Encrypted: A Boolean value that, if true, specifies that the file system is encrypted. If KmsKeyId is specified, Encrypted must be set to true.
    ///
    /// * KmsKeyId: Specifies the Amazon Web Services KMS key that is used to encrypt the restored file system. You can specify a key from another Amazon Web Services account provided that key it is properly shared with your account via Amazon Web Services KMS.
    ///
    /// * PerformanceMode: Specifies the throughput mode of the file system.
    ///
    /// * CreationToken: A user-supplied value that ensures the uniqueness (idempotency) of the request.
    ///
    /// * newFileSystem: A Boolean value that, if true, specifies that the recovery point is restored to a new Amazon EFS file system.
    ///
    /// * ItemsToRestore: An array of one to five strings where each string is a file path. Use ItemsToRestore to restore specific files or directories rather than the entire file system. This parameter is optional. For example, "itemsToRestore":"[\"/my.test\"]".
    /// This member is required.
    public var metadata: [Swift.String:Swift.String]?
    /// An ARN that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?
    /// Starts a job to restore a recovery point for one of the following resources:
    ///
    /// * DynamoDB for Amazon DynamoDB
    ///
    /// * EBS for Amazon Elastic Block Store
    ///
    /// * EC2 for Amazon Elastic Compute Cloud
    ///
    /// * EFS for Amazon Elastic File System
    ///
    /// * RDS for Amazon Relational Database Service
    ///
    /// * Aurora for Amazon Aurora
    ///
    /// * Storage Gateway for Storage Gateway
    public var resourceType: Swift.String?

    public init (
        iamRoleArn: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        recoveryPointArn: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.iamRoleArn = iamRoleArn
        self.idempotencyToken = idempotencyToken
        self.metadata = metadata
        self.recoveryPointArn = recoveryPointArn
        self.resourceType = resourceType
    }
}

struct StartRestoreJobInputBody: Swift.Equatable {
    public let recoveryPointArn: Swift.String?
    public let metadata: [Swift.String:Swift.String]?
    public let iamRoleArn: Swift.String?
    public let idempotencyToken: Swift.String?
    public let resourceType: Swift.String?
}

extension StartRestoreJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IamRoleArn"
        case idempotencyToken = "IdempotencyToken"
        case metadata = "Metadata"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in metadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    metadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        metadata = metadataDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension StartRestoreJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRestoreJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartRestoreJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRestoreJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRestoreJobOutputResponse(restoreJobId: \(Swift.String(describing: restoreJobId)))"}
}

extension StartRestoreJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartRestoreJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.restoreJobId = output.restoreJobId
        } else {
            self.restoreJobId = nil
        }
    }
}

public struct StartRestoreJobOutputResponse: Swift.Equatable {
    /// Uniquely identifies the job that restores a recovery point.
    public var restoreJobId: Swift.String?

    public init (
        restoreJobId: Swift.String? = nil
    )
    {
        self.restoreJobId = restoreJobId
    }
}

struct StartRestoreJobOutputResponseBody: Swift.Equatable {
    public let restoreJobId: Swift.String?
}

extension StartRestoreJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restoreJobId = "RestoreJobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restoreJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreJobId)
        restoreJobId = restoreJobIdDecoded
    }
}

extension StopBackupJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopBackupJobInput(backupJobId: \(Swift.String(describing: backupJobId)))"}
}

extension StopBackupJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StopBackupJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopBackupJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopBackupJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopBackupJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopBackupJobOutputError>
}

public struct StopBackupJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopBackupJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopBackupJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopBackupJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopBackupJobOutputError>
}

public struct StopBackupJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopBackupJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopBackupJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopBackupJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopBackupJobOutputError>
}

public struct StopBackupJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopBackupJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopBackupJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopBackupJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupJobId = input.backupJobId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupJobId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-jobs/\(backupJobId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopBackupJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopBackupJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopBackupJobOutputError>
}

public struct StopBackupJobInput: Swift.Equatable {
    /// Uniquely identifies a request to Backup to back up a resource.
    /// This member is required.
    public var backupJobId: Swift.String?

    public init (
        backupJobId: Swift.String? = nil
    )
    {
        self.backupJobId = backupJobId
    }
}

struct StopBackupJobInputBody: Swift.Equatable {
}

extension StopBackupJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopBackupJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopBackupJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopBackupJobOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopBackupJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopBackupJobOutputResponse()"}
}

extension StopBackupJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopBackupJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopBackupJobOutputResponseBody: Swift.Equatable {
}

extension StopBackupJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension BackupClientTypes {
    public enum StorageClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cold
        case deleted
        case warm
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageClass] {
            return [
                .cold,
                .deleted,
                .warm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cold: return "COLD"
            case .deleted: return "DELETED"
            case .warm: return "WARM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
        }
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Key-value pairs that are used to help organize your resources. You can assign your own metadata to the resources you create. For clarity, this is the structure to assign tags: [{"Key":"string","Value":"string"}].
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeyList: \(Swift.String(describing: tagKeyList)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkeylist0 in tagKeyList {
                try tagKeyListContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/untag/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// An ARN that uniquely identifies a resource. The format of the ARN depends on the type of the tagged resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys to identify which key-value tags to remove from a resource.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let tagKeyList: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateBackupPlanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackupPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackupPlanOutputError>
}

extension UpdateBackupPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackupPlanInput(backupPlan: \(Swift.String(describing: backupPlan)), backupPlanId: \(Swift.String(describing: backupPlanId)))"}
}

extension UpdateBackupPlanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlan = backupPlan {
            try encodeContainer.encode(backupPlan, forKey: .backupPlan)
        }
    }
}

public struct UpdateBackupPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackupPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackupPlanOutputError>
}

public struct UpdateBackupPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackupPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackupPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackupPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackupPlanOutputError>
}

public struct UpdateBackupPlanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackupPlanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateBackupPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBackupPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackupPlanOutputError>
}

public struct UpdateBackupPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackupPlanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateBackupPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupPlanId = input.backupPlanId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupPlanId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup/plans/\(backupPlanId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBackupPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackupPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackupPlanOutputError>
}

public struct UpdateBackupPlanInput: Swift.Equatable {
    /// Specifies the body of a backup plan. Includes a BackupPlanName and one or more sets of Rules.
    /// This member is required.
    public var backupPlan: BackupClientTypes.BackupPlanInput?
    /// Uniquely identifies a backup plan.
    /// This member is required.
    public var backupPlanId: Swift.String?

    public init (
        backupPlan: BackupClientTypes.BackupPlanInput? = nil,
        backupPlanId: Swift.String? = nil
    )
    {
        self.backupPlan = backupPlan
        self.backupPlanId = backupPlanId
    }
}

struct UpdateBackupPlanInputBody: Swift.Equatable {
    public let backupPlan: BackupClientTypes.BackupPlanInput?
}

extension UpdateBackupPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(BackupClientTypes.BackupPlanInput.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
    }
}

extension UpdateBackupPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackupPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackupPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackupPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackupPlanOutputResponse(advancedBackupSettings: \(Swift.String(describing: advancedBackupSettings)), backupPlanArn: \(Swift.String(describing: backupPlanArn)), backupPlanId: \(Swift.String(describing: backupPlanId)), creationDate: \(Swift.String(describing: creationDate)), versionId: \(Swift.String(describing: versionId)))"}
}

extension UpdateBackupPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBackupPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedBackupSettings = output.advancedBackupSettings
            self.backupPlanArn = output.backupPlanArn
            self.backupPlanId = output.backupPlanId
            self.creationDate = output.creationDate
            self.versionId = output.versionId
        } else {
            self.advancedBackupSettings = nil
            self.backupPlanArn = nil
            self.backupPlanId = nil
            self.creationDate = nil
            self.versionId = nil
        }
    }
}

public struct UpdateBackupPlanOutputResponse: Swift.Equatable {
    /// Contains a list of BackupOptions for each resource type.
    public var advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
    /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan; for example, arn:aws:backup:us-east-1:123456789012:plan:8F81F553-3A74-4A3F-B93D-B3360DC80C50.
    public var backupPlanArn: Swift.String?
    /// Uniquely identifies a backup plan.
    public var backupPlanId: Swift.String?
    /// The date and time a backup plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationDate: ClientRuntime.Date?
    /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version Ids cannot be edited.
    public var versionId: Swift.String?

    public init (
        advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]? = nil,
        backupPlanArn: Swift.String? = nil,
        backupPlanId: Swift.String? = nil,
        creationDate: ClientRuntime.Date? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.advancedBackupSettings = advancedBackupSettings
        self.backupPlanArn = backupPlanArn
        self.backupPlanId = backupPlanId
        self.creationDate = creationDate
        self.versionId = versionId
    }
}

struct UpdateBackupPlanOutputResponseBody: Swift.Equatable {
    public let backupPlanId: Swift.String?
    public let backupPlanArn: Swift.String?
    public let creationDate: ClientRuntime.Date?
    public let versionId: Swift.String?
    public let advancedBackupSettings: [BackupClientTypes.AdvancedBackupSetting]?
}

extension UpdateBackupPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case creationDate = "CreationDate"
        case versionId = "VersionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([BackupClientTypes.AdvancedBackupSetting?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[BackupClientTypes.AdvancedBackupSetting]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [BackupClientTypes.AdvancedBackupSetting]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
    }
}

public struct UpdateFrameworkInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFrameworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFrameworkOutputError>
}

extension UpdateFrameworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFrameworkInput(frameworkControls: \(Swift.String(describing: frameworkControls)), frameworkDescription: \(Swift.String(describing: frameworkDescription)), frameworkName: \(Swift.String(describing: frameworkName)), idempotencyToken: \(Swift.String(describing: idempotencyToken)))"}
}

extension UpdateFrameworkInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case idempotencyToken = "IdempotencyToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameworkControls = frameworkControls {
            var frameworkControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameworkControls)
            for frameworkcontrols0 in frameworkControls {
                try frameworkControlsContainer.encode(frameworkcontrols0)
            }
        }
        if let frameworkDescription = frameworkDescription {
            try encodeContainer.encode(frameworkDescription, forKey: .frameworkDescription)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
    }
}

public struct UpdateFrameworkInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFrameworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFrameworkOutputError>
}

public struct UpdateFrameworkInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFrameworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFrameworkInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFrameworkInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFrameworkOutputError>
}

public struct UpdateFrameworkInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFrameworkInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateFrameworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFrameworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFrameworkOutputError>
}

public struct UpdateFrameworkInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFrameworkInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateFrameworkInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let frameworkName = input.frameworkName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("frameworkName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/audit/frameworks/\(frameworkName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateFrameworkInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFrameworkOutputError>
}

public struct UpdateFrameworkInput: Swift.Equatable {
    /// A list of the controls that make up the framework. Each control in the list has a name, input parameters, and scope.
    public var frameworkControls: [BackupClientTypes.FrameworkControl]?
    /// An optional description of the framework with a maximum 1,024 characters.
    public var frameworkDescription: Swift.String?
    /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var frameworkName: Swift.String?
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateFrameworkInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?

    public init (
        frameworkControls: [BackupClientTypes.FrameworkControl]? = nil,
        frameworkDescription: Swift.String? = nil,
        frameworkName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.frameworkControls = frameworkControls
        self.frameworkDescription = frameworkDescription
        self.frameworkName = frameworkName
        self.idempotencyToken = idempotencyToken
    }
}

struct UpdateFrameworkInputBody: Swift.Equatable {
    public let frameworkDescription: Swift.String?
    public let frameworkControls: [BackupClientTypes.FrameworkControl]?
    public let idempotencyToken: Swift.String?
}

extension UpdateFrameworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameworkControls = "FrameworkControls"
        case frameworkDescription = "FrameworkDescription"
        case idempotencyToken = "IdempotencyToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkDescription)
        frameworkDescription = frameworkDescriptionDecoded
        let frameworkControlsContainer = try containerValues.decodeIfPresent([BackupClientTypes.FrameworkControl?].self, forKey: .frameworkControls)
        var frameworkControlsDecoded0:[BackupClientTypes.FrameworkControl]? = nil
        if let frameworkControlsContainer = frameworkControlsContainer {
            frameworkControlsDecoded0 = [BackupClientTypes.FrameworkControl]()
            for structure0 in frameworkControlsContainer {
                if let structure0 = structure0 {
                    frameworkControlsDecoded0?.append(structure0)
                }
            }
        }
        frameworkControls = frameworkControlsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension UpdateFrameworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFrameworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFrameworkOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFrameworkOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFrameworkOutputResponse(creationTime: \(Swift.String(describing: creationTime)), frameworkArn: \(Swift.String(describing: frameworkArn)), frameworkName: \(Swift.String(describing: frameworkName)))"}
}

extension UpdateFrameworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.frameworkArn = output.frameworkArn
            self.frameworkName = output.frameworkName
        } else {
            self.creationTime = nil
            self.frameworkArn = nil
            self.frameworkName = nil
        }
    }
}

public struct UpdateFrameworkOutputResponse: Swift.Equatable {
    /// The date and time that a framework is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var frameworkArn: Swift.String?
    /// The unique name of a framework. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    public var frameworkName: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        frameworkArn: Swift.String? = nil,
        frameworkName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.frameworkArn = frameworkArn
        self.frameworkName = frameworkName
    }
}

struct UpdateFrameworkOutputResponseBody: Swift.Equatable {
    public let frameworkName: Swift.String?
    public let frameworkArn: Swift.String?
    public let creationTime: ClientRuntime.Date?
}

extension UpdateFrameworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case frameworkArn = "FrameworkArn"
        case frameworkName = "FrameworkName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkName)
        frameworkName = frameworkNameDecoded
        let frameworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameworkArn)
        frameworkArn = frameworkArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

public struct UpdateGlobalSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

extension UpdateGlobalSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlobalSettingsInput(globalSettings: \(Swift.String(describing: globalSettings)))"}
}

extension UpdateGlobalSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSettings = "GlobalSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalSettings = globalSettings {
            var globalSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .globalSettings)
            for (dictKey0, globalsettings0) in globalSettings {
                try globalSettingsContainer.encode(globalsettings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateGlobalSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGlobalSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateGlobalSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGlobalSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGlobalSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateGlobalSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/global-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGlobalSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGlobalSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGlobalSettingsOutputError>
}

public struct UpdateGlobalSettingsInput: Swift.Equatable {
    /// A value for isCrossAccountBackupEnabled and a Region. Example: update-global-settings --global-settings isCrossAccountBackupEnabled=false --region us-west-2.
    public var globalSettings: [Swift.String:Swift.String]?

    public init (
        globalSettings: [Swift.String:Swift.String]? = nil
    )
    {
        self.globalSettings = globalSettings
    }
}

struct UpdateGlobalSettingsInputBody: Swift.Equatable {
    public let globalSettings: [Swift.String:Swift.String]?
}

extension UpdateGlobalSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSettings = "GlobalSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSettingsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .globalSettings)
        var globalSettingsDecoded0: [Swift.String:Swift.String]? = nil
        if let globalSettingsContainer = globalSettingsContainer {
            globalSettingsDecoded0 = [Swift.String:Swift.String]()
            for (key0, globalsettingsvalue0) in globalSettingsContainer {
                if let globalsettingsvalue0 = globalsettingsvalue0 {
                    globalSettingsDecoded0?[key0] = globalsettingsvalue0
                }
            }
        }
        globalSettings = globalSettingsDecoded0
    }
}

extension UpdateGlobalSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGlobalSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGlobalSettingsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGlobalSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGlobalSettingsOutputResponse()"}
}

extension UpdateGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGlobalSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateGlobalSettingsOutputResponseBody: Swift.Equatable {
}

extension UpdateGlobalSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateRecoveryPointLifecycleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecoveryPointLifecycleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRecoveryPointLifecycleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRecoveryPointLifecycleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecoveryPointLifecycleOutputError>
}

extension UpdateRecoveryPointLifecycleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRecoveryPointLifecycleInput(backupVaultName: \(Swift.String(describing: backupVaultName)), lifecycle: \(Swift.String(describing: lifecycle)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)))"}
}

extension UpdateRecoveryPointLifecycleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
    }
}

public struct UpdateRecoveryPointLifecycleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecoveryPointLifecycleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRecoveryPointLifecycleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRecoveryPointLifecycleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecoveryPointLifecycleOutputError>
}

public struct UpdateRecoveryPointLifecycleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecoveryPointLifecycleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRecoveryPointLifecycleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRecoveryPointLifecycleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecoveryPointLifecycleOutputError>
}

public struct UpdateRecoveryPointLifecycleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecoveryPointLifecycleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateRecoveryPointLifecycleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRecoveryPointLifecycleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecoveryPointLifecycleOutputError>
}

public struct UpdateRecoveryPointLifecycleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecoveryPointLifecycleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateRecoveryPointLifecycleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let backupVaultName = input.backupVaultName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("backupVaultName is nil and needs a value for the path of this operation"))))
        }
        guard let recoveryPointArn = input.recoveryPointArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("recoveryPointArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/backup-vaults/\(backupVaultName.urlPercentEncoding())/recovery-points/\(recoveryPointArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRecoveryPointLifecycleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecoveryPointLifecycleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecoveryPointLifecycleOutputError>
}

public struct UpdateRecoveryPointLifecycleInput: Swift.Equatable {
    /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
    /// This member is required.
    public var backupVaultName: Swift.String?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    /// This member is required.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultName: Swift.String? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultName = backupVaultName
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

struct UpdateRecoveryPointLifecycleInputBody: Swift.Equatable {
    public let lifecycle: BackupClientTypes.Lifecycle?
}

extension UpdateRecoveryPointLifecycleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension UpdateRecoveryPointLifecycleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecoveryPointLifecycleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRecoveryPointLifecycleOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecoveryPointLifecycleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRecoveryPointLifecycleOutputResponse(backupVaultArn: \(Swift.String(describing: backupVaultArn)), calculatedLifecycle: \(Swift.String(describing: calculatedLifecycle)), lifecycle: \(Swift.String(describing: lifecycle)), recoveryPointArn: \(Swift.String(describing: recoveryPointArn)))"}
}

extension UpdateRecoveryPointLifecycleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRecoveryPointLifecycleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupVaultArn = output.backupVaultArn
            self.calculatedLifecycle = output.calculatedLifecycle
            self.lifecycle = output.lifecycle
            self.recoveryPointArn = output.recoveryPointArn
        } else {
            self.backupVaultArn = nil
            self.calculatedLifecycle = nil
            self.lifecycle = nil
            self.recoveryPointArn = nil
        }
    }
}

public struct UpdateRecoveryPointLifecycleOutputResponse: Swift.Equatable {
    /// An ARN that uniquely identifies a backup vault; for example, arn:aws:backup:us-east-1:123456789012:vault:aBackupVault.
    public var backupVaultArn: Swift.String?
    /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
    public var calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
    /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days. Therefore, the “expire after days” setting must be 90 days greater than the “transition to cold after days” setting. The “transition to cold after days” setting cannot be changed after a backup has been transitioned to cold. Only Amazon EFS file system backups can be transitioned to cold storage.
    public var lifecycle: BackupClientTypes.Lifecycle?
    /// An Amazon Resource Name (ARN) that uniquely identifies a recovery point; for example, arn:aws:backup:us-east-1:123456789012:recovery-point:1EB3B5E7-9EB0-435A-A80B-108B488B0D45.
    public var recoveryPointArn: Swift.String?

    public init (
        backupVaultArn: Swift.String? = nil,
        calculatedLifecycle: BackupClientTypes.CalculatedLifecycle? = nil,
        lifecycle: BackupClientTypes.Lifecycle? = nil,
        recoveryPointArn: Swift.String? = nil
    )
    {
        self.backupVaultArn = backupVaultArn
        self.calculatedLifecycle = calculatedLifecycle
        self.lifecycle = lifecycle
        self.recoveryPointArn = recoveryPointArn
    }
}

struct UpdateRecoveryPointLifecycleOutputResponseBody: Swift.Equatable {
    public let backupVaultArn: Swift.String?
    public let recoveryPointArn: Swift.String?
    public let lifecycle: BackupClientTypes.Lifecycle?
    public let calculatedLifecycle: BackupClientTypes.CalculatedLifecycle?
}

extension UpdateRecoveryPointLifecycleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultArn = "BackupVaultArn"
        case calculatedLifecycle = "CalculatedLifecycle"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.Lifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(BackupClientTypes.CalculatedLifecycle.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
    }
}

public struct UpdateRegionSettingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRegionSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRegionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRegionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRegionSettingsOutputError>
}

extension UpdateRegionSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRegionSettingsInput(resourceTypeManagementPreference: \(Swift.String(describing: resourceTypeManagementPreference)), resourceTypeOptInPreference: \(Swift.String(describing: resourceTypeOptInPreference)))"}
}

extension UpdateRegionSettingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceTypeManagementPreference = resourceTypeManagementPreference {
            var resourceTypeManagementPreferenceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTypeManagementPreference)
            for (dictKey0, resourcetypemanagementpreference0) in resourceTypeManagementPreference {
                try resourceTypeManagementPreferenceContainer.encode(resourcetypemanagementpreference0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceTypeOptInPreference = resourceTypeOptInPreference {
            var resourceTypeOptInPreferenceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTypeOptInPreference)
            for (dictKey0, resourcetypeoptinpreference0) in resourceTypeOptInPreference {
                try resourceTypeOptInPreferenceContainer.encode(resourcetypeoptinpreference0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateRegionSettingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRegionSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRegionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRegionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRegionSettingsOutputError>
}

public struct UpdateRegionSettingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRegionSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRegionSettingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRegionSettingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRegionSettingsOutputError>
}

public struct UpdateRegionSettingsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRegionSettingsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateRegionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRegionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRegionSettingsOutputError>
}

public struct UpdateRegionSettingsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRegionSettingsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateRegionSettingsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/account-settings"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRegionSettingsInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRegionSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRegionSettingsOutputError>
}

public struct UpdateRegionSettingsInput: Swift.Equatable {
    /// Enables or disables [ Backup's advanced DynamoDB backup features](https://docs.aws.amazon.com/aws-backup/latest/devguide/advanced-ddb-backup.html) for the Region.
    public var resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
    /// Updates the list of services along with the opt-in preferences for the Region.
    public var resourceTypeOptInPreference: [Swift.String:Swift.Bool]?

    public init (
        resourceTypeManagementPreference: [Swift.String:Swift.Bool]? = nil,
        resourceTypeOptInPreference: [Swift.String:Swift.Bool]? = nil
    )
    {
        self.resourceTypeManagementPreference = resourceTypeManagementPreference
        self.resourceTypeOptInPreference = resourceTypeOptInPreference
    }
}

struct UpdateRegionSettingsInputBody: Swift.Equatable {
    public let resourceTypeOptInPreference: [Swift.String:Swift.Bool]?
    public let resourceTypeManagementPreference: [Swift.String:Swift.Bool]?
}

extension UpdateRegionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTypeManagementPreference = "ResourceTypeManagementPreference"
        case resourceTypeOptInPreference = "ResourceTypeOptInPreference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeOptInPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeOptInPreference)
        var resourceTypeOptInPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeOptInPreferenceContainer = resourceTypeOptInPreferenceContainer {
            resourceTypeOptInPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeOptInPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeOptInPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeOptInPreference = resourceTypeOptInPreferenceDecoded0
        let resourceTypeManagementPreferenceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .resourceTypeManagementPreference)
        var resourceTypeManagementPreferenceDecoded0: [Swift.String:Swift.Bool]? = nil
        if let resourceTypeManagementPreferenceContainer = resourceTypeManagementPreferenceContainer {
            resourceTypeManagementPreferenceDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, isenabled0) in resourceTypeManagementPreferenceContainer {
                if let isenabled0 = isenabled0 {
                    resourceTypeManagementPreferenceDecoded0?[key0] = isenabled0
                }
            }
        }
        resourceTypeManagementPreference = resourceTypeManagementPreferenceDecoded0
    }
}

extension UpdateRegionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRegionSettingsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegionSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRegionSettingsOutputResponse()"}
}

extension UpdateRegionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRegionSettingsOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateRegionSettingsOutputResponseBody: Swift.Equatable {
}

extension UpdateRegionSettingsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateReportPlanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReportPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReportPlanOutputError>
}

extension UpdateReportPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReportPlanInput(idempotencyToken: \(Swift.String(describing: idempotencyToken)), reportDeliveryChannel: \(Swift.String(describing: reportDeliveryChannel)), reportPlanDescription: \(Swift.String(describing: reportPlanDescription)), reportPlanName: \(Swift.String(describing: reportPlanName)), reportSetting: \(Swift.String(describing: reportSetting)))"}
}

extension UpdateReportPlanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportSetting = "ReportSetting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let reportDeliveryChannel = reportDeliveryChannel {
            try encodeContainer.encode(reportDeliveryChannel, forKey: .reportDeliveryChannel)
        }
        if let reportPlanDescription = reportPlanDescription {
            try encodeContainer.encode(reportPlanDescription, forKey: .reportPlanDescription)
        }
        if let reportSetting = reportSetting {
            try encodeContainer.encode(reportSetting, forKey: .reportSetting)
        }
    }
}

public struct UpdateReportPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReportPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReportPlanOutputError>
}

public struct UpdateReportPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReportPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateReportPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateReportPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReportPlanOutputError>
}

public struct UpdateReportPlanInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReportPlanInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateReportPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateReportPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReportPlanOutputError>
}

public struct UpdateReportPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReportPlanInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateReportPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let reportPlanName = input.reportPlanName else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("reportPlanName is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/audit/report-plans/\(reportPlanName.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateReportPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReportPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReportPlanOutputError>
}

public struct UpdateReportPlanInput: Swift.Equatable {
    /// A customer-chosen string that you can use to distinguish between otherwise identical calls to UpdateReportPlanInput. Retrying a successful request with the same idempotency token results in a success message with no action taken.
    public var idempotencyToken: Swift.String?
    /// A structure that contains information about where to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
    public var reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    /// An optional description of the report plan with a maximum 1,024 characters.
    public var reportPlanDescription: Swift.String?
    /// The unique name of the report plan. This name is between 1 and 256 characters, starting with a letter, and consisting of letters (a-z, A-Z), numbers (0-9), and underscores (_).
    /// This member is required.
    public var reportPlanName: Swift.String?
    /// Identifies the report template for the report. Reports are built using a report template. The report templates are: RESOURCE_COMPLIANCE_REPORT | CONTROL_COMPLIANCE_REPORT | BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT If the report template is RESOURCE_COMPLIANCE_REPORT or CONTROL_COMPLIANCE_REPORT, this API resource also describes the report coverage by Amazon Web Services Regions and frameworks.
    public var reportSetting: BackupClientTypes.ReportSetting?

    public init (
        idempotencyToken: Swift.String? = nil,
        reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel? = nil,
        reportPlanDescription: Swift.String? = nil,
        reportPlanName: Swift.String? = nil,
        reportSetting: BackupClientTypes.ReportSetting? = nil
    )
    {
        self.idempotencyToken = idempotencyToken
        self.reportDeliveryChannel = reportDeliveryChannel
        self.reportPlanDescription = reportPlanDescription
        self.reportPlanName = reportPlanName
        self.reportSetting = reportSetting
    }
}

struct UpdateReportPlanInputBody: Swift.Equatable {
    public let reportPlanDescription: Swift.String?
    public let reportDeliveryChannel: BackupClientTypes.ReportDeliveryChannel?
    public let reportSetting: BackupClientTypes.ReportSetting?
    public let idempotencyToken: Swift.String?
}

extension UpdateReportPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idempotencyToken = "IdempotencyToken"
        case reportDeliveryChannel = "ReportDeliveryChannel"
        case reportPlanDescription = "ReportPlanDescription"
        case reportSetting = "ReportSetting"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanDescription)
        reportPlanDescription = reportPlanDescriptionDecoded
        let reportDeliveryChannelDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportDeliveryChannel.self, forKey: .reportDeliveryChannel)
        reportDeliveryChannel = reportDeliveryChannelDecoded
        let reportSettingDecoded = try containerValues.decodeIfPresent(BackupClientTypes.ReportSetting.self, forKey: .reportSetting)
        reportSetting = reportSettingDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension UpdateReportPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReportPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReportPlanOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReportPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReportPlanOutputResponse(creationTime: \(Swift.String(describing: creationTime)), reportPlanArn: \(Swift.String(describing: reportPlanArn)), reportPlanName: \(Swift.String(describing: reportPlanName)))"}
}

extension UpdateReportPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateReportPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.reportPlanArn = output.reportPlanArn
            self.reportPlanName = output.reportPlanName
        } else {
            self.creationTime = nil
            self.reportPlanArn = nil
            self.reportPlanName = nil
        }
    }
}

public struct UpdateReportPlanOutputResponse: Swift.Equatable {
    /// The date and time that a report plan is created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
    public var creationTime: ClientRuntime.Date?
    /// An Amazon Resource Name (ARN) that uniquely identifies a resource. The format of the ARN depends on the resource type.
    public var reportPlanArn: Swift.String?
    /// The unique name of the report plan.
    public var reportPlanName: Swift.String?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        reportPlanArn: Swift.String? = nil,
        reportPlanName: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.reportPlanArn = reportPlanArn
        self.reportPlanName = reportPlanName
    }
}

struct UpdateReportPlanOutputResponseBody: Swift.Equatable {
    public let reportPlanName: Swift.String?
    public let reportPlanArn: Swift.String?
    public let creationTime: ClientRuntime.Date?
}

extension UpdateReportPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case reportPlanArn = "ReportPlanArn"
        case reportPlanName = "ReportPlanName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanName)
        reportPlanName = reportPlanNameDecoded
        let reportPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportPlanArn)
        reportPlanArn = reportPlanArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}
