// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct SendAutomationSignalInput: Equatable {
    /// <p>The unique identifier for an existing Automation execution that you want to send the signal
    ///    to.</p>
    public let automationExecutionId: String?
    /// <p>The data sent with the signal. The data schema depends on the type of signal used in the
    ///    request.</p>
    ///          <p>For <code>Approve</code> and <code>Reject</code> signal types, the payload is an optional
    ///    comment that you can send with the signal type. For example:</p>
    ///          <p>
    ///             <code>Comment="Looks good"</code>
    ///          </p>
    ///          <p>For <code>StartStep</code> and <code>Resume</code> signal types, you must send the name of
    ///    the Automation step to start or resume as the payload. For example:</p>
    ///          <p>
    ///             <code>StepName="step1"</code>
    ///          </p>
    ///          <p>For the <code>StopStep</code> signal type, you must send the step execution ID as the
    ///    payload. For example:</p>
    ///          <p>
    ///             <code>StepExecutionId="97fff367-fc5a-4299-aed8-0123456789ab"</code>
    ///          </p>
    public let payload: [String:[String]]?
    /// <p>The type of signal to send to an Automation execution. </p>
    public let signalType: SignalType?

    public init (
        automationExecutionId: String? = nil,
        payload: [String:[String]]? = nil,
        signalType: SignalType? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
        self.payload = payload
        self.signalType = signalType
    }
}

extension SendAutomationSignalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendAutomationSignalInput(automationExecutionId: \(String(describing: automationExecutionId)), payload: \(String(describing: payload)), signalType: \(String(describing: signalType)))"}
}
