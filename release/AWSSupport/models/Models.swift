// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddAttachmentsToSetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttachmentsToSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttachmentsToSetOutputError>
}

extension AddAttachmentsToSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddAttachmentsToSetInput(attachmentSetId: \(Swift.String(describing: attachmentSetId)), attachments: \(Swift.String(describing: attachments)))"}
}

extension AddAttachmentsToSetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case attachments
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSetId = attachmentSetId {
            try encodeContainer.encode(attachmentSetId, forKey: .attachmentSetId)
        }
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachments0 in attachments {
                try attachmentsContainer.encode(attachments0)
            }
        }
    }
}

public struct AddAttachmentsToSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttachmentsToSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttachmentsToSetOutputError>
}

public struct AddAttachmentsToSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttachmentsToSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddAttachmentsToSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttachmentsToSetOutputError>
}

public struct AddAttachmentsToSetInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttachmentsToSetInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AddAttachmentsToSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddAttachmentsToSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttachmentsToSetOutputError>
}

public struct AddAttachmentsToSetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddAttachmentsToSetInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AddAttachmentsToSetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddAttachmentsToSetInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddAttachmentsToSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddAttachmentsToSetOutputError>
}

public struct AddAttachmentsToSetInput: Swift.Equatable {
    /// The ID of the attachment set. If an attachmentSetId is not specified, a new attachment set is created, and the ID of the set is returned in the response. If an attachmentSetId is specified, the attachments are added to the specified set, if it exists.
    public var attachmentSetId: Swift.String?
    /// One or more attachments to add to the set. You can add up to three attachments per set. The size limit is 5 MB per attachment. In the Attachment object, use the data parameter to specify the contents of the attachment file. In the previous request syntax, the value for data appear as blob, which is represented as a base64-encoded string. The value for fileName is the name of the attachment, such as troubleshoot-screenshot.png.
    /// This member is required.
    public var attachments: [SupportClientTypes.Attachment]?

    public init (
        attachmentSetId: Swift.String? = nil,
        attachments: [SupportClientTypes.Attachment]? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.attachments = attachments
    }
}

struct AddAttachmentsToSetInputBody: Swift.Equatable {
    public let attachmentSetId: Swift.String?
    public let attachments: [SupportClientTypes.Attachment]?
}

extension AddAttachmentsToSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case attachments
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([SupportClientTypes.Attachment?].self, forKey: .attachments)
        var attachmentsDecoded0:[SupportClientTypes.Attachment]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [SupportClientTypes.Attachment]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
    }
}

extension AddAttachmentsToSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddAttachmentsToSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AttachmentLimitExceeded" : self = .attachmentLimitExceeded(try AttachmentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetExpired" : self = .attachmentSetExpired(try AttachmentSetExpired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetIdNotFound" : self = .attachmentSetIdNotFound(try AttachmentSetIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetSizeLimitExceeded" : self = .attachmentSetSizeLimitExceeded(try AttachmentSetSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddAttachmentsToSetOutputError: Swift.Error, Swift.Equatable {
    case attachmentLimitExceeded(AttachmentLimitExceeded)
    case attachmentSetExpired(AttachmentSetExpired)
    case attachmentSetIdNotFound(AttachmentSetIdNotFound)
    case attachmentSetSizeLimitExceeded(AttachmentSetSizeLimitExceeded)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddAttachmentsToSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddAttachmentsToSetOutputResponse(attachmentSetId: \(Swift.String(describing: attachmentSetId)), expiryTime: \(Swift.String(describing: expiryTime)))"}
}

extension AddAttachmentsToSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddAttachmentsToSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachmentSetId = output.attachmentSetId
            self.expiryTime = output.expiryTime
        } else {
            self.attachmentSetId = nil
            self.expiryTime = nil
        }
    }
}

/// The ID and expiry time of the attachment set returned by the [AddAttachmentsToSet] operation.
public struct AddAttachmentsToSetOutputResponse: Swift.Equatable {
    /// The ID of the attachment set. If an attachmentSetId was not specified, a new attachment set is created, and the ID of the set is returned in the response. If an attachmentSetId was specified, the attachments are added to the specified set, if it exists.
    public var attachmentSetId: Swift.String?
    /// The time and date when the attachment set expires.
    public var expiryTime: Swift.String?

    public init (
        attachmentSetId: Swift.String? = nil,
        expiryTime: Swift.String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.expiryTime = expiryTime
    }
}

struct AddAttachmentsToSetOutputResponseBody: Swift.Equatable {
    public let attachmentSetId: Swift.String?
    public let expiryTime: Swift.String?
}

extension AddAttachmentsToSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case expiryTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
        let expiryTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
    }
}

public struct AddCommunicationToCaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCommunicationToCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCommunicationToCaseOutputError>
}

extension AddCommunicationToCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddCommunicationToCaseInput(attachmentSetId: \(Swift.String(describing: attachmentSetId)), caseId: \(Swift.String(describing: caseId)), ccEmailAddresses: \(Swift.String(describing: ccEmailAddresses)), communicationBody: \(Swift.String(describing: communicationBody)))"}
}

extension AddCommunicationToCaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case caseId
        case ccEmailAddresses
        case communicationBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSetId = attachmentSetId {
            try encodeContainer.encode(attachmentSetId, forKey: .attachmentSetId)
        }
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let ccEmailAddresses = ccEmailAddresses {
            var ccEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccEmailAddresses)
            for ccemailaddresslist0 in ccEmailAddresses {
                try ccEmailAddressesContainer.encode(ccemailaddresslist0)
            }
        }
        if let communicationBody = communicationBody {
            try encodeContainer.encode(communicationBody, forKey: .communicationBody)
        }
    }
}

public struct AddCommunicationToCaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCommunicationToCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCommunicationToCaseOutputError>
}

public struct AddCommunicationToCaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCommunicationToCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddCommunicationToCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCommunicationToCaseOutputError>
}

public struct AddCommunicationToCaseInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCommunicationToCaseInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AddCommunicationToCaseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddCommunicationToCaseInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCommunicationToCaseOutputError>
}

public struct AddCommunicationToCaseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddCommunicationToCaseInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AddCommunicationToCaseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AddCommunicationToCaseInput
    public typealias MOutput = ClientRuntime.OperationOutput<AddCommunicationToCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddCommunicationToCaseOutputError>
}

public struct AddCommunicationToCaseInput: Swift.Equatable {
    /// The ID of a set of one or more attachments for the communication to add to the case. Create the set by calling [AddAttachmentsToSet]
    public var attachmentSetId: Swift.String?
    /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
    public var caseId: Swift.String?
    /// The email addresses in the CC line of an email to be added to the support case.
    public var ccEmailAddresses: [Swift.String]?
    /// The body of an email communication to add to the support case.
    /// This member is required.
    public var communicationBody: Swift.String?

    public init (
        attachmentSetId: Swift.String? = nil,
        caseId: Swift.String? = nil,
        ccEmailAddresses: [Swift.String]? = nil,
        communicationBody: Swift.String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.caseId = caseId
        self.ccEmailAddresses = ccEmailAddresses
        self.communicationBody = communicationBody
    }
}

struct AddCommunicationToCaseInputBody: Swift.Equatable {
    public let caseId: Swift.String?
    public let communicationBody: Swift.String?
    public let ccEmailAddresses: [Swift.String]?
    public let attachmentSetId: Swift.String?
}

extension AddCommunicationToCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case caseId
        case ccEmailAddresses
        case communicationBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let communicationBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .communicationBody)
        communicationBody = communicationBodyDecoded
        let ccEmailAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ccEmailAddresses)
        var ccEmailAddressesDecoded0:[Swift.String]? = nil
        if let ccEmailAddressesContainer = ccEmailAddressesContainer {
            ccEmailAddressesDecoded0 = [Swift.String]()
            for string0 in ccEmailAddressesContainer {
                if let string0 = string0 {
                    ccEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        ccEmailAddresses = ccEmailAddressesDecoded0
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
    }
}

extension AddCommunicationToCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddCommunicationToCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AttachmentSetExpired" : self = .attachmentSetExpired(try AttachmentSetExpired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetIdNotFound" : self = .attachmentSetIdNotFound(try AttachmentSetIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddCommunicationToCaseOutputError: Swift.Error, Swift.Equatable {
    case attachmentSetExpired(AttachmentSetExpired)
    case attachmentSetIdNotFound(AttachmentSetIdNotFound)
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddCommunicationToCaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddCommunicationToCaseOutputResponse(result: \(Swift.String(describing: result)))"}
}

extension AddCommunicationToCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddCommunicationToCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = false
        }
    }
}

/// The result of the [AddCommunicationToCase] operation.
public struct AddCommunicationToCaseOutputResponse: Swift.Equatable {
    /// True if [AddCommunicationToCase] succeeds. Otherwise, returns an error.
    public var result: Swift.Bool

    public init (
        result: Swift.Bool = false
    )
    {
        self.result = result
    }
}

struct AddCommunicationToCaseOutputResponseBody: Swift.Equatable {
    public let result: Swift.Bool
}

extension AddCommunicationToCaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decode(Swift.Bool.self, forKey: .result)
        result = resultDecoded
    }
}

extension SupportClientTypes.Attachment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case fileName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let fileName = fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
    }
}

extension SupportClientTypes.Attachment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attachment(data: \(Swift.String(describing: data)), fileName: \(Swift.String(describing: fileName)))"}
}

extension SupportClientTypes {
    /// An attachment to a case communication. The attachment consists of the file name and the content of the file.
    public struct Attachment: Swift.Equatable {
        /// The content of the attachment file.
        public var data: ClientRuntime.Data?
        /// The name of the attachment file.
        public var fileName: Swift.String?

        public init (
            data: ClientRuntime.Data? = nil,
            fileName: Swift.String? = nil
        )
        {
            self.data = data
            self.fileName = fileName
        }
    }

}

extension SupportClientTypes.AttachmentDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId
        case fileName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let fileName = fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
    }
}

extension SupportClientTypes.AttachmentDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentDetails(attachmentId: \(Swift.String(describing: attachmentId)), fileName: \(Swift.String(describing: fileName)))"}
}

extension SupportClientTypes {
    /// The file name and ID of an attachment to a case communication. You can use the ID to retrieve the attachment with the [DescribeAttachment] operation.
    public struct AttachmentDetails: Swift.Equatable {
        /// The ID of the attachment.
        public var attachmentId: Swift.String?
        /// The file name of the attachment.
        public var fileName: Swift.String?

        public init (
            attachmentId: Swift.String? = nil,
            fileName: Swift.String? = nil
        )
        {
            self.attachmentId = attachmentId
            self.fileName = fileName
        }
    }

}

extension AttachmentIdNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentIdNotFound(message: \(Swift.String(describing: message)))"}
}

extension AttachmentIdNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentIdNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An attachment with the specified ID could not be found.
public struct AttachmentIdNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// An attachment with the specified ID could not be found.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentIdNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentIdNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension AttachmentLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit for the number of attachment sets created in a short period of time has been exceeded.
public struct AttachmentLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The limit for the number of attachment sets created in a short period of time has been exceeded.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentSetExpired: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentSetExpired(message: \(Swift.String(describing: message)))"}
}

extension AttachmentSetExpired {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentSetExpiredBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The expiration time of the attachment set has passed. The set expires 1 hour after it is created.
public struct AttachmentSetExpired: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The expiration time of the attachment set has passed. The set expires one hour after it is created.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentSetExpiredBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentSetExpiredBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentSetIdNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentSetIdNotFound(message: \(Swift.String(describing: message)))"}
}

extension AttachmentSetIdNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentSetIdNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An attachment set with the specified ID could not be found.
public struct AttachmentSetIdNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// An attachment set with the specified ID could not be found.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentSetIdNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentSetIdNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AttachmentSetSizeLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentSetSizeLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension AttachmentSetSizeLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AttachmentSetSizeLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit for the size of an attachment set has been exceeded. The limits are three attachments and 5 MB per attachment.
public struct AttachmentSetSizeLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A limit for the size of an attachment set has been exceeded. The limits are three attachments and 5 MB per attachment.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AttachmentSetSizeLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AttachmentSetSizeLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CaseCreationLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaseCreationLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension CaseCreationLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CaseCreationLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The case creation limit for the account has been exceeded.
public struct CaseCreationLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// An error message that indicates that you have exceeded the number of cases you can have open.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CaseCreationLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CaseCreationLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportClientTypes.CaseDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
        case categoryCode
        case ccEmailAddresses
        case displayId
        case language
        case recentCommunications
        case serviceCode
        case severityCode
        case status
        case subject
        case submittedBy
        case timeCreated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let categoryCode = categoryCode {
            try encodeContainer.encode(categoryCode, forKey: .categoryCode)
        }
        if let ccEmailAddresses = ccEmailAddresses {
            var ccEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccEmailAddresses)
            for ccemailaddresslist0 in ccEmailAddresses {
                try ccEmailAddressesContainer.encode(ccemailaddresslist0)
            }
        }
        if let displayId = displayId {
            try encodeContainer.encode(displayId, forKey: .displayId)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let recentCommunications = recentCommunications {
            try encodeContainer.encode(recentCommunications, forKey: .recentCommunications)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let severityCode = severityCode {
            try encodeContainer.encode(severityCode, forKey: .severityCode)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let submittedBy = submittedBy {
            try encodeContainer.encode(submittedBy, forKey: .submittedBy)
        }
        if let timeCreated = timeCreated {
            try encodeContainer.encode(timeCreated, forKey: .timeCreated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let displayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayId)
        displayId = displayIdDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let categoryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .categoryCode)
        categoryCode = categoryCodeDecoded
        let severityCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severityCode)
        severityCode = severityCodeDecoded
        let submittedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .submittedBy)
        submittedBy = submittedByDecoded
        let timeCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeCreated)
        timeCreated = timeCreatedDecoded
        let recentCommunicationsDecoded = try containerValues.decodeIfPresent(SupportClientTypes.RecentCaseCommunications.self, forKey: .recentCommunications)
        recentCommunications = recentCommunicationsDecoded
        let ccEmailAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ccEmailAddresses)
        var ccEmailAddressesDecoded0:[Swift.String]? = nil
        if let ccEmailAddressesContainer = ccEmailAddressesContainer {
            ccEmailAddressesDecoded0 = [Swift.String]()
            for string0 in ccEmailAddressesContainer {
                if let string0 = string0 {
                    ccEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        ccEmailAddresses = ccEmailAddressesDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension SupportClientTypes.CaseDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaseDetails(caseId: \(Swift.String(describing: caseId)), categoryCode: \(Swift.String(describing: categoryCode)), ccEmailAddresses: \(Swift.String(describing: ccEmailAddresses)), displayId: \(Swift.String(describing: displayId)), language: \(Swift.String(describing: language)), recentCommunications: \(Swift.String(describing: recentCommunications)), serviceCode: \(Swift.String(describing: serviceCode)), severityCode: \(Swift.String(describing: severityCode)), status: \(Swift.String(describing: status)), subject: \(Swift.String(describing: subject)), submittedBy: \(Swift.String(describing: submittedBy)), timeCreated: \(Swift.String(describing: timeCreated)))"}
}

extension SupportClientTypes {
    /// A JSON-formatted object that contains the metadata for a support case. It is contained in the response from a [DescribeCases] request. CaseDetails contains the following fields:
    ///
    /// * caseId - The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47.
    ///
    /// * categoryCode - The category of problem for the support case. Corresponds to the CategoryCode values returned by a call to [DescribeServices].
    ///
    /// * displayId - The identifier for the case on pages in the AWS Support Center.
    ///
    /// * language - The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English ("en") and Japanese ("ja"). Language parameters must be passed explicitly for operations that take them.
    ///
    /// * nextToken - A resumption point for pagination.
    ///
    /// * recentCommunications - One or more [Communication] objects. Fields of these objects are attachments, body, caseId, submittedBy, and timeCreated.
    ///
    /// * serviceCode - The identifier for the AWS service that corresponds to the service code defined in the call to [DescribeServices].
    ///
    /// * severityCode - The severity code assigned to the case. Contains one of the values returned by the call to [DescribeSeverityLevels]. The possible values are: low, normal, high, urgent, and critical.
    ///
    /// * status - The status of the case in the AWS Support Center. Valid values:
    ///
    /// * opened
    ///
    /// * pending-customer-action
    ///
    /// * reopened
    ///
    /// * resolved
    ///
    /// * unassigned
    ///
    /// * work-in-progress
    ///
    ///
    ///
    ///
    /// * subject - The subject line of the case.
    ///
    /// * submittedBy - The email address of the account that submitted the case.
    ///
    /// * timeCreated - The time the case was created, in ISO-8601 format.
    public struct CaseDetails: Swift.Equatable {
        /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
        public var caseId: Swift.String?
        /// The category of problem for the support case.
        public var categoryCode: Swift.String?
        /// The email addresses that receive copies of communication about the case.
        public var ccEmailAddresses: [Swift.String]?
        /// The ID displayed for the case in the AWS Support Center. This is a numeric string.
        public var displayId: Swift.String?
        /// The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English ("en") and Japanese ("ja"). Language parameters must be passed explicitly for operations that take them.
        public var language: Swift.String?
        /// The five most recent communications between you and AWS Support Center, including the IDs of any attachments to the communications. Also includes a nextToken that you can use to retrieve earlier communications.
        public var recentCommunications: SupportClientTypes.RecentCaseCommunications?
        /// The code for the AWS service. You can get a list of codes and the corresponding service names by calling [DescribeServices].
        public var serviceCode: Swift.String?
        /// The code for the severity level returned by the call to [DescribeSeverityLevels].
        public var severityCode: Swift.String?
        /// The status of the case. Valid values:
        ///
        /// * opened
        ///
        /// * pending-customer-action
        ///
        /// * reopened
        ///
        /// * resolved
        ///
        /// * unassigned
        ///
        /// * work-in-progress
        public var status: Swift.String?
        /// The subject line for the case in the AWS Support Center.
        public var subject: Swift.String?
        /// The email address of the account that submitted the case.
        public var submittedBy: Swift.String?
        /// The time that the case was created in the AWS Support Center.
        public var timeCreated: Swift.String?

        public init (
            caseId: Swift.String? = nil,
            categoryCode: Swift.String? = nil,
            ccEmailAddresses: [Swift.String]? = nil,
            displayId: Swift.String? = nil,
            language: Swift.String? = nil,
            recentCommunications: SupportClientTypes.RecentCaseCommunications? = nil,
            serviceCode: Swift.String? = nil,
            severityCode: Swift.String? = nil,
            status: Swift.String? = nil,
            subject: Swift.String? = nil,
            submittedBy: Swift.String? = nil,
            timeCreated: Swift.String? = nil
        )
        {
            self.caseId = caseId
            self.categoryCode = categoryCode
            self.ccEmailAddresses = ccEmailAddresses
            self.displayId = displayId
            self.language = language
            self.recentCommunications = recentCommunications
            self.serviceCode = serviceCode
            self.severityCode = severityCode
            self.status = status
            self.subject = subject
            self.submittedBy = submittedBy
            self.timeCreated = timeCreated
        }
    }

}

extension CaseIdNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaseIdNotFound(message: \(Swift.String(describing: message)))"}
}

extension CaseIdNotFound {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CaseIdNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested caseId couldn't be located.
public struct CaseIdNotFound: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The requested CaseId could not be located.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CaseIdNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CaseIdNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportClientTypes.Category: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SupportClientTypes.Category: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Category(code: \(Swift.String(describing: code)), name: \(Swift.String(describing: name)))"}
}

extension SupportClientTypes {
    /// A JSON-formatted name/value pair that represents the category name and category code of the problem, selected from the [DescribeServices] response for each AWS service.
    public struct Category: Swift.Equatable {
        /// The category code for the support case.
        public var code: Swift.String?
        /// The category name for the support case.
        public var name: Swift.String?

        public init (
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }

}

extension SupportClientTypes.Communication: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSet
        case body
        case caseId
        case submittedBy
        case timeCreated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSet = attachmentSet {
            var attachmentSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentSet)
            for attachmentset0 in attachmentSet {
                try attachmentSetContainer.encode(attachmentset0)
            }
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let submittedBy = submittedBy {
            try encodeContainer.encode(submittedBy, forKey: .submittedBy)
        }
        if let timeCreated = timeCreated {
            try encodeContainer.encode(timeCreated, forKey: .timeCreated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let submittedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .submittedBy)
        submittedBy = submittedByDecoded
        let timeCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeCreated)
        timeCreated = timeCreatedDecoded
        let attachmentSetContainer = try containerValues.decodeIfPresent([SupportClientTypes.AttachmentDetails?].self, forKey: .attachmentSet)
        var attachmentSetDecoded0:[SupportClientTypes.AttachmentDetails]? = nil
        if let attachmentSetContainer = attachmentSetContainer {
            attachmentSetDecoded0 = [SupportClientTypes.AttachmentDetails]()
            for structure0 in attachmentSetContainer {
                if let structure0 = structure0 {
                    attachmentSetDecoded0?.append(structure0)
                }
            }
        }
        attachmentSet = attachmentSetDecoded0
    }
}

extension SupportClientTypes.Communication: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Communication(attachmentSet: \(Swift.String(describing: attachmentSet)), body: \(Swift.String(describing: body)), caseId: \(Swift.String(describing: caseId)), submittedBy: \(Swift.String(describing: submittedBy)), timeCreated: \(Swift.String(describing: timeCreated)))"}
}

extension SupportClientTypes {
    /// A communication associated with a support case. The communication consists of the case ID, the message body, attachment information, the submitter of the communication, and the date and time of the communication.
    public struct Communication: Swift.Equatable {
        /// Information about the attachments to the case communication.
        public var attachmentSet: [SupportClientTypes.AttachmentDetails]?
        /// The text of the communication between the customer and AWS Support.
        public var body: Swift.String?
        /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
        public var caseId: Swift.String?
        /// The identity of the account that submitted, or responded to, the support case. Customer entries include the role or IAM user as well as the email address. For example, "AdminRole (Role) . Entries from the AWS Support team display "Amazon Web Services," and don't show an email address.
        public var submittedBy: Swift.String?
        /// The time the communication was created.
        public var timeCreated: Swift.String?

        public init (
            attachmentSet: [SupportClientTypes.AttachmentDetails]? = nil,
            body: Swift.String? = nil,
            caseId: Swift.String? = nil,
            submittedBy: Swift.String? = nil,
            timeCreated: Swift.String? = nil
        )
        {
            self.attachmentSet = attachmentSet
            self.body = body
            self.caseId = caseId
            self.submittedBy = submittedBy
            self.timeCreated = timeCreated
        }
    }

}

public struct CreateCaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCaseOutputError>
}

extension CreateCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCaseInput(attachmentSetId: \(Swift.String(describing: attachmentSetId)), categoryCode: \(Swift.String(describing: categoryCode)), ccEmailAddresses: \(Swift.String(describing: ccEmailAddresses)), communicationBody: \(Swift.String(describing: communicationBody)), issueType: \(Swift.String(describing: issueType)), language: \(Swift.String(describing: language)), serviceCode: \(Swift.String(describing: serviceCode)), severityCode: \(Swift.String(describing: severityCode)), subject: \(Swift.String(describing: subject)))"}
}

extension CreateCaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case categoryCode
        case ccEmailAddresses
        case communicationBody
        case issueType
        case language
        case serviceCode
        case severityCode
        case subject
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentSetId = attachmentSetId {
            try encodeContainer.encode(attachmentSetId, forKey: .attachmentSetId)
        }
        if let categoryCode = categoryCode {
            try encodeContainer.encode(categoryCode, forKey: .categoryCode)
        }
        if let ccEmailAddresses = ccEmailAddresses {
            var ccEmailAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ccEmailAddresses)
            for ccemailaddresslist0 in ccEmailAddresses {
                try ccEmailAddressesContainer.encode(ccemailaddresslist0)
            }
        }
        if let communicationBody = communicationBody {
            try encodeContainer.encode(communicationBody, forKey: .communicationBody)
        }
        if let issueType = issueType {
            try encodeContainer.encode(issueType, forKey: .issueType)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let serviceCode = serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let severityCode = severityCode {
            try encodeContainer.encode(severityCode, forKey: .severityCode)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }
}

public struct CreateCaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCaseOutputError>
}

public struct CreateCaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCaseOutputError>
}

public struct CreateCaseInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCaseInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateCaseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCaseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCaseOutputError>
}

public struct CreateCaseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCaseInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateCaseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCaseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCaseOutputError>
}

public struct CreateCaseInput: Swift.Equatable {
    /// The ID of a set of one or more attachments for the case. Create the set by using the [AddAttachmentsToSet] operation.
    public var attachmentSetId: Swift.String?
    /// The category of problem for the support case. You also use the [DescribeServices] operation to get the category code for a service. Each AWS service defines its own set of category codes.
    public var categoryCode: Swift.String?
    /// A list of email addresses that AWS Support copies on case correspondence. AWS Support identifies the account that creates the case when you specify your AWS credentials in an HTTP POST method or use the [AWS SDKs](http://aws.amazon.com/tools/).
    public var ccEmailAddresses: [Swift.String]?
    /// The communication body text that describes the issue. This text appears in the Description field on the AWS Support Center [Create Case](https://console.aws.amazon.com/support/home#/case/create) page.
    /// This member is required.
    public var communicationBody: Swift.String?
    /// The type of issue for the case. You can specify customer-service or technical. If you don't specify a value, the default is technical.
    public var issueType: Swift.String?
    /// The language in which AWS Support handles the case. You must specify the ISO 639-1 code for the language parameter if you want support in that language. Currently, English ("en") and Japanese ("ja") are supported.
    public var language: Swift.String?
    /// The code for the AWS service. You can use the [DescribeServices] operation to get the possible serviceCode values.
    public var serviceCode: Swift.String?
    /// A value that indicates the urgency of the case. This value determines the response time according to your service level agreement with AWS Support. You can use the [DescribeSeverityLevels] operation to get the possible values for severityCode. For more information, see [SeverityLevel] and [Choosing a Severity](https://docs.aws.amazon.com/awssupport/latest/user/getting-started.html#choosing-severity) in the AWS Support User Guide. The availability of severity levels depends on the support plan for the AWS account.
    public var severityCode: Swift.String?
    /// The title of the support case. The title appears in the Subject field on the AWS Support Center [Create Case](https://console.aws.amazon.com/support/home#/case/create) page.
    /// This member is required.
    public var subject: Swift.String?

    public init (
        attachmentSetId: Swift.String? = nil,
        categoryCode: Swift.String? = nil,
        ccEmailAddresses: [Swift.String]? = nil,
        communicationBody: Swift.String? = nil,
        issueType: Swift.String? = nil,
        language: Swift.String? = nil,
        serviceCode: Swift.String? = nil,
        severityCode: Swift.String? = nil,
        subject: Swift.String? = nil
    )
    {
        self.attachmentSetId = attachmentSetId
        self.categoryCode = categoryCode
        self.ccEmailAddresses = ccEmailAddresses
        self.communicationBody = communicationBody
        self.issueType = issueType
        self.language = language
        self.serviceCode = serviceCode
        self.severityCode = severityCode
        self.subject = subject
    }
}

struct CreateCaseInputBody: Swift.Equatable {
    public let subject: Swift.String?
    public let serviceCode: Swift.String?
    public let severityCode: Swift.String?
    public let categoryCode: Swift.String?
    public let communicationBody: Swift.String?
    public let ccEmailAddresses: [Swift.String]?
    public let language: Swift.String?
    public let issueType: Swift.String?
    public let attachmentSetId: Swift.String?
}

extension CreateCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentSetId
        case categoryCode
        case ccEmailAddresses
        case communicationBody
        case issueType
        case language
        case serviceCode
        case severityCode
        case subject
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let severityCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severityCode)
        severityCode = severityCodeDecoded
        let categoryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .categoryCode)
        categoryCode = categoryCodeDecoded
        let communicationBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .communicationBody)
        communicationBody = communicationBodyDecoded
        let ccEmailAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ccEmailAddresses)
        var ccEmailAddressesDecoded0:[Swift.String]? = nil
        if let ccEmailAddressesContainer = ccEmailAddressesContainer {
            ccEmailAddressesDecoded0 = [Swift.String]()
            for string0 in ccEmailAddressesContainer {
                if let string0 = string0 {
                    ccEmailAddressesDecoded0?.append(string0)
                }
            }
        }
        ccEmailAddresses = ccEmailAddressesDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let issueTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issueType)
        issueType = issueTypeDecoded
        let attachmentSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentSetId)
        attachmentSetId = attachmentSetIdDecoded
    }
}

extension CreateCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AttachmentSetExpired" : self = .attachmentSetExpired(try AttachmentSetExpired(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AttachmentSetIdNotFound" : self = .attachmentSetIdNotFound(try AttachmentSetIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CaseCreationLimitExceeded" : self = .caseCreationLimitExceeded(try CaseCreationLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCaseOutputError: Swift.Error, Swift.Equatable {
    case attachmentSetExpired(AttachmentSetExpired)
    case attachmentSetIdNotFound(AttachmentSetIdNotFound)
    case caseCreationLimitExceeded(CaseCreationLimitExceeded)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCaseOutputResponse(caseId: \(Swift.String(describing: caseId)))"}
}

extension CreateCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.caseId = output.caseId
        } else {
            self.caseId = nil
        }
    }
}

/// The support case ID returned by a successful completion of the [CreateCase] operation.
public struct CreateCaseOutputResponse: Swift.Equatable {
    /// The support case ID requested or returned in the call. The case ID is an alphanumeric string in the following format: case-12345678910-2013-c4c1d2bf33c5cf47
    public var caseId: Swift.String?

    public init (
        caseId: Swift.String? = nil
    )
    {
        self.caseId = caseId
    }
}

struct CreateCaseOutputResponseBody: Swift.Equatable {
    public let caseId: Swift.String?
}

extension CreateCaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
    }
}

public struct DescribeAttachmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAttachmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAttachmentOutputError>
}

extension DescribeAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAttachmentInput(attachmentId: \(Swift.String(describing: attachmentId)))"}
}

extension DescribeAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
    }
}

public struct DescribeAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAttachmentOutputError>
}

public struct DescribeAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAttachmentOutputError>
}

public struct DescribeAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAttachmentOutputError>
}

public struct DescribeAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAttachmentOutputError>
}

public struct DescribeAttachmentInput: Swift.Equatable {
    /// The ID of the attachment to return. Attachment IDs are returned by the [DescribeCommunications] operation.
    /// This member is required.
    public var attachmentId: Swift.String?

    public init (
        attachmentId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
    }
}

struct DescribeAttachmentInputBody: Swift.Equatable {
    public let attachmentId: Swift.String?
}

extension DescribeAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
    }
}

extension DescribeAttachmentLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAttachmentLimitExceeded(message: \(Swift.String(describing: message)))"}
}

extension DescribeAttachmentLimitExceeded {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAttachmentLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit for the number of [DescribeAttachment] requests in a short period of time has been exceeded.
public struct DescribeAttachmentLimitExceeded: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The limit for the number of [DescribeAttachment] requests in a short period of time has been exceeded.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DescribeAttachmentLimitExceededBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DescribeAttachmentLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AttachmentIdNotFound" : self = .attachmentIdNotFound(try AttachmentIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DescribeAttachmentLimitExceeded" : self = .describeAttachmentLimitExceeded(try DescribeAttachmentLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAttachmentOutputError: Swift.Error, Swift.Equatable {
    case attachmentIdNotFound(AttachmentIdNotFound)
    case describeAttachmentLimitExceeded(DescribeAttachmentLimitExceeded)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAttachmentOutputResponse(attachment: \(Swift.String(describing: attachment)))"}
}

extension DescribeAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachment = output.attachment
        } else {
            self.attachment = nil
        }
    }
}

/// The content and file name of the attachment returned by the [DescribeAttachment] operation.
public struct DescribeAttachmentOutputResponse: Swift.Equatable {
    /// This object includes the attachment content and file name. In the previous response syntax, the value for the data parameter appears as blob, which is represented as a base64-encoded string. The value for fileName is the name of the attachment, such as troubleshoot-screenshot.png.
    public var attachment: SupportClientTypes.Attachment?

    public init (
        attachment: SupportClientTypes.Attachment? = nil
    )
    {
        self.attachment = attachment
    }
}

struct DescribeAttachmentOutputResponseBody: Swift.Equatable {
    public let attachment: SupportClientTypes.Attachment?
}

extension DescribeAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(SupportClientTypes.Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
    }
}

public struct DescribeCasesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCasesOutputError>
}

extension DescribeCasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCasesInput(afterTime: \(Swift.String(describing: afterTime)), beforeTime: \(Swift.String(describing: beforeTime)), caseIdList: \(Swift.String(describing: caseIdList)), displayId: \(Swift.String(describing: displayId)), includeCommunications: \(Swift.String(describing: includeCommunications)), includeResolvedCases: \(Swift.String(describing: includeResolvedCases)), language: \(Swift.String(describing: language)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCasesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterTime
        case beforeTime
        case caseIdList
        case displayId
        case includeCommunications
        case includeResolvedCases
        case language
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterTime = afterTime {
            try encodeContainer.encode(afterTime, forKey: .afterTime)
        }
        if let beforeTime = beforeTime {
            try encodeContainer.encode(beforeTime, forKey: .beforeTime)
        }
        if let caseIdList = caseIdList {
            var caseIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .caseIdList)
            for caseidlist0 in caseIdList {
                try caseIdListContainer.encode(caseidlist0)
            }
        }
        if let displayId = displayId {
            try encodeContainer.encode(displayId, forKey: .displayId)
        }
        if let includeCommunications = includeCommunications {
            try encodeContainer.encode(includeCommunications, forKey: .includeCommunications)
        }
        if includeResolvedCases != false {
            try encodeContainer.encode(includeResolvedCases, forKey: .includeResolvedCases)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCasesOutputError>
}

public struct DescribeCasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCasesOutputError>
}

public struct DescribeCasesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCasesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeCasesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCasesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCasesOutputError>
}

public struct DescribeCasesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCasesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeCasesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCasesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCasesOutputError>
}

public struct DescribeCasesInput: Swift.Equatable {
    /// The start date for a filtered date search on support case communications. Case communications are available for 12 months after creation.
    public var afterTime: Swift.String?
    /// The end date for a filtered date search on support case communications. Case communications are available for 12 months after creation.
    public var beforeTime: Swift.String?
    /// A list of ID numbers of the support cases you want returned. The maximum number of cases is 100.
    public var caseIdList: [Swift.String]?
    /// The ID displayed for a case in the AWS Support Center user interface.
    public var displayId: Swift.String?
    /// Specifies whether to include communications in the DescribeCases response. By default, communications are included.
    public var includeCommunications: Swift.Bool?
    /// Specifies whether to include resolved support cases in the DescribeCases response. By default, resolved cases aren't included.
    public var includeResolvedCases: Swift.Bool
    /// The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English ("en") and Japanese ("ja"). Language parameters must be passed explicitly for operations that take them.
    public var language: Swift.String?
    /// The maximum number of results to return before paginating.
    public var maxResults: Swift.Int?
    /// A resumption point for pagination.
    public var nextToken: Swift.String?

    public init (
        afterTime: Swift.String? = nil,
        beforeTime: Swift.String? = nil,
        caseIdList: [Swift.String]? = nil,
        displayId: Swift.String? = nil,
        includeCommunications: Swift.Bool? = nil,
        includeResolvedCases: Swift.Bool = false,
        language: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.afterTime = afterTime
        self.beforeTime = beforeTime
        self.caseIdList = caseIdList
        self.displayId = displayId
        self.includeCommunications = includeCommunications
        self.includeResolvedCases = includeResolvedCases
        self.language = language
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCasesInputBody: Swift.Equatable {
    public let caseIdList: [Swift.String]?
    public let displayId: Swift.String?
    public let afterTime: Swift.String?
    public let beforeTime: Swift.String?
    public let includeResolvedCases: Swift.Bool
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let language: Swift.String?
    public let includeCommunications: Swift.Bool?
}

extension DescribeCasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterTime
        case beforeTime
        case caseIdList
        case displayId
        case includeCommunications
        case includeResolvedCases
        case language
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .caseIdList)
        var caseIdListDecoded0:[Swift.String]? = nil
        if let caseIdListContainer = caseIdListContainer {
            caseIdListDecoded0 = [Swift.String]()
            for string0 in caseIdListContainer {
                if let string0 = string0 {
                    caseIdListDecoded0?.append(string0)
                }
            }
        }
        caseIdList = caseIdListDecoded0
        let displayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayId)
        displayId = displayIdDecoded
        let afterTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterTime)
        afterTime = afterTimeDecoded
        let beforeTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeTime)
        beforeTime = beforeTimeDecoded
        let includeResolvedCasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeResolvedCases)
        includeResolvedCases = includeResolvedCasesDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let includeCommunicationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCommunications)
        includeCommunications = includeCommunicationsDecoded
    }
}

extension DescribeCasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCasesOutputError: Swift.Error, Swift.Equatable {
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCasesOutputResponse(cases: \(Swift.String(describing: cases)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cases = output.cases
            self.nextToken = output.nextToken
        } else {
            self.cases = nil
            self.nextToken = nil
        }
    }
}

/// Returns an array of [CaseDetails](https://docs.aws.amazon.com/awssupport/latest/APIReference/API_CaseDetails.html) objects and a nextToken that defines a point for pagination in the result set.
public struct DescribeCasesOutputResponse: Swift.Equatable {
    /// The details for the cases that match the request.
    public var cases: [SupportClientTypes.CaseDetails]?
    /// A resumption point for pagination.
    public var nextToken: Swift.String?

    public init (
        cases: [SupportClientTypes.CaseDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cases = cases
        self.nextToken = nextToken
    }
}

struct DescribeCasesOutputResponseBody: Swift.Equatable {
    public let cases: [SupportClientTypes.CaseDetails]?
    public let nextToken: Swift.String?
}

extension DescribeCasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cases
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let casesContainer = try containerValues.decodeIfPresent([SupportClientTypes.CaseDetails?].self, forKey: .cases)
        var casesDecoded0:[SupportClientTypes.CaseDetails]? = nil
        if let casesContainer = casesContainer {
            casesDecoded0 = [SupportClientTypes.CaseDetails]()
            for structure0 in casesContainer {
                if let structure0 = structure0 {
                    casesDecoded0?.append(structure0)
                }
            }
        }
        cases = casesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeCommunicationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommunicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommunicationsOutputError>
}

extension DescribeCommunicationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCommunicationsInput(afterTime: \(Swift.String(describing: afterTime)), beforeTime: \(Swift.String(describing: beforeTime)), caseId: \(Swift.String(describing: caseId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCommunicationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterTime
        case beforeTime
        case caseId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterTime = afterTime {
            try encodeContainer.encode(afterTime, forKey: .afterTime)
        }
        if let beforeTime = beforeTime {
            try encodeContainer.encode(beforeTime, forKey: .beforeTime)
        }
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCommunicationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommunicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommunicationsOutputError>
}

public struct DescribeCommunicationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommunicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCommunicationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommunicationsOutputError>
}

public struct DescribeCommunicationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommunicationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeCommunicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCommunicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommunicationsOutputError>
}

public struct DescribeCommunicationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCommunicationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeCommunicationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCommunicationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCommunicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCommunicationsOutputError>
}

public struct DescribeCommunicationsInput: Swift.Equatable {
    /// The start date for a filtered date search on support case communications. Case communications are available for 12 months after creation.
    public var afterTime: Swift.String?
    /// The end date for a filtered date search on support case communications. Case communications are available for 12 months after creation.
    public var beforeTime: Swift.String?
    /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
    /// This member is required.
    public var caseId: Swift.String?
    /// The maximum number of results to return before paginating.
    public var maxResults: Swift.Int?
    /// A resumption point for pagination.
    public var nextToken: Swift.String?

    public init (
        afterTime: Swift.String? = nil,
        beforeTime: Swift.String? = nil,
        caseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.afterTime = afterTime
        self.beforeTime = beforeTime
        self.caseId = caseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCommunicationsInputBody: Swift.Equatable {
    public let caseId: Swift.String?
    public let beforeTime: Swift.String?
    public let afterTime: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeCommunicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterTime
        case beforeTime
        case caseId
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
        let beforeTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeTime)
        beforeTime = beforeTimeDecoded
        let afterTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterTime)
        afterTime = afterTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeCommunicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCommunicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCommunicationsOutputError: Swift.Error, Swift.Equatable {
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCommunicationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCommunicationsOutputResponse(communications: \(Swift.String(describing: communications)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeCommunicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCommunicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.communications = output.communications
            self.nextToken = output.nextToken
        } else {
            self.communications = nil
            self.nextToken = nil
        }
    }
}

/// The communications returned by the [DescribeCommunications] operation.
public struct DescribeCommunicationsOutputResponse: Swift.Equatable {
    /// The communications for the case.
    public var communications: [SupportClientTypes.Communication]?
    /// A resumption point for pagination.
    public var nextToken: Swift.String?

    public init (
        communications: [SupportClientTypes.Communication]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.communications = communications
        self.nextToken = nextToken
    }
}

struct DescribeCommunicationsOutputResponseBody: Swift.Equatable {
    public let communications: [SupportClientTypes.Communication]?
    public let nextToken: Swift.String?
}

extension DescribeCommunicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case communications
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let communicationsContainer = try containerValues.decodeIfPresent([SupportClientTypes.Communication?].self, forKey: .communications)
        var communicationsDecoded0:[SupportClientTypes.Communication]? = nil
        if let communicationsContainer = communicationsContainer {
            communicationsDecoded0 = [SupportClientTypes.Communication]()
            for structure0 in communicationsContainer {
                if let structure0 = structure0 {
                    communicationsDecoded0?.append(structure0)
                }
            }
        }
        communications = communicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeServicesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

extension DescribeServicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServicesInput(language: \(Swift.String(describing: language)), serviceCodeList: \(Swift.String(describing: serviceCodeList)))"}
}

extension DescribeServicesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
        case serviceCodeList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let serviceCodeList = serviceCodeList {
            var serviceCodeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceCodeList)
            for servicecodelist0 in serviceCodeList {
                try serviceCodeListContainer.encode(servicecodelist0)
            }
        }
    }
}

public struct DescribeServicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeServicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServicesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeServicesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServicesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServicesOutputError>
}

public struct DescribeServicesInput: Swift.Equatable {
    /// The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English ("en") and Japanese ("ja"). Language parameters must be passed explicitly for operations that take them.
    public var language: Swift.String?
    /// A JSON-formatted list of service codes available for AWS services.
    public var serviceCodeList: [Swift.String]?

    public init (
        language: Swift.String? = nil,
        serviceCodeList: [Swift.String]? = nil
    )
    {
        self.language = language
        self.serviceCodeList = serviceCodeList
    }
}

struct DescribeServicesInputBody: Swift.Equatable {
    public let serviceCodeList: [Swift.String]?
    public let language: Swift.String?
}

extension DescribeServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
        case serviceCodeList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceCodeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceCodeList)
        var serviceCodeListDecoded0:[Swift.String]? = nil
        if let serviceCodeListContainer = serviceCodeListContainer {
            serviceCodeListDecoded0 = [Swift.String]()
            for string0 in serviceCodeListContainer {
                if let string0 = string0 {
                    serviceCodeListDecoded0?.append(string0)
                }
            }
        }
        serviceCodeList = serviceCodeListDecoded0
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServicesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServicesOutputResponse(services: \(Swift.String(describing: services)))"}
}

extension DescribeServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.services = output.services
        } else {
            self.services = nil
        }
    }
}

/// The list of AWS services returned by the [DescribeServices] operation.
public struct DescribeServicesOutputResponse: Swift.Equatable {
    /// A JSON-formatted list of AWS services.
    public var services: [SupportClientTypes.Service]?

    public init (
        services: [SupportClientTypes.Service]? = nil
    )
    {
        self.services = services
    }
}

struct DescribeServicesOutputResponseBody: Swift.Equatable {
    public let services: [SupportClientTypes.Service]?
}

extension DescribeServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case services
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([SupportClientTypes.Service?].self, forKey: .services)
        var servicesDecoded0:[SupportClientTypes.Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [SupportClientTypes.Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
    }
}

public struct DescribeSeverityLevelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSeverityLevelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSeverityLevelsOutputError>
}

extension DescribeSeverityLevelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSeverityLevelsInput(language: \(Swift.String(describing: language)))"}
}

extension DescribeSeverityLevelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
    }
}

public struct DescribeSeverityLevelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSeverityLevelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSeverityLevelsOutputError>
}

public struct DescribeSeverityLevelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSeverityLevelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSeverityLevelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSeverityLevelsOutputError>
}

public struct DescribeSeverityLevelsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSeverityLevelsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeSeverityLevelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSeverityLevelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSeverityLevelsOutputError>
}

public struct DescribeSeverityLevelsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSeverityLevelsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeSeverityLevelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSeverityLevelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSeverityLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSeverityLevelsOutputError>
}

public struct DescribeSeverityLevelsInput: Swift.Equatable {
    /// The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English ("en") and Japanese ("ja"). Language parameters must be passed explicitly for operations that take them.
    public var language: Swift.String?

    public init (
        language: Swift.String? = nil
    )
    {
        self.language = language
    }
}

struct DescribeSeverityLevelsInputBody: Swift.Equatable {
    public let language: Swift.String?
}

extension DescribeSeverityLevelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeSeverityLevelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSeverityLevelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSeverityLevelsOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSeverityLevelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSeverityLevelsOutputResponse(severityLevels: \(Swift.String(describing: severityLevels)))"}
}

extension DescribeSeverityLevelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSeverityLevelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.severityLevels = output.severityLevels
        } else {
            self.severityLevels = nil
        }
    }
}

/// The list of severity levels returned by the [DescribeSeverityLevels] operation.
public struct DescribeSeverityLevelsOutputResponse: Swift.Equatable {
    /// The available severity levels for the support case. Available severity levels are defined by your service level agreement with AWS.
    public var severityLevels: [SupportClientTypes.SeverityLevel]?

    public init (
        severityLevels: [SupportClientTypes.SeverityLevel]? = nil
    )
    {
        self.severityLevels = severityLevels
    }
}

struct DescribeSeverityLevelsOutputResponseBody: Swift.Equatable {
    public let severityLevels: [SupportClientTypes.SeverityLevel]?
}

extension DescribeSeverityLevelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case severityLevels
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severityLevelsContainer = try containerValues.decodeIfPresent([SupportClientTypes.SeverityLevel?].self, forKey: .severityLevels)
        var severityLevelsDecoded0:[SupportClientTypes.SeverityLevel]? = nil
        if let severityLevelsContainer = severityLevelsContainer {
            severityLevelsDecoded0 = [SupportClientTypes.SeverityLevel]()
            for structure0 in severityLevelsContainer {
                if let structure0 = structure0 {
                    severityLevelsDecoded0?.append(structure0)
                }
            }
        }
        severityLevels = severityLevelsDecoded0
    }
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckRefreshStatusesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckRefreshStatusesInput(checkIds: \(Swift.String(describing: checkIds)))"}
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkIds = checkIds {
            var checkIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .checkIds)
            for stringlist0 in checkIds {
                try checkIdsContainer.encode(stringlist0)
            }
        }
    }
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckRefreshStatusesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckRefreshStatusesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckRefreshStatusesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckRefreshStatusesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeTrustedAdvisorCheckRefreshStatusesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrustedAdvisorCheckRefreshStatusesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckRefreshStatusesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeTrustedAdvisorCheckRefreshStatusesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrustedAdvisorCheckRefreshStatusesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckRefreshStatusesOutputError>
}

public struct DescribeTrustedAdvisorCheckRefreshStatusesInput: Swift.Equatable {
    /// The IDs of the Trusted Advisor checks to get the status. If you specify the check ID of a check that is automatically refreshed, you might see an InvalidParameterValue error.
    /// This member is required.
    public var checkIds: [Swift.String]?

    public init (
        checkIds: [Swift.String]? = nil
    )
    {
        self.checkIds = checkIds
    }
}

struct DescribeTrustedAdvisorCheckRefreshStatusesInputBody: Swift.Equatable {
    public let checkIds: [Swift.String]?
}

extension DescribeTrustedAdvisorCheckRefreshStatusesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .checkIds)
        var checkIdsDecoded0:[Swift.String]? = nil
        if let checkIdsContainer = checkIdsContainer {
            checkIdsDecoded0 = [Swift.String]()
            for string0 in checkIdsContainer {
                if let string0 = string0 {
                    checkIdsDecoded0?.append(string0)
                }
            }
        }
        checkIds = checkIdsDecoded0
    }
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorCheckRefreshStatusesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse(statuses: \(Swift.String(describing: statuses)))"}
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorCheckRefreshStatusesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.statuses = output.statuses
        } else {
            self.statuses = nil
        }
    }
}

/// The statuses of the Trusted Advisor checks returned by the [DescribeTrustedAdvisorCheckRefreshStatuses] operation.
public struct DescribeTrustedAdvisorCheckRefreshStatusesOutputResponse: Swift.Equatable {
    /// The refresh status of the specified Trusted Advisor checks.
    /// This member is required.
    public var statuses: [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]?

    public init (
        statuses: [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]? = nil
    )
    {
        self.statuses = statuses
    }
}

struct DescribeTrustedAdvisorCheckRefreshStatusesOutputResponseBody: Swift.Equatable {
    public let statuses: [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]?
}

extension DescribeTrustedAdvisorCheckRefreshStatusesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statuses
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusesContainer = try containerValues.decodeIfPresent([SupportClientTypes.TrustedAdvisorCheckRefreshStatus?].self, forKey: .statuses)
        var statusesDecoded0:[SupportClientTypes.TrustedAdvisorCheckRefreshStatus]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [SupportClientTypes.TrustedAdvisorCheckRefreshStatus]()
            for structure0 in statusesContainer {
                if let structure0 = structure0 {
                    statusesDecoded0?.append(structure0)
                }
            }
        }
        statuses = statusesDecoded0
    }
}

public struct DescribeTrustedAdvisorCheckResultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

extension DescribeTrustedAdvisorCheckResultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckResultInput(checkId: \(Swift.String(describing: checkId)), language: \(Swift.String(describing: language)))"}
}

extension DescribeTrustedAdvisorCheckResultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
        case language
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
    }
}

public struct DescribeTrustedAdvisorCheckResultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

public struct DescribeTrustedAdvisorCheckResultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

public struct DescribeTrustedAdvisorCheckResultInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckResultInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeTrustedAdvisorCheckResultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrustedAdvisorCheckResultInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

public struct DescribeTrustedAdvisorCheckResultInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckResultInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeTrustedAdvisorCheckResultInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrustedAdvisorCheckResultInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckResultOutputError>
}

///
public struct DescribeTrustedAdvisorCheckResultInput: Swift.Equatable {
    /// The unique identifier for the Trusted Advisor check.
    /// This member is required.
    public var checkId: Swift.String?
    /// The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English ("en") and Japanese ("ja"). Language parameters must be passed explicitly for operations that take them.
    public var language: Swift.String?

    public init (
        checkId: Swift.String? = nil,
        language: Swift.String? = nil
    )
    {
        self.checkId = checkId
        self.language = language
    }
}

struct DescribeTrustedAdvisorCheckResultInputBody: Swift.Equatable {
    public let checkId: Swift.String?
    public let language: Swift.String?
}

extension DescribeTrustedAdvisorCheckResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
        case language
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeTrustedAdvisorCheckResultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorCheckResultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorCheckResultOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorCheckResultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckResultOutputResponse(result: \(Swift.String(describing: result)))"}
}

extension DescribeTrustedAdvisorCheckResultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorCheckResultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

/// The result of the Trusted Advisor check returned by the [DescribeTrustedAdvisorCheckResult] operation.
public struct DescribeTrustedAdvisorCheckResultOutputResponse: Swift.Equatable {
    /// The detailed results of the Trusted Advisor check.
    public var result: SupportClientTypes.TrustedAdvisorCheckResult?

    public init (
        result: SupportClientTypes.TrustedAdvisorCheckResult? = nil
    )
    {
        self.result = result
    }
}

struct DescribeTrustedAdvisorCheckResultOutputResponseBody: Swift.Equatable {
    public let result: SupportClientTypes.TrustedAdvisorCheckResult?
}

extension DescribeTrustedAdvisorCheckResultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case result
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCheckResult.self, forKey: .result)
        result = resultDecoded
    }
}

public struct DescribeTrustedAdvisorCheckSummariesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

extension DescribeTrustedAdvisorCheckSummariesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckSummariesInput(checkIds: \(Swift.String(describing: checkIds)))"}
}

extension DescribeTrustedAdvisorCheckSummariesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkIds = checkIds {
            var checkIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .checkIds)
            for stringlist0 in checkIds {
                try checkIdsContainer.encode(stringlist0)
            }
        }
    }
}

public struct DescribeTrustedAdvisorCheckSummariesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

public struct DescribeTrustedAdvisorCheckSummariesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorCheckSummariesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

public struct DescribeTrustedAdvisorCheckSummariesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckSummariesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeTrustedAdvisorCheckSummariesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrustedAdvisorCheckSummariesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

public struct DescribeTrustedAdvisorCheckSummariesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorCheckSummariesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeTrustedAdvisorCheckSummariesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrustedAdvisorCheckSummariesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorCheckSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorCheckSummariesOutputError>
}

public struct DescribeTrustedAdvisorCheckSummariesInput: Swift.Equatable {
    /// The IDs of the Trusted Advisor checks.
    /// This member is required.
    public var checkIds: [Swift.String]?

    public init (
        checkIds: [Swift.String]? = nil
    )
    {
        self.checkIds = checkIds
    }
}

struct DescribeTrustedAdvisorCheckSummariesInputBody: Swift.Equatable {
    public let checkIds: [Swift.String]?
}

extension DescribeTrustedAdvisorCheckSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .checkIds)
        var checkIdsDecoded0:[Swift.String]? = nil
        if let checkIdsContainer = checkIdsContainer {
            checkIdsDecoded0 = [Swift.String]()
            for string0 in checkIdsContainer {
                if let string0 = string0 {
                    checkIdsDecoded0?.append(string0)
                }
            }
        }
        checkIds = checkIdsDecoded0
    }
}

extension DescribeTrustedAdvisorCheckSummariesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorCheckSummariesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorCheckSummariesOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorCheckSummariesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorCheckSummariesOutputResponse(summaries: \(Swift.String(describing: summaries)))"}
}

extension DescribeTrustedAdvisorCheckSummariesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorCheckSummariesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.summaries = output.summaries
        } else {
            self.summaries = nil
        }
    }
}

/// The summaries of the Trusted Advisor checks returned by the [DescribeTrustedAdvisorCheckSummaries] operation.
public struct DescribeTrustedAdvisorCheckSummariesOutputResponse: Swift.Equatable {
    /// The summary information for the requested Trusted Advisor checks.
    /// This member is required.
    public var summaries: [SupportClientTypes.TrustedAdvisorCheckSummary]?

    public init (
        summaries: [SupportClientTypes.TrustedAdvisorCheckSummary]? = nil
    )
    {
        self.summaries = summaries
    }
}

struct DescribeTrustedAdvisorCheckSummariesOutputResponseBody: Swift.Equatable {
    public let summaries: [SupportClientTypes.TrustedAdvisorCheckSummary]?
}

extension DescribeTrustedAdvisorCheckSummariesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([SupportClientTypes.TrustedAdvisorCheckSummary?].self, forKey: .summaries)
        var summariesDecoded0:[SupportClientTypes.TrustedAdvisorCheckSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [SupportClientTypes.TrustedAdvisorCheckSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
    }
}

public struct DescribeTrustedAdvisorChecksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorChecksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorChecksOutputError>
}

extension DescribeTrustedAdvisorChecksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorChecksInput(language: \(Swift.String(describing: language)))"}
}

extension DescribeTrustedAdvisorChecksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
    }
}

public struct DescribeTrustedAdvisorChecksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorChecksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorChecksOutputError>
}

public struct DescribeTrustedAdvisorChecksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorChecksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTrustedAdvisorChecksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorChecksOutputError>
}

public struct DescribeTrustedAdvisorChecksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorChecksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeTrustedAdvisorChecksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrustedAdvisorChecksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorChecksOutputError>
}

public struct DescribeTrustedAdvisorChecksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTrustedAdvisorChecksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeTrustedAdvisorChecksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTrustedAdvisorChecksInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTrustedAdvisorChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTrustedAdvisorChecksOutputError>
}

public struct DescribeTrustedAdvisorChecksInput: Swift.Equatable {
    /// The ISO 639-1 code for the language in which AWS provides support. AWS Support currently supports English ("en") and Japanese ("ja"). Language parameters must be passed explicitly for operations that take them.
    /// This member is required.
    public var language: Swift.String?

    public init (
        language: Swift.String? = nil
    )
    {
        self.language = language
    }
}

struct DescribeTrustedAdvisorChecksInputBody: Swift.Equatable {
    public let language: Swift.String?
}

extension DescribeTrustedAdvisorChecksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case language
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
    }
}

extension DescribeTrustedAdvisorChecksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrustedAdvisorChecksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrustedAdvisorChecksOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrustedAdvisorChecksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTrustedAdvisorChecksOutputResponse(checks: \(Swift.String(describing: checks)))"}
}

extension DescribeTrustedAdvisorChecksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTrustedAdvisorChecksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.checks = output.checks
        } else {
            self.checks = nil
        }
    }
}

/// Information about the Trusted Advisor checks returned by the [DescribeTrustedAdvisorChecks] operation.
public struct DescribeTrustedAdvisorChecksOutputResponse: Swift.Equatable {
    /// Information about all available Trusted Advisor checks.
    /// This member is required.
    public var checks: [SupportClientTypes.TrustedAdvisorCheckDescription]?

    public init (
        checks: [SupportClientTypes.TrustedAdvisorCheckDescription]? = nil
    )
    {
        self.checks = checks
    }
}

struct DescribeTrustedAdvisorChecksOutputResponseBody: Swift.Equatable {
    public let checks: [SupportClientTypes.TrustedAdvisorCheckDescription]?
}

extension DescribeTrustedAdvisorChecksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checks
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checksContainer = try containerValues.decodeIfPresent([SupportClientTypes.TrustedAdvisorCheckDescription?].self, forKey: .checks)
        var checksDecoded0:[SupportClientTypes.TrustedAdvisorCheckDescription]? = nil
        if let checksContainer = checksContainer {
            checksDecoded0 = [SupportClientTypes.TrustedAdvisorCheckDescription]()
            for structure0 in checksContainer {
                if let structure0 = structure0 {
                    checksDecoded0?.append(structure0)
                }
            }
        }
        checks = checksDecoded0
    }
}

extension InternalServerError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerError(message: \(Swift.String(describing: message)))"}
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error occurred.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// An internal server error occurred.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportClientTypes.RecentCaseCommunications: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case communications
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let communications = communications {
            var communicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .communications)
            for communicationlist0 in communications {
                try communicationsContainer.encode(communicationlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let communicationsContainer = try containerValues.decodeIfPresent([SupportClientTypes.Communication?].self, forKey: .communications)
        var communicationsDecoded0:[SupportClientTypes.Communication]? = nil
        if let communicationsContainer = communicationsContainer {
            communicationsDecoded0 = [SupportClientTypes.Communication]()
            for structure0 in communicationsContainer {
                if let structure0 = structure0 {
                    communicationsDecoded0?.append(structure0)
                }
            }
        }
        communications = communicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SupportClientTypes.RecentCaseCommunications: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecentCaseCommunications(communications: \(Swift.String(describing: communications)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension SupportClientTypes {
    /// The five most recent communications associated with the case.
    public struct RecentCaseCommunications: Swift.Equatable {
        /// The five most recent communications associated with the case.
        public var communications: [SupportClientTypes.Communication]?
        /// A resumption point for pagination.
        public var nextToken: Swift.String?

        public init (
            communications: [SupportClientTypes.Communication]? = nil,
            nextToken: Swift.String? = nil
        )
        {
            self.communications = communications
            self.nextToken = nextToken
        }
    }

}

public struct RefreshTrustedAdvisorCheckInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTrustedAdvisorCheckInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshTrustedAdvisorCheckOutputError>
}

extension RefreshTrustedAdvisorCheckInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTrustedAdvisorCheckInput(checkId: \(Swift.String(describing: checkId)))"}
}

extension RefreshTrustedAdvisorCheckInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
    }
}

public struct RefreshTrustedAdvisorCheckInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTrustedAdvisorCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshTrustedAdvisorCheckOutputError>
}

public struct RefreshTrustedAdvisorCheckInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTrustedAdvisorCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshTrustedAdvisorCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshTrustedAdvisorCheckOutputError>
}

public struct RefreshTrustedAdvisorCheckInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTrustedAdvisorCheckInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RefreshTrustedAdvisorCheckInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RefreshTrustedAdvisorCheckInput
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshTrustedAdvisorCheckOutputError>
}

public struct RefreshTrustedAdvisorCheckInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTrustedAdvisorCheckInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RefreshTrustedAdvisorCheckInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RefreshTrustedAdvisorCheckInput
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTrustedAdvisorCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RefreshTrustedAdvisorCheckOutputError>
}

///
public struct RefreshTrustedAdvisorCheckInput: Swift.Equatable {
    /// The unique identifier for the Trusted Advisor check to refresh. Specifying the check ID of a check that is automatically refreshed causes an InvalidParameterValue error.
    /// This member is required.
    public var checkId: Swift.String?

    public init (
        checkId: Swift.String? = nil
    )
    {
        self.checkId = checkId
    }
}

struct RefreshTrustedAdvisorCheckInputBody: Swift.Equatable {
    public let checkId: Swift.String?
}

extension RefreshTrustedAdvisorCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
    }
}

extension RefreshTrustedAdvisorCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshTrustedAdvisorCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RefreshTrustedAdvisorCheckOutputError: Swift.Error, Swift.Equatable {
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshTrustedAdvisorCheckOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTrustedAdvisorCheckOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension RefreshTrustedAdvisorCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RefreshTrustedAdvisorCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// The current refresh status of a Trusted Advisor check.
public struct RefreshTrustedAdvisorCheckOutputResponse: Swift.Equatable {
    /// The current refresh status for a check, including the amount of time until the check is eligible for refresh.
    /// This member is required.
    public var status: SupportClientTypes.TrustedAdvisorCheckRefreshStatus?

    public init (
        status: SupportClientTypes.TrustedAdvisorCheckRefreshStatus? = nil
    )
    {
        self.status = status
    }
}

struct RefreshTrustedAdvisorCheckOutputResponseBody: Swift.Equatable {
    public let status: SupportClientTypes.TrustedAdvisorCheckRefreshStatus?
}

extension RefreshTrustedAdvisorCheckOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCheckRefreshStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct ResolveCaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveCaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveCaseOutputError>
}

extension ResolveCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolveCaseInput(caseId: \(Swift.String(describing: caseId)))"}
}

extension ResolveCaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseId = caseId {
            try encodeContainer.encode(caseId, forKey: .caseId)
        }
    }
}

public struct ResolveCaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveCaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveCaseOutputError>
}

public struct ResolveCaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveCaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResolveCaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResolveCaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveCaseOutputError>
}

public struct ResolveCaseInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveCaseInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ResolveCaseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResolveCaseInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveCaseOutputError>
}

public struct ResolveCaseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResolveCaseInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ResolveCaseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResolveCaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResolveCaseInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResolveCaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResolveCaseOutputError>
}

public struct ResolveCaseInput: Swift.Equatable {
    /// The support case ID requested or returned in the call. The case ID is an alphanumeric string formatted as shown in this example: case-12345678910-2013-c4c1d2bf33c5cf47
    public var caseId: Swift.String?

    public init (
        caseId: Swift.String? = nil
    )
    {
        self.caseId = caseId
    }
}

struct ResolveCaseInputBody: Swift.Equatable {
    public let caseId: Swift.String?
}

extension ResolveCaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let caseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caseId)
        caseId = caseIdDecoded
    }
}

extension ResolveCaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveCaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CaseIdNotFound" : self = .caseIdNotFound(try CaseIdNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveCaseOutputError: Swift.Error, Swift.Equatable {
    case caseIdNotFound(CaseIdNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveCaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResolveCaseOutputResponse(finalCaseStatus: \(Swift.String(describing: finalCaseStatus)), initialCaseStatus: \(Swift.String(describing: initialCaseStatus)))"}
}

extension ResolveCaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResolveCaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.finalCaseStatus = output.finalCaseStatus
            self.initialCaseStatus = output.initialCaseStatus
        } else {
            self.finalCaseStatus = nil
            self.initialCaseStatus = nil
        }
    }
}

/// The status of the case returned by the [ResolveCase] operation.
public struct ResolveCaseOutputResponse: Swift.Equatable {
    /// The status of the case after the [ResolveCase] request was processed.
    public var finalCaseStatus: Swift.String?
    /// The status of the case when the [ResolveCase] request was sent.
    public var initialCaseStatus: Swift.String?

    public init (
        finalCaseStatus: Swift.String? = nil,
        initialCaseStatus: Swift.String? = nil
    )
    {
        self.finalCaseStatus = finalCaseStatus
        self.initialCaseStatus = initialCaseStatus
    }
}

struct ResolveCaseOutputResponseBody: Swift.Equatable {
    public let initialCaseStatus: Swift.String?
    public let finalCaseStatus: Swift.String?
}

extension ResolveCaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalCaseStatus
        case initialCaseStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialCaseStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialCaseStatus)
        initialCaseStatus = initialCaseStatusDecoded
        let finalCaseStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .finalCaseStatus)
        finalCaseStatus = finalCaseStatusDecoded
    }
}

extension SupportClientTypes.Service: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categories
        case code
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for categorylist0 in categories {
                try categoriesContainer.encode(categorylist0)
            }
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([SupportClientTypes.Category?].self, forKey: .categories)
        var categoriesDecoded0:[SupportClientTypes.Category]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [SupportClientTypes.Category]()
            for structure0 in categoriesContainer {
                if let structure0 = structure0 {
                    categoriesDecoded0?.append(structure0)
                }
            }
        }
        categories = categoriesDecoded0
    }
}

extension SupportClientTypes.Service: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Service(categories: \(Swift.String(describing: categories)), code: \(Swift.String(describing: code)), name: \(Swift.String(describing: name)))"}
}

extension SupportClientTypes {
    /// Information about an AWS service returned by the [DescribeServices] operation.
    public struct Service: Swift.Equatable {
        /// A list of categories that describe the type of support issue a case describes. Categories consist of a category name and a category code. Category names and codes are passed to AWS Support when you call [CreateCase].
        public var categories: [SupportClientTypes.Category]?
        /// The code for an AWS service returned by the [DescribeServices] response. The name element contains the corresponding friendly name.
        public var code: Swift.String?
        /// The friendly name for an AWS service. The code element contains the corresponding code.
        public var name: Swift.String?

        public init (
            categories: [SupportClientTypes.Category]? = nil,
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.categories = categories
            self.code = code
            self.name = name
        }
    }

}

extension SupportClientTypes.SeverityLevel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SupportClientTypes.SeverityLevel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SeverityLevel(code: \(Swift.String(describing: code)), name: \(Swift.String(describing: name)))"}
}

extension SupportClientTypes {
    /// A code and name pair that represents the severity level of a support case. The available values depend on the support plan for the account. For more information, see [Choosing a severity](https://docs.aws.amazon.com/awssupport/latest/user/case-management.html#choosing-severity) in the AWS Support User Guide.
    public struct SeverityLevel: Swift.Equatable {
        /// The code for case severity level. Valid values: low | normal | high | urgent | critical
        public var code: Swift.String?
        /// The name of the severity level that corresponds to the severity level code. The values returned by the API are different from the values that appear in the AWS Support Center. For example, the API uses the code low, but the name appears as General guidance in Support Center. The following are the API code names and how they appear in the console:
        ///
        /// * low - General guidance
        ///
        /// * normal - System impaired
        ///
        /// * high - Production system impaired
        ///
        /// * urgent - Production system down
        ///
        /// * critical - Business-critical system down
        ///
        ///
        /// For more information, see [Choosing a severity](https://docs.aws.amazon.com/awssupport/latest/user/case-management.html#choosing-severity) in the AWS Support User Guide.
        public var name: Swift.String?

        public init (
            code: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCategorySpecificSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costOptimizing
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costOptimizing = costOptimizing {
            try encodeContainer.encode(costOptimizing, forKey: .costOptimizing)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costOptimizingDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCostOptimizingSummary.self, forKey: .costOptimizing)
        costOptimizing = costOptimizingDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorCategorySpecificSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCategorySpecificSummary(costOptimizing: \(Swift.String(describing: costOptimizing)))"}
}

extension SupportClientTypes {
    /// The container for summary information that relates to the category of the Trusted Advisor check.
    public struct TrustedAdvisorCategorySpecificSummary: Swift.Equatable {
        /// The summary information about cost savings for a Trusted Advisor check that is in the Cost Optimizing category.
        public var costOptimizing: SupportClientTypes.TrustedAdvisorCostOptimizingSummary?

        public init (
            costOptimizing: SupportClientTypes.TrustedAdvisorCostOptimizingSummary? = nil
        )
        {
            self.costOptimizing = costOptimizing
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCheckDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case description
        case id
        case metadata
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadata)
            for stringlist0 in metadata {
                try metadataContainer.encode(stringlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metadata)
        var metadataDecoded0:[Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String]()
            for string0 in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?.append(string0)
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension SupportClientTypes.TrustedAdvisorCheckDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCheckDescription(category: \(Swift.String(describing: category)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)))"}
}

extension SupportClientTypes {
    /// The description and metadata for a Trusted Advisor check.
    public struct TrustedAdvisorCheckDescription: Swift.Equatable {
        /// The category of the Trusted Advisor check.
        /// This member is required.
        public var category: Swift.String?
        /// The description of the Trusted Advisor check, which includes the alert criteria and recommended operations (contains HTML markup).
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier for the Trusted Advisor check.
        /// This member is required.
        public var id: Swift.String?
        /// The column headings for the data returned by the Trusted Advisor check. The order of the headings corresponds to the order of the data in the Metadata element of the [TrustedAdvisorResourceDetail] for the check. Metadata contains all the data that is shown in the Excel download, even in those cases where the UI shows just summary data.
        /// This member is required.
        public var metadata: [Swift.String]?
        /// The display name for the Trusted Advisor check.
        /// This member is required.
        public var name: Swift.String?

        public init (
            category: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.description = description
            self.id = id
            self.metadata = metadata
            self.name = name
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCheckRefreshStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkId
        case millisUntilNextRefreshable
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if millisUntilNextRefreshable != 0 {
            try encodeContainer.encode(millisUntilNextRefreshable, forKey: .millisUntilNextRefreshable)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let millisUntilNextRefreshableDecoded = try containerValues.decode(Swift.Int.self, forKey: .millisUntilNextRefreshable)
        millisUntilNextRefreshable = millisUntilNextRefreshableDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorCheckRefreshStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCheckRefreshStatus(checkId: \(Swift.String(describing: checkId)), millisUntilNextRefreshable: \(Swift.String(describing: millisUntilNextRefreshable)), status: \(Swift.String(describing: status)))"}
}

extension SupportClientTypes {
    /// The refresh status of a Trusted Advisor check.
    public struct TrustedAdvisorCheckRefreshStatus: Swift.Equatable {
        /// The unique identifier for the Trusted Advisor check.
        /// This member is required.
        public var checkId: Swift.String?
        /// The amount of time, in milliseconds, until the Trusted Advisor check is eligible for refresh.
        /// This member is required.
        public var millisUntilNextRefreshable: Swift.Int
        /// The status of the Trusted Advisor check for which a refresh has been requested:
        ///
        /// * none - The check is not refreshed or the non-success status exceeds the timeout
        ///
        /// * enqueued - The check refresh requests has entered the refresh queue
        ///
        /// * processing - The check refresh request is picked up by the rule processing engine
        ///
        /// * success - The check is successfully refreshed
        ///
        /// * abandoned - The check refresh has failed
        /// This member is required.
        public var status: Swift.String?

        public init (
            checkId: Swift.String? = nil,
            millisUntilNextRefreshable: Swift.Int = 0,
            status: Swift.String? = nil
        )
        {
            self.checkId = checkId
            self.millisUntilNextRefreshable = millisUntilNextRefreshable
            self.status = status
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCheckResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categorySpecificSummary
        case checkId
        case flaggedResources
        case resourcesSummary
        case status
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categorySpecificSummary = categorySpecificSummary {
            try encodeContainer.encode(categorySpecificSummary, forKey: .categorySpecificSummary)
        }
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if let flaggedResources = flaggedResources {
            var flaggedResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .flaggedResources)
            for trustedadvisorresourcedetaillist0 in flaggedResources {
                try flaggedResourcesContainer.encode(trustedadvisorresourcedetaillist0)
            }
        }
        if let resourcesSummary = resourcesSummary {
            try encodeContainer.encode(resourcesSummary, forKey: .resourcesSummary)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let resourcesSummaryDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorResourcesSummary.self, forKey: .resourcesSummary)
        resourcesSummary = resourcesSummaryDecoded
        let categorySpecificSummaryDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCategorySpecificSummary.self, forKey: .categorySpecificSummary)
        categorySpecificSummary = categorySpecificSummaryDecoded
        let flaggedResourcesContainer = try containerValues.decodeIfPresent([SupportClientTypes.TrustedAdvisorResourceDetail?].self, forKey: .flaggedResources)
        var flaggedResourcesDecoded0:[SupportClientTypes.TrustedAdvisorResourceDetail]? = nil
        if let flaggedResourcesContainer = flaggedResourcesContainer {
            flaggedResourcesDecoded0 = [SupportClientTypes.TrustedAdvisorResourceDetail]()
            for structure0 in flaggedResourcesContainer {
                if let structure0 = structure0 {
                    flaggedResourcesDecoded0?.append(structure0)
                }
            }
        }
        flaggedResources = flaggedResourcesDecoded0
    }
}

extension SupportClientTypes.TrustedAdvisorCheckResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCheckResult(categorySpecificSummary: \(Swift.String(describing: categorySpecificSummary)), checkId: \(Swift.String(describing: checkId)), flaggedResources: \(Swift.String(describing: flaggedResources)), resourcesSummary: \(Swift.String(describing: resourcesSummary)), status: \(Swift.String(describing: status)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension SupportClientTypes {
    /// The results of a Trusted Advisor check returned by [DescribeTrustedAdvisorCheckResult].
    public struct TrustedAdvisorCheckResult: Swift.Equatable {
        /// Summary information that relates to the category of the check. Cost Optimizing is the only category that is currently supported.
        /// This member is required.
        public var categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary?
        /// The unique identifier for the Trusted Advisor check.
        /// This member is required.
        public var checkId: Swift.String?
        /// The details about each resource listed in the check result.
        /// This member is required.
        public var flaggedResources: [SupportClientTypes.TrustedAdvisorResourceDetail]?
        /// Details about AWS resources that were analyzed in a call to Trusted Advisor [DescribeTrustedAdvisorCheckSummaries].
        /// This member is required.
        public var resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary?
        /// The alert status of the check: "ok" (green), "warning" (yellow), "error" (red), or "not_available".
        /// This member is required.
        public var status: Swift.String?
        /// The time of the last refresh of the check.
        /// This member is required.
        public var timestamp: Swift.String?

        public init (
            categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary? = nil,
            checkId: Swift.String? = nil,
            flaggedResources: [SupportClientTypes.TrustedAdvisorResourceDetail]? = nil,
            resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary? = nil,
            status: Swift.String? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.categorySpecificSummary = categorySpecificSummary
            self.checkId = checkId
            self.flaggedResources = flaggedResources
            self.resourcesSummary = resourcesSummary
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCheckSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categorySpecificSummary
        case checkId
        case hasFlaggedResources
        case resourcesSummary
        case status
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categorySpecificSummary = categorySpecificSummary {
            try encodeContainer.encode(categorySpecificSummary, forKey: .categorySpecificSummary)
        }
        if let checkId = checkId {
            try encodeContainer.encode(checkId, forKey: .checkId)
        }
        if hasFlaggedResources != false {
            try encodeContainer.encode(hasFlaggedResources, forKey: .hasFlaggedResources)
        }
        if let resourcesSummary = resourcesSummary {
            try encodeContainer.encode(resourcesSummary, forKey: .resourcesSummary)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let checkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkId)
        checkId = checkIdDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let hasFlaggedResourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .hasFlaggedResources)
        hasFlaggedResources = hasFlaggedResourcesDecoded
        let resourcesSummaryDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorResourcesSummary.self, forKey: .resourcesSummary)
        resourcesSummary = resourcesSummaryDecoded
        let categorySpecificSummaryDecoded = try containerValues.decodeIfPresent(SupportClientTypes.TrustedAdvisorCategorySpecificSummary.self, forKey: .categorySpecificSummary)
        categorySpecificSummary = categorySpecificSummaryDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorCheckSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCheckSummary(categorySpecificSummary: \(Swift.String(describing: categorySpecificSummary)), checkId: \(Swift.String(describing: checkId)), hasFlaggedResources: \(Swift.String(describing: hasFlaggedResources)), resourcesSummary: \(Swift.String(describing: resourcesSummary)), status: \(Swift.String(describing: status)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension SupportClientTypes {
    /// A summary of a Trusted Advisor check result, including the alert status, last refresh, and number of resources examined.
    public struct TrustedAdvisorCheckSummary: Swift.Equatable {
        /// Summary information that relates to the category of the check. Cost Optimizing is the only category that is currently supported.
        /// This member is required.
        public var categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary?
        /// The unique identifier for the Trusted Advisor check.
        /// This member is required.
        public var checkId: Swift.String?
        /// Specifies whether the Trusted Advisor check has flagged resources.
        public var hasFlaggedResources: Swift.Bool
        /// Details about AWS resources that were analyzed in a call to Trusted Advisor [DescribeTrustedAdvisorCheckSummaries].
        /// This member is required.
        public var resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary?
        /// The alert status of the check: "ok" (green), "warning" (yellow), "error" (red), or "not_available".
        /// This member is required.
        public var status: Swift.String?
        /// The time of the last refresh of the check.
        /// This member is required.
        public var timestamp: Swift.String?

        public init (
            categorySpecificSummary: SupportClientTypes.TrustedAdvisorCategorySpecificSummary? = nil,
            checkId: Swift.String? = nil,
            hasFlaggedResources: Swift.Bool = false,
            resourcesSummary: SupportClientTypes.TrustedAdvisorResourcesSummary? = nil,
            status: Swift.String? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.categorySpecificSummary = categorySpecificSummary
            self.checkId = checkId
            self.hasFlaggedResources = hasFlaggedResources
            self.resourcesSummary = resourcesSummary
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension SupportClientTypes.TrustedAdvisorCostOptimizingSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMonthlySavings
        case estimatedPercentMonthlySavings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if estimatedMonthlySavings != 0.0 {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
        if estimatedPercentMonthlySavings != 0.0 {
            try encodeContainer.encode(estimatedPercentMonthlySavings, forKey: .estimatedPercentMonthlySavings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlySavingsDecoded = try containerValues.decode(Swift.Double.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let estimatedPercentMonthlySavingsDecoded = try containerValues.decode(Swift.Double.self, forKey: .estimatedPercentMonthlySavings)
        estimatedPercentMonthlySavings = estimatedPercentMonthlySavingsDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorCostOptimizingSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorCostOptimizingSummary(estimatedMonthlySavings: \(Swift.String(describing: estimatedMonthlySavings)), estimatedPercentMonthlySavings: \(Swift.String(describing: estimatedPercentMonthlySavings)))"}
}

extension SupportClientTypes {
    /// The estimated cost savings that might be realized if the recommended operations are taken.
    public struct TrustedAdvisorCostOptimizingSummary: Swift.Equatable {
        /// The estimated monthly savings that might be realized if the recommended operations are taken.
        /// This member is required.
        public var estimatedMonthlySavings: Swift.Double
        /// The estimated percentage of savings that might be realized if the recommended operations are taken.
        /// This member is required.
        public var estimatedPercentMonthlySavings: Swift.Double

        public init (
            estimatedMonthlySavings: Swift.Double = 0.0,
            estimatedPercentMonthlySavings: Swift.Double = 0.0
        )
        {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.estimatedPercentMonthlySavings = estimatedPercentMonthlySavings
        }
    }

}

extension SupportClientTypes.TrustedAdvisorResourceDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isSuppressed
        case metadata
        case region
        case resourceId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isSuppressed != false {
            try encodeContainer.encode(isSuppressed, forKey: .isSuppressed)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadata)
            for stringlist0 in metadata {
                try metadataContainer.encode(stringlist0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let isSuppressedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isSuppressed)
        isSuppressed = isSuppressedDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metadata)
        var metadataDecoded0:[Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String]()
            for string0 in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?.append(string0)
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension SupportClientTypes.TrustedAdvisorResourceDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorResourceDetail(isSuppressed: \(Swift.String(describing: isSuppressed)), metadata: \(Swift.String(describing: metadata)), region: \(Swift.String(describing: region)), resourceId: \(Swift.String(describing: resourceId)), status: \(Swift.String(describing: status)))"}
}

extension SupportClientTypes {
    /// Contains information about a resource identified by a Trusted Advisor check.
    public struct TrustedAdvisorResourceDetail: Swift.Equatable {
        /// Specifies whether the AWS resource was ignored by Trusted Advisor because it was marked as suppressed by the user.
        public var isSuppressed: Swift.Bool
        /// Additional information about the identified resource. The exact metadata and its order can be obtained by inspecting the [TrustedAdvisorCheckDescription] object returned by the call to [DescribeTrustedAdvisorChecks]. Metadata contains all the data that is shown in the Excel download, even in those cases where the UI shows just summary data.
        /// This member is required.
        public var metadata: [Swift.String]?
        /// The AWS Region in which the identified resource is located.
        public var region: Swift.String?
        /// The unique identifier for the identified resource.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The status code for the resource identified in the Trusted Advisor check.
        /// This member is required.
        public var status: Swift.String?

        public init (
            isSuppressed: Swift.Bool = false,
            metadata: [Swift.String]? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.isSuppressed = isSuppressed
            self.metadata = metadata
            self.region = region
            self.resourceId = resourceId
            self.status = status
        }
    }

}

extension SupportClientTypes.TrustedAdvisorResourcesSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourcesFlagged
        case resourcesIgnored
        case resourcesProcessed
        case resourcesSuppressed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if resourcesFlagged != 0 {
            try encodeContainer.encode(resourcesFlagged, forKey: .resourcesFlagged)
        }
        if resourcesIgnored != 0 {
            try encodeContainer.encode(resourcesIgnored, forKey: .resourcesIgnored)
        }
        if resourcesProcessed != 0 {
            try encodeContainer.encode(resourcesProcessed, forKey: .resourcesProcessed)
        }
        if resourcesSuppressed != 0 {
            try encodeContainer.encode(resourcesSuppressed, forKey: .resourcesSuppressed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesProcessedDecoded = try containerValues.decode(Swift.Int.self, forKey: .resourcesProcessed)
        resourcesProcessed = resourcesProcessedDecoded
        let resourcesFlaggedDecoded = try containerValues.decode(Swift.Int.self, forKey: .resourcesFlagged)
        resourcesFlagged = resourcesFlaggedDecoded
        let resourcesIgnoredDecoded = try containerValues.decode(Swift.Int.self, forKey: .resourcesIgnored)
        resourcesIgnored = resourcesIgnoredDecoded
        let resourcesSuppressedDecoded = try containerValues.decode(Swift.Int.self, forKey: .resourcesSuppressed)
        resourcesSuppressed = resourcesSuppressedDecoded
    }
}

extension SupportClientTypes.TrustedAdvisorResourcesSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrustedAdvisorResourcesSummary(resourcesFlagged: \(Swift.String(describing: resourcesFlagged)), resourcesIgnored: \(Swift.String(describing: resourcesIgnored)), resourcesProcessed: \(Swift.String(describing: resourcesProcessed)), resourcesSuppressed: \(Swift.String(describing: resourcesSuppressed)))"}
}

extension SupportClientTypes {
    /// Details about AWS resources that were analyzed in a call to Trusted Advisor [DescribeTrustedAdvisorCheckSummaries].
    public struct TrustedAdvisorResourcesSummary: Swift.Equatable {
        /// The number of AWS resources that were flagged (listed) by the Trusted Advisor check.
        /// This member is required.
        public var resourcesFlagged: Swift.Int
        /// The number of AWS resources ignored by Trusted Advisor because information was unavailable.
        /// This member is required.
        public var resourcesIgnored: Swift.Int
        /// The number of AWS resources that were analyzed by the Trusted Advisor check.
        /// This member is required.
        public var resourcesProcessed: Swift.Int
        /// The number of AWS resources ignored by Trusted Advisor because they were marked as suppressed by the user.
        /// This member is required.
        public var resourcesSuppressed: Swift.Int

        public init (
            resourcesFlagged: Swift.Int = 0,
            resourcesIgnored: Swift.Int = 0,
            resourcesProcessed: Swift.Int = 0,
            resourcesSuppressed: Swift.Int = 0
        )
        {
            self.resourcesFlagged = resourcesFlagged
            self.resourcesIgnored = resourcesIgnored
            self.resourcesProcessed = resourcesProcessed
            self.resourcesSuppressed = resourcesSuppressed
        }
    }

}
