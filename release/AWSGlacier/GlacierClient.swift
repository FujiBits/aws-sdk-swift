// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class GlacierClient {
    let client: ClientRuntime.SdkHttpClient
    let config: AWSClientRuntime.AWSClientConfiguration
    let serviceName = "Glacier"
    let encoder: ClientRuntime.RequestEncoder
    let decoder: ClientRuntime.ResponseDecoder

    public init(config: AWSClientRuntime.AWSClientConfiguration) {
        client = ClientRuntime.SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public convenience init(region: Swift.String? = nil) throws {
        let config = try GlacierClientConfiguration(region: region)
        self.init(config: config)
    }

    deinit {
        client.close()
    }

    public class GlacierClientConfiguration: AWSClientRuntime.AWSClientConfiguration {

        public var clientLogMode: ClientRuntime.ClientLogMode
        public var decoder: ClientRuntime.ResponseDecoder?
        public var encoder: ClientRuntime.RequestEncoder?
        public var httpClientConfiguration: ClientRuntime.HttpClientConfiguration
        public var httpClientEngine: ClientRuntime.HttpClientEngine
        public var idempotencyTokenGenerator: ClientRuntime.IdempotencyTokenGenerator
        public var logger: ClientRuntime.LogAgent
        public var retryer: ClientRuntime.SDKRetryer

        public var credentialsProvider: AWSClientRuntime.CredentialsProvider
        public var endpointResolver: AWSClientRuntime.EndpointResolver
        public var region: Swift.String?
        public var regionResolver: AWSClientRuntime.RegionResolver
        public var signingRegion: Swift.String?

        public init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil,
            runtimeConfig: ClientRuntime.SDKRuntimeConfiguration
        ) throws {
            self.regionResolver = regionResolver ?? DefaultRegionResolver()
            let defaultRegion = self.regionResolver.resolveRegion()
            self.region = region ?? defaultRegion
            self.signingRegion = signingRegion ?? defaultRegion
            self.endpointResolver = endpointResolver ?? DefaultEndpointResolver()
            if let credProvider = credentialsProvider {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromCustom(credProvider)
            } else {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromChain()
            }
            self.clientLogMode = runtimeConfig.clientLogMode
            self.decoder = runtimeConfig.decoder
            self.encoder = runtimeConfig.encoder
            self.httpClientConfiguration = runtimeConfig.httpClientConfiguration
            self.httpClientEngine = runtimeConfig.httpClientEngine
            self.idempotencyTokenGenerator = runtimeConfig.idempotencyTokenGenerator
            self.logger = runtimeConfig.logger
            self.retryer = runtimeConfig.retryer
        }

        public convenience init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil
        ) throws {
            let defaultRuntimeConfig = try ClientRuntime.DefaultSDKRuntimeConfiguration("GlacierClient")
            try self.init(credentialsProvider: credentialsProvider, endpointResolver: endpointResolver, region: region, regionResolver: regionResolver, signingRegion: signingRegion, runtimeConfig: defaultRuntimeConfig)
        }
    }
}

public struct GlacierClientLogHandlerFactory: ClientRuntime.SDKLogHandlerFactory {
    public var label = "GlacierClient"
    let logLevel: ClientRuntime.SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: ClientRuntime.SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension GlacierClient: GlacierClientProtocol {
    /// This operation aborts a multipart upload identified by the upload ID.
    ///
    ///
    ///          After the Abort Multipart Upload request succeeds, you cannot upload any more parts
    ///          to the multipart upload or complete the multipart upload. Aborting a completed upload
    ///          fails. However, aborting an already-aborted upload will succeed, for a short time. For more
    ///          information about uploading a part and completing a multipart upload, see UploadMultipartPart and CompleteMultipartUpload.
    ///
    ///          This operation is idempotent.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///           For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html">Working with Archives in
    ///             Amazon S3 Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html">Abort Multipart
    ///             Upload in the Amazon Glacier Developer Guide.
    public func abortMultipartUpload(input: AbortMultipartUploadInput, completion: @escaping (ClientRuntime.SdkResult<AbortMultipartUploadOutputResponse, AbortMultipartUploadOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "abortMultipartUpload")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<AbortMultipartUploadInput, AbortMultipartUploadOutputResponse, AbortMultipartUploadOutputError>(id: "abortMultipartUpload")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<AbortMultipartUploadOutputResponse>, ClientRuntime.SdkError<AbortMultipartUploadOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: AbortMultipartUploadInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: AbortMultipartUploadInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: AbortMultipartUploadInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<AbortMultipartUploadInput, AbortMultipartUploadOutputResponse, AbortMultipartUploadOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation aborts the vault locking process if the vault lock is not in the
    ///             Locked state. If the vault lock is in the Locked state when
    ///          this operation is requested, the operation returns an AccessDeniedException
    ///          error. Aborting the vault locking process removes the vault lock policy from the specified
    ///          vault.
    ///          A vault lock is put into the InProgress state by calling InitiateVaultLock. A vault lock is put into the Locked state by
    ///          calling CompleteVaultLock. You can get the state of a vault lock by
    ///          calling GetVaultLock. For more information about the vault locking
    ///          process, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock.html">Amazon Glacier Vault Lock. For more information about vault lock policies, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock-policy.html">Amazon
    ///             Glacier Access Control with Vault Lock Policies.
    ///          This operation is idempotent. You can successfully invoke this operation multiple
    ///          times, if the vault lock is in the InProgress state or if there is no policy
    ///          associated with the vault.
    public func abortVaultLock(input: AbortVaultLockInput, completion: @escaping (ClientRuntime.SdkResult<AbortVaultLockOutputResponse, AbortVaultLockOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "abortVaultLock")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<AbortVaultLockInput, AbortVaultLockOutputResponse, AbortVaultLockOutputError>(id: "abortVaultLock")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<AbortVaultLockOutputResponse>, ClientRuntime.SdkError<AbortVaultLockOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: AbortVaultLockInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: AbortVaultLockInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: AbortVaultLockInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<AbortVaultLockInput, AbortVaultLockOutputResponse, AbortVaultLockOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation adds the specified tags to a vault. Each tag is composed of a key and
    ///          a value. Each vault can have up to 10 tags. If your request would cause the tag limit for
    ///          the vault to be exceeded, the operation throws the LimitExceededException
    ///          error. If a tag already exists on the vault under a specified key, the existing key value
    ///          will be overwritten. For more information about tags, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/tagging.html">Tagging Amazon S3 Glacier Resources.
    ///
    public func addTagsToVault(input: AddTagsToVaultInput, completion: @escaping (ClientRuntime.SdkResult<AddTagsToVaultOutputResponse, AddTagsToVaultOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "addTagsToVault")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<AddTagsToVaultInput, AddTagsToVaultOutputResponse, AddTagsToVaultOutputError>(id: "addTagsToVault")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToVaultOutputResponse>, ClientRuntime.SdkError<AddTagsToVaultOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: AddTagsToVaultInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: AddTagsToVaultInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: AddTagsToVaultInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<AddTagsToVaultInput, AddTagsToVaultOutputResponse, AddTagsToVaultOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: AddTagsToVaultInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// You call this operation to inform Amazon S3 Glacier (Glacier) that all the archive parts have been
    ///          uploaded and that Glacier can now assemble the archive from the uploaded parts.
    ///          After assembling and saving the archive to the vault, Glacier returns the URI path
    ///          of the newly created archive resource. Using the URI path, you can then access the archive.
    ///          After you upload an archive, you should save the archive ID returned to retrieve the
    ///          archive at a later point. You can also get the vault inventory to obtain a list of archive
    ///          IDs in a vault. For more information, see InitiateJob.
    ///
    ///          In the request, you must include the computed SHA256 tree hash of the entire archive
    ///          you have uploaded. For information about computing a SHA256 tree hash, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html">Computing
    ///             Checksums. On the server side, Glacier also constructs the SHA256 tree
    ///          hash of the assembled archive. If the values match, Glacier saves the archive to the
    ///          vault; otherwise, it returns an error, and the operation fails. The ListParts operation returns a list of parts uploaded for a specific
    ///          multipart upload. It includes checksum information for each uploaded part that can be used
    ///          to debug a bad checksum issue.
    ///
    ///          Additionally, Glacier also checks for any missing content ranges when
    ///          assembling the archive, if missing content ranges are found, Glacier returns an
    ///          error and the operation fails.
    ///
    ///          Complete Multipart Upload is an idempotent operation. After your first successful
    ///          complete multipart upload, if you call the operation again within a short period, the
    ///          operation will succeed and return the same archive ID. This is useful in the event you
    ///          experience a network issue that causes an aborted connection or receive a 500 server error,
    ///          in which case you can repeat your Complete Multipart Upload request and get the same
    ///          archive ID without creating duplicate archives. Note, however, that after the multipart
    ///          upload completes, you cannot call the List Parts operation and the multipart upload will
    ///          not appear in List Multipart Uploads response, even if idempotent complete is
    ///          possible.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///           For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html">Uploading Large Archives in
    ///             Parts (Multipart Upload) and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-complete-upload.html">Complete Multipart
    ///             Upload in the Amazon Glacier Developer Guide.
    public func completeMultipartUpload(input: CompleteMultipartUploadInput, completion: @escaping (ClientRuntime.SdkResult<CompleteMultipartUploadOutputResponse, CompleteMultipartUploadOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "completeMultipartUpload")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CompleteMultipartUploadInput, CompleteMultipartUploadOutputResponse, CompleteMultipartUploadOutputError>(id: "completeMultipartUpload")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CompleteMultipartUploadOutputResponse>, ClientRuntime.SdkError<CompleteMultipartUploadOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: CompleteMultipartUploadInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: CompleteMultipartUploadInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CompleteMultipartUploadInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CompleteMultipartUploadInput, CompleteMultipartUploadOutputResponse, CompleteMultipartUploadOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation completes the vault locking process by transitioning the vault lock
    ///          from the InProgress state to the Locked state, which causes the
    ///          vault lock policy to become unchangeable. A vault lock is put into the
    ///             InProgress state by calling InitiateVaultLock. You can
    ///          obtain the state of the vault lock by calling GetVaultLock. For more
    ///          information about the vault locking process, <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock.html">Amazon Glacier Vault Lock.
    ///          This operation is idempotent. This request is always successful if the vault lock is
    ///          in the Locked state and the provided lock ID matches the lock ID originally
    ///          used to lock the vault.
    ///          If an invalid lock ID is passed in the request when the vault lock is in the
    ///             Locked state, the operation returns an AccessDeniedException
    ///          error. If an invalid lock ID is passed in the request when the vault lock is in the
    ///             InProgress state, the operation throws an InvalidParameter
    ///          error.
    public func completeVaultLock(input: CompleteVaultLockInput, completion: @escaping (ClientRuntime.SdkResult<CompleteVaultLockOutputResponse, CompleteVaultLockOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "completeVaultLock")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CompleteVaultLockInput, CompleteVaultLockOutputResponse, CompleteVaultLockOutputError>(id: "completeVaultLock")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CompleteVaultLockOutputResponse>, ClientRuntime.SdkError<CompleteVaultLockOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: CompleteVaultLockInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: CompleteVaultLockInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CompleteVaultLockInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CompleteVaultLockInput, CompleteVaultLockOutputResponse, CompleteVaultLockOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation creates a new vault with the specified name. The name of the vault
    ///          must be unique within a region for an AWS account. You can create up to 1,000 vaults per
    ///          account. If you need to create more vaults, contact Amazon S3 Glacier.
    ///          You must use the following guidelines when naming a vault.
    ///
    ///
    ///                Names can be between 1 and 255 characters long.
    ///
    ///
    ///                Allowed characters are a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen), and '.'
    ///                (period).
    ///
    ///
    ///
    ///          This operation is idempotent.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///           For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/creating-vaults.html">Creating a Vault in Amazon
    ///             Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-put.html">Create Vault  in the
    ///             Amazon Glacier Developer Guide.
    public func createVault(input: CreateVaultInput, completion: @escaping (ClientRuntime.SdkResult<CreateVaultOutputResponse, CreateVaultOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVault")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<CreateVaultInput, CreateVaultOutputResponse, CreateVaultOutputError>(id: "createVault")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<CreateVaultOutputResponse>, ClientRuntime.SdkError<CreateVaultOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: CreateVaultInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: CreateVaultInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: CreateVaultInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateVaultInput, CreateVaultOutputResponse, CreateVaultOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation deletes an archive from a vault. Subsequent requests to initiate a
    ///          retrieval of this archive will fail. Archive retrievals that are in progress for this
    ///          archive ID may or may not succeed according to the following scenarios:
    ///
    ///
    ///                If the archive retrieval job is actively preparing the data for download when
    ///                Amazon S3 Glacier receives the delete archive request, the archival retrieval operation
    ///                might fail.
    ///
    ///
    ///                If the archive retrieval job has successfully prepared the archive for download
    ///                when Amazon S3 Glacier receives the delete archive request, you will be able to download
    ///                the output.
    ///
    ///
    ///
    ///          This operation is idempotent. Attempting to delete an already-deleted archive does
    ///          not result in an error.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///           For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-an-archive.html">Deleting an Archive in Amazon
    ///             Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html">Delete Archive in the
    ///             Amazon Glacier Developer Guide.
    public func deleteArchive(input: DeleteArchiveInput, completion: @escaping (ClientRuntime.SdkResult<DeleteArchiveOutputResponse, DeleteArchiveOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteArchive")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteArchiveInput, DeleteArchiveOutputResponse, DeleteArchiveOutputError>(id: "deleteArchive")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<DeleteArchiveOutputResponse>, ClientRuntime.SdkError<DeleteArchiveOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: DeleteArchiveInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: DeleteArchiveInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteArchiveInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteArchiveInput, DeleteArchiveOutputResponse, DeleteArchiveOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation deletes a vault. Amazon S3 Glacier will delete a vault only if there are
    ///          no archives in the vault as of the last inventory and there have been no writes to the
    ///          vault since the last inventory. If either of these conditions is not satisfied, the vault
    ///          deletion fails (that is, the vault is not removed) and Amazon S3 Glacier returns an error. You
    ///          can use DescribeVault to return the number of archives in a vault, and
    ///          you can use <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html">Initiate a Job (POST
    ///             jobs) to initiate a new inventory retrieval for a vault. The inventory contains
    ///          the archive IDs you use to delete archives using <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-delete.html">Delete Archive (DELETE
    ///             archive).
    ///
    ///          This operation is idempotent.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///           For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/deleting-vaults.html">Deleting a Vault in Amazon
    ///             Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-delete.html">Delete Vault  in the
    ///             Amazon S3 Glacier Developer Guide.
    public func deleteVault(input: DeleteVaultInput, completion: @escaping (ClientRuntime.SdkResult<DeleteVaultOutputResponse, DeleteVaultOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVault")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteVaultInput, DeleteVaultOutputResponse, DeleteVaultOutputError>(id: "deleteVault")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVaultOutputResponse>, ClientRuntime.SdkError<DeleteVaultOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: DeleteVaultInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: DeleteVaultInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteVaultInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteVaultInput, DeleteVaultOutputResponse, DeleteVaultOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation deletes the access policy associated with the specified vault. The
    ///          operation is eventually consistent; that is, it might take some time for Amazon S3 Glacier to
    ///          completely remove the access policy, and you might still see the effect of the policy for a
    ///          short time after you send the delete request.
    ///          This operation is idempotent. You can invoke delete multiple times, even if there is
    ///          no policy associated with the vault. For more information about vault access policies, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html">Amazon Glacier Access Control with Vault Access Policies.
    public func deleteVaultAccessPolicy(input: DeleteVaultAccessPolicyInput, completion: @escaping (ClientRuntime.SdkResult<DeleteVaultAccessPolicyOutputResponse, DeleteVaultAccessPolicyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVaultAccessPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteVaultAccessPolicyInput, DeleteVaultAccessPolicyOutputResponse, DeleteVaultAccessPolicyOutputError>(id: "deleteVaultAccessPolicy")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVaultAccessPolicyOutputResponse>, ClientRuntime.SdkError<DeleteVaultAccessPolicyOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: DeleteVaultAccessPolicyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: DeleteVaultAccessPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteVaultAccessPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteVaultAccessPolicyInput, DeleteVaultAccessPolicyOutputResponse, DeleteVaultAccessPolicyOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation deletes the notification configuration set for a vault. The operation
    ///          is eventually consistent; that is, it might take some time for Amazon S3 Glacier to completely
    ///          disable the notifications and you might still receive some notifications for a short time
    ///          after you send the delete request.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///          <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access
    ///             Control Using AWS Identity and Access Management (IAM).
    ///           For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html">Configuring Vault
    ///             Notifications in Amazon S3 Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-delete.html">Delete Vault
    ///             Notification Configuration  in the Amazon S3 Glacier Developer Guide.
    public func deleteVaultNotifications(input: DeleteVaultNotificationsInput, completion: @escaping (ClientRuntime.SdkResult<DeleteVaultNotificationsOutputResponse, DeleteVaultNotificationsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVaultNotifications")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DeleteVaultNotificationsInput, DeleteVaultNotificationsOutputResponse, DeleteVaultNotificationsOutputError>(id: "deleteVaultNotifications")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<DeleteVaultNotificationsOutputResponse>, ClientRuntime.SdkError<DeleteVaultNotificationsOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: DeleteVaultNotificationsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: DeleteVaultNotificationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DeleteVaultNotificationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteVaultNotificationsInput, DeleteVaultNotificationsOutputResponse, DeleteVaultNotificationsOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation returns information about a job you previously initiated, including
    ///          the job initiation date, the user who initiated the job, the job status code/message and
    ///          the Amazon SNS topic to notify after Amazon S3 Glacier (Glacier) completes the job. For more information
    ///          about initiating a job, see InitiateJob.
    ///
    ///
    ///             This operation enables you to check the status of your job. However, it is
    ///             strongly recommended that you set up an Amazon SNS topic and specify it in your initiate
    ///             job request so that Glacier can notify the topic after it completes the
    ///             job.
    ///
    ///
    ///          A job ID will not expire for at least 24 hours after Glacier completes the
    ///          job.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///
    ///           For more information about using this operation,
    ///          see the documentation for the underlying REST API <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-describe-job-get.html">Describe Job
    ///          in the Amazon Glacier Developer Guide.
    public func describeJob(input: DescribeJobInput, completion: @escaping (ClientRuntime.SdkResult<DescribeJobOutputResponse, DescribeJobOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DescribeJobInput, DescribeJobOutputResponse, DescribeJobOutputError>(id: "describeJob")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<DescribeJobOutputResponse>, ClientRuntime.SdkError<DescribeJobOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: DescribeJobInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: DescribeJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DescribeJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeJobInput, DescribeJobOutputResponse, DescribeJobOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation returns information about a vault, including the vault's Amazon
    ///          Resource Name (ARN), the date the vault was created, the number of archives it contains,
    ///          and the total size of all the archives in the vault. The number of archives and their total
    ///          size are as of the last inventory generation. This means that if you add or remove an
    ///          archive from a vault, and then immediately use Describe Vault, the change in contents will
    ///          not be immediately reflected. If you want to retrieve the latest inventory of the vault,
    ///          use InitiateJob. Amazon S3 Glacier generates vault inventories approximately
    ///          daily. For more information, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html">Downloading a Vault Inventory in
    ///             Amazon S3 Glacier.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///          For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html">Retrieving Vault Metadata in
    ///             Amazon S3 Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-get.html">Describe Vault  in the
    ///             Amazon Glacier Developer Guide.
    public func describeVault(input: DescribeVaultInput, completion: @escaping (ClientRuntime.SdkResult<DescribeVaultOutputResponse, DescribeVaultOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVault")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<DescribeVaultInput, DescribeVaultOutputResponse, DescribeVaultOutputError>(id: "describeVault")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<DescribeVaultOutputResponse>, ClientRuntime.SdkError<DescribeVaultOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: DescribeVaultInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: DescribeVaultInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: DescribeVaultInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DescribeVaultInput, DescribeVaultOutputResponse, DescribeVaultOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation returns the current data retrieval policy for the account and region
    ///          specified in the GET request. For more information about data retrieval policies, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html">Amazon Glacier Data Retrieval Policies.
    public func getDataRetrievalPolicy(input: GetDataRetrievalPolicyInput, completion: @escaping (ClientRuntime.SdkResult<GetDataRetrievalPolicyOutputResponse, GetDataRetrievalPolicyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDataRetrievalPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetDataRetrievalPolicyInput, GetDataRetrievalPolicyOutputResponse, GetDataRetrievalPolicyOutputError>(id: "getDataRetrievalPolicy")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<GetDataRetrievalPolicyOutputResponse>, ClientRuntime.SdkError<GetDataRetrievalPolicyOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: GetDataRetrievalPolicyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: GetDataRetrievalPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetDataRetrievalPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDataRetrievalPolicyInput, GetDataRetrievalPolicyOutputResponse, GetDataRetrievalPolicyOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation downloads the output of the job you initiated using InitiateJob. Depending on the job type you specified when you initiated the
    ///          job, the output will be either the content of an archive or a vault inventory.
    ///
    ///          You can download all the job output or download a portion of the output by specifying
    ///          a byte range. In the case of an archive retrieval job, depending on the byte range you
    ///          specify, Amazon S3 Glacier (Glacier) returns the checksum for the portion of the data. You can compute the
    ///          checksum on the client and verify that the values match to ensure the portion you downloaded
    ///          is the correct data.
    ///          A job ID will not expire for at least 24 hours after Glacier completes the job. That
    ///          a byte range. For both archive and inventory retrieval jobs, you should verify the downloaded
    ///          size against the size returned in the headers from the
    ///          Get Job Output response.
    ///          For archive retrieval jobs, you should also verify that the size is what you expected. If
    ///          you download a portion of the output, the expected size is based on the range of bytes
    ///          you specified. For example, if you specify a range of bytes=0-1048575, you should
    ///          verify your download size is 1,048,576 bytes. If you download an entire archive, the
    ///          expected size is the size of the archive when you uploaded it to Amazon S3 Glacier
    ///          The expected size is also returned in the headers from the
    ///          Get Job Output response.
    ///          In the case of an archive retrieval job, depending on the byte range you
    ///          specify, Glacier returns the checksum for the portion of the data. To ensure the portion you downloaded
    ///          is the correct data, compute the checksum on the client, verify that the values match,
    ///          and verify that the size is what you expected.
    ///
    ///          A job ID does not expire for at least 24 hours after Glacier completes the
    ///          job. That is, you can download the job output within the 24 hours period after Amazon
    ///          Glacier completes the job.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///          For conceptual information and the underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-inventory.html">Downloading a
    ///             Vault Inventory, <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/downloading-an-archive.html">Downloading an
    ///             Archive, and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-job-output-get.html">Get Job Output
    ///
    public func getJobOutput(input: GetJobOutputInput, completion: @escaping (ClientRuntime.SdkResult<GetJobOutputOutputResponse, GetJobOutputOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getJobOutput")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetJobOutputInput, GetJobOutputOutputResponse, GetJobOutputOutputError>(id: "getJobOutput")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<GetJobOutputOutputResponse>, ClientRuntime.SdkError<GetJobOutputOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: GetJobOutputInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: GetJobOutputInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetJobOutputInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetJobOutputInput, GetJobOutputOutputResponse, GetJobOutputOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation retrieves the access-policy subresource set on the vault;
    ///          for more information on setting this subresource, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-SetVaultAccessPolicy.html">Set Vault Access Policy
    ///             (PUT access-policy). If there is no access policy set on the vault, the
    ///          operation returns a 404 Not found error. For more information about vault
    ///          access policies, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html">Amazon Glacier Access Control
    ///             with Vault Access Policies.
    public func getVaultAccessPolicy(input: GetVaultAccessPolicyInput, completion: @escaping (ClientRuntime.SdkResult<GetVaultAccessPolicyOutputResponse, GetVaultAccessPolicyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getVaultAccessPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetVaultAccessPolicyInput, GetVaultAccessPolicyOutputResponse, GetVaultAccessPolicyOutputError>(id: "getVaultAccessPolicy")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<GetVaultAccessPolicyOutputResponse>, ClientRuntime.SdkError<GetVaultAccessPolicyOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: GetVaultAccessPolicyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: GetVaultAccessPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetVaultAccessPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetVaultAccessPolicyInput, GetVaultAccessPolicyOutputResponse, GetVaultAccessPolicyOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation retrieves the following attributes from the lock-policy
    ///          subresource set on the specified vault:
    ///
    ///
    ///                The vault lock policy set on the vault.
    ///
    ///
    ///                The state of the vault lock, which is either InProgess or
    ///                   Locked.
    ///
    ///
    ///                When the lock ID expires. The lock ID is used to complete the vault locking
    ///                process.
    ///
    ///
    ///                When the vault lock was initiated and put into the InProgress
    ///                state.
    ///
    ///
    ///
    ///          A vault lock is put into the InProgress state by calling InitiateVaultLock. A vault lock is put into the Locked state by
    ///          calling CompleteVaultLock. You can abort the vault locking process by
    ///          calling AbortVaultLock. For more information about the vault locking
    ///          process, <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock.html">Amazon
    ///             Glacier Vault Lock.
    ///          If there is no vault lock policy set on the vault, the operation returns a 404
    ///             Not found error. For more information about vault lock policies, <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock-policy.html">Amazon
    ///             Glacier Access Control with Vault Lock Policies.
    public func getVaultLock(input: GetVaultLockInput, completion: @escaping (ClientRuntime.SdkResult<GetVaultLockOutputResponse, GetVaultLockOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getVaultLock")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetVaultLockInput, GetVaultLockOutputResponse, GetVaultLockOutputError>(id: "getVaultLock")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<GetVaultLockOutputResponse>, ClientRuntime.SdkError<GetVaultLockOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: GetVaultLockInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: GetVaultLockInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetVaultLockInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetVaultLockInput, GetVaultLockOutputResponse, GetVaultLockOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation retrieves the notification-configuration subresource of
    ///          the specified vault.
    ///
    ///          For information about setting a notification configuration on a vault, see SetVaultNotifications. If a notification configuration for a vault is not
    ///          set, the operation returns a 404 Not Found error. For more information about
    ///          vault notifications, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html">Configuring Vault
    ///             Notifications in Amazon S3 Glacier.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///          For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html">Configuring Vault
    ///             Notifications in Amazon S3 Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-get.html">Get Vault Notification
    ///             Configuration  in the Amazon Glacier Developer Guide.
    public func getVaultNotifications(input: GetVaultNotificationsInput, completion: @escaping (ClientRuntime.SdkResult<GetVaultNotificationsOutputResponse, GetVaultNotificationsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getVaultNotifications")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<GetVaultNotificationsInput, GetVaultNotificationsOutputResponse, GetVaultNotificationsOutputError>(id: "getVaultNotifications")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<GetVaultNotificationsOutputResponse>, ClientRuntime.SdkError<GetVaultNotificationsOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: GetVaultNotificationsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: GetVaultNotificationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: GetVaultNotificationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetVaultNotificationsInput, GetVaultNotificationsOutputResponse, GetVaultNotificationsOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation initiates a job of the specified type, which can be a select, an archival retrieval,
    ///          or a vault retrieval. For more information about using this operation,
    ///          see the documentation for the underlying REST API <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html">Initiate
    ///             a Job.
    ///
    public func initiateJob(input: InitiateJobInput, completion: @escaping (ClientRuntime.SdkResult<InitiateJobOutputResponse, InitiateJobOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "initiateJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<InitiateJobInput, InitiateJobOutputResponse, InitiateJobOutputError>(id: "initiateJob")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<InitiateJobOutputResponse>, ClientRuntime.SdkError<InitiateJobOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: InitiateJobInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: InitiateJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: InitiateJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<InitiateJobInput, InitiateJobOutputResponse, InitiateJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: InitiateJobInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation initiates a multipart upload. Amazon S3 Glacier creates a multipart
    ///          upload resource and returns its ID in the response. The multipart upload ID is used in
    ///          subsequent requests to upload parts of an archive (see UploadMultipartPart).
    ///
    ///          When you initiate a multipart upload, you specify the part size in number of bytes.
    ///          The part size must be a megabyte (1024 KB) multiplied by a power of 2-for example, 1048576
    ///          (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8 MB), and so on. The minimum allowable
    ///          part size is 1 MB, and the maximum is 4 GB.
    ///
    ///          Every part you upload to this resource (see UploadMultipartPart),
    ///          except the last one, must have the same size. The last one can be the same size or smaller.
    ///          For example, suppose you want to upload a 16.2 MB file. If you initiate the multipart
    ///          upload with a part size of 4 MB, you will upload four parts of 4 MB each and one part of
    ///          0.2 MB.
    ///
    ///
    ///             You don't need to know the size of the archive when you start a multipart upload
    ///             because Amazon S3 Glacier does not require you to specify the overall archive
    ///             size.
    ///
    ///
    ///          After you complete the multipart upload, Amazon S3 Glacier (Glacier) removes the multipart upload
    ///          resource referenced by the ID. Glacier also removes the multipart upload resource if
    ///          you cancel the multipart upload or it may be removed if there is no activity for a period
    ///          of 24 hours.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///          For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html">Uploading Large Archives in
    ///             Parts (Multipart Upload) and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-initiate-upload.html">Initiate Multipart
    ///             Upload in the Amazon Glacier Developer Guide.
    public func initiateMultipartUpload(input: InitiateMultipartUploadInput, completion: @escaping (ClientRuntime.SdkResult<InitiateMultipartUploadOutputResponse, InitiateMultipartUploadOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "initiateMultipartUpload")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<InitiateMultipartUploadInput, InitiateMultipartUploadOutputResponse, InitiateMultipartUploadOutputError>(id: "initiateMultipartUpload")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<InitiateMultipartUploadOutputResponse>, ClientRuntime.SdkError<InitiateMultipartUploadOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: InitiateMultipartUploadInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: InitiateMultipartUploadInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: InitiateMultipartUploadInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<InitiateMultipartUploadInput, InitiateMultipartUploadOutputResponse, InitiateMultipartUploadOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation initiates the vault locking process by doing the following:
    ///
    ///
    ///                Installing a vault lock policy on the specified vault.
    ///
    ///
    ///                Setting the lock state of vault lock to InProgress.
    ///
    ///
    ///                Returning a lock ID, which is used to complete the vault locking
    ///                process.
    ///
    ///
    ///
    ///          You can set one vault lock policy for each vault and this policy can be up to 20 KB
    ///          in size. For more information about vault lock policies, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock-policy.html">Amazon Glacier Access Control with
    ///             Vault Lock Policies.
    ///          You must complete the vault locking process within 24 hours after the vault lock
    ///          enters the InProgress state. After the 24 hour window ends, the lock ID
    ///          expires, the vault automatically exits the InProgress state, and the vault
    ///          lock policy is removed from the vault. You call CompleteVaultLock to
    ///          complete the vault locking process by setting the state of the vault lock to
    ///             Locked.
    ///          After a vault lock is in the Locked state, you cannot initiate a new
    ///          vault lock for the vault.
    ///
    ///          You can abort the vault locking process by calling AbortVaultLock.
    ///          You can get the state of the vault lock by calling GetVaultLock. For more
    ///          information about the vault locking process, <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-lock.html">Amazon Glacier Vault
    ///          Lock.
    ///
    ///          If this operation is called when the vault lock is in the InProgress
    ///          state, the operation returns an AccessDeniedException error. When the vault
    ///          lock is in the InProgress state you must call AbortVaultLock
    ///          before you can initiate a new vault lock policy.
    public func initiateVaultLock(input: InitiateVaultLockInput, completion: @escaping (ClientRuntime.SdkResult<InitiateVaultLockOutputResponse, InitiateVaultLockOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "initiateVaultLock")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<InitiateVaultLockInput, InitiateVaultLockOutputResponse, InitiateVaultLockOutputError>(id: "initiateVaultLock")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<InitiateVaultLockOutputResponse>, ClientRuntime.SdkError<InitiateVaultLockOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: InitiateVaultLockInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: InitiateVaultLockInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: InitiateVaultLockInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<InitiateVaultLockInput, InitiateVaultLockOutputResponse, InitiateVaultLockOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: InitiateVaultLockInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation lists jobs for a vault, including jobs that are in-progress and jobs
    ///          that have recently finished. The List Job operation returns a list of these jobs sorted by job initiation
    ///          time.
    ///
    ///
    ///             Amazon Glacier retains recently completed jobs for a period before deleting them;
    ///             however, it eventually removes completed jobs. The output of completed jobs can be
    ///             retrieved. Retaining completed jobs for a period of time after they have completed
    ///             enables you to get a job output in the event you miss the job completion notification or
    ///             your first attempt to download it fails. For example, suppose you start an archive
    ///             retrieval job to download an archive. After the job completes, you start to download the
    ///             archive but encounter a network error. In this scenario, you can retry and download the
    ///             archive while the job exists.
    ///
    ///
    ///          The List Jobs operation supports pagination. You should always check the response Marker field.
    ///          If there are no more jobs to list, the Marker field is set to null. If there are more jobs to list,
    ///          the Marker field is set to a non-null value, which you can use to continue the pagination of the list.
    ///          To return a list of jobs that begins at a specific job,
    ///          set the marker request parameter to the Marker value for that job that you obtained from a previous List Jobs request.
    ///
    ///          You can set a maximum limit for the number of jobs returned in the response by
    ///          specifying the limit parameter in the request. The default limit is 50. The
    ///          number of jobs returned might be fewer than the limit, but the number of returned jobs
    ///          never exceeds the limit.
    ///
    ///         Additionally, you can filter the jobs list returned by specifying the optional
    ///             statuscode parameter or completed parameter, or both. Using
    ///          the statuscode parameter, you can specify to return only jobs that match
    ///          either the InProgress, Succeeded, or Failed status.
    ///          Using the completed parameter, you can specify to return only jobs that were
    ///          completed (true) or jobs that were not completed
    ///          (false).
    ///
    ///          For more information about using this operation,
    ///          see the documentation for the underlying REST API <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-jobs-get.html">List Jobs.
    public func listJobs(input: ListJobsInput, completion: @escaping (ClientRuntime.SdkResult<ListJobsOutputResponse, ListJobsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listJobs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListJobsInput, ListJobsOutputResponse, ListJobsOutputError>(id: "listJobs")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsOutputResponse>, ClientRuntime.SdkError<ListJobsOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: ListJobsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: ListJobsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListJobsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListJobsInput, ListJobsOutputResponse, ListJobsOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation lists in-progress multipart uploads for the specified vault. An
    ///          in-progress multipart upload is a multipart upload that has been initiated by an InitiateMultipartUpload request, but has not yet been completed or aborted.
    ///          The list returned in the List Multipart Upload response has no guaranteed order.
    ///
    ///          The List Multipart Uploads operation supports pagination. By default, this operation
    ///          returns up to 50 multipart uploads in the response. You should always check the response
    ///          for a marker at which to continue the list; if there are no more items the
    ///             marker is null. To return a list of multipart uploads that
    ///          begins at a specific upload, set the marker request parameter to the value you
    ///          obtained from a previous List Multipart Upload request. You can also limit the number of
    ///          uploads returned in the response by specifying the limit parameter in the
    ///          request.
    ///
    ///          Note the difference between this operation and listing parts (ListParts). The List Multipart Uploads operation lists all multipart uploads
    ///          for a vault and does not require a multipart upload ID. The List Parts operation requires a
    ///          multipart upload ID since parts are associated with a single upload.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///
    ///          For conceptual information and the underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html">Working
    ///             with Archives in Amazon S3 Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-uploads.html">List Multipart Uploads
    ///           in the Amazon Glacier Developer Guide.
    public func listMultipartUploads(input: ListMultipartUploadsInput, completion: @escaping (ClientRuntime.SdkResult<ListMultipartUploadsOutputResponse, ListMultipartUploadsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listMultipartUploads")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListMultipartUploadsInput, ListMultipartUploadsOutputResponse, ListMultipartUploadsOutputError>(id: "listMultipartUploads")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<ListMultipartUploadsOutputResponse>, ClientRuntime.SdkError<ListMultipartUploadsOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: ListMultipartUploadsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: ListMultipartUploadsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListMultipartUploadsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListMultipartUploadsInput, ListMultipartUploadsOutputResponse, ListMultipartUploadsOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation lists the parts of an archive that have been uploaded in a specific
    ///          multipart upload. You can make this request at any time during an in-progress multipart
    ///          upload before you complete the upload (see CompleteMultipartUpload. List
    ///          Parts returns an error for completed uploads. The list returned in the List Parts response
    ///          is sorted by part range.
    ///
    ///          The List Parts operation supports pagination. By default, this operation returns up
    ///          to 50 uploaded parts in the response. You should always check the response for a
    ///             marker at which to continue the list; if there are no more items the
    ///             marker is null. To return a list of parts that begins at a
    ///          specific part, set the marker request parameter to the value you obtained from
    ///          a previous List Parts request. You can also limit the number of parts returned in the
    ///          response by specifying the limit parameter in the request.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///          For conceptual information and the underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html">Working
    ///             with Archives in Amazon S3 Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-list-parts.html">List Parts in the
    ///             Amazon Glacier Developer Guide.
    public func listParts(input: ListPartsInput, completion: @escaping (ClientRuntime.SdkResult<ListPartsOutputResponse, ListPartsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listParts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListPartsInput, ListPartsOutputResponse, ListPartsOutputError>(id: "listParts")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<ListPartsOutputResponse>, ClientRuntime.SdkError<ListPartsOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: ListPartsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: ListPartsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListPartsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListPartsInput, ListPartsOutputResponse, ListPartsOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation lists the provisioned capacity units for the specified AWS
    ///          account.
    public func listProvisionedCapacity(input: ListProvisionedCapacityInput, completion: @escaping (ClientRuntime.SdkResult<ListProvisionedCapacityOutputResponse, ListProvisionedCapacityOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listProvisionedCapacity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListProvisionedCapacityInput, ListProvisionedCapacityOutputResponse, ListProvisionedCapacityOutputError>(id: "listProvisionedCapacity")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedCapacityOutputResponse>, ClientRuntime.SdkError<ListProvisionedCapacityOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: ListProvisionedCapacityInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: ListProvisionedCapacityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListProvisionedCapacityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListProvisionedCapacityInput, ListProvisionedCapacityOutputResponse, ListProvisionedCapacityOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation lists all the tags attached to a vault. The operation returns an empty
    ///          map if there are no tags. For more information about tags, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/tagging.html">Tagging Amazon S3 Glacier
    ///          Resources.
    public func listTagsForVault(input: ListTagsForVaultInput, completion: @escaping (ClientRuntime.SdkResult<ListTagsForVaultOutputResponse, ListTagsForVaultOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForVault")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListTagsForVaultInput, ListTagsForVaultOutputResponse, ListTagsForVaultOutputError>(id: "listTagsForVault")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForVaultOutputResponse>, ClientRuntime.SdkError<ListTagsForVaultOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: ListTagsForVaultInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: ListTagsForVaultInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListTagsForVaultInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListTagsForVaultInput, ListTagsForVaultOutputResponse, ListTagsForVaultOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation lists all vaults owned by the calling user's account. The list
    ///          returned in the response is ASCII-sorted by vault name.
    ///
    ///          By default, this operation returns up to 10 items. If there are more vaults to
    ///          list, the response marker field contains the vault Amazon Resource Name (ARN)
    ///          at which to continue the list with a new List Vaults request; otherwise, the
    ///             marker field is null. To return a list of vaults that begins
    ///          at a specific vault, set the marker request parameter to the vault ARN you
    ///          obtained from a previous List Vaults request. You can also limit the number of vaults
    ///          returned in the response by specifying the limit parameter in the request.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///          For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/retrieving-vault-info.html">Retrieving Vault Metadata in
    ///             Amazon S3 Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-vaults-get.html">List Vaults  in the
    ///             Amazon Glacier Developer Guide.
    public func listVaults(input: ListVaultsInput, completion: @escaping (ClientRuntime.SdkResult<ListVaultsOutputResponse, ListVaultsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVaults")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<ListVaultsInput, ListVaultsOutputResponse, ListVaultsOutputError>(id: "listVaults")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<ListVaultsOutputResponse>, ClientRuntime.SdkError<ListVaultsOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: ListVaultsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: ListVaultsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ListVaultsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ListVaultsInput, ListVaultsOutputResponse, ListVaultsOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation purchases a provisioned capacity unit for an AWS account.
    public func purchaseProvisionedCapacity(input: PurchaseProvisionedCapacityInput, completion: @escaping (ClientRuntime.SdkResult<PurchaseProvisionedCapacityOutputResponse, PurchaseProvisionedCapacityOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "purchaseProvisionedCapacity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<PurchaseProvisionedCapacityInput, PurchaseProvisionedCapacityOutputResponse, PurchaseProvisionedCapacityOutputError>(id: "purchaseProvisionedCapacity")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<PurchaseProvisionedCapacityOutputResponse>, ClientRuntime.SdkError<PurchaseProvisionedCapacityOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: PurchaseProvisionedCapacityInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: PurchaseProvisionedCapacityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: PurchaseProvisionedCapacityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<PurchaseProvisionedCapacityInput, PurchaseProvisionedCapacityOutputResponse, PurchaseProvisionedCapacityOutputError>(contentType: "application/json"))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation removes one or more tags from the set of tags attached to a vault. For
    ///          more information about tags, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/tagging.html">Tagging Amazon S3 Glacier Resources.
    ///          This operation is idempotent. The operation will be successful, even if there are no tags
    ///          attached to the vault.
    public func removeTagsFromVault(input: RemoveTagsFromVaultInput, completion: @escaping (ClientRuntime.SdkResult<RemoveTagsFromVaultOutputResponse, RemoveTagsFromVaultOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "removeTagsFromVault")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<RemoveTagsFromVaultInput, RemoveTagsFromVaultOutputResponse, RemoveTagsFromVaultOutputError>(id: "removeTagsFromVault")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromVaultOutputResponse>, ClientRuntime.SdkError<RemoveTagsFromVaultOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: RemoveTagsFromVaultInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: RemoveTagsFromVaultInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: RemoveTagsFromVaultInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<RemoveTagsFromVaultInput, RemoveTagsFromVaultOutputResponse, RemoveTagsFromVaultOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: RemoveTagsFromVaultInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation sets and then enacts a data retrieval policy in the region specified
    ///          in the PUT request. You can set one policy per region for an AWS account. The policy is
    ///          enacted within a few minutes of a successful PUT operation.
    ///          The set policy operation does not affect retrieval jobs that were in progress before
    ///          the policy was enacted. For more information about data retrieval policies, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/data-retrieval-policy.html">Amazon
    ///             Glacier Data Retrieval Policies.
    public func setDataRetrievalPolicy(input: SetDataRetrievalPolicyInput, completion: @escaping (ClientRuntime.SdkResult<SetDataRetrievalPolicyOutputResponse, SetDataRetrievalPolicyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setDataRetrievalPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<SetDataRetrievalPolicyInput, SetDataRetrievalPolicyOutputResponse, SetDataRetrievalPolicyOutputError>(id: "setDataRetrievalPolicy")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<SetDataRetrievalPolicyOutputResponse>, ClientRuntime.SdkError<SetDataRetrievalPolicyOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: SetDataRetrievalPolicyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: SetDataRetrievalPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: SetDataRetrievalPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<SetDataRetrievalPolicyInput, SetDataRetrievalPolicyOutputResponse, SetDataRetrievalPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: SetDataRetrievalPolicyInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation configures an access policy for a vault and will overwrite an existing
    ///          policy. To configure a vault access policy, send a PUT request to the
    ///             access-policy subresource of the vault. An access policy is specific to a
    ///          vault and is also called a vault subresource. You can set one access policy per vault and
    ///          the policy can be up to 20 KB in size. For more information about vault access policies,
    ///          see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/vault-access-policy.html">Amazon Glacier Access Control with Vault Access Policies.
    public func setVaultAccessPolicy(input: SetVaultAccessPolicyInput, completion: @escaping (ClientRuntime.SdkResult<SetVaultAccessPolicyOutputResponse, SetVaultAccessPolicyOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setVaultAccessPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<SetVaultAccessPolicyInput, SetVaultAccessPolicyOutputResponse, SetVaultAccessPolicyOutputError>(id: "setVaultAccessPolicy")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<SetVaultAccessPolicyOutputResponse>, ClientRuntime.SdkError<SetVaultAccessPolicyOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: SetVaultAccessPolicyInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: SetVaultAccessPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: SetVaultAccessPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<SetVaultAccessPolicyInput, SetVaultAccessPolicyOutputResponse, SetVaultAccessPolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: SetVaultAccessPolicyInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation configures notifications that will be sent when specific events happen
    ///          to a vault. By default, you don't get any notifications.
    ///
    ///          To configure vault notifications, send a PUT request to the
    ///             notification-configuration subresource of the vault. The request should
    ///          include a JSON document that provides an Amazon SNS topic and specific events for which you
    ///          want Amazon S3 Glacier to send notifications to the topic.
    ///
    ///          Amazon SNS topics must grant permission to the vault to be allowed to publish
    ///          notifications to the topic. You can configure a vault to publish a notification for the
    ///          following vault events:
    ///
    ///
    ///
    ///
    ///                   ArchiveRetrievalCompleted This event occurs when a
    ///                job that was initiated for an archive retrieval is completed (InitiateJob). The status of the completed job can be "Succeeded" or
    ///                "Failed". The notification sent to the SNS topic is the same output as returned from
    ///                   DescribeJob.
    ///
    ///
    ///
    ///
    ///                   InventoryRetrievalCompleted This event occurs when a
    ///                job that was initiated for an inventory retrieval is completed (InitiateJob). The status of the completed job can be "Succeeded" or
    ///                "Failed". The notification sent to the SNS topic is the same output as returned from
    ///                   DescribeJob.
    ///
    ///
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///          For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/configuring-notifications.html">Configuring Vault
    ///             Notifications in Amazon S3 Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-vault-notifications-put.html">Set Vault Notification
    ///             Configuration  in the Amazon Glacier Developer Guide.
    public func setVaultNotifications(input: SetVaultNotificationsInput, completion: @escaping (ClientRuntime.SdkResult<SetVaultNotificationsOutputResponse, SetVaultNotificationsOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "setVaultNotifications")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<SetVaultNotificationsInput, SetVaultNotificationsOutputResponse, SetVaultNotificationsOutputError>(id: "setVaultNotifications")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<SetVaultNotificationsOutputResponse>, ClientRuntime.SdkError<SetVaultNotificationsOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: SetVaultNotificationsInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: SetVaultNotificationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: SetVaultNotificationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<SetVaultNotificationsInput, SetVaultNotificationsOutputResponse, SetVaultNotificationsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: SetVaultNotificationsInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation adds an archive to a vault. This is a synchronous operation, and for a
    ///          successful upload, your data is durably persisted. Amazon S3 Glacier returns the archive ID in
    ///          the x-amz-archive-id header of the response.
    ///
    ///          You must use the archive ID to access your data in Amazon S3 Glacier. After you upload
    ///          an archive, you should save the archive ID returned so that you can retrieve or delete the
    ///          archive later. Besides saving the archive ID, you can also index it and give it a friendly
    ///          name to allow for better searching. You can also use the optional archive description field
    ///          to specify how the archive is referred to in an external index of archives, such as you
    ///          might create in Amazon DynamoDB. You can also get the vault inventory to obtain a list of
    ///          archive IDs in a vault. For more information, see InitiateJob.
    ///
    ///          You must provide a SHA256 tree hash of the data you are uploading. For information
    ///          about computing a SHA256 tree hash, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html">Computing Checksums.
    ///
    ///          You can optionally specify an archive description of up to 1,024 printable ASCII
    ///          characters. You can get the archive description when you either retrieve the archive or get
    ///          the vault inventory. For more information, see InitiateJob. Amazon
    ///          Glacier does not interpret the description in any way. An archive description does not need
    ///          to be unique. You cannot use the description to retrieve or sort the archive list.
    ///
    ///          Archives are immutable. After you upload an archive, you cannot edit the archive or
    ///          its description.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///           For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-an-archive.html">Uploading an Archive in Amazon
    ///             Glacier and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html">Upload Archive in the
    ///             Amazon Glacier Developer Guide.
    public func uploadArchive(input: UploadArchiveInput, completion: @escaping (ClientRuntime.SdkResult<UploadArchiveOutputResponse, UploadArchiveOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "uploadArchive")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<UploadArchiveInput, UploadArchiveOutputResponse, UploadArchiveOutputError>(id: "uploadArchive")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<UploadArchiveOutputResponse>, ClientRuntime.SdkError<UploadArchiveOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: UploadArchiveInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: UploadArchiveInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: UploadArchiveInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UploadArchiveInput, UploadArchiveOutputResponse, UploadArchiveOutputError>(contentType: "application/octet-stream"))
        operation.serializeStep.intercept(position: .after, middleware: UploadArchiveInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// This operation uploads a part of an archive. You can upload archive parts in any
    ///          order. You can also upload them in parallel. You can upload up to 10,000 parts for a
    ///          multipart upload.
    ///
    ///          Amazon Glacier rejects your upload part request if any of the following conditions is
    ///          true:
    ///
    ///
    ///
    ///
    ///                   SHA256 tree hash does not matchTo ensure that part
    ///                data is not corrupted in transmission, you compute a SHA256 tree hash of the part and
    ///                include it in your request. Upon receiving the part data, Amazon S3 Glacier also
    ///                computes a SHA256 tree hash. If these hash values don't match, the operation fails.
    ///                For information about computing a SHA256 tree hash, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/checksum-calculations.html">Computing
    ///                   Checksums.
    ///
    ///
    ///
    ///                   Part size does not matchThe size of each part except
    ///                the last must match the size specified in the corresponding InitiateMultipartUpload request. The size of the last part must be the
    ///                same size as, or smaller than, the specified size.
    ///
    ///                   If you upload a part whose size is smaller than the part size you specified
    ///                   in your initiate multipart upload request and that part is not the last part, then
    ///                   the upload part request will succeed. However, the subsequent Complete Multipart
    ///                   Upload request will fail.
    ///
    ///
    ///
    ///
    ///                   Range does not alignThe byte range value in the
    ///                request does not align with the part size specified in the corresponding initiate
    ///                request. For example, if you specify a part size of 4194304 bytes (4 MB), then 0 to
    ///                4194303 bytes (4 MB - 1) and 4194304 (4 MB) to 8388607 (8 MB - 1) are valid part
    ///                ranges. However, if you set a range value of 2 MB to 6 MB, the range does not align
    ///                with the part size and the upload will fail.
    ///
    ///
    ///
    ///          This operation is idempotent. If you upload the same part multiple times, the data
    ///          included in the most recent request overwrites the previously uploaded data.
    ///
    ///          An AWS account has full permission to perform all operations (actions). However, AWS
    ///          Identity and Access Management (IAM) users don't have any permissions by default. You must
    ///          grant them explicit permission to perform specific actions. For more information, see
    ///             <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/using-iam-with-amazon-glacier.html">Access Control Using
    ///             AWS Identity and Access Management (IAM).
    ///           For conceptual information and underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/uploading-archive-mpu.html">Uploading Large Archives in
    ///             Parts (Multipart Upload) and <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-upload-part.html">Upload Part  in the
    ///             Amazon Glacier Developer Guide.
    public func uploadMultipartPart(input: UploadMultipartPartInput, completion: @escaping (ClientRuntime.SdkResult<UploadMultipartPartOutputResponse, UploadMultipartPartOutputError>) -> Void)
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "uploadMultipartPart")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "glacier")
                      .withSigningRegion(value: config.signingRegion)
        var operation = ClientRuntime.OperationStack<UploadMultipartPartInput, UploadMultipartPartOutputResponse, UploadMultipartPartOutputError>(id: "uploadMultipartPart")
        operation.initializeStep.intercept(position: .before, id: "GlacierAccountIdAutoFill") { (context, input, next) -> Swift.Result<ClientRuntime.OperationOutput<UploadMultipartPartOutputResponse>, ClientRuntime.SdkError<UploadMultipartPartOutputError>> in
            guard let accountId = input.accountId, !accountId.isEmpty else {
                var copiedInput = input
                copiedInput.accountId = "-"
                return next.handle(context: context, input: copiedInput)
            }
            return next.handle(context: context, input: input)
        }
        operation.initializeStep.intercept(position: .after, middleware: UploadMultipartPartInputURLPathMiddleware())
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["X-Amz-Glacier-Version": "2012-06-01"]))
        operation.serializeStep.intercept(position: .after, middleware: UploadMultipartPartInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: UploadMultipartPartInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UploadMultipartPartInput, UploadMultipartPartOutputResponse, UploadMultipartPartOutputError>(contentType: "application/octet-stream"))
        operation.serializeStep.intercept(position: .after, middleware: UploadMultipartPartInputBodyMiddleware())
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware())
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
