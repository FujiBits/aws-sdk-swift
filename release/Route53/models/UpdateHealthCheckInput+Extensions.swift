// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

public struct UpdateHealthCheckInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateHealthCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHealthCheckInput>
    public typealias MOutput = OperationOutput<UpdateHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHealthCheckOutputError>
}

public struct UpdateHealthCheckInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateHealthCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHealthCheckInput>
    public typealias MOutput = OperationOutput<UpdateHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHealthCheckOutputError>
}

public struct UpdateHealthCheckInputBodyMiddleware: Middleware {
    public let id: String = "UpdateHealthCheckInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateHealthCheckInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateHealthCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateHealthCheckInput>
    public typealias MOutput = OperationOutput<UpdateHealthCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateHealthCheckOutputError>
}

extension UpdateHealthCheckInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmIdentifier = "AlarmIdentifier"
        case childHealthChecks = "ChildHealthChecks"
        case disabled = "Disabled"
        case enableSNI = "EnableSNI"
        case failureThreshold = "FailureThreshold"
        case fullyQualifiedDomainName = "FullyQualifiedDomainName"
        case healthCheckVersion = "HealthCheckVersion"
        case healthThreshold = "HealthThreshold"
        case iPAddress = "IPAddress"
        case insufficientDataHealthStatus = "InsufficientDataHealthStatus"
        case inverted = "Inverted"
        case port = "Port"
        case regions = "Regions"
        case resetElements = "ResetElements"
        case resourcePath = "ResourcePath"
        case searchString = "SearchString"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("https://route53.amazonaws.com/doc/2013-04-01/", forKey: Key("xmlns"))
        }
        if let alarmIdentifier = alarmIdentifier {
            try container.encode(alarmIdentifier, forKey: Key("alarmIdentifier"))
        }
        if let childHealthChecks = childHealthChecks {
            var childHealthChecksContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("childHealthChecks"))
            for healthcheckid0 in childHealthChecks {
                try childHealthChecksContainer.encode(healthcheckid0, forKey: Key("ChildHealthCheck"))
            }
        }
        if let disabled = disabled {
            try container.encode(disabled, forKey: Key("disabled"))
        }
        if let enableSNI = enableSNI {
            try container.encode(enableSNI, forKey: Key("enableSNI"))
        }
        if let failureThreshold = failureThreshold {
            try container.encode(failureThreshold, forKey: Key("failureThreshold"))
        }
        if let fullyQualifiedDomainName = fullyQualifiedDomainName {
            try container.encode(fullyQualifiedDomainName, forKey: Key("fullyQualifiedDomainName"))
        }
        if let healthCheckVersion = healthCheckVersion {
            try container.encode(healthCheckVersion, forKey: Key("healthCheckVersion"))
        }
        if let healthThreshold = healthThreshold {
            try container.encode(healthThreshold, forKey: Key("healthThreshold"))
        }
        if let iPAddress = iPAddress {
            try container.encode(iPAddress, forKey: Key("iPAddress"))
        }
        if let insufficientDataHealthStatus = insufficientDataHealthStatus {
            try container.encode(insufficientDataHealthStatus, forKey: Key("insufficientDataHealthStatus"))
        }
        if let inverted = inverted {
            try container.encode(inverted, forKey: Key("inverted"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("port"))
        }
        if let regions = regions {
            var regionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("regions"))
            for healthcheckregion0 in regions {
                try regionsContainer.encode(healthcheckregion0, forKey: Key("Region"))
            }
        }
        if let resetElements = resetElements {
            var resetElementsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("resetElements"))
            for resettableelementname0 in resetElements {
                try resetElementsContainer.encode(resettableelementname0, forKey: Key("ResettableElementName"))
            }
        }
        if let resourcePath = resourcePath {
            try container.encode(resourcePath, forKey: Key("resourcePath"))
        }
        if let searchString = searchString {
            try container.encode(searchString, forKey: Key("searchString"))
        }
    }
}
