// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension QldbSessionClientTypes.AbortTransactionRequest: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension QldbSessionClientTypes.AbortTransactionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbortTransactionRequest()"}
}

extension QldbSessionClientTypes {
    /// Contains the details of the transaction to abort.
    public struct AbortTransactionRequest: Swift.Equatable {

        public init() {}
    }

}

extension QldbSessionClientTypes.AbortTransactionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension QldbSessionClientTypes.AbortTransactionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbortTransactionResult(timingInformation: \(Swift.String(describing: timingInformation)))"}
}

extension QldbSessionClientTypes {
    /// Contains the details of the aborted transaction.
    public struct AbortTransactionResult: Swift.Equatable {
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.timingInformation = timingInformation
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the request is malformed or contains an error such as an invalid parameter
///          value or a missing required parameter.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CapacityExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CapacityExceededException(message: \(Swift.String(describing: message)))"}
}

extension CapacityExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CapacityExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned when the request exceeds the processing capacity of the ledger.
public struct CapacityExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CapacityExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CapacityExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QldbSessionClientTypes.CommitTransactionRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitDigest = "CommitDigest"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitDigest = commitDigest {
            try encodeContainer.encode(commitDigest.base64EncodedString(), forKey: .commitDigest)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let commitDigestDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .commitDigest)
        commitDigest = commitDigestDecoded
    }
}

extension QldbSessionClientTypes.CommitTransactionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CommitTransactionRequest(commitDigest: \(Swift.String(describing: commitDigest)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension QldbSessionClientTypes {
    /// Contains the details of the transaction to commit.
    public struct CommitTransactionRequest: Swift.Equatable {
        /// Specifies the commit digest for the transaction to commit. For every active transaction,
        ///          the commit digest must be passed. QLDB validates CommitDigest and rejects
        ///          the commit with an error if the digest computed on the client does not match the digest
        ///          computed by QLDB.
        ///          The purpose of the CommitDigest parameter is to ensure that QLDB commits
        ///          a transaction if and only if the server has processed the exact set of statements sent by
        ///          the client, in the same order that client sent them, and with no duplicates.
        /// This member is required.
        public var commitDigest: ClientRuntime.Data?
        /// Specifies the transaction ID of the transaction to commit.
        /// This member is required.
        public var transactionId: Swift.String?

        public init (
            commitDigest: ClientRuntime.Data? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.commitDigest = commitDigest
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.CommitTransactionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitDigest = "CommitDigest"
        case consumedIOs = "ConsumedIOs"
        case timingInformation = "TimingInformation"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitDigest = commitDigest {
            try encodeContainer.encode(commitDigest.base64EncodedString(), forKey: .commitDigest)
        }
        if let consumedIOs = consumedIOs {
            try encodeContainer.encode(consumedIOs, forKey: .consumedIOs)
        }
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let commitDigestDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .commitDigest)
        commitDigest = commitDigestDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
        let consumedIOsDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.IOUsage.self, forKey: .consumedIOs)
        consumedIOs = consumedIOsDecoded
    }
}

extension QldbSessionClientTypes.CommitTransactionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CommitTransactionResult(commitDigest: \(Swift.String(describing: commitDigest)), consumedIOs: \(Swift.String(describing: consumedIOs)), timingInformation: \(Swift.String(describing: timingInformation)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension QldbSessionClientTypes {
    /// Contains the details of the committed transaction.
    public struct CommitTransactionResult: Swift.Equatable {
        /// The commit digest of the committed transaction.
        public var commitDigest: ClientRuntime.Data?
        /// Contains metrics about the number of I/O requests that were consumed.
        public var consumedIOs: QldbSessionClientTypes.IOUsage?
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?
        /// The transaction ID of the committed transaction.
        public var transactionId: Swift.String?

        public init (
            commitDigest: ClientRuntime.Data? = nil,
            consumedIOs: QldbSessionClientTypes.IOUsage? = nil,
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.commitDigest = commitDigest
            self.consumedIOs = consumedIOs
            self.timingInformation = timingInformation
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.EndSessionRequest: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension QldbSessionClientTypes.EndSessionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndSessionRequest()"}
}

extension QldbSessionClientTypes {
    /// Specifies a request to end the session.
    public struct EndSessionRequest: Swift.Equatable {

        public init() {}
    }

}

extension QldbSessionClientTypes.EndSessionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension QldbSessionClientTypes.EndSessionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndSessionResult(timingInformation: \(Swift.String(describing: timingInformation)))"}
}

extension QldbSessionClientTypes {
    /// Contains the details of the ended session.
    public struct EndSessionResult: Swift.Equatable {
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.timingInformation = timingInformation
        }
    }

}

extension QldbSessionClientTypes.ExecuteStatementRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "Parameters"
        case statement = "Statement"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for statementparameters0 in parameters {
                try parametersContainer.encode(statementparameters0)
            }
        }
        if let statement = statement {
            try encodeContainer.encode(statement, forKey: .statement)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let statementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statement)
        statement = statementDecoded
        let parametersContainer = try containerValues.decodeIfPresent([QldbSessionClientTypes.ValueHolder?].self, forKey: .parameters)
        var parametersDecoded0:[QldbSessionClientTypes.ValueHolder]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [QldbSessionClientTypes.ValueHolder]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension QldbSessionClientTypes.ExecuteStatementRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteStatementRequest(parameters: \(Swift.String(describing: parameters)), statement: \(Swift.String(describing: statement)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension QldbSessionClientTypes {
    /// Specifies a request to execute a statement.
    public struct ExecuteStatementRequest: Swift.Equatable {
        /// Specifies the parameters for the parameterized statement in the request.
        public var parameters: [QldbSessionClientTypes.ValueHolder]?
        /// Specifies the statement of the request.
        /// This member is required.
        public var statement: Swift.String?
        /// Specifies the transaction ID of the request.
        /// This member is required.
        public var transactionId: Swift.String?

        public init (
            parameters: [QldbSessionClientTypes.ValueHolder]? = nil,
            statement: Swift.String? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.statement = statement
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.ExecuteStatementResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumedIOs = "ConsumedIOs"
        case firstPage = "FirstPage"
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedIOs = consumedIOs {
            try encodeContainer.encode(consumedIOs, forKey: .consumedIOs)
        }
        if let firstPage = firstPage {
            try encodeContainer.encode(firstPage, forKey: .firstPage)
        }
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firstPageDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.Page.self, forKey: .firstPage)
        firstPage = firstPageDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
        let consumedIOsDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.IOUsage.self, forKey: .consumedIOs)
        consumedIOs = consumedIOsDecoded
    }
}

extension QldbSessionClientTypes.ExecuteStatementResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteStatementResult(consumedIOs: \(Swift.String(describing: consumedIOs)), firstPage: \(Swift.String(describing: firstPage)), timingInformation: \(Swift.String(describing: timingInformation)))"}
}

extension QldbSessionClientTypes {
    /// Contains the details of the executed statement.
    public struct ExecuteStatementResult: Swift.Equatable {
        /// Contains metrics about the number of I/O requests that were consumed.
        public var consumedIOs: QldbSessionClientTypes.IOUsage?
        /// Contains the details of the first fetched page.
        public var firstPage: QldbSessionClientTypes.Page?
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            consumedIOs: QldbSessionClientTypes.IOUsage? = nil,
            firstPage: QldbSessionClientTypes.Page? = nil,
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.consumedIOs = consumedIOs
            self.firstPage = firstPage
            self.timingInformation = timingInformation
        }
    }

}

extension QldbSessionClientTypes.FetchPageRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension QldbSessionClientTypes.FetchPageRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FetchPageRequest(nextPageToken: \(Swift.String(describing: nextPageToken)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension QldbSessionClientTypes {
    /// Specifies the details of the page to be fetched.
    public struct FetchPageRequest: Swift.Equatable {
        /// Specifies the next page token of the page to be fetched.
        /// This member is required.
        public var nextPageToken: Swift.String?
        /// Specifies the transaction ID of the page to be fetched.
        /// This member is required.
        public var transactionId: Swift.String?

        public init (
            nextPageToken: Swift.String? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.nextPageToken = nextPageToken
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.FetchPageResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consumedIOs = "ConsumedIOs"
        case page = "Page"
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consumedIOs = consumedIOs {
            try encodeContainer.encode(consumedIOs, forKey: .consumedIOs)
        }
        if let page = page {
            try encodeContainer.encode(page, forKey: .page)
        }
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.Page.self, forKey: .page)
        page = pageDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
        let consumedIOsDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.IOUsage.self, forKey: .consumedIOs)
        consumedIOs = consumedIOsDecoded
    }
}

extension QldbSessionClientTypes.FetchPageResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FetchPageResult(consumedIOs: \(Swift.String(describing: consumedIOs)), page: \(Swift.String(describing: page)), timingInformation: \(Swift.String(describing: timingInformation)))"}
}

extension QldbSessionClientTypes {
    /// Contains the page that was fetched.
    public struct FetchPageResult: Swift.Equatable {
        /// Contains metrics about the number of I/O requests that were consumed.
        public var consumedIOs: QldbSessionClientTypes.IOUsage?
        /// Contains details of the fetched page.
        public var page: QldbSessionClientTypes.Page?
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            consumedIOs: QldbSessionClientTypes.IOUsage? = nil,
            page: QldbSessionClientTypes.Page? = nil,
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.consumedIOs = consumedIOs
            self.page = page
            self.timingInformation = timingInformation
        }
    }

}

extension QldbSessionClientTypes.IOUsage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readIOs = "ReadIOs"
        case writeIOs = "WriteIOs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if readIOs != 0 {
            try encodeContainer.encode(readIOs, forKey: .readIOs)
        }
        if writeIOs != 0 {
            try encodeContainer.encode(writeIOs, forKey: .writeIOs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readIOsDecoded = try containerValues.decode(Swift.Int.self, forKey: .readIOs)
        readIOs = readIOsDecoded
        let writeIOsDecoded = try containerValues.decode(Swift.Int.self, forKey: .writeIOs)
        writeIOs = writeIOsDecoded
    }
}

extension QldbSessionClientTypes.IOUsage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IOUsage(readIOs: \(Swift.String(describing: readIOs)), writeIOs: \(Swift.String(describing: writeIOs)))"}
}

extension QldbSessionClientTypes {
    /// Contains I/O usage metrics for a command that was invoked.
    public struct IOUsage: Swift.Equatable {
        /// The number of read I/O requests that the command made.
        public var readIOs: Swift.Int
        /// The number of write I/O requests that the command made.
        public var writeIOs: Swift.Int

        public init (
            readIOs: Swift.Int = 0,
            writeIOs: Swift.Int = 0
        )
        {
            self.readIOs = readIOs
            self.writeIOs = writeIOs
        }
    }

}

extension InvalidSessionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSessionException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InvalidSessionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSessionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if the session doesn't exist anymore because it timed out or expired.
public struct InvalidSessionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidSessionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let code: Swift.String?
}

extension InvalidSessionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned if a resource limit such as number of active sessions is exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OccConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OccConflictException(message: \(Swift.String(describing: message)))"}
}

extension OccConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OccConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned when a transaction cannot be written to the journal due to a failure in the
///          verification phase of optimistic concurrency control (OCC).
public struct OccConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OccConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OccConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QldbSessionClientTypes.Page: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valueholders0 in values {
                try valuesContainer.encode(valueholders0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([QldbSessionClientTypes.ValueHolder?].self, forKey: .values)
        var valuesDecoded0:[QldbSessionClientTypes.ValueHolder]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [QldbSessionClientTypes.ValueHolder]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension QldbSessionClientTypes.Page: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Page(nextPageToken: \(Swift.String(describing: nextPageToken)), values: \(Swift.String(describing: values)))"}
}

extension QldbSessionClientTypes {
    /// Contains details of the fetched page.
    public struct Page: Swift.Equatable {
        /// The token of the next page.
        public var nextPageToken: Swift.String?
        /// A structure that contains values in multiple encoding formats.
        public var values: [QldbSessionClientTypes.ValueHolder]?

        public init (
            nextPageToken: Swift.String? = nil,
            values: [QldbSessionClientTypes.ValueHolder]? = nil
        )
        {
            self.nextPageToken = nextPageToken
            self.values = values
        }
    }

}

extension RateExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RateExceededException(message: \(Swift.String(describing: message)))"}
}

extension RateExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RateExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returned when the rate of requests exceeds the allowed throughput.
public struct RateExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RateExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RateExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SendCommandInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendCommandInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendCommandInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendCommandOutputError>
}

extension SendCommandInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendCommandInput(abortTransaction: \(Swift.String(describing: abortTransaction)), commitTransaction: \(Swift.String(describing: commitTransaction)), endSession: \(Swift.String(describing: endSession)), executeStatement: \(Swift.String(describing: executeStatement)), fetchPage: \(Swift.String(describing: fetchPage)), sessionToken: \(Swift.String(describing: sessionToken)), startSession: \(Swift.String(describing: startSession)), startTransaction: \(Swift.String(describing: startTransaction)))"}
}

extension SendCommandInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortTransaction = "AbortTransaction"
        case commitTransaction = "CommitTransaction"
        case endSession = "EndSession"
        case executeStatement = "ExecuteStatement"
        case fetchPage = "FetchPage"
        case sessionToken = "SessionToken"
        case startSession = "StartSession"
        case startTransaction = "StartTransaction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortTransaction = abortTransaction {
            try encodeContainer.encode(abortTransaction, forKey: .abortTransaction)
        }
        if let commitTransaction = commitTransaction {
            try encodeContainer.encode(commitTransaction, forKey: .commitTransaction)
        }
        if let endSession = endSession {
            try encodeContainer.encode(endSession, forKey: .endSession)
        }
        if let executeStatement = executeStatement {
            try encodeContainer.encode(executeStatement, forKey: .executeStatement)
        }
        if let fetchPage = fetchPage {
            try encodeContainer.encode(fetchPage, forKey: .fetchPage)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
        if let startSession = startSession {
            try encodeContainer.encode(startSession, forKey: .startSession)
        }
        if let startTransaction = startTransaction {
            try encodeContainer.encode(startTransaction, forKey: .startTransaction)
        }
    }
}

public struct SendCommandInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendCommandInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendCommandInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendCommandOutputError>
}

public struct SendCommandInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendCommandInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendCommandInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendCommandInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendCommandOutputError>
}

public struct SendCommandInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendCommandInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SendCommandInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendCommandOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendCommandInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendCommandOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendCommandOutputError>
}

public struct SendCommandInput: Swift.Equatable {
    /// Command to abort the current transaction.
    public var abortTransaction: QldbSessionClientTypes.AbortTransactionRequest?
    /// Command to commit the specified transaction.
    public var commitTransaction: QldbSessionClientTypes.CommitTransactionRequest?
    /// Command to end the current session.
    public var endSession: QldbSessionClientTypes.EndSessionRequest?
    /// Command to execute a statement in the specified transaction.
    public var executeStatement: QldbSessionClientTypes.ExecuteStatementRequest?
    /// Command to fetch a page.
    public var fetchPage: QldbSessionClientTypes.FetchPageRequest?
    /// Specifies the session token for the current command. A session token is constant
    ///          throughout the life of the session.
    ///          To obtain a session token, run the StartSession command. This
    ///             SessionToken is required for every subsequent command that is issued during
    ///          the current session.
    public var sessionToken: Swift.String?
    /// Command to start a new session. A session token is obtained as part of the
    ///          response.
    public var startSession: QldbSessionClientTypes.StartSessionRequest?
    /// Command to start a new transaction.
    public var startTransaction: QldbSessionClientTypes.StartTransactionRequest?

    public init (
        abortTransaction: QldbSessionClientTypes.AbortTransactionRequest? = nil,
        commitTransaction: QldbSessionClientTypes.CommitTransactionRequest? = nil,
        endSession: QldbSessionClientTypes.EndSessionRequest? = nil,
        executeStatement: QldbSessionClientTypes.ExecuteStatementRequest? = nil,
        fetchPage: QldbSessionClientTypes.FetchPageRequest? = nil,
        sessionToken: Swift.String? = nil,
        startSession: QldbSessionClientTypes.StartSessionRequest? = nil,
        startTransaction: QldbSessionClientTypes.StartTransactionRequest? = nil
    )
    {
        self.abortTransaction = abortTransaction
        self.commitTransaction = commitTransaction
        self.endSession = endSession
        self.executeStatement = executeStatement
        self.fetchPage = fetchPage
        self.sessionToken = sessionToken
        self.startSession = startSession
        self.startTransaction = startTransaction
    }
}

struct SendCommandInputBody: Swift.Equatable {
    public let sessionToken: Swift.String?
    public let startSession: QldbSessionClientTypes.StartSessionRequest?
    public let startTransaction: QldbSessionClientTypes.StartTransactionRequest?
    public let endSession: QldbSessionClientTypes.EndSessionRequest?
    public let commitTransaction: QldbSessionClientTypes.CommitTransactionRequest?
    public let abortTransaction: QldbSessionClientTypes.AbortTransactionRequest?
    public let executeStatement: QldbSessionClientTypes.ExecuteStatementRequest?
    public let fetchPage: QldbSessionClientTypes.FetchPageRequest?
}

extension SendCommandInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortTransaction = "AbortTransaction"
        case commitTransaction = "CommitTransaction"
        case endSession = "EndSession"
        case executeStatement = "ExecuteStatement"
        case fetchPage = "FetchPage"
        case sessionToken = "SessionToken"
        case startSession = "StartSession"
        case startTransaction = "StartTransaction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let startSessionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.StartSessionRequest.self, forKey: .startSession)
        startSession = startSessionDecoded
        let startTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.StartTransactionRequest.self, forKey: .startTransaction)
        startTransaction = startTransactionDecoded
        let endSessionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.EndSessionRequest.self, forKey: .endSession)
        endSession = endSessionDecoded
        let commitTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.CommitTransactionRequest.self, forKey: .commitTransaction)
        commitTransaction = commitTransactionDecoded
        let abortTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.AbortTransactionRequest.self, forKey: .abortTransaction)
        abortTransaction = abortTransactionDecoded
        let executeStatementDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.ExecuteStatementRequest.self, forKey: .executeStatement)
        executeStatement = executeStatementDecoded
        let fetchPageDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.FetchPageRequest.self, forKey: .fetchPage)
        fetchPage = fetchPageDecoded
    }
}

extension SendCommandOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendCommandOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CapacityExceededException" : self = .capacityExceededException(try CapacityExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSessionException" : self = .invalidSessionException(try InvalidSessionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OccConflictException" : self = .occConflictException(try OccConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RateExceededException" : self = .rateExceededException(try RateExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendCommandOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case capacityExceededException(CapacityExceededException)
    case invalidSessionException(InvalidSessionException)
    case limitExceededException(LimitExceededException)
    case occConflictException(OccConflictException)
    case rateExceededException(RateExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendCommandOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendCommandOutputResponse(abortTransaction: \(Swift.String(describing: abortTransaction)), commitTransaction: \(Swift.String(describing: commitTransaction)), endSession: \(Swift.String(describing: endSession)), executeStatement: \(Swift.String(describing: executeStatement)), fetchPage: \(Swift.String(describing: fetchPage)), startSession: \(Swift.String(describing: startSession)), startTransaction: \(Swift.String(describing: startTransaction)))"}
}

extension SendCommandOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendCommandOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.abortTransaction = output.abortTransaction
            self.commitTransaction = output.commitTransaction
            self.endSession = output.endSession
            self.executeStatement = output.executeStatement
            self.fetchPage = output.fetchPage
            self.startSession = output.startSession
            self.startTransaction = output.startTransaction
        } else {
            self.abortTransaction = nil
            self.commitTransaction = nil
            self.endSession = nil
            self.executeStatement = nil
            self.fetchPage = nil
            self.startSession = nil
            self.startTransaction = nil
        }
    }
}

public struct SendCommandOutputResponse: Swift.Equatable {
    /// Contains the details of the aborted transaction.
    public var abortTransaction: QldbSessionClientTypes.AbortTransactionResult?
    /// Contains the details of the committed transaction.
    public var commitTransaction: QldbSessionClientTypes.CommitTransactionResult?
    /// Contains the details of the ended session.
    public var endSession: QldbSessionClientTypes.EndSessionResult?
    /// Contains the details of the executed statement.
    public var executeStatement: QldbSessionClientTypes.ExecuteStatementResult?
    /// Contains the details of the fetched page.
    public var fetchPage: QldbSessionClientTypes.FetchPageResult?
    /// Contains the details of the started session that includes a session token. This
    ///             SessionToken is required for every subsequent command that is issued during
    ///          the current session.
    public var startSession: QldbSessionClientTypes.StartSessionResult?
    /// Contains the details of the started transaction.
    public var startTransaction: QldbSessionClientTypes.StartTransactionResult?

    public init (
        abortTransaction: QldbSessionClientTypes.AbortTransactionResult? = nil,
        commitTransaction: QldbSessionClientTypes.CommitTransactionResult? = nil,
        endSession: QldbSessionClientTypes.EndSessionResult? = nil,
        executeStatement: QldbSessionClientTypes.ExecuteStatementResult? = nil,
        fetchPage: QldbSessionClientTypes.FetchPageResult? = nil,
        startSession: QldbSessionClientTypes.StartSessionResult? = nil,
        startTransaction: QldbSessionClientTypes.StartTransactionResult? = nil
    )
    {
        self.abortTransaction = abortTransaction
        self.commitTransaction = commitTransaction
        self.endSession = endSession
        self.executeStatement = executeStatement
        self.fetchPage = fetchPage
        self.startSession = startSession
        self.startTransaction = startTransaction
    }
}

struct SendCommandOutputResponseBody: Swift.Equatable {
    public let startSession: QldbSessionClientTypes.StartSessionResult?
    public let startTransaction: QldbSessionClientTypes.StartTransactionResult?
    public let endSession: QldbSessionClientTypes.EndSessionResult?
    public let commitTransaction: QldbSessionClientTypes.CommitTransactionResult?
    public let abortTransaction: QldbSessionClientTypes.AbortTransactionResult?
    public let executeStatement: QldbSessionClientTypes.ExecuteStatementResult?
    public let fetchPage: QldbSessionClientTypes.FetchPageResult?
}

extension SendCommandOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortTransaction = "AbortTransaction"
        case commitTransaction = "CommitTransaction"
        case endSession = "EndSession"
        case executeStatement = "ExecuteStatement"
        case fetchPage = "FetchPage"
        case startSession = "StartSession"
        case startTransaction = "StartTransaction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startSessionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.StartSessionResult.self, forKey: .startSession)
        startSession = startSessionDecoded
        let startTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.StartTransactionResult.self, forKey: .startTransaction)
        startTransaction = startTransactionDecoded
        let endSessionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.EndSessionResult.self, forKey: .endSession)
        endSession = endSessionDecoded
        let commitTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.CommitTransactionResult.self, forKey: .commitTransaction)
        commitTransaction = commitTransactionDecoded
        let abortTransactionDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.AbortTransactionResult.self, forKey: .abortTransaction)
        abortTransaction = abortTransactionDecoded
        let executeStatementDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.ExecuteStatementResult.self, forKey: .executeStatement)
        executeStatement = executeStatementDecoded
        let fetchPageDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.FetchPageResult.self, forKey: .fetchPage)
        fetchPage = fetchPageDecoded
    }
}

extension QldbSessionClientTypes.StartSessionRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ledgerName = "LedgerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ledgerName = ledgerName {
            try encodeContainer.encode(ledgerName, forKey: .ledgerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ledgerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ledgerName)
        ledgerName = ledgerNameDecoded
    }
}

extension QldbSessionClientTypes.StartSessionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSessionRequest(ledgerName: \(Swift.String(describing: ledgerName)))"}
}

extension QldbSessionClientTypes {
    /// Specifies a request to start a new session.
    public struct StartSessionRequest: Swift.Equatable {
        /// The name of the ledger to start a new session against.
        /// This member is required.
        public var ledgerName: Swift.String?

        public init (
            ledgerName: Swift.String? = nil
        )
        {
            self.ledgerName = ledgerName
        }
    }

}

extension QldbSessionClientTypes.StartSessionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionToken = "SessionToken"
        case timingInformation = "TimingInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension QldbSessionClientTypes.StartSessionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSessionResult(sessionToken: \(Swift.String(describing: sessionToken)), timingInformation: \(Swift.String(describing: timingInformation)))"}
}

extension QldbSessionClientTypes {
    /// Contains the details of the started session.
    public struct StartSessionResult: Swift.Equatable {
        /// Session token of the started session. This SessionToken is required for
        ///          every subsequent command that is issued during the current session.
        public var sessionToken: Swift.String?
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?

        public init (
            sessionToken: Swift.String? = nil,
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil
        )
        {
            self.sessionToken = sessionToken
            self.timingInformation = timingInformation
        }
    }

}

extension QldbSessionClientTypes.StartTransactionRequest: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension QldbSessionClientTypes.StartTransactionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartTransactionRequest()"}
}

extension QldbSessionClientTypes {
    /// Specifies a request to start a transaction.
    public struct StartTransactionRequest: Swift.Equatable {

        public init() {}
    }

}

extension QldbSessionClientTypes.StartTransactionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timingInformation = "TimingInformation"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timingInformation = timingInformation {
            try encodeContainer.encode(timingInformation, forKey: .timingInformation)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let timingInformationDecoded = try containerValues.decodeIfPresent(QldbSessionClientTypes.TimingInformation.self, forKey: .timingInformation)
        timingInformation = timingInformationDecoded
    }
}

extension QldbSessionClientTypes.StartTransactionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartTransactionResult(timingInformation: \(Swift.String(describing: timingInformation)), transactionId: \(Swift.String(describing: transactionId)))"}
}

extension QldbSessionClientTypes {
    /// Contains the details of the started transaction.
    public struct StartTransactionResult: Swift.Equatable {
        /// Contains server-side performance information for the command.
        public var timingInformation: QldbSessionClientTypes.TimingInformation?
        /// The transaction ID of the started transaction.
        public var transactionId: Swift.String?

        public init (
            timingInformation: QldbSessionClientTypes.TimingInformation? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.timingInformation = timingInformation
            self.transactionId = transactionId
        }
    }

}

extension QldbSessionClientTypes.TimingInformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case processingTimeMilliseconds = "ProcessingTimeMilliseconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if processingTimeMilliseconds != 0 {
            try encodeContainer.encode(processingTimeMilliseconds, forKey: .processingTimeMilliseconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingTimeMillisecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .processingTimeMilliseconds)
        processingTimeMilliseconds = processingTimeMillisecondsDecoded
    }
}

extension QldbSessionClientTypes.TimingInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimingInformation(processingTimeMilliseconds: \(Swift.String(describing: processingTimeMilliseconds)))"}
}

extension QldbSessionClientTypes {
    /// Contains server-side performance information for a command. Amazon QLDB captures timing
    ///          information between the times when it receives the request and when it sends the
    ///          corresponding response.
    public struct TimingInformation: Swift.Equatable {
        /// The amount of time that QLDB spent on processing the command, measured in
        ///          milliseconds.
        public var processingTimeMilliseconds: Swift.Int

        public init (
            processingTimeMilliseconds: Swift.Int = 0
        )
        {
            self.processingTimeMilliseconds = processingTimeMilliseconds
        }
    }

}

extension QldbSessionClientTypes.ValueHolder: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ionBinary = "IonBinary"
        case ionText = "IonText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ionBinary = ionBinary {
            try encodeContainer.encode(ionBinary.base64EncodedString(), forKey: .ionBinary)
        }
        if let ionText = ionText {
            try encodeContainer.encode(ionText, forKey: .ionText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ionBinaryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .ionBinary)
        ionBinary = ionBinaryDecoded
        let ionTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ionText)
        ionText = ionTextDecoded
    }
}

extension QldbSessionClientTypes.ValueHolder: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValueHolder(ionBinary: \(Swift.String(describing: ionBinary)), ionText: \(Swift.String(describing: ionText)))"}
}

extension QldbSessionClientTypes {
    /// A structure that can contain a value in multiple encoding formats.
    public struct ValueHolder: Swift.Equatable {
        /// An Amazon Ion binary value contained in a ValueHolder structure.
        public var ionBinary: ClientRuntime.Data?
        /// An Amazon Ion plaintext value contained in a ValueHolder structure.
        public var ionText: Swift.String?

        public init (
            ionBinary: ClientRuntime.Data? = nil,
            ionText: Swift.String? = nil
        )
        {
            self.ionBinary = ionBinary
            self.ionText = ionText
        }
    }

}
