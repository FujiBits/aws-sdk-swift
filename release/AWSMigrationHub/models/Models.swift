// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubClientTypes.ApplicationState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case applicationStatus = "ApplicationStatus"
        case lastUpdatedTime = "LastUpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let applicationStatus = applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension MigrationHubClientTypes.ApplicationState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApplicationState(applicationId: \(Swift.String(describing: applicationId)), applicationStatus: \(Swift.String(describing: applicationStatus)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)))"}
}

extension MigrationHubClientTypes {
    /// The state of an application discovered through Migration Hub import, the AWS Agentless Discovery Connector, or the AWS Application Discovery Agent.
    public struct ApplicationState: Swift.Equatable {
        /// The configurationId from the Application Discovery Service that uniquely identifies an application.
        public var applicationId: Swift.String?
        /// The current status of an application.
        public var applicationStatus: MigrationHubClientTypes.ApplicationStatus?
        /// The timestamp when the application status was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?

        public init (
            applicationId: Swift.String? = nil,
            applicationStatus: MigrationHubClientTypes.ApplicationStatus? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.applicationStatus = applicationStatus
            self.lastUpdatedTime = lastUpdatedTime
        }
    }

}

extension MigrationHubClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

public struct AssociateCreatedArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCreatedArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCreatedArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCreatedArtifactOutputError>
}

extension AssociateCreatedArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCreatedArtifactInput(createdArtifact: \(Swift.String(describing: createdArtifact)), dryRun: \(Swift.String(describing: dryRun)), migrationTaskName: \(Swift.String(describing: migrationTaskName)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)))"}
}

extension AssociateCreatedArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifact = "CreatedArtifact"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdArtifact = createdArtifact {
            try encodeContainer.encode(createdArtifact, forKey: .createdArtifact)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct AssociateCreatedArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCreatedArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCreatedArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCreatedArtifactOutputError>
}

public struct AssociateCreatedArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCreatedArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateCreatedArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCreatedArtifactOutputError>
}

public struct AssociateCreatedArtifactInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCreatedArtifactInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateCreatedArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateCreatedArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCreatedArtifactOutputError>
}

public struct AssociateCreatedArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateCreatedArtifactInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateCreatedArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateCreatedArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateCreatedArtifactOutputError>
}

public struct AssociateCreatedArtifactInput: Swift.Equatable {
    /// An ARN of the AWS resource related to the migration (e.g., AMI, EC2 instance, RDS instance, etc.)
    /// This member is required.
    public var createdArtifact: MigrationHubClientTypes.CreatedArtifact?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        createdArtifact: MigrationHubClientTypes.CreatedArtifact? = nil,
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.createdArtifact = createdArtifact
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct AssociateCreatedArtifactInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
    public let createdArtifact: MigrationHubClientTypes.CreatedArtifact?
    public let dryRun: Swift.Bool
}

extension AssociateCreatedArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifact = "CreatedArtifact"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let createdArtifactDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.CreatedArtifact.self, forKey: .createdArtifact)
        createdArtifact = createdArtifactDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension AssociateCreatedArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCreatedArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateCreatedArtifactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCreatedArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateCreatedArtifactOutputResponse()"}
}

extension AssociateCreatedArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateCreatedArtifactOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateCreatedArtifactOutputResponseBody: Swift.Equatable {
}

extension AssociateCreatedArtifactOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociateDiscoveredResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDiscoveredResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDiscoveredResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDiscoveredResourceOutputError>
}

extension AssociateDiscoveredResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateDiscoveredResourceInput(discoveredResource: \(Swift.String(describing: discoveredResource)), dryRun: \(Swift.String(describing: dryRun)), migrationTaskName: \(Swift.String(describing: migrationTaskName)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)))"}
}

extension AssociateDiscoveredResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredResource = "DiscoveredResource"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let discoveredResource = discoveredResource {
            try encodeContainer.encode(discoveredResource, forKey: .discoveredResource)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct AssociateDiscoveredResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDiscoveredResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDiscoveredResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDiscoveredResourceOutputError>
}

public struct AssociateDiscoveredResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDiscoveredResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDiscoveredResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDiscoveredResourceOutputError>
}

public struct AssociateDiscoveredResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDiscoveredResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateDiscoveredResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateDiscoveredResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDiscoveredResourceOutputError>
}

public struct AssociateDiscoveredResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDiscoveredResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateDiscoveredResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateDiscoveredResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDiscoveredResourceOutputError>
}

public struct AssociateDiscoveredResourceInput: Swift.Equatable {
    /// Object representing a Resource.
    /// This member is required.
    public var discoveredResource: MigrationHubClientTypes.DiscoveredResource?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// The identifier given to the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        discoveredResource: MigrationHubClientTypes.DiscoveredResource? = nil,
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.discoveredResource = discoveredResource
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct AssociateDiscoveredResourceInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
    public let discoveredResource: MigrationHubClientTypes.DiscoveredResource?
    public let dryRun: Swift.Bool
}

extension AssociateDiscoveredResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredResource = "DiscoveredResource"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let discoveredResourceDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.DiscoveredResource.self, forKey: .discoveredResource)
        discoveredResource = discoveredResourceDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension AssociateDiscoveredResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDiscoveredResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDiscoveredResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDiscoveredResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateDiscoveredResourceOutputResponse()"}
}

extension AssociateDiscoveredResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDiscoveredResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateDiscoveredResourceOutputResponseBody: Swift.Equatable {
}

extension AssociateDiscoveredResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateProgressUpdateStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgressUpdateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProgressUpdateStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgressUpdateStreamOutputError>
}

extension CreateProgressUpdateStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProgressUpdateStreamInput(dryRun: \(Swift.String(describing: dryRun)), progressUpdateStreamName: \(Swift.String(describing: progressUpdateStreamName)))"}
}

extension CreateProgressUpdateStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let progressUpdateStreamName = progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }
}

public struct CreateProgressUpdateStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgressUpdateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProgressUpdateStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgressUpdateStreamOutputError>
}

public struct CreateProgressUpdateStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgressUpdateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProgressUpdateStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgressUpdateStreamOutputError>
}

public struct CreateProgressUpdateStreamInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgressUpdateStreamInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateProgressUpdateStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProgressUpdateStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgressUpdateStreamOutputError>
}

public struct CreateProgressUpdateStreamInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProgressUpdateStreamInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateProgressUpdateStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProgressUpdateStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProgressUpdateStreamOutputError>
}

public struct CreateProgressUpdateStreamInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// The name of the ProgressUpdateStream. Do not store personal data in this field.
    /// This member is required.
    public var progressUpdateStreamName: Swift.String?

    public init (
        dryRun: Swift.Bool = false,
        progressUpdateStreamName: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.progressUpdateStreamName = progressUpdateStreamName
    }
}

struct CreateProgressUpdateStreamInputBody: Swift.Equatable {
    public let progressUpdateStreamName: Swift.String?
    public let dryRun: Swift.Bool
}

extension CreateProgressUpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateProgressUpdateStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProgressUpdateStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProgressUpdateStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProgressUpdateStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProgressUpdateStreamOutputResponse()"}
}

extension CreateProgressUpdateStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateProgressUpdateStreamOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateProgressUpdateStreamOutputResponseBody: Swift.Equatable {
}

extension CreateProgressUpdateStreamOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MigrationHubClientTypes.CreatedArtifact: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MigrationHubClientTypes.CreatedArtifact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatedArtifact(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)))"}
}

extension MigrationHubClientTypes {
    /// An ARN of the AWS cloud resource target receiving the migration (e.g., AMI, EC2 instance, RDS instance, etc.).
    public struct CreatedArtifact: Swift.Equatable {
        /// A description that can be free-form text to record additional detail about the artifact for clarity or for later reference.
        public var description: Swift.String?
        /// An ARN that uniquely identifies the result of a migration task.
        /// This member is required.
        public var name: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
        }
    }

}

public struct DeleteProgressUpdateStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProgressUpdateStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProgressUpdateStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProgressUpdateStreamOutputError>
}

extension DeleteProgressUpdateStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProgressUpdateStreamInput(dryRun: \(Swift.String(describing: dryRun)), progressUpdateStreamName: \(Swift.String(describing: progressUpdateStreamName)))"}
}

extension DeleteProgressUpdateStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let progressUpdateStreamName = progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }
}

public struct DeleteProgressUpdateStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProgressUpdateStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProgressUpdateStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProgressUpdateStreamOutputError>
}

public struct DeleteProgressUpdateStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProgressUpdateStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProgressUpdateStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProgressUpdateStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProgressUpdateStreamOutputError>
}

public struct DeleteProgressUpdateStreamInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProgressUpdateStreamInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteProgressUpdateStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProgressUpdateStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProgressUpdateStreamOutputError>
}

public struct DeleteProgressUpdateStreamInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProgressUpdateStreamInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteProgressUpdateStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProgressUpdateStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProgressUpdateStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProgressUpdateStreamOutputError>
}

public struct DeleteProgressUpdateStreamInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// The name of the ProgressUpdateStream. Do not store personal data in this field.
    /// This member is required.
    public var progressUpdateStreamName: Swift.String?

    public init (
        dryRun: Swift.Bool = false,
        progressUpdateStreamName: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.progressUpdateStreamName = progressUpdateStreamName
    }
}

struct DeleteProgressUpdateStreamInputBody: Swift.Equatable {
    public let progressUpdateStreamName: Swift.String?
    public let dryRun: Swift.Bool
}

extension DeleteProgressUpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension DeleteProgressUpdateStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProgressUpdateStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProgressUpdateStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProgressUpdateStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProgressUpdateStreamOutputResponse()"}
}

extension DeleteProgressUpdateStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProgressUpdateStreamOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProgressUpdateStreamOutputResponseBody: Swift.Equatable {
}

extension DeleteProgressUpdateStreamOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeApplicationStateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApplicationStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeApplicationStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeApplicationStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApplicationStateOutputError>
}

extension DescribeApplicationStateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeApplicationStateInput(applicationId: \(Swift.String(describing: applicationId)))"}
}

extension DescribeApplicationStateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
    }
}

public struct DescribeApplicationStateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApplicationStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeApplicationStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeApplicationStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApplicationStateOutputError>
}

public struct DescribeApplicationStateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApplicationStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeApplicationStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeApplicationStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApplicationStateOutputError>
}

public struct DescribeApplicationStateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApplicationStateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeApplicationStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeApplicationStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApplicationStateOutputError>
}

public struct DescribeApplicationStateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeApplicationStateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeApplicationStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeApplicationStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeApplicationStateOutputError>
}

public struct DescribeApplicationStateInput: Swift.Equatable {
    /// The configurationId in Application Discovery Service that uniquely identifies the grouped application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DescribeApplicationStateInputBody: Swift.Equatable {
    public let applicationId: Swift.String?
}

extension DescribeApplicationStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
    }
}

extension DescribeApplicationStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationStateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeApplicationStateOutputResponse(applicationStatus: \(Swift.String(describing: applicationStatus)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)))"}
}

extension DescribeApplicationStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeApplicationStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationStatus = output.applicationStatus
            self.lastUpdatedTime = output.lastUpdatedTime
        } else {
            self.applicationStatus = nil
            self.lastUpdatedTime = nil
        }
    }
}

public struct DescribeApplicationStateOutputResponse: Swift.Equatable {
    /// Status of the application - Not Started, In-Progress, Complete.
    public var applicationStatus: MigrationHubClientTypes.ApplicationStatus?
    /// The timestamp when the application status was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?

    public init (
        applicationStatus: MigrationHubClientTypes.ApplicationStatus? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil
    )
    {
        self.applicationStatus = applicationStatus
        self.lastUpdatedTime = lastUpdatedTime
    }
}

struct DescribeApplicationStateOutputResponseBody: Swift.Equatable {
    public let applicationStatus: MigrationHubClientTypes.ApplicationStatus?
    public let lastUpdatedTime: ClientRuntime.Date?
}

extension DescribeApplicationStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationStatus = "ApplicationStatus"
        case lastUpdatedTime = "LastUpdatedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationStatusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

public struct DescribeMigrationTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMigrationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMigrationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMigrationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMigrationTaskOutputError>
}

extension DescribeMigrationTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMigrationTaskInput(migrationTaskName: \(Swift.String(describing: migrationTaskName)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)))"}
}

extension DescribeMigrationTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct DescribeMigrationTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMigrationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMigrationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMigrationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMigrationTaskOutputError>
}

public struct DescribeMigrationTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMigrationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMigrationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMigrationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMigrationTaskOutputError>
}

public struct DescribeMigrationTaskInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMigrationTaskInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMigrationTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMigrationTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMigrationTaskOutputError>
}

public struct DescribeMigrationTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMigrationTaskInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMigrationTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMigrationTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMigrationTaskOutputError>
}

public struct DescribeMigrationTaskInput: Swift.Equatable {
    /// The identifier given to the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DescribeMigrationTaskInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
}

extension DescribeMigrationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
    }
}

extension DescribeMigrationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMigrationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMigrationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMigrationTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMigrationTaskOutputResponse(migrationTask: \(Swift.String(describing: migrationTask)))"}
}

extension DescribeMigrationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMigrationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.migrationTask = output.migrationTask
        } else {
            self.migrationTask = nil
        }
    }
}

public struct DescribeMigrationTaskOutputResponse: Swift.Equatable {
    /// Object encapsulating information about the migration task.
    public var migrationTask: MigrationHubClientTypes.MigrationTask?

    public init (
        migrationTask: MigrationHubClientTypes.MigrationTask? = nil
    )
    {
        self.migrationTask = migrationTask
    }
}

struct DescribeMigrationTaskOutputResponseBody: Swift.Equatable {
    public let migrationTask: MigrationHubClientTypes.MigrationTask?
}

extension DescribeMigrationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTask = "MigrationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationTaskDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.MigrationTask.self, forKey: .migrationTask)
        migrationTask = migrationTaskDecoded
    }
}

public struct DisassociateCreatedArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCreatedArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCreatedArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCreatedArtifactOutputError>
}

extension DisassociateCreatedArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCreatedArtifactInput(createdArtifactName: \(Swift.String(describing: createdArtifactName)), dryRun: \(Swift.String(describing: dryRun)), migrationTaskName: \(Swift.String(describing: migrationTaskName)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)))"}
}

extension DisassociateCreatedArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifactName = "CreatedArtifactName"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdArtifactName = createdArtifactName {
            try encodeContainer.encode(createdArtifactName, forKey: .createdArtifactName)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct DisassociateCreatedArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCreatedArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCreatedArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCreatedArtifactOutputError>
}

public struct DisassociateCreatedArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCreatedArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateCreatedArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateCreatedArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCreatedArtifactOutputError>
}

public struct DisassociateCreatedArtifactInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCreatedArtifactInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateCreatedArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateCreatedArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCreatedArtifactOutputError>
}

public struct DisassociateCreatedArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateCreatedArtifactInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateCreatedArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateCreatedArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateCreatedArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateCreatedArtifactOutputError>
}

public struct DisassociateCreatedArtifactInput: Swift.Equatable {
    /// An ARN of the AWS resource related to the migration (e.g., AMI, EC2 instance, RDS instance, etc.)
    /// This member is required.
    public var createdArtifactName: Swift.String?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task to be disassociated with the artifact. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        createdArtifactName: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.createdArtifactName = createdArtifactName
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DisassociateCreatedArtifactInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
    public let createdArtifactName: Swift.String?
    public let dryRun: Swift.Bool
}

extension DisassociateCreatedArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifactName = "CreatedArtifactName"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let createdArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdArtifactName)
        createdArtifactName = createdArtifactNameDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension DisassociateCreatedArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCreatedArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateCreatedArtifactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCreatedArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateCreatedArtifactOutputResponse()"}
}

extension DisassociateCreatedArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateCreatedArtifactOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateCreatedArtifactOutputResponseBody: Swift.Equatable {
}

extension DisassociateCreatedArtifactOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateDiscoveredResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDiscoveredResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDiscoveredResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDiscoveredResourceOutputError>
}

extension DisassociateDiscoveredResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateDiscoveredResourceInput(configurationId: \(Swift.String(describing: configurationId)), dryRun: \(Swift.String(describing: dryRun)), migrationTaskName: \(Swift.String(describing: migrationTaskName)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)))"}
}

extension DisassociateDiscoveredResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "ConfigurationId"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct DisassociateDiscoveredResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDiscoveredResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDiscoveredResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDiscoveredResourceOutputError>
}

public struct DisassociateDiscoveredResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDiscoveredResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDiscoveredResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDiscoveredResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDiscoveredResourceOutputError>
}

public struct DisassociateDiscoveredResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDiscoveredResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateDiscoveredResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateDiscoveredResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDiscoveredResourceOutputError>
}

public struct DisassociateDiscoveredResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDiscoveredResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateDiscoveredResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateDiscoveredResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDiscoveredResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDiscoveredResourceOutputError>
}

public struct DisassociateDiscoveredResourceInput: Swift.Equatable {
    /// ConfigurationId of the Application Discovery Service resource to be disassociated.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// The identifier given to the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DisassociateDiscoveredResourceInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
    public let configurationId: Swift.String?
    public let dryRun: Swift.Bool
}

extension DisassociateDiscoveredResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "ConfigurationId"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension DisassociateDiscoveredResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDiscoveredResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDiscoveredResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDiscoveredResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateDiscoveredResourceOutputResponse()"}
}

extension DisassociateDiscoveredResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDiscoveredResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateDiscoveredResourceOutputResponseBody: Swift.Equatable {
}

extension DisassociateDiscoveredResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MigrationHubClientTypes.DiscoveredResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "ConfigurationId"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MigrationHubClientTypes.DiscoveredResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DiscoveredResource(configurationId: \(Swift.String(describing: configurationId)), description: \(Swift.String(describing: description)))"}
}

extension MigrationHubClientTypes {
    /// Object representing the on-premises resource being migrated.
    public struct DiscoveredResource: Swift.Equatable {
        /// The configurationId in Application Discovery Service that uniquely identifies the on-premise resource.
        /// This member is required.
        public var configurationId: Swift.String?
        /// A description that can be free-form text to record additional detail about the discovered resource for clarity or later reference.
        public var description: Swift.String?

        public init (
            configurationId: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.configurationId = configurationId
            self.description = description
        }
    }

}

extension DryRunOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DryRunOperation(message: \(Swift.String(describing: message)))"}
}

extension DryRunOperation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DryRunOperationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised to indicate a successfully authorized action when the DryRun flag is set to "true".
public struct DryRunOperation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DryRunOperationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DryRunOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HomeRegionNotSetException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HomeRegionNotSetException(message: \(Swift.String(describing: message)))"}
}

extension HomeRegionNotSetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: HomeRegionNotSetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The home region is not set. Set the home region to continue.
public struct HomeRegionNotSetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HomeRegionNotSetExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension HomeRegionNotSetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ImportMigrationTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportMigrationTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportMigrationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportMigrationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportMigrationTaskOutputError>
}

extension ImportMigrationTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportMigrationTaskInput(dryRun: \(Swift.String(describing: dryRun)), migrationTaskName: \(Swift.String(describing: migrationTaskName)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)))"}
}

extension ImportMigrationTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct ImportMigrationTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportMigrationTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportMigrationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportMigrationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportMigrationTaskOutputError>
}

public struct ImportMigrationTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportMigrationTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportMigrationTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportMigrationTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportMigrationTaskOutputError>
}

public struct ImportMigrationTaskInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportMigrationTaskInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ImportMigrationTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportMigrationTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportMigrationTaskOutputError>
}

public struct ImportMigrationTaskInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportMigrationTaskInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ImportMigrationTaskInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportMigrationTaskInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportMigrationTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportMigrationTaskOutputError>
}

public struct ImportMigrationTaskInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream. >
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ImportMigrationTaskInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
    public let dryRun: Swift.Bool
}

extension ImportMigrationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension ImportMigrationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportMigrationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportMigrationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportMigrationTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportMigrationTaskOutputResponse()"}
}

extension ImportMigrationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ImportMigrationTaskOutputResponse: Swift.Equatable {

    public init() {}
}

struct ImportMigrationTaskOutputResponseBody: Swift.Equatable {
}

extension ImportMigrationTaskOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InternalServerError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerError(message: \(Swift.String(describing: message)))"}
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when an internal, configuration, or dependency error is encountered.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInputException(message: \(Swift.String(describing: message)))"}
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when the provided input violates a policy constraint or is entered in the wrong format or data type.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListApplicationStatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationStatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationStatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationStatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationStatesOutputError>
}

extension ListApplicationStatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationStatesInput(applicationIds: \(Swift.String(describing: applicationIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationStatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIds = "ApplicationIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIds = applicationIds {
            var applicationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIds)
            for applicationids0 in applicationIds {
                try applicationIdsContainer.encode(applicationids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListApplicationStatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationStatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationStatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationStatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationStatesOutputError>
}

public struct ListApplicationStatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationStatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListApplicationStatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListApplicationStatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationStatesOutputError>
}

public struct ListApplicationStatesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationStatesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListApplicationStatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationStatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationStatesOutputError>
}

public struct ListApplicationStatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListApplicationStatesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListApplicationStatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListApplicationStatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListApplicationStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListApplicationStatesOutputError>
}

public struct ListApplicationStatesInput: Swift.Equatable {
    /// The configurationIds from the Application Discovery Service that uniquely identifies your applications.
    public var applicationIds: [Swift.String]?
    /// Maximum number of results to be returned per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?

    public init (
        applicationIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationIds = applicationIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationStatesInputBody: Swift.Equatable {
    public let applicationIds: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListApplicationStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIds = "ApplicationIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIds)
        var applicationIdsDecoded0:[Swift.String]? = nil
        if let applicationIdsContainer = applicationIdsContainer {
            applicationIdsDecoded0 = [Swift.String]()
            for string0 in applicationIdsContainer {
                if let string0 = string0 {
                    applicationIdsDecoded0?.append(string0)
                }
            }
        }
        applicationIds = applicationIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApplicationStatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationStatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationStatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationStatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApplicationStatesOutputResponse(applicationStateList: \(Swift.String(describing: applicationStateList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListApplicationStatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationStatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationStateList = output.applicationStateList
            self.nextToken = output.nextToken
        } else {
            self.applicationStateList = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationStatesOutputResponse: Swift.Equatable {
    /// A list of Applications that exist in Application Discovery Service.
    public var applicationStateList: [MigrationHubClientTypes.ApplicationState]?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?

    public init (
        applicationStateList: [MigrationHubClientTypes.ApplicationState]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationStateList = applicationStateList
        self.nextToken = nextToken
    }
}

struct ListApplicationStatesOutputResponseBody: Swift.Equatable {
    public let applicationStateList: [MigrationHubClientTypes.ApplicationState]?
    public let nextToken: Swift.String?
}

extension ListApplicationStatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationStateList = "ApplicationStateList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationStateListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ApplicationState?].self, forKey: .applicationStateList)
        var applicationStateListDecoded0:[MigrationHubClientTypes.ApplicationState]? = nil
        if let applicationStateListContainer = applicationStateListContainer {
            applicationStateListDecoded0 = [MigrationHubClientTypes.ApplicationState]()
            for structure0 in applicationStateListContainer {
                if let structure0 = structure0 {
                    applicationStateListDecoded0?.append(structure0)
                }
            }
        }
        applicationStateList = applicationStateListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCreatedArtifactsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCreatedArtifactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCreatedArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCreatedArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCreatedArtifactsOutputError>
}

extension ListCreatedArtifactsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCreatedArtifactsInput(maxResults: \(Swift.String(describing: maxResults)), migrationTaskName: \(Swift.String(describing: migrationTaskName)), nextToken: \(Swift.String(describing: nextToken)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)))"}
}

extension ListCreatedArtifactsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct ListCreatedArtifactsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCreatedArtifactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCreatedArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCreatedArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCreatedArtifactsOutputError>
}

public struct ListCreatedArtifactsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCreatedArtifactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCreatedArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCreatedArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCreatedArtifactsOutputError>
}

public struct ListCreatedArtifactsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCreatedArtifactsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListCreatedArtifactsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCreatedArtifactsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCreatedArtifactsOutputError>
}

public struct ListCreatedArtifactsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCreatedArtifactsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListCreatedArtifactsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCreatedArtifactsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCreatedArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCreatedArtifactsOutputError>
}

public struct ListCreatedArtifactsInput: Swift.Equatable {
    /// Maximum number of results to be returned per page.
    public var maxResults: Swift.Int?
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        migrationTaskName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.migrationTaskName = migrationTaskName
        self.nextToken = nextToken
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ListCreatedArtifactsInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListCreatedArtifactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCreatedArtifactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCreatedArtifactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCreatedArtifactsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCreatedArtifactsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCreatedArtifactsOutputResponse(createdArtifactList: \(Swift.String(describing: createdArtifactList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCreatedArtifactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCreatedArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdArtifactList = output.createdArtifactList
            self.nextToken = output.nextToken
        } else {
            self.createdArtifactList = nil
            self.nextToken = nil
        }
    }
}

public struct ListCreatedArtifactsOutputResponse: Swift.Equatable {
    /// List of created artifacts up to the maximum number of results specified in the request.
    public var createdArtifactList: [MigrationHubClientTypes.CreatedArtifact]?
    /// If there are more created artifacts than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?

    public init (
        createdArtifactList: [MigrationHubClientTypes.CreatedArtifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.createdArtifactList = createdArtifactList
        self.nextToken = nextToken
    }
}

struct ListCreatedArtifactsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let createdArtifactList: [MigrationHubClientTypes.CreatedArtifact]?
}

extension ListCreatedArtifactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifactList = "CreatedArtifactList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let createdArtifactListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.CreatedArtifact?].self, forKey: .createdArtifactList)
        var createdArtifactListDecoded0:[MigrationHubClientTypes.CreatedArtifact]? = nil
        if let createdArtifactListContainer = createdArtifactListContainer {
            createdArtifactListDecoded0 = [MigrationHubClientTypes.CreatedArtifact]()
            for structure0 in createdArtifactListContainer {
                if let structure0 = structure0 {
                    createdArtifactListDecoded0?.append(structure0)
                }
            }
        }
        createdArtifactList = createdArtifactListDecoded0
    }
}

public struct ListDiscoveredResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDiscoveredResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDiscoveredResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDiscoveredResourcesOutputError>
}

extension ListDiscoveredResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDiscoveredResourcesInput(maxResults: \(Swift.String(describing: maxResults)), migrationTaskName: \(Swift.String(describing: migrationTaskName)), nextToken: \(Swift.String(describing: nextToken)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)))"}
}

extension ListDiscoveredResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

public struct ListDiscoveredResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDiscoveredResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDiscoveredResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDiscoveredResourcesOutputError>
}

public struct ListDiscoveredResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDiscoveredResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDiscoveredResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDiscoveredResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDiscoveredResourcesOutputError>
}

public struct ListDiscoveredResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDiscoveredResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDiscoveredResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDiscoveredResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDiscoveredResourcesOutputError>
}

public struct ListDiscoveredResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDiscoveredResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDiscoveredResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDiscoveredResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDiscoveredResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDiscoveredResourcesOutputError>
}

public struct ListDiscoveredResourcesInput: Swift.Equatable {
    /// The maximum number of results returned per page.
    public var maxResults: Swift.Int?
    /// The name of the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        migrationTaskName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.migrationTaskName = migrationTaskName
        self.nextToken = nextToken
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ListDiscoveredResourcesInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDiscoveredResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDiscoveredResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDiscoveredResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDiscoveredResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDiscoveredResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDiscoveredResourcesOutputResponse(discoveredResourceList: \(Swift.String(describing: discoveredResourceList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDiscoveredResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDiscoveredResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.discoveredResourceList = output.discoveredResourceList
            self.nextToken = output.nextToken
        } else {
            self.discoveredResourceList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDiscoveredResourcesOutputResponse: Swift.Equatable {
    /// Returned list of discovered resources associated with the given MigrationTask.
    public var discoveredResourceList: [MigrationHubClientTypes.DiscoveredResource]?
    /// If there are more discovered resources than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?

    public init (
        discoveredResourceList: [MigrationHubClientTypes.DiscoveredResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.discoveredResourceList = discoveredResourceList
        self.nextToken = nextToken
    }
}

struct ListDiscoveredResourcesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let discoveredResourceList: [MigrationHubClientTypes.DiscoveredResource]?
}

extension ListDiscoveredResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredResourceList = "DiscoveredResourceList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let discoveredResourceListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.DiscoveredResource?].self, forKey: .discoveredResourceList)
        var discoveredResourceListDecoded0:[MigrationHubClientTypes.DiscoveredResource]? = nil
        if let discoveredResourceListContainer = discoveredResourceListContainer {
            discoveredResourceListDecoded0 = [MigrationHubClientTypes.DiscoveredResource]()
            for structure0 in discoveredResourceListContainer {
                if let structure0 = structure0 {
                    discoveredResourceListDecoded0?.append(structure0)
                }
            }
        }
        discoveredResourceList = discoveredResourceListDecoded0
    }
}

public struct ListMigrationTasksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMigrationTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMigrationTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMigrationTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMigrationTasksOutputError>
}

extension ListMigrationTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMigrationTasksInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension ListMigrationTasksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct ListMigrationTasksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMigrationTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMigrationTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMigrationTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMigrationTasksOutputError>
}

public struct ListMigrationTasksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMigrationTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMigrationTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMigrationTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMigrationTasksOutputError>
}

public struct ListMigrationTasksInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMigrationTasksInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMigrationTasksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMigrationTasksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMigrationTasksOutputError>
}

public struct ListMigrationTasksInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMigrationTasksInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMigrationTasksInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMigrationTasksInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMigrationTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMigrationTasksOutputError>
}

public struct ListMigrationTasksInput: Swift.Equatable {
    /// Value to specify how many results are returned per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?
    /// Filter migration tasks by discovered resource name.
    public var resourceName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceName = resourceName
    }
}

struct ListMigrationTasksInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let resourceName: Swift.String?
}

extension ListMigrationTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ListMigrationTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMigrationTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMigrationTasksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMigrationTasksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMigrationTasksOutputResponse(migrationTaskSummaryList: \(Swift.String(describing: migrationTaskSummaryList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMigrationTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMigrationTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.migrationTaskSummaryList = output.migrationTaskSummaryList
            self.nextToken = output.nextToken
        } else {
            self.migrationTaskSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMigrationTasksOutputResponse: Swift.Equatable {
    /// Lists the migration task's summary which includes: MigrationTaskName, ProgressPercent, ProgressUpdateStream, Status, and the UpdateDateTime for each task.
    public var migrationTaskSummaryList: [MigrationHubClientTypes.MigrationTaskSummary]?
    /// If there are more migration tasks than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?

    public init (
        migrationTaskSummaryList: [MigrationHubClientTypes.MigrationTaskSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.migrationTaskSummaryList = migrationTaskSummaryList
        self.nextToken = nextToken
    }
}

struct ListMigrationTasksOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let migrationTaskSummaryList: [MigrationHubClientTypes.MigrationTaskSummary]?
}

extension ListMigrationTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskSummaryList = "MigrationTaskSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let migrationTaskSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.MigrationTaskSummary?].self, forKey: .migrationTaskSummaryList)
        var migrationTaskSummaryListDecoded0:[MigrationHubClientTypes.MigrationTaskSummary]? = nil
        if let migrationTaskSummaryListContainer = migrationTaskSummaryListContainer {
            migrationTaskSummaryListDecoded0 = [MigrationHubClientTypes.MigrationTaskSummary]()
            for structure0 in migrationTaskSummaryListContainer {
                if let structure0 = structure0 {
                    migrationTaskSummaryListDecoded0?.append(structure0)
                }
            }
        }
        migrationTaskSummaryList = migrationTaskSummaryListDecoded0
    }
}

public struct ListProgressUpdateStreamsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProgressUpdateStreamsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProgressUpdateStreamsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProgressUpdateStreamsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProgressUpdateStreamsOutputError>
}

extension ListProgressUpdateStreamsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProgressUpdateStreamsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListProgressUpdateStreamsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListProgressUpdateStreamsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProgressUpdateStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProgressUpdateStreamsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProgressUpdateStreamsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProgressUpdateStreamsOutputError>
}

public struct ListProgressUpdateStreamsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProgressUpdateStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProgressUpdateStreamsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProgressUpdateStreamsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProgressUpdateStreamsOutputError>
}

public struct ListProgressUpdateStreamsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProgressUpdateStreamsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListProgressUpdateStreamsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProgressUpdateStreamsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProgressUpdateStreamsOutputError>
}

public struct ListProgressUpdateStreamsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProgressUpdateStreamsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListProgressUpdateStreamsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProgressUpdateStreamsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProgressUpdateStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProgressUpdateStreamsOutputError>
}

public struct ListProgressUpdateStreamsInput: Swift.Equatable {
    /// Filter to limit the maximum number of results to list per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProgressUpdateStreamsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListProgressUpdateStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProgressUpdateStreamsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProgressUpdateStreamsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProgressUpdateStreamsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProgressUpdateStreamsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProgressUpdateStreamsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), progressUpdateStreamSummaryList: \(Swift.String(describing: progressUpdateStreamSummaryList)))"}
}

extension ListProgressUpdateStreamsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProgressUpdateStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.progressUpdateStreamSummaryList = output.progressUpdateStreamSummaryList
        } else {
            self.nextToken = nil
            self.progressUpdateStreamSummaryList = nil
        }
    }
}

public struct ListProgressUpdateStreamsOutputResponse: Swift.Equatable {
    /// If there are more streams created than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?
    /// List of progress update streams up to the max number of results passed in the input.
    public var progressUpdateStreamSummaryList: [MigrationHubClientTypes.ProgressUpdateStreamSummary]?

    public init (
        nextToken: Swift.String? = nil,
        progressUpdateStreamSummaryList: [MigrationHubClientTypes.ProgressUpdateStreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.progressUpdateStreamSummaryList = progressUpdateStreamSummaryList
    }
}

struct ListProgressUpdateStreamsOutputResponseBody: Swift.Equatable {
    public let progressUpdateStreamSummaryList: [MigrationHubClientTypes.ProgressUpdateStreamSummary]?
    public let nextToken: Swift.String?
}

extension ListProgressUpdateStreamsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case progressUpdateStreamSummaryList = "ProgressUpdateStreamSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ProgressUpdateStreamSummary?].self, forKey: .progressUpdateStreamSummaryList)
        var progressUpdateStreamSummaryListDecoded0:[MigrationHubClientTypes.ProgressUpdateStreamSummary]? = nil
        if let progressUpdateStreamSummaryListContainer = progressUpdateStreamSummaryListContainer {
            progressUpdateStreamSummaryListDecoded0 = [MigrationHubClientTypes.ProgressUpdateStreamSummary]()
            for structure0 in progressUpdateStreamSummaryListContainer {
                if let structure0 = structure0 {
                    progressUpdateStreamSummaryListDecoded0?.append(structure0)
                }
            }
        }
        progressUpdateStreamSummaryList = progressUpdateStreamSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MigrationHubClientTypes.MigrationTask: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let resourceAttributeList = resourceAttributeList {
            var resourceAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAttributeList)
            for latestresourceattributelist0 in resourceAttributeList {
                try resourceAttributeListContainer.encode(latestresourceattributelist0)
            }
        }
        if let task = task {
            try encodeContainer.encode(task, forKey: .task)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let taskDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Task.self, forKey: .task)
        task = taskDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let resourceAttributeListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ResourceAttribute?].self, forKey: .resourceAttributeList)
        var resourceAttributeListDecoded0:[MigrationHubClientTypes.ResourceAttribute]? = nil
        if let resourceAttributeListContainer = resourceAttributeListContainer {
            resourceAttributeListDecoded0 = [MigrationHubClientTypes.ResourceAttribute]()
            for structure0 in resourceAttributeListContainer {
                if let structure0 = structure0 {
                    resourceAttributeListDecoded0?.append(structure0)
                }
            }
        }
        resourceAttributeList = resourceAttributeListDecoded0
    }
}

extension MigrationHubClientTypes.MigrationTask: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MigrationTask(migrationTaskName: \(Swift.String(describing: migrationTaskName)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)), resourceAttributeList: \(Swift.String(describing: resourceAttributeList)), task: \(Swift.String(describing: task)), updateDateTime: \(Swift.String(describing: updateDateTime)))"}
}

extension MigrationHubClientTypes {
    /// Represents a migration task in a migration tool.
    public struct MigrationTask: Swift.Equatable {
        /// Unique identifier that references the migration task. Do not store personal data in this field.
        public var migrationTaskName: Swift.String?
        /// A name that identifies the vendor of the migration tool being used.
        public var progressUpdateStream: Swift.String?
        /// Information about the resource that is being migrated. This data will be used to map the task to a resource in the Application Discovery Service repository.
        public var resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]?
        /// Task object encapsulating task information.
        public var task: MigrationHubClientTypes.Task?
        /// The timestamp when the task was gathered.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            migrationTaskName: Swift.String? = nil,
            progressUpdateStream: Swift.String? = nil,
            resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]? = nil,
            task: MigrationHubClientTypes.Task? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.migrationTaskName = migrationTaskName
            self.progressUpdateStream = progressUpdateStream
            self.resourceAttributeList = resourceAttributeList
            self.task = task
            self.updateDateTime = updateDateTime
        }
    }

}

extension MigrationHubClientTypes.MigrationTaskSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressPercent = "ProgressPercent"
        case progressUpdateStream = "ProgressUpdateStream"
        case status = "Status"
        case statusDetail = "StatusDetail"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressPercent = progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension MigrationHubClientTypes.MigrationTaskSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MigrationTaskSummary(migrationTaskName: \(Swift.String(describing: migrationTaskName)), progressPercent: \(Swift.String(describing: progressPercent)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)), status: \(Swift.String(describing: status)), statusDetail: \(Swift.String(describing: statusDetail)), updateDateTime: \(Swift.String(describing: updateDateTime)))"}
}

extension MigrationHubClientTypes {
    /// MigrationTaskSummary includes MigrationTaskName, ProgressPercent, ProgressUpdateStream, Status, and UpdateDateTime for each task.
    public struct MigrationTaskSummary: Swift.Equatable {
        /// Unique identifier that references the migration task. Do not store personal data in this field.
        public var migrationTaskName: Swift.String?
        /// Indication of the percentage completion of the task.
        public var progressPercent: Swift.Int?
        /// An AWS resource used for access control. It should uniquely identify the migration tool as it is used for all updates made by the tool.
        public var progressUpdateStream: Swift.String?
        /// Status of the task.
        public var status: MigrationHubClientTypes.Status?
        /// Detail information of what is being done within the overall status state.
        public var statusDetail: Swift.String?
        /// The timestamp when the task was gathered.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            migrationTaskName: Swift.String? = nil,
            progressPercent: Swift.Int? = nil,
            progressUpdateStream: Swift.String? = nil,
            status: MigrationHubClientTypes.Status? = nil,
            statusDetail: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.migrationTaskName = migrationTaskName
            self.progressPercent = progressPercent
            self.progressUpdateStream = progressUpdateStream
            self.status = status
            self.statusDetail = statusDetail
            self.updateDateTime = updateDateTime
        }
    }

}

public struct NotifyApplicationStateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyApplicationStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyApplicationStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyApplicationStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyApplicationStateOutputError>
}

extension NotifyApplicationStateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyApplicationStateInput(applicationId: \(Swift.String(describing: applicationId)), dryRun: \(Swift.String(describing: dryRun)), status: \(Swift.String(describing: status)), updateDateTime: \(Swift.String(describing: updateDateTime)))"}
}

extension NotifyApplicationStateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case dryRun = "DryRun"
        case status = "Status"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }
}

public struct NotifyApplicationStateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyApplicationStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyApplicationStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyApplicationStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyApplicationStateOutputError>
}

public struct NotifyApplicationStateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyApplicationStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyApplicationStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyApplicationStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyApplicationStateOutputError>
}

public struct NotifyApplicationStateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyApplicationStateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: NotifyApplicationStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = NotifyApplicationStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyApplicationStateOutputError>
}

public struct NotifyApplicationStateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyApplicationStateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: NotifyApplicationStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = NotifyApplicationStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyApplicationStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyApplicationStateOutputError>
}

public struct NotifyApplicationStateInput: Swift.Equatable {
    /// The configurationId in Application Discovery Service that uniquely identifies the grouped application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Status of the application - Not Started, In-Progress, Complete.
    /// This member is required.
    public var status: MigrationHubClientTypes.ApplicationStatus?
    /// The timestamp when the application state changed.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        applicationId: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        status: MigrationHubClientTypes.ApplicationStatus? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.dryRun = dryRun
        self.status = status
        self.updateDateTime = updateDateTime
    }
}

struct NotifyApplicationStateInputBody: Swift.Equatable {
    public let applicationId: Swift.String?
    public let status: MigrationHubClientTypes.ApplicationStatus?
    public let updateDateTime: ClientRuntime.Date?
    public let dryRun: Swift.Bool
}

extension NotifyApplicationStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case dryRun = "DryRun"
        case status = "Status"
        case updateDateTime = "UpdateDateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension NotifyApplicationStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyApplicationStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyApplicationStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyApplicationStateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyApplicationStateOutputResponse()"}
}

extension NotifyApplicationStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct NotifyApplicationStateOutputResponse: Swift.Equatable {

    public init() {}
}

struct NotifyApplicationStateOutputResponseBody: Swift.Equatable {
}

extension NotifyApplicationStateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct NotifyMigrationTaskStateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyMigrationTaskStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyMigrationTaskStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyMigrationTaskStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyMigrationTaskStateOutputError>
}

extension NotifyMigrationTaskStateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyMigrationTaskStateInput(dryRun: \(Swift.String(describing: dryRun)), migrationTaskName: \(Swift.String(describing: migrationTaskName)), nextUpdateSeconds: \(Swift.String(describing: nextUpdateSeconds)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)), task: \(Swift.String(describing: task)), updateDateTime: \(Swift.String(describing: updateDateTime)))"}
}

extension NotifyMigrationTaskStateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case nextUpdateSeconds = "NextUpdateSeconds"
        case progressUpdateStream = "ProgressUpdateStream"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if nextUpdateSeconds != 0 {
            try encodeContainer.encode(nextUpdateSeconds, forKey: .nextUpdateSeconds)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let task = task {
            try encodeContainer.encode(task, forKey: .task)
        }
        if let updateDateTime = updateDateTime {
            try encodeContainer.encode(updateDateTime.timeIntervalSince1970, forKey: .updateDateTime)
        }
    }
}

public struct NotifyMigrationTaskStateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyMigrationTaskStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyMigrationTaskStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyMigrationTaskStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyMigrationTaskStateOutputError>
}

public struct NotifyMigrationTaskStateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyMigrationTaskStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyMigrationTaskStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyMigrationTaskStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyMigrationTaskStateOutputError>
}

public struct NotifyMigrationTaskStateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyMigrationTaskStateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: NotifyMigrationTaskStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = NotifyMigrationTaskStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyMigrationTaskStateOutputError>
}

public struct NotifyMigrationTaskStateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyMigrationTaskStateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: NotifyMigrationTaskStateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = NotifyMigrationTaskStateInput
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyMigrationTaskStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyMigrationTaskStateOutputError>
}

public struct NotifyMigrationTaskStateInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// Number of seconds after the UpdateDateTime within which the Migration Hub can expect an update. If Migration Hub does not receive an update within the specified interval, then the migration task will be considered stale.
    /// This member is required.
    public var nextUpdateSeconds: Swift.Int
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?
    /// Information about the task's progress and status.
    /// This member is required.
    public var task: MigrationHubClientTypes.Task?
    /// The timestamp when the task was gathered.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        nextUpdateSeconds: Swift.Int = 0,
        progressUpdateStream: Swift.String? = nil,
        task: MigrationHubClientTypes.Task? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.nextUpdateSeconds = nextUpdateSeconds
        self.progressUpdateStream = progressUpdateStream
        self.task = task
        self.updateDateTime = updateDateTime
    }
}

struct NotifyMigrationTaskStateInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
    public let task: MigrationHubClientTypes.Task?
    public let updateDateTime: ClientRuntime.Date?
    public let nextUpdateSeconds: Swift.Int
    public let dryRun: Swift.Bool
}

extension NotifyMigrationTaskStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case nextUpdateSeconds = "NextUpdateSeconds"
        case progressUpdateStream = "ProgressUpdateStream"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let taskDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Task.self, forKey: .task)
        task = taskDecoded
        let updateDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let nextUpdateSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .nextUpdateSeconds)
        nextUpdateSeconds = nextUpdateSecondsDecoded
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension NotifyMigrationTaskStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyMigrationTaskStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyMigrationTaskStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyMigrationTaskStateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyMigrationTaskStateOutputResponse()"}
}

extension NotifyMigrationTaskStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct NotifyMigrationTaskStateOutputResponse: Swift.Equatable {

    public init() {}
}

struct NotifyMigrationTaskStateOutputResponseBody: Swift.Equatable {
}

extension NotifyMigrationTaskStateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PolicyErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyErrorException(message: \(Swift.String(describing: message)))"}
}

extension PolicyErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PolicyErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when there are problems accessing Application Discovery Service (Application Discovery Service); most likely due to a misconfigured policy or the migrationhub-discovery role is missing or not configured correctly.
public struct PolicyErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PolicyErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubClientTypes.ProgressUpdateStreamSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let progressUpdateStreamName = progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
    }
}

extension MigrationHubClientTypes.ProgressUpdateStreamSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProgressUpdateStreamSummary(progressUpdateStreamName: \(Swift.String(describing: progressUpdateStreamName)))"}
}

extension MigrationHubClientTypes {
    /// Summary of the AWS resource used for access control that is implicitly linked to your AWS account.
    public struct ProgressUpdateStreamSummary: Swift.Equatable {
        /// The name of the ProgressUpdateStream. Do not store personal data in this field.
        public var progressUpdateStreamName: Swift.String?

        public init (
            progressUpdateStreamName: Swift.String? = nil
        )
        {
            self.progressUpdateStreamName = progressUpdateStreamName
        }
    }

}

public struct PutResourceAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourceAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourceAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourceAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourceAttributesOutputError>
}

extension PutResourceAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourceAttributesInput(dryRun: \(Swift.String(describing: dryRun)), migrationTaskName: \(Swift.String(describing: migrationTaskName)), progressUpdateStream: \(Swift.String(describing: progressUpdateStream)), resourceAttributeList: \(Swift.String(describing: resourceAttributeList)))"}
}

extension PutResourceAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let resourceAttributeList = resourceAttributeList {
            var resourceAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAttributeList)
            for resourceattributelist0 in resourceAttributeList {
                try resourceAttributeListContainer.encode(resourceattributelist0)
            }
        }
    }
}

public struct PutResourceAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourceAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourceAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourceAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourceAttributesOutputError>
}

public struct PutResourceAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourceAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutResourceAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutResourceAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourceAttributesOutputError>
}

public struct PutResourceAttributesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourceAttributesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutResourceAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutResourceAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourceAttributesOutputError>
}

public struct PutResourceAttributesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutResourceAttributesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutResourceAttributesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutResourceAttributesInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutResourceAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutResourceAttributesOutputError>
}

public struct PutResourceAttributesInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?
    /// Information about the resource that is being migrated. This data will be used to map the task to a resource in the Application Discovery Service repository. Takes the object array of ResourceAttribute where the Type field is reserved for the following values: IPV4_ADDRESS | IPV6_ADDRESS | MAC_ADDRESS | FQDN | VM_MANAGER_ID | VM_MANAGED_OBJECT_REFERENCE | VM_NAME | VM_PATH | BIOS_ID | MOTHERBOARD_SERIAL_NUMBER where the identifying value can be a string up to 256 characters.
    ///
    /// * If any "VM" related value is set for a ResourceAttribute object, it is required that VM_MANAGER_ID, as a minimum, is always set. If VM_MANAGER_ID is not set, then all "VM" fields will be discarded and "VM" fields will not be used for matching the migration task to a server in Application Discovery Service repository. See the [Example](https://docs.aws.amazon.com/migrationhub/latest/ug/API_PutResourceAttributes.html#API_PutResourceAttributes_Examples) section below for a use case of specifying "VM" related values.
    ///
    /// * If a server you are trying to match has multiple IP or MAC addresses, you should provide as many as you know in separate type/value pairs passed to the ResourceAttributeList parameter to maximize the chances of matching.
    /// This member is required.
    public var resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]?

    public init (
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil,
        resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
        self.resourceAttributeList = resourceAttributeList
    }
}

struct PutResourceAttributesInputBody: Swift.Equatable {
    public let progressUpdateStream: Swift.String?
    public let migrationTaskName: Swift.String?
    public let resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]?
    public let dryRun: Swift.Bool
}

extension PutResourceAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let resourceAttributeListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ResourceAttribute?].self, forKey: .resourceAttributeList)
        var resourceAttributeListDecoded0:[MigrationHubClientTypes.ResourceAttribute]? = nil
        if let resourceAttributeListContainer = resourceAttributeListContainer {
            resourceAttributeListDecoded0 = [MigrationHubClientTypes.ResourceAttribute]()
            for structure0 in resourceAttributeListContainer {
                if let structure0 = structure0 {
                    resourceAttributeListDecoded0?.append(structure0)
                }
            }
        }
        resourceAttributeList = resourceAttributeListDecoded0
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension PutResourceAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourceAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutResourceAttributesOutputResponse()"}
}

extension PutResourceAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourceAttributesOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutResourceAttributesOutputResponseBody: Swift.Equatable {
}

extension PutResourceAttributesOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MigrationHubClientTypes.ResourceAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ResourceAttributeType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MigrationHubClientTypes.ResourceAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAttribute(type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension MigrationHubClientTypes {
    /// Attribute associated with a resource. Note the corresponding format required per type listed below: IPV4 x.x.x.x where x is an integer in the range [0,255] IPV6 y : y : y : y : y : y : y : y where y is a hexadecimal between 0 and FFFF. [0, FFFF] MAC_ADDRESS ^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$ FQDN ^[^<>{}\\/?,=\p{Cntrl}]{1,256}$
    public struct ResourceAttribute: Swift.Equatable {
        /// Type of resource.
        /// This member is required.
        public var type: MigrationHubClientTypes.ResourceAttributeType?
        /// Value of the resource type.
        /// This member is required.
        public var value: Swift.String?

        public init (
            type: MigrationHubClientTypes.ResourceAttributeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension MigrationHubClientTypes {
    public enum ResourceAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case biosId
        case fqdn
        case ipv4Address
        case ipv6Address
        case macAddress
        case motherboardSerialNumber
        case vmManagedObjectReference
        case vmManagerId
        case vmName
        case vmPath
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceAttributeType] {
            return [
                .biosId,
                .fqdn,
                .ipv4Address,
                .ipv6Address,
                .macAddress,
                .motherboardSerialNumber,
                .vmManagedObjectReference,
                .vmManagerId,
                .vmName,
                .vmPath,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .biosId: return "BIOS_ID"
            case .fqdn: return "FQDN"
            case .ipv4Address: return "IPV4_ADDRESS"
            case .ipv6Address: return "IPV6_ADDRESS"
            case .macAddress: return "MAC_ADDRESS"
            case .motherboardSerialNumber: return "MOTHERBOARD_SERIAL_NUMBER"
            case .vmManagedObjectReference: return "VM_MANAGED_OBJECT_REFERENCE"
            case .vmManagerId: return "VM_MANAGER_ID"
            case .vmName: return "VM_NAME"
            case .vmPath: return "VM_PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceAttributeType(rawValue: rawValue) ?? ResourceAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when the request references a resource (Application Discovery Service configuration, update stream, migration task, etc.) that does not exist in Application Discovery Service (Application Discovery Service) or in Migration Hub's repository.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when there is an internal, configuration, or dependency error encountered.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .failed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubClientTypes.Task: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressPercent = "ProgressPercent"
        case status = "Status"
        case statusDetail = "StatusDetail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let progressPercent = progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
    }
}

extension MigrationHubClientTypes.Task: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Task(progressPercent: \(Swift.String(describing: progressPercent)), status: \(Swift.String(describing: status)), statusDetail: \(Swift.String(describing: statusDetail)))"}
}

extension MigrationHubClientTypes {
    /// Task object encapsulating task information.
    public struct Task: Swift.Equatable {
        /// Indication of the percentage completion of the task.
        public var progressPercent: Swift.Int?
        /// Status of the task - Not Started, In-Progress, Complete.
        /// This member is required.
        public var status: MigrationHubClientTypes.Status?
        /// Details of task status as notified by a migration tool. A tool might use this field to provide clarifying information about the status that is unique to that tool or that explains an error state.
        public var statusDetail: Swift.String?

        public init (
            progressPercent: Swift.Int? = nil,
            status: MigrationHubClientTypes.Status? = nil,
            statusDetail: Swift.String? = nil
        )
        {
            self.progressPercent = progressPercent
            self.status = status
            self.statusDetail = statusDetail
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the exception.
    /// This member is required.
    public var message: Swift.String?
    /// The number of seconds the caller should wait before retrying.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedOperation(message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedOperation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedOperationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised to indicate a request was not authorized when the DryRun flag is set to "true".
public struct UnauthorizedOperation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedOperationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnauthorizedOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
