// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension MqClientTypes {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public enum AuthenticationStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ldap
        case simple
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationStrategy] {
            return [
                .ldap,
                .simple,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ldap: return "LDAP"
            case .simple: return "SIMPLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationStrategy(rawValue: rawValue) ?? AuthenticationStrategy.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.AvailabilityZone: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MqClientTypes.AvailabilityZone: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AvailabilityZone(name: \(Swift.String(describing: name)))"}
}

extension MqClientTypes {
    /// Name of the availability zone.
    public struct AvailabilityZone: Swift.Equatable {
        /// Id for the availability zone.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(errorAttribute: \(Swift.String(describing: errorAttribute)), message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let errorAttribute: Swift.String?
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MqClientTypes.BrokerEngineType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineType = "engineType"
        case engineVersions = "engineVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersions = engineVersions {
            var engineVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineVersions)
            for __listofengineversion0 in engineVersions {
                try engineVersionsContainer.encode(__listofengineversion0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionsContainer = try containerValues.decodeIfPresent([MqClientTypes.EngineVersion?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[MqClientTypes.EngineVersion]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [MqClientTypes.EngineVersion]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
    }
}

extension MqClientTypes.BrokerEngineType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrokerEngineType(engineType: \(Swift.String(describing: engineType)), engineVersions: \(Swift.String(describing: engineVersions)))"}
}

extension MqClientTypes {
    /// Types of broker engines.
    public struct BrokerEngineType: Swift.Equatable {
        /// The broker's engine type.
        public var engineType: MqClientTypes.EngineType?
        /// The list of engine versions.
        public var engineVersions: [MqClientTypes.EngineVersion]?

        public init (
            engineType: MqClientTypes.EngineType? = nil,
            engineVersions: [MqClientTypes.EngineVersion]? = nil
        )
        {
            self.engineType = engineType
            self.engineVersions = engineVersions
        }
    }

}

extension MqClientTypes.BrokerInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleURL = "consoleURL"
        case endpoints = "endpoints"
        case ipAddress = "ipAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleURL = consoleURL {
            try encodeContainer.encode(consoleURL, forKey: .consoleURL)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __listof__string0 in endpoints {
                try endpointsContainer.encode(__listof__string0)
            }
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consoleURL)
        consoleURL = consoleURLDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .endpoints)
        var endpointsDecoded0:[Swift.String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension MqClientTypes.BrokerInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrokerInstance(consoleURL: \(Swift.String(describing: consoleURL)), endpoints: \(Swift.String(describing: endpoints)), ipAddress: \(Swift.String(describing: ipAddress)))"}
}

extension MqClientTypes {
    /// Returns information about all brokers.
    public struct BrokerInstance: Swift.Equatable {
        /// The brokers web console URL.
        public var consoleURL: Swift.String?
        /// The broker's wire-level protocol endpoints.
        public var endpoints: [Swift.String]?
        /// The IP address of the Elastic Network Interface (ENI) attached to the broker. Does not apply to RabbitMQ brokers.
        public var ipAddress: Swift.String?

        public init (
            consoleURL: Swift.String? = nil,
            endpoints: [Swift.String]? = nil,
            ipAddress: Swift.String? = nil
        )
        {
            self.consoleURL = consoleURL
            self.endpoints = endpoints
            self.ipAddress = ipAddress
        }
    }

}

extension MqClientTypes.BrokerInstanceOption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "availabilityZones"
        case engineType = "engineType"
        case hostInstanceType = "hostInstanceType"
        case storageType = "storageType"
        case supportedDeploymentModes = "supportedDeploymentModes"
        case supportedEngineVersions = "supportedEngineVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for __listofavailabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(__listofavailabilityzone0)
            }
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let supportedDeploymentModes = supportedDeploymentModes {
            var supportedDeploymentModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDeploymentModes)
            for __listofdeploymentmode0 in supportedDeploymentModes {
                try supportedDeploymentModesContainer.encode(__listofdeploymentmode0.rawValue)
            }
        }
        if let supportedEngineVersions = supportedEngineVersions {
            var supportedEngineVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedEngineVersions)
            for __listof__string0 in supportedEngineVersions {
                try supportedEngineVersionsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([MqClientTypes.AvailabilityZone?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[MqClientTypes.AvailabilityZone]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [MqClientTypes.AvailabilityZone]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportedDeploymentModesContainer = try containerValues.decodeIfPresent([MqClientTypes.DeploymentMode?].self, forKey: .supportedDeploymentModes)
        var supportedDeploymentModesDecoded0:[MqClientTypes.DeploymentMode]? = nil
        if let supportedDeploymentModesContainer = supportedDeploymentModesContainer {
            supportedDeploymentModesDecoded0 = [MqClientTypes.DeploymentMode]()
            for string0 in supportedDeploymentModesContainer {
                if let string0 = string0 {
                    supportedDeploymentModesDecoded0?.append(string0)
                }
            }
        }
        supportedDeploymentModes = supportedDeploymentModesDecoded0
        let supportedEngineVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedEngineVersions)
        var supportedEngineVersionsDecoded0:[Swift.String]? = nil
        if let supportedEngineVersionsContainer = supportedEngineVersionsContainer {
            supportedEngineVersionsDecoded0 = [Swift.String]()
            for string0 in supportedEngineVersionsContainer {
                if let string0 = string0 {
                    supportedEngineVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedEngineVersions = supportedEngineVersionsDecoded0
    }
}

extension MqClientTypes.BrokerInstanceOption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrokerInstanceOption(availabilityZones: \(Swift.String(describing: availabilityZones)), engineType: \(Swift.String(describing: engineType)), hostInstanceType: \(Swift.String(describing: hostInstanceType)), storageType: \(Swift.String(describing: storageType)), supportedDeploymentModes: \(Swift.String(describing: supportedDeploymentModes)), supportedEngineVersions: \(Swift.String(describing: supportedEngineVersions)))"}
}

extension MqClientTypes {
    /// Option for host instance type.
    public struct BrokerInstanceOption: Swift.Equatable {
        /// The list of available az.
        public var availabilityZones: [MqClientTypes.AvailabilityZone]?
        /// The broker's engine type.
        public var engineType: MqClientTypes.EngineType?
        /// The broker's instance type.
        public var hostInstanceType: Swift.String?
        /// The broker's storage type.
        public var storageType: MqClientTypes.BrokerStorageType?
        /// The list of supported deployment modes.
        public var supportedDeploymentModes: [MqClientTypes.DeploymentMode]?
        /// The list of supported engine versions.
        public var supportedEngineVersions: [Swift.String]?

        public init (
            availabilityZones: [MqClientTypes.AvailabilityZone]? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            hostInstanceType: Swift.String? = nil,
            storageType: MqClientTypes.BrokerStorageType? = nil,
            supportedDeploymentModes: [MqClientTypes.DeploymentMode]? = nil,
            supportedEngineVersions: [Swift.String]? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
            self.storageType = storageType
            self.supportedDeploymentModes = supportedDeploymentModes
            self.supportedEngineVersions = supportedEngineVersions
        }
    }

}

extension MqClientTypes {
    /// The broker's status.
    public enum BrokerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case deletionInProgress
        case rebootInProgress
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerState] {
            return [
                .creationFailed,
                .creationInProgress,
                .deletionInProgress,
                .rebootInProgress,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .rebootInProgress: return "REBOOT_IN_PROGRESS"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrokerState(rawValue: rawValue) ?? BrokerState.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes {
    /// The broker's storage type. EFS is not supported for RabbitMQ engine type.
    public enum BrokerStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebs
        case efs
        case sdkUnknown(Swift.String)

        public static var allCases: [BrokerStorageType] {
            return [
                .ebs,
                .efs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebs: return "EBS"
            case .efs: return "EFS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BrokerStorageType(rawValue: rawValue) ?? BrokerStorageType.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.BrokerSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
        case brokerName = "brokerName"
        case brokerState = "brokerState"
        case created = "created"
        case deploymentMode = "deploymentMode"
        case engineType = "engineType"
        case hostInstanceType = "hostInstanceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerArn = brokerArn {
            try encodeContainer.encode(brokerArn, forKey: .brokerArn)
        }
        if let brokerId = brokerId {
            try encodeContainer.encode(brokerId, forKey: .brokerId)
        }
        if let brokerName = brokerName {
            try encodeContainer.encode(brokerName, forKey: .brokerName)
        }
        if let brokerState = brokerState {
            try encodeContainer.encode(brokerState.rawValue, forKey: .brokerState)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let deploymentMode = deploymentMode {
            try encodeContainer.encode(deploymentMode.rawValue, forKey: .deploymentMode)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let brokerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let brokerStateDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerState.self, forKey: .brokerState)
        brokerState = brokerStateDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
    }
}

extension MqClientTypes.BrokerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BrokerSummary(brokerArn: \(Swift.String(describing: brokerArn)), brokerId: \(Swift.String(describing: brokerId)), brokerName: \(Swift.String(describing: brokerName)), brokerState: \(Swift.String(describing: brokerState)), created: \(Swift.String(describing: created)), deploymentMode: \(Swift.String(describing: deploymentMode)), engineType: \(Swift.String(describing: engineType)), hostInstanceType: \(Swift.String(describing: hostInstanceType)))"}
}

extension MqClientTypes {
    /// Returns information about all brokers.
    public struct BrokerSummary: Swift.Equatable {
        /// The broker's Amazon Resource Name (ARN).
        public var brokerArn: Swift.String?
        /// The unique ID that Amazon MQ generates for the broker.
        public var brokerId: Swift.String?
        /// The broker's name. This value is unique in your AWS account, 1-50 characters long, and containing only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
        public var brokerName: Swift.String?
        /// The broker's status.
        public var brokerState: MqClientTypes.BrokerState?
        /// The time when the broker was created.
        public var created: ClientRuntime.Date?
        /// The broker's deployment mode.
        /// This member is required.
        public var deploymentMode: MqClientTypes.DeploymentMode?
        /// The type of broker engine.
        /// This member is required.
        public var engineType: MqClientTypes.EngineType?
        /// The broker's instance type.
        public var hostInstanceType: Swift.String?

        public init (
            brokerArn: Swift.String? = nil,
            brokerId: Swift.String? = nil,
            brokerName: Swift.String? = nil,
            brokerState: MqClientTypes.BrokerState? = nil,
            created: ClientRuntime.Date? = nil,
            deploymentMode: MqClientTypes.DeploymentMode? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            hostInstanceType: Swift.String? = nil
        )
        {
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerName = brokerName
            self.brokerState = brokerState
            self.created = created
            self.deploymentMode = deploymentMode
            self.engineType = engineType
            self.hostInstanceType = hostInstanceType
        }
    }

}

extension MqClientTypes {
    /// The type of change pending for the ActiveMQ user.
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.Configuration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case description = "description"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let latestRevision = latestRevision {
            try encodeContainer.encode(latestRevision, forKey: .latestRevision)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MqClientTypes.Configuration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Configuration(arn: \(Swift.String(describing: arn)), authenticationStrategy: \(Swift.String(describing: authenticationStrategy)), created: \(Swift.String(describing: created)), description: \(Swift.String(describing: description)), engineType: \(Swift.String(describing: engineType)), engineVersion: \(Swift.String(describing: engineVersion)), id: \(Swift.String(describing: id)), latestRevision: \(Swift.String(describing: latestRevision)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension MqClientTypes {
    /// Returns information about all configurations.
    public struct Configuration: Swift.Equatable {
        /// Required. The ARN of the configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
        /// This member is required.
        public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
        /// Required. The date and time of the configuration revision.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// Required. The description of the configuration.
        /// This member is required.
        public var description: Swift.String?
        /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
        /// This member is required.
        public var engineType: MqClientTypes.EngineType?
        /// Required. The broker engine's version. For a list of supported engine versions, see, <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html">Supported engines.
        /// This member is required.
        public var engineVersion: Swift.String?
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        /// This member is required.
        public var id: Swift.String?
        /// Required. The latest revision of the configuration.
        /// This member is required.
        public var latestRevision: MqClientTypes.ConfigurationRevision?
        /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
        /// This member is required.
        public var name: Swift.String?
        /// The list of all tags associated with this configuration.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            engineType: MqClientTypes.EngineType? = nil,
            engineVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            latestRevision: MqClientTypes.ConfigurationRevision? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.authenticationStrategy = authenticationStrategy
            self.created = created
            self.description = description
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.id = id
            self.latestRevision = latestRevision
            self.name = name
            self.tags = tags
        }
    }

}

extension MqClientTypes.ConfigurationId: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension MqClientTypes.ConfigurationId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigurationId(id: \(Swift.String(describing: id)), revision: \(Swift.String(describing: revision)))"}
}

extension MqClientTypes {
    /// A list of information about the configuration. Does not apply to RabbitMQ brokers.
    public struct ConfigurationId: Swift.Equatable {
        /// Required. The unique ID that Amazon MQ generates for the configuration.
        /// This member is required.
        public var id: Swift.String?
        /// The revision number of the configuration.
        public var revision: Swift.Int?

        public init (
            id: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.id = id
            self.revision = revision
        }
    }

}

extension MqClientTypes.ConfigurationRevision: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "created"
        case description = "description"
        case revision = "revision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension MqClientTypes.ConfigurationRevision: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigurationRevision(created: \(Swift.String(describing: created)), description: \(Swift.String(describing: description)), revision: \(Swift.String(describing: revision)))"}
}

extension MqClientTypes {
    /// Returns information about the specified configuration revision.
    public struct ConfigurationRevision: Swift.Equatable {
        /// Required. The date and time of the configuration revision.
        /// This member is required.
        public var created: ClientRuntime.Date?
        /// The description of the configuration revision.
        public var description: Swift.String?
        /// Required. The revision number of the configuration.
        /// This member is required.
        public var revision: Swift.Int?

        public init (
            created: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            revision: Swift.Int? = nil
        )
        {
            self.created = created
            self.description = description
            self.revision = revision
        }
    }

}

extension MqClientTypes.Configurations: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case current = "current"
        case history = "history"
        case pending = "pending"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let current = current {
            try encodeContainer.encode(current, forKey: .current)
        }
        if let history = history {
            var historyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .history)
            for __listofconfigurationid0 in history {
                try historyContainer.encode(__listofconfigurationid0)
            }
        }
        if let pending = pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .current)
        current = currentDecoded
        let historyContainer = try containerValues.decodeIfPresent([MqClientTypes.ConfigurationId?].self, forKey: .history)
        var historyDecoded0:[MqClientTypes.ConfigurationId]? = nil
        if let historyContainer = historyContainer {
            historyDecoded0 = [MqClientTypes.ConfigurationId]()
            for structure0 in historyContainer {
                if let structure0 = structure0 {
                    historyDecoded0?.append(structure0)
                }
            }
        }
        history = historyDecoded0
        let pendingDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .pending)
        pending = pendingDecoded
    }
}

extension MqClientTypes.Configurations: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Configurations(current: \(Swift.String(describing: current)), history: \(Swift.String(describing: history)), pending: \(Swift.String(describing: pending)))"}
}

extension MqClientTypes {
    /// Broker configuration information
    public struct Configurations: Swift.Equatable {
        /// The broker's current configuration.
        public var current: MqClientTypes.ConfigurationId?
        /// The history of configurations applied to the broker.
        public var history: [MqClientTypes.ConfigurationId]?
        /// The broker's pending configuration.
        public var pending: MqClientTypes.ConfigurationId?

        public init (
            current: MqClientTypes.ConfigurationId? = nil,
            history: [MqClientTypes.ConfigurationId]? = nil,
            pending: MqClientTypes.ConfigurationId? = nil
        )
        {
            self.current = current
            self.history = history
            self.pending = pending
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(errorAttribute: \(Swift.String(describing: errorAttribute)), message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let errorAttribute: Swift.String?
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateBrokerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrokerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrokerOutputError>
}

extension CreateBrokerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBrokerInput(authenticationStrategy: \(Swift.String(describing: authenticationStrategy)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), brokerName: \(Swift.String(describing: brokerName)), configuration: \(Swift.String(describing: configuration)), creatorRequestId: \(Swift.String(describing: creatorRequestId)), deploymentMode: \(Swift.String(describing: deploymentMode)), encryptionOptions: \(Swift.String(describing: encryptionOptions)), engineType: \(Swift.String(describing: engineType)), engineVersion: \(Swift.String(describing: engineVersion)), hostInstanceType: \(Swift.String(describing: hostInstanceType)), ldapServerMetadata: \(Swift.String(describing: ldapServerMetadata)), logs: \(Swift.String(describing: logs)), maintenanceWindowStartTime: \(Swift.String(describing: maintenanceWindowStartTime)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), securityGroups: \(Swift.String(describing: securityGroups)), storageType: \(Swift.String(describing: storageType)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), users: \(Swift.String(describing: users)))"}
}

extension CreateBrokerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerName = "brokerName"
        case configuration = "configuration"
        case creatorRequestId = "creatorRequestId"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let brokerName = brokerName {
            try encodeContainer.encode(brokerName, forKey: .brokerName)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let deploymentMode = deploymentMode {
            try encodeContainer.encode(deploymentMode.rawValue, forKey: .deploymentMode)
        }
        if let encryptionOptions = encryptionOptions {
            try encodeContainer.encode(encryptionOptions, forKey: .encryptionOptions)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let ldapServerMetadata = ldapServerMetadata {
            try encodeContainer.encode(ldapServerMetadata, forKey: .ldapServerMetadata)
        }
        if let logs = logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let maintenanceWindowStartTime = maintenanceWindowStartTime {
            try encodeContainer.encode(maintenanceWindowStartTime, forKey: .maintenanceWindowStartTime)
        }
        if let publiclyAccessible = publiclyAccessible {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for __listof__string0 in subnetIds {
                try subnetIdsContainer.encode(__listof__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for __listofuser0 in users {
                try usersContainer.encode(__listofuser0)
            }
        }
    }
}

public struct CreateBrokerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrokerOutputError>
}

public struct CreateBrokerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrokerOutputError>
}

public struct CreateBrokerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrokerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrokerOutputError>
}

public struct CreateBrokerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBrokerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/brokers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBrokerOutputError>
}

/// Creates a broker using the specified properties.
public struct CreateBrokerInput: Swift.Equatable {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot. Set to true by default, if no value is specified.
    /// This member is required.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// Required. The broker's name. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
    /// This member is required.
    public var brokerName: Swift.String?
    /// A list of information about the configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The unique ID that the requester receives for the created broker. Amazon MQ passes your ID with the API action. Note: We recommend using a Universally Unique Identifier (UUID) for the creatorRequestId. You may omit the creatorRequestId if your application doesn't require idempotency.
    public var creatorRequestId: Swift.String?
    /// Required. The broker's deployment mode.
    /// This member is required.
    public var deploymentMode: MqClientTypes.DeploymentMode?
    /// Encryption options for the broker. Does not apply to RabbitMQ brokers.
    public var encryptionOptions: MqClientTypes.EncryptionOptions?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    /// This member is required.
    public var engineType: MqClientTypes.EngineType?
    /// Required. The broker engine's version. For a list of supported engine versions, see <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html">Supported engines.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// Required. The broker's instance type.
    /// This member is required.
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// Enables connections from applications outside of the VPC that hosts the broker's subnets. Set to false by default, if no value is provided.
    /// This member is required.
    public var publiclyAccessible: Swift.Bool?
    /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
    public var securityGroups: [Swift.String]?
    /// The broker's storage type.
    public var storageType: MqClientTypes.BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. If you specify more than one subnet, the subnets must be in different Availability Zones. Amazon MQ will not be able to create VPC endpoints for your broker with multiple subnets in the same Availability Zone. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ Amazon MQ for ActiveMQ deployment requires two subnets. A CLUSTER_MULTI_AZ Amazon MQ for RabbitMQ deployment has no subnet requirements when deployed with public accessibility. Deployment without public accessibility requires at least one subnet. If you specify subnets in a <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-sharing.html">shared VPC for a RabbitMQ broker, the associated VPC to which the specified subnets belong must be owned by your AWS account. Amazon MQ will not be able to create VPC endpoints in VPCs that are not owned by your AWS account.
    public var subnetIds: [Swift.String]?
    /// Create tags when creating the broker.
    public var tags: [Swift.String:Swift.String]?
    /// Required. The list of broker users (persons or applications) who can access queues and topics. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. <title>Amazon MQ for RabbitMQ</title> When you create an Amazon MQ for RabbitMQ broker, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
    /// This member is required.
    public var users: [MqClientTypes.User]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerName: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        creatorRequestId: Swift.String? = nil,
        deploymentMode: MqClientTypes.DeploymentMode? = nil,
        encryptionOptions: MqClientTypes.EncryptionOptions? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataInput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroups: [Swift.String]? = nil,
        storageType: MqClientTypes.BrokerStorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        users: [MqClientTypes.User]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerName = brokerName
        self.configuration = configuration
        self.creatorRequestId = creatorRequestId
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

struct CreateBrokerInputBody: Swift.Equatable {
    public let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    public let autoMinorVersionUpgrade: Swift.Bool?
    public let brokerName: Swift.String?
    public let configuration: MqClientTypes.ConfigurationId?
    public let creatorRequestId: Swift.String?
    public let deploymentMode: MqClientTypes.DeploymentMode?
    public let encryptionOptions: MqClientTypes.EncryptionOptions?
    public let engineType: MqClientTypes.EngineType?
    public let engineVersion: Swift.String?
    public let hostInstanceType: Swift.String?
    public let ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    public let logs: MqClientTypes.Logs?
    public let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    public let publiclyAccessible: Swift.Bool?
    public let securityGroups: [Swift.String]?
    public let storageType: MqClientTypes.BrokerStorageType?
    public let subnetIds: [Swift.String]?
    public let tags: [Swift.String:Swift.String]?
    public let users: [MqClientTypes.User]?
}

extension CreateBrokerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerName = "brokerName"
        case configuration = "configuration"
        case creatorRequestId = "creatorRequestId"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let encryptionOptionsDecoded = try containerValues.decodeIfPresent(MqClientTypes.EncryptionOptions.self, forKey: .encryptionOptions)
        encryptionOptions = encryptionOptionsDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataInput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([MqClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[MqClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MqClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension CreateBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBrokerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBrokerOutputResponse(brokerArn: \(Swift.String(describing: brokerArn)), brokerId: \(Swift.String(describing: brokerId)))"}
}

extension CreateBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBrokerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerArn = output.brokerArn
            self.brokerId = output.brokerId
        } else {
            self.brokerArn = nil
            self.brokerId = nil
        }
    }
}

public struct CreateBrokerOutputResponse: Swift.Equatable {
    /// The broker's Amazon Resource Name (ARN).
    public var brokerArn: Swift.String?
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init (
        brokerArn: Swift.String? = nil,
        brokerId: Swift.String? = nil
    )
    {
        self.brokerArn = brokerArn
        self.brokerId = brokerId
    }
}

struct CreateBrokerOutputResponseBody: Swift.Equatable {
    public let brokerArn: Swift.String?
    public let brokerId: Swift.String?
}

extension CreateBrokerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
    }
}

public struct CreateConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

extension CreateConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationInput(authenticationStrategy: \(Swift.String(describing: authenticationStrategy)), engineType: \(Swift.String(describing: engineType)), engineVersion: \(Swift.String(describing: engineVersion)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/configurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConfigurationOutputError>
}

/// Creates a new configuration for the specified configuration name. Amazon MQ uses the default configuration (the engine type and version).
public struct CreateConfigurationInput: Swift.Equatable {
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    /// This member is required.
    public var engineType: MqClientTypes.EngineType?
    /// Required. The broker engine's version. For a list of supported engine versions, see <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html">Supported engines.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    /// This member is required.
    public var name: Swift.String?
    /// Create tags when creating the configuration.
    public var tags: [Swift.String:Swift.String]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateConfigurationInputBody: Swift.Equatable {
    public let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    public let engineType: MqClientTypes.EngineType?
    public let engineVersion: Swift.String?
    public let name: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConfigurationOutputResponse(arn: \(Swift.String(describing: arn)), authenticationStrategy: \(Swift.String(describing: authenticationStrategy)), created: \(Swift.String(describing: created)), id: \(Swift.String(describing: id)), latestRevision: \(Swift.String(describing: latestRevision)), name: \(Swift.String(describing: name)))"}
}

extension CreateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authenticationStrategy = output.authenticationStrategy
            self.created = output.created
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
        } else {
            self.arn = nil
            self.authenticationStrategy = nil
            self.created = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
        }
    }
}

public struct CreateConfigurationOutputResponse: Swift.Equatable {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The date and time of the configuration.
    public var created: ClientRuntime.Date?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        created: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
    }
}

struct CreateConfigurationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    public let created: ClientRuntime.Date?
    public let id: Swift.String?
    public let latestRevision: MqClientTypes.ConfigurationRevision?
    public let name: Swift.String?
}

extension CreateConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateTagsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

extension CreateTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTagsInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateTagsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagsOutputError>
}

/// A map of the key-value pairs for the resource tag.
public struct CreateTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTagsOutputResponse()"}
}

extension CreateTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateTagsOutputResponseBody: Swift.Equatable {
}

extension CreateTagsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(brokerId: \(Swift.String(describing: brokerId)), consoleAccess: \(Swift.String(describing: consoleAccess)), groups: \(Swift.String(describing: groups)), password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension CreateUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let brokerId = input.brokerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("brokerId is nil and needs a value for the path of this operation"))))
        }
        guard let username = input.username else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("username is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

/// Creates a new ActiveMQ user.
public struct CreateUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// Enables access to the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
    /// This member is required.
    public var password: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.username = username
    }
}

struct CreateUserInputBody: Swift.Equatable {
    public let consoleAccess: Swift.Bool?
    public let groups: [Swift.String]?
    public let password: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserOutputResponse()"}
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateUserOutputResponseBody: Swift.Equatable {
}

extension CreateUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MqClientTypes {
    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
        }
    }
}

extension DeleteBrokerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBrokerInput(brokerId: \(Swift.String(describing: brokerId)))"}
}

extension DeleteBrokerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteBrokerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBrokerOutputError>
}

public struct DeleteBrokerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBrokerOutputError>
}

public struct DeleteBrokerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBrokerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBrokerOutputError>
}

public struct DeleteBrokerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBrokerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let brokerId = input.brokerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("brokerId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/brokers/\(brokerId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBrokerOutputError>
}

public struct DeleteBrokerInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init (
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DeleteBrokerInputBody: Swift.Equatable {
}

extension DeleteBrokerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBrokerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBrokerOutputResponse(brokerId: \(Swift.String(describing: brokerId)))"}
}

extension DeleteBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBrokerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
        } else {
            self.brokerId = nil
        }
    }
}

public struct DeleteBrokerOutputResponse: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?

    public init (
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DeleteBrokerOutputResponseBody: Swift.Equatable {
    public let brokerId: Swift.String?
}

extension DeleteBrokerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
    }
}

extension DeleteTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTagsInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension DeleteTagsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
}

extension DeleteTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTagsOutputResponse()"}
}

extension DeleteTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTagsOutputResponseBody: Swift.Equatable {
}

extension DeleteTagsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserInput(brokerId: \(Swift.String(describing: brokerId)), username: \(Swift.String(describing: username)))"}
}

extension DeleteUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let brokerId = input.brokerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("brokerId is nil and needs a value for the path of this operation"))))
        }
        guard let username = input.username else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("username is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Swift.Equatable {
}

extension DeleteUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MqClientTypes {
    /// The broker's deployment mode.
    public enum DeploymentMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeStandbyMultiAz
        case clusterMultiAz
        case singleInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentMode] {
            return [
                .activeStandbyMultiAz,
                .clusterMultiAz,
                .singleInstance,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeStandbyMultiAz: return "ACTIVE_STANDBY_MULTI_AZ"
            case .clusterMultiAz: return "CLUSTER_MULTI_AZ"
            case .singleInstance: return "SINGLE_INSTANCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentMode(rawValue: rawValue) ?? DeploymentMode.sdkUnknown(rawValue)
        }
    }
}

extension DescribeBrokerEngineTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBrokerEngineTypesInput(engineType: \(Swift.String(describing: engineType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBrokerEngineTypesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeBrokerEngineTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerEngineTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBrokerEngineTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerEngineTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBrokerEngineTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerEngineTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerEngineTypesOutputError>
}

public struct DescribeBrokerEngineTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerEngineTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBrokerEngineTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerEngineTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let engineType = input.operationInput.engineType {
            let engineTypeQueryItem = ClientRuntime.URLQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType).urlPercentEncoding())
            input.builder.withQueryItem(engineTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBrokerEngineTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerEngineTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerEngineTypesOutputError>
}

public struct DescribeBrokerEngineTypesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerEngineTypesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeBrokerEngineTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerEngineTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBrokerEngineTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerEngineTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerEngineTypesOutputError>
}

public struct DescribeBrokerEngineTypesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerEngineTypesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeBrokerEngineTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerEngineTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/broker-engine-types"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBrokerEngineTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerEngineTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerEngineTypesOutputError>
}

public struct DescribeBrokerEngineTypesInput: Swift.Equatable {
    /// Filter response by engine type.
    public var engineType: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        engineType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerEngineTypesInputBody: Swift.Equatable {
}

extension DescribeBrokerEngineTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBrokerEngineTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBrokerEngineTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBrokerEngineTypesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBrokerEngineTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBrokerEngineTypesOutputResponse(brokerEngineTypes: \(Swift.String(describing: brokerEngineTypes)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBrokerEngineTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBrokerEngineTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerEngineTypes = output.brokerEngineTypes
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.brokerEngineTypes = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBrokerEngineTypesOutputResponse: Swift.Equatable {
    /// List of available engine types and versions.
    public var brokerEngineTypes: [MqClientTypes.BrokerEngineType]?
    /// Required. The maximum number of engine types that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        brokerEngineTypes: [MqClientTypes.BrokerEngineType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerEngineTypes = brokerEngineTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerEngineTypesOutputResponseBody: Swift.Equatable {
    public let brokerEngineTypes: [MqClientTypes.BrokerEngineType]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeBrokerEngineTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerEngineTypes = "brokerEngineTypes"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerEngineTypesContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerEngineType?].self, forKey: .brokerEngineTypes)
        var brokerEngineTypesDecoded0:[MqClientTypes.BrokerEngineType]? = nil
        if let brokerEngineTypesContainer = brokerEngineTypesContainer {
            brokerEngineTypesDecoded0 = [MqClientTypes.BrokerEngineType]()
            for structure0 in brokerEngineTypesContainer {
                if let structure0 = structure0 {
                    brokerEngineTypesDecoded0?.append(structure0)
                }
            }
        }
        brokerEngineTypes = brokerEngineTypesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBrokerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBrokerInput(brokerId: \(Swift.String(describing: brokerId)))"}
}

extension DescribeBrokerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeBrokerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerOutputError>
}

public struct DescribeBrokerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerOutputError>
}

public struct DescribeBrokerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerOutputError>
}

public struct DescribeBrokerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let brokerId = input.brokerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("brokerId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/brokers/\(brokerId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerOutputError>
}

public struct DescribeBrokerInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init (
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DescribeBrokerInputBody: Swift.Equatable {
}

extension DescribeBrokerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBrokerInstanceOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBrokerInstanceOptionsInput(engineType: \(Swift.String(describing: engineType)), hostInstanceType: \(Swift.String(describing: hostInstanceType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), storageType: \(Swift.String(describing: storageType)))"}
}

extension DescribeBrokerInstanceOptionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeBrokerInstanceOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerInstanceOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBrokerInstanceOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBrokerInstanceOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerInstanceOptionsOutputError>
}

public struct DescribeBrokerInstanceOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerInstanceOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBrokerInstanceOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let storageType = input.operationInput.storageType {
            let storageTypeQueryItem = ClientRuntime.URLQueryItem(name: "storageType".urlPercentEncoding(), value: Swift.String(storageType).urlPercentEncoding())
            input.builder.withQueryItem(storageTypeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let engineType = input.operationInput.engineType {
            let engineTypeQueryItem = ClientRuntime.URLQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType).urlPercentEncoding())
            input.builder.withQueryItem(engineTypeQueryItem)
        }
        if let hostInstanceType = input.operationInput.hostInstanceType {
            let hostInstanceTypeQueryItem = ClientRuntime.URLQueryItem(name: "hostInstanceType".urlPercentEncoding(), value: Swift.String(hostInstanceType).urlPercentEncoding())
            input.builder.withQueryItem(hostInstanceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBrokerInstanceOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerInstanceOptionsOutputError>
}

public struct DescribeBrokerInstanceOptionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerInstanceOptionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeBrokerInstanceOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBrokerInstanceOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerInstanceOptionsOutputError>
}

public struct DescribeBrokerInstanceOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBrokerInstanceOptionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeBrokerInstanceOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/broker-instance-options"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBrokerInstanceOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBrokerInstanceOptionsOutputError>
}

public struct DescribeBrokerInstanceOptionsInput: Swift.Equatable {
    /// Filter response by engine type.
    public var engineType: Swift.String?
    /// Filter response by host instance type.
    public var hostInstanceType: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// Filter response by storage type.
    public var storageType: Swift.String?

    public init (
        engineType: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        storageType: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.hostInstanceType = hostInstanceType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.storageType = storageType
    }
}

struct DescribeBrokerInstanceOptionsInputBody: Swift.Equatable {
}

extension DescribeBrokerInstanceOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBrokerInstanceOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBrokerInstanceOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBrokerInstanceOptionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBrokerInstanceOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBrokerInstanceOptionsOutputResponse(brokerInstanceOptions: \(Swift.String(describing: brokerInstanceOptions)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBrokerInstanceOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBrokerInstanceOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerInstanceOptions = output.brokerInstanceOptions
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.brokerInstanceOptions = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBrokerInstanceOptionsOutputResponse: Swift.Equatable {
    /// List of available broker instance options.
    public var brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]?
    /// Required. The maximum number of instance options that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerInstanceOptions = brokerInstanceOptions
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerInstanceOptionsOutputResponseBody: Swift.Equatable {
    public let brokerInstanceOptions: [MqClientTypes.BrokerInstanceOption]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeBrokerInstanceOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerInstanceOptions = "brokerInstanceOptions"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerInstanceOptionsContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerInstanceOption?].self, forKey: .brokerInstanceOptions)
        var brokerInstanceOptionsDecoded0:[MqClientTypes.BrokerInstanceOption]? = nil
        if let brokerInstanceOptionsContainer = brokerInstanceOptionsContainer {
            brokerInstanceOptionsDecoded0 = [MqClientTypes.BrokerInstanceOption]()
            for structure0 in brokerInstanceOptionsContainer {
                if let structure0 = structure0 {
                    brokerInstanceOptionsDecoded0?.append(structure0)
                }
            }
        }
        brokerInstanceOptions = brokerInstanceOptionsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBrokerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBrokerOutputResponse(authenticationStrategy: \(Swift.String(describing: authenticationStrategy)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), brokerArn: \(Swift.String(describing: brokerArn)), brokerId: \(Swift.String(describing: brokerId)), brokerInstances: \(Swift.String(describing: brokerInstances)), brokerName: \(Swift.String(describing: brokerName)), brokerState: \(Swift.String(describing: brokerState)), configurations: \(Swift.String(describing: configurations)), created: \(Swift.String(describing: created)), deploymentMode: \(Swift.String(describing: deploymentMode)), encryptionOptions: \(Swift.String(describing: encryptionOptions)), engineType: \(Swift.String(describing: engineType)), engineVersion: \(Swift.String(describing: engineVersion)), hostInstanceType: \(Swift.String(describing: hostInstanceType)), ldapServerMetadata: \(Swift.String(describing: ldapServerMetadata)), logs: \(Swift.String(describing: logs)), maintenanceWindowStartTime: \(Swift.String(describing: maintenanceWindowStartTime)), pendingAuthenticationStrategy: \(Swift.String(describing: pendingAuthenticationStrategy)), pendingEngineVersion: \(Swift.String(describing: pendingEngineVersion)), pendingHostInstanceType: \(Swift.String(describing: pendingHostInstanceType)), pendingLdapServerMetadata: \(Swift.String(describing: pendingLdapServerMetadata)), pendingSecurityGroups: \(Swift.String(describing: pendingSecurityGroups)), publiclyAccessible: \(Swift.String(describing: publiclyAccessible)), securityGroups: \(Swift.String(describing: securityGroups)), storageType: \(Swift.String(describing: storageType)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), users: \(Swift.String(describing: users)))"}
}

extension DescribeBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBrokerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authenticationStrategy = output.authenticationStrategy
            self.autoMinorVersionUpgrade = output.autoMinorVersionUpgrade
            self.brokerArn = output.brokerArn
            self.brokerId = output.brokerId
            self.brokerInstances = output.brokerInstances
            self.brokerName = output.brokerName
            self.brokerState = output.brokerState
            self.configurations = output.configurations
            self.created = output.created
            self.deploymentMode = output.deploymentMode
            self.encryptionOptions = output.encryptionOptions
            self.engineType = output.engineType
            self.engineVersion = output.engineVersion
            self.hostInstanceType = output.hostInstanceType
            self.ldapServerMetadata = output.ldapServerMetadata
            self.logs = output.logs
            self.maintenanceWindowStartTime = output.maintenanceWindowStartTime
            self.pendingAuthenticationStrategy = output.pendingAuthenticationStrategy
            self.pendingEngineVersion = output.pendingEngineVersion
            self.pendingHostInstanceType = output.pendingHostInstanceType
            self.pendingLdapServerMetadata = output.pendingLdapServerMetadata
            self.pendingSecurityGroups = output.pendingSecurityGroups
            self.publiclyAccessible = output.publiclyAccessible
            self.securityGroups = output.securityGroups
            self.storageType = output.storageType
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.users = output.users
        } else {
            self.authenticationStrategy = nil
            self.autoMinorVersionUpgrade = nil
            self.brokerArn = nil
            self.brokerId = nil
            self.brokerInstances = nil
            self.brokerName = nil
            self.brokerState = nil
            self.configurations = nil
            self.created = nil
            self.deploymentMode = nil
            self.encryptionOptions = nil
            self.engineType = nil
            self.engineVersion = nil
            self.hostInstanceType = nil
            self.ldapServerMetadata = nil
            self.logs = nil
            self.maintenanceWindowStartTime = nil
            self.pendingAuthenticationStrategy = nil
            self.pendingEngineVersion = nil
            self.pendingHostInstanceType = nil
            self.pendingLdapServerMetadata = nil
            self.pendingSecurityGroups = nil
            self.publiclyAccessible = nil
            self.securityGroups = nil
            self.storageType = nil
            self.subnetIds = nil
            self.tags = nil
            self.users = nil
        }
    }
}

public struct DescribeBrokerOutputResponse: Swift.Equatable {
    /// The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The broker's Amazon Resource Name (ARN).
    public var brokerArn: Swift.String?
    /// The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// A list of information about allocated brokers.
    public var brokerInstances: [MqClientTypes.BrokerInstance]?
    /// The broker's name. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain white spaces, brackets, wildcard characters, or special characters.
    public var brokerName: Swift.String?
    /// The broker's status.
    public var brokerState: MqClientTypes.BrokerState?
    /// The list of all revisions for the specified configuration.
    public var configurations: MqClientTypes.Configurations?
    /// The time when the broker was created.
    public var created: ClientRuntime.Date?
    /// The broker's deployment mode.
    public var deploymentMode: MqClientTypes.DeploymentMode?
    /// Encryption options for the broker. Does not apply to RabbitMQ brokers.
    public var encryptionOptions: MqClientTypes.EncryptionOptions?
    /// The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public var engineType: MqClientTypes.EngineType?
    /// The broker engine's version. For a list of supported engine versions, see <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html">Supported engines.
    public var engineVersion: Swift.String?
    /// The broker's instance type.
    public var hostInstanceType: Swift.String?
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    public var logs: MqClientTypes.LogsSummary?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The authentication strategy that will be applied when the broker is rebooted. The default is SIMPLE.
    public var pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// The broker engine version to upgrade to. For a list of supported engine versions, see <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html">Supported engines.
    public var pendingEngineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types">Broker instance types.
    public var pendingHostInstanceType: Swift.String?
    /// The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker after it is rebooted.
    public var pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of pending security groups to authorize connections to brokers.
    public var pendingSecurityGroups: [Swift.String]?
    /// Enables connections from applications outside of the VPC that hosts the broker's subnets.
    public var publiclyAccessible: Swift.Bool?
    /// The list of rules (1 minimum, 125 maximum) that authorize connections to brokers.
    public var securityGroups: [Swift.String]?
    /// The broker's storage type.
    public var storageType: MqClientTypes.BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones.
    public var subnetIds: [Swift.String]?
    /// The list of all tags associated with this broker.
    public var tags: [Swift.String:Swift.String]?
    /// The list of all broker usernames for the specified broker.
    public var users: [MqClientTypes.UserSummary]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerArn: Swift.String? = nil,
        brokerId: Swift.String? = nil,
        brokerInstances: [MqClientTypes.BrokerInstance]? = nil,
        brokerName: Swift.String? = nil,
        brokerState: MqClientTypes.BrokerState? = nil,
        configurations: MqClientTypes.Configurations? = nil,
        created: ClientRuntime.Date? = nil,
        deploymentMode: MqClientTypes.DeploymentMode? = nil,
        encryptionOptions: MqClientTypes.EncryptionOptions? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        logs: MqClientTypes.LogsSummary? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        pendingEngineVersion: Swift.String? = nil,
        pendingHostInstanceType: Swift.String? = nil,
        pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        pendingSecurityGroups: [Swift.String]? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroups: [Swift.String]? = nil,
        storageType: MqClientTypes.BrokerStorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        users: [MqClientTypes.UserSummary]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerArn = brokerArn
        self.brokerId = brokerId
        self.brokerInstances = brokerInstances
        self.brokerName = brokerName
        self.brokerState = brokerState
        self.configurations = configurations
        self.created = created
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.pendingAuthenticationStrategy = pendingAuthenticationStrategy
        self.pendingEngineVersion = pendingEngineVersion
        self.pendingHostInstanceType = pendingHostInstanceType
        self.pendingLdapServerMetadata = pendingLdapServerMetadata
        self.pendingSecurityGroups = pendingSecurityGroups
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

struct DescribeBrokerOutputResponseBody: Swift.Equatable {
    public let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    public let autoMinorVersionUpgrade: Swift.Bool?
    public let brokerArn: Swift.String?
    public let brokerId: Swift.String?
    public let brokerInstances: [MqClientTypes.BrokerInstance]?
    public let brokerName: Swift.String?
    public let brokerState: MqClientTypes.BrokerState?
    public let configurations: MqClientTypes.Configurations?
    public let created: ClientRuntime.Date?
    public let deploymentMode: MqClientTypes.DeploymentMode?
    public let encryptionOptions: MqClientTypes.EncryptionOptions?
    public let engineType: MqClientTypes.EngineType?
    public let engineVersion: Swift.String?
    public let hostInstanceType: Swift.String?
    public let ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    public let logs: MqClientTypes.LogsSummary?
    public let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    public let pendingAuthenticationStrategy: MqClientTypes.AuthenticationStrategy?
    public let pendingEngineVersion: Swift.String?
    public let pendingHostInstanceType: Swift.String?
    public let pendingLdapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    public let pendingSecurityGroups: [Swift.String]?
    public let publiclyAccessible: Swift.Bool?
    public let securityGroups: [Swift.String]?
    public let storageType: MqClientTypes.BrokerStorageType?
    public let subnetIds: [Swift.String]?
    public let tags: [Swift.String:Swift.String]?
    public let users: [MqClientTypes.UserSummary]?
}

extension DescribeBrokerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
        case brokerInstances = "brokerInstances"
        case brokerName = "brokerName"
        case brokerState = "brokerState"
        case configurations = "configurations"
        case created = "created"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case pendingAuthenticationStrategy = "pendingAuthenticationStrategy"
        case pendingEngineVersion = "pendingEngineVersion"
        case pendingHostInstanceType = "pendingHostInstanceType"
        case pendingLdapServerMetadata = "pendingLdapServerMetadata"
        case pendingSecurityGroups = "pendingSecurityGroups"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let brokerInstancesContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerInstance?].self, forKey: .brokerInstances)
        var brokerInstancesDecoded0:[MqClientTypes.BrokerInstance]? = nil
        if let brokerInstancesContainer = brokerInstancesContainer {
            brokerInstancesDecoded0 = [MqClientTypes.BrokerInstance]()
            for structure0 in brokerInstancesContainer {
                if let structure0 = structure0 {
                    brokerInstancesDecoded0?.append(structure0)
                }
            }
        }
        brokerInstances = brokerInstancesDecoded0
        let brokerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let brokerStateDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerState.self, forKey: .brokerState)
        brokerState = brokerStateDecoded
        let configurationsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Configurations.self, forKey: .configurations)
        configurations = configurationsDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(MqClientTypes.DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let encryptionOptionsDecoded = try containerValues.decodeIfPresent(MqClientTypes.EncryptionOptions.self, forKey: .encryptionOptions)
        encryptionOptions = encryptionOptionsDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataOutput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.LogsSummary.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let pendingAuthenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .pendingAuthenticationStrategy)
        pendingAuthenticationStrategy = pendingAuthenticationStrategyDecoded
        let pendingEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingEngineVersion)
        pendingEngineVersion = pendingEngineVersionDecoded
        let pendingHostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingHostInstanceType)
        pendingHostInstanceType = pendingHostInstanceTypeDecoded
        let pendingLdapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataOutput.self, forKey: .pendingLdapServerMetadata)
        pendingLdapServerMetadata = pendingLdapServerMetadataDecoded
        let pendingSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pendingSecurityGroups)
        var pendingSecurityGroupsDecoded0:[Swift.String]? = nil
        if let pendingSecurityGroupsContainer = pendingSecurityGroupsContainer {
            pendingSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in pendingSecurityGroupsContainer {
                if let string0 = string0 {
                    pendingSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        pendingSecurityGroups = pendingSecurityGroupsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([MqClientTypes.UserSummary?].self, forKey: .users)
        var usersDecoded0:[MqClientTypes.UserSummary]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MqClientTypes.UserSummary]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension DescribeConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConfigurationInput(configurationId: \(Swift.String(describing: configurationId)))"}
}

extension DescribeConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let configurationId = input.configurationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/configurations/\(configurationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?

    public init (
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct DescribeConfigurationInputBody: Swift.Equatable {
}

extension DescribeConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConfigurationOutputResponse(arn: \(Swift.String(describing: arn)), authenticationStrategy: \(Swift.String(describing: authenticationStrategy)), created: \(Swift.String(describing: created)), description: \(Swift.String(describing: description)), engineType: \(Swift.String(describing: engineType)), engineVersion: \(Swift.String(describing: engineVersion)), id: \(Swift.String(describing: id)), latestRevision: \(Swift.String(describing: latestRevision)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authenticationStrategy = output.authenticationStrategy
            self.created = output.created
            self.description = output.description
            self.engineType = output.engineType
            self.engineVersion = output.engineVersion
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authenticationStrategy = nil
            self.created = nil
            self.description = nil
            self.engineType = nil
            self.engineVersion = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct DescribeConfigurationOutputResponse: Swift.Equatable {
    /// Required. The ARN of the configuration.
    public var arn: Swift.String?
    /// Optional. The authentication strategy associated with the configuration. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Required. The date and time of the configuration revision.
    public var created: ClientRuntime.Date?
    /// Required. The description of the configuration.
    public var description: Swift.String?
    /// Required. The type of broker engine. Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public var engineType: MqClientTypes.EngineType?
    /// Required. The broker engine's version. For a list of supported engine versions, see, <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html">Supported engines.
    public var engineVersion: Swift.String?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// Required. The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?
    /// The list of all tags associated with this configuration.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        created: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        engineType: MqClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.tags = tags
    }
}

struct DescribeConfigurationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    public let created: ClientRuntime.Date?
    public let description: Swift.String?
    public let engineType: MqClientTypes.EngineType?
    public let engineVersion: Swift.String?
    public let id: Swift.String?
    public let latestRevision: MqClientTypes.ConfigurationRevision?
    public let name: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case description = "description"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(MqClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeConfigurationRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConfigurationRevisionInput(configurationId: \(Swift.String(describing: configurationId)), configurationRevision: \(Swift.String(describing: configurationRevision)))"}
}

extension DescribeConfigurationRevisionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeConfigurationRevisionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConfigurationRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConfigurationRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConfigurationRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConfigurationRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationRevisionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeConfigurationRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeConfigurationRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConfigurationRevisionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeConfigurationRevisionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let configurationId = input.configurationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationId is nil and needs a value for the path of this operation"))))
        }
        guard let configurationRevision = input.configurationRevision else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationRevision is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/configurations/\(configurationId.urlPercentEncoding())/revisions/\(configurationRevision.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeConfigurationRevisionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// The revision of the configuration.
    /// This member is required.
    public var configurationRevision: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        configurationRevision: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.configurationRevision = configurationRevision
    }
}

struct DescribeConfigurationRevisionInputBody: Swift.Equatable {
}

extension DescribeConfigurationRevisionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeConfigurationRevisionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationRevisionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationRevisionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationRevisionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConfigurationRevisionOutputResponse(configurationId: \(Swift.String(describing: configurationId)), created: \(Swift.String(describing: created)), data: \(Swift.String(describing: data)), description: \(Swift.String(describing: description)))"}
}

extension DescribeConfigurationRevisionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConfigurationRevisionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
            self.created = output.created
            self.data = output.data
            self.description = output.description
        } else {
            self.configurationId = nil
            self.created = nil
            self.data = nil
            self.description = nil
        }
    }
}

public struct DescribeConfigurationRevisionOutputResponse: Swift.Equatable {
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var configurationId: Swift.String?
    /// Required. The date and time of the configuration.
    public var created: ClientRuntime.Date?
    /// Required. The base64-encoded XML configuration.
    public var data: Swift.String?
    /// The description of the configuration.
    public var description: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        created: ClientRuntime.Date? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.created = created
        self.data = data
        self.description = description
    }
}

struct DescribeConfigurationRevisionOutputResponseBody: Swift.Equatable {
    public let configurationId: Swift.String?
    public let created: ClientRuntime.Date?
    public let data: Swift.String?
    public let description: Swift.String?
}

extension DescribeConfigurationRevisionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "configurationId"
        case created = "created"
        case data = "data"
        case description = "description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DescribeUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserInput(brokerId: \(Swift.String(describing: brokerId)), username: \(Swift.String(describing: username)))"}
}

extension DescribeUserInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let brokerId = input.brokerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("brokerId is nil and needs a value for the path of this operation"))))
        }
        guard let username = input.username else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("username is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

struct DescribeUserInputBody: Swift.Equatable {
}

extension DescribeUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserOutputResponse(brokerId: \(Swift.String(describing: brokerId)), consoleAccess: \(Swift.String(describing: consoleAccess)), groups: \(Swift.String(describing: groups)), pending: \(Swift.String(describing: pending)), username: \(Swift.String(describing: username)))"}
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
            self.consoleAccess = output.consoleAccess
            self.groups = output.groups
            self.pending = output.pending
            self.username = output.username
        } else {
            self.brokerId = nil
            self.consoleAccess = nil
            self.groups = nil
            self.pending = nil
            self.username = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// The status of the changes pending for the ActiveMQ user.
    public var pending: MqClientTypes.UserPendingChanges?
    /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        pending: MqClientTypes.UserPendingChanges? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.pending = pending
        self.username = username
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    public let brokerId: Swift.String?
    public let consoleAccess: Swift.Bool?
    public let groups: [Swift.String]?
    public let pending: MqClientTypes.UserPendingChanges?
    public let username: Swift.String?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case pending = "pending"
        case username = "username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let pendingDecoded = try containerValues.decodeIfPresent(MqClientTypes.UserPendingChanges.self, forKey: .pending)
        pending = pendingDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension MqClientTypes.EncryptionOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "kmsKeyId"
        case useAwsOwnedKey = "useAwsOwnedKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let useAwsOwnedKey = useAwsOwnedKey {
            try encodeContainer.encode(useAwsOwnedKey, forKey: .useAwsOwnedKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let useAwsOwnedKeyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAwsOwnedKey)
        useAwsOwnedKey = useAwsOwnedKeyDecoded
    }
}

extension MqClientTypes.EncryptionOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionOptions(kmsKeyId: \(Swift.String(describing: kmsKeyId)), useAwsOwnedKey: \(Swift.String(describing: useAwsOwnedKey)))"}
}

extension MqClientTypes {
    /// Does not apply to RabbitMQ brokers. Encryption options for the broker.
    public struct EncryptionOptions: Swift.Equatable {
        /// The customer master key (CMK) to use for the AWS Key Management Service (KMS). This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
        public var kmsKeyId: Swift.String?
        /// Enables the use of an AWS owned CMK using AWS Key Management Service (KMS). Set to true by default, if no value is provided, for example, for RabbitMQ brokers.
        /// This member is required.
        public var useAwsOwnedKey: Swift.Bool?

        public init (
            kmsKeyId: Swift.String? = nil,
            useAwsOwnedKey: Swift.Bool? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.useAwsOwnedKey = useAwsOwnedKey
        }
    }

}

extension MqClientTypes {
    /// The type of broker engine. Amazon MQ supports ActiveMQ and RabbitMQ.
    public enum EngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activemq
        case rabbitmq
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineType] {
            return [
                .activemq,
                .rabbitmq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activemq: return "ACTIVEMQ"
            case .rabbitmq: return "RABBITMQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EngineType(rawValue: rawValue) ?? EngineType.sdkUnknown(rawValue)
        }
    }
}

extension MqClientTypes.EngineVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MqClientTypes.EngineVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngineVersion(name: \(Swift.String(describing: name)))"}
}

extension MqClientTypes {
    /// Id of the engine version.
    public struct EngineVersion: Swift.Equatable {
        /// Id for the version.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(errorAttribute: \(Swift.String(describing: errorAttribute)), message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let errorAttribute: Swift.String?
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerErrorException(errorAttribute: \(Swift.String(describing: errorAttribute)), message: \(Swift.String(describing: message)))"}
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    public let errorAttribute: Swift.String?
    public let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MqClientTypes.LdapServerMetadataInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hosts = "hosts"
        case roleBase = "roleBase"
        case roleName = "roleName"
        case roleSearchMatching = "roleSearchMatching"
        case roleSearchSubtree = "roleSearchSubtree"
        case serviceAccountPassword = "serviceAccountPassword"
        case serviceAccountUsername = "serviceAccountUsername"
        case userBase = "userBase"
        case userRoleName = "userRoleName"
        case userSearchMatching = "userSearchMatching"
        case userSearchSubtree = "userSearchSubtree"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for __listof__string0 in hosts {
                try hostsContainer.encode(__listof__string0)
            }
        }
        if let roleBase = roleBase {
            try encodeContainer.encode(roleBase, forKey: .roleBase)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let roleSearchMatching = roleSearchMatching {
            try encodeContainer.encode(roleSearchMatching, forKey: .roleSearchMatching)
        }
        if let roleSearchSubtree = roleSearchSubtree {
            try encodeContainer.encode(roleSearchSubtree, forKey: .roleSearchSubtree)
        }
        if let serviceAccountPassword = serviceAccountPassword {
            try encodeContainer.encode(serviceAccountPassword, forKey: .serviceAccountPassword)
        }
        if let serviceAccountUsername = serviceAccountUsername {
            try encodeContainer.encode(serviceAccountUsername, forKey: .serviceAccountUsername)
        }
        if let userBase = userBase {
            try encodeContainer.encode(userBase, forKey: .userBase)
        }
        if let userRoleName = userRoleName {
            try encodeContainer.encode(userRoleName, forKey: .userRoleName)
        }
        if let userSearchMatching = userSearchMatching {
            try encodeContainer.encode(userSearchMatching, forKey: .userSearchMatching)
        }
        if let userSearchSubtree = userSearchSubtree {
            try encodeContainer.encode(userSearchSubtree, forKey: .userSearchSubtree)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hosts)
        var hostsDecoded0:[Swift.String]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [Swift.String]()
            for string0 in hostsContainer {
                if let string0 = string0 {
                    hostsDecoded0?.append(string0)
                }
            }
        }
        hosts = hostsDecoded0
        let roleBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleBase)
        roleBase = roleBaseDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleSearchMatching)
        roleSearchMatching = roleSearchMatchingDecoded
        let roleSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roleSearchSubtree)
        roleSearchSubtree = roleSearchSubtreeDecoded
        let serviceAccountPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccountPassword)
        serviceAccountPassword = serviceAccountPasswordDecoded
        let serviceAccountUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccountUsername)
        serviceAccountUsername = serviceAccountUsernameDecoded
        let userBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userBase)
        userBase = userBaseDecoded
        let userRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleName)
        userRoleName = userRoleNameDecoded
        let userSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSearchMatching)
        userSearchMatching = userSearchMatchingDecoded
        let userSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userSearchSubtree)
        userSearchSubtree = userSearchSubtreeDecoded
    }
}

extension MqClientTypes.LdapServerMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LdapServerMetadataInput(hosts: \(Swift.String(describing: hosts)), roleBase: \(Swift.String(describing: roleBase)), roleName: \(Swift.String(describing: roleName)), roleSearchMatching: \(Swift.String(describing: roleSearchMatching)), roleSearchSubtree: \(Swift.String(describing: roleSearchSubtree)), serviceAccountPassword: \(Swift.String(describing: serviceAccountPassword)), serviceAccountUsername: \(Swift.String(describing: serviceAccountUsername)), userBase: \(Swift.String(describing: userBase)), userRoleName: \(Swift.String(describing: userRoleName)), userSearchMatching: \(Swift.String(describing: userSearchMatching)), userSearchSubtree: \(Swift.String(describing: userSearchSubtree)))"}
}

extension MqClientTypes {
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public struct LdapServerMetadataInput: Swift.Equatable {
        /// Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        /// This member is required.
        public var hosts: [Swift.String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp,
        ///                   dc=example, dc=com.
        /// This member is required.
        public var roleBase: Swift.String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public var roleName: Swift.String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        /// This member is required.
        public var roleSearchMatching: Swift.String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public var roleSearchSubtree: Swift.Bool?
        /// Service account password. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example,
        ///                   dc=com.
        /// This member is required.
        public var serviceAccountPassword: Swift.String?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example,
        ///                   dc=com.
        /// This member is required.
        public var serviceAccountUsername: Swift.String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp,
        ///                   dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userBase: Swift.String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public var userRoleName: Swift.String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example,
        ///                   dc=com.
        /// This member is required.
        public var userSearchMatching: Swift.String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public var userSearchSubtree: Swift.Bool?

        public init (
            hosts: [Swift.String]? = nil,
            roleBase: Swift.String? = nil,
            roleName: Swift.String? = nil,
            roleSearchMatching: Swift.String? = nil,
            roleSearchSubtree: Swift.Bool? = nil,
            serviceAccountPassword: Swift.String? = nil,
            serviceAccountUsername: Swift.String? = nil,
            userBase: Swift.String? = nil,
            userRoleName: Swift.String? = nil,
            userSearchMatching: Swift.String? = nil,
            userSearchSubtree: Swift.Bool? = nil
        )
        {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountPassword = serviceAccountPassword
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }
    }

}

extension MqClientTypes.LdapServerMetadataOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hosts = "hosts"
        case roleBase = "roleBase"
        case roleName = "roleName"
        case roleSearchMatching = "roleSearchMatching"
        case roleSearchSubtree = "roleSearchSubtree"
        case serviceAccountUsername = "serviceAccountUsername"
        case userBase = "userBase"
        case userRoleName = "userRoleName"
        case userSearchMatching = "userSearchMatching"
        case userSearchSubtree = "userSearchSubtree"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for __listof__string0 in hosts {
                try hostsContainer.encode(__listof__string0)
            }
        }
        if let roleBase = roleBase {
            try encodeContainer.encode(roleBase, forKey: .roleBase)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let roleSearchMatching = roleSearchMatching {
            try encodeContainer.encode(roleSearchMatching, forKey: .roleSearchMatching)
        }
        if let roleSearchSubtree = roleSearchSubtree {
            try encodeContainer.encode(roleSearchSubtree, forKey: .roleSearchSubtree)
        }
        if let serviceAccountUsername = serviceAccountUsername {
            try encodeContainer.encode(serviceAccountUsername, forKey: .serviceAccountUsername)
        }
        if let userBase = userBase {
            try encodeContainer.encode(userBase, forKey: .userBase)
        }
        if let userRoleName = userRoleName {
            try encodeContainer.encode(userRoleName, forKey: .userRoleName)
        }
        if let userSearchMatching = userSearchMatching {
            try encodeContainer.encode(userSearchMatching, forKey: .userSearchMatching)
        }
        if let userSearchSubtree = userSearchSubtree {
            try encodeContainer.encode(userSearchSubtree, forKey: .userSearchSubtree)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hosts)
        var hostsDecoded0:[Swift.String]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [Swift.String]()
            for string0 in hostsContainer {
                if let string0 = string0 {
                    hostsDecoded0?.append(string0)
                }
            }
        }
        hosts = hostsDecoded0
        let roleBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleBase)
        roleBase = roleBaseDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleSearchMatching)
        roleSearchMatching = roleSearchMatchingDecoded
        let roleSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roleSearchSubtree)
        roleSearchSubtree = roleSearchSubtreeDecoded
        let serviceAccountUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccountUsername)
        serviceAccountUsername = serviceAccountUsernameDecoded
        let userBaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userBase)
        userBase = userBaseDecoded
        let userRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleName)
        userRoleName = userRoleNameDecoded
        let userSearchMatchingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userSearchMatching)
        userSearchMatching = userSearchMatchingDecoded
        let userSearchSubtreeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .userSearchSubtree)
        userSearchSubtree = userSearchSubtreeDecoded
    }
}

extension MqClientTypes.LdapServerMetadataOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LdapServerMetadataOutput(hosts: \(Swift.String(describing: hosts)), roleBase: \(Swift.String(describing: roleBase)), roleName: \(Swift.String(describing: roleName)), roleSearchMatching: \(Swift.String(describing: roleSearchMatching)), roleSearchSubtree: \(Swift.String(describing: roleSearchSubtree)), serviceAccountUsername: \(Swift.String(describing: serviceAccountUsername)), userBase: \(Swift.String(describing: userBase)), userRoleName: \(Swift.String(describing: userRoleName)), userSearchMatching: \(Swift.String(describing: userSearchMatching)), userSearchSubtree: \(Swift.String(describing: userSearchSubtree)))"}
}

extension MqClientTypes {
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public struct LdapServerMetadataOutput: Swift.Equatable {
        /// Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        /// This member is required.
        public var hosts: [Swift.String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, ou=group, ou=corp, dc=corp,
        ///                   dc=example, dc=com.
        /// This member is required.
        public var roleBase: Swift.String?
        /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
        public var roleName: Swift.String?
        /// The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the {0} placeholder in the search filter. The client's username is substituted into the {1} placeholder. For example, if you set this option to (member=uid={1})for the user janedoe, the search filter becomes (member=uid=janedoe) after string substitution. It matches all role entries that have a member attribute equal to uid=janedoe under the subtree selected by the roleBase.
        /// This member is required.
        public var roleSearchMatching: Swift.String?
        /// The directory search scope for the role. If set to true, scope is to search the entire subtree.
        public var roleSearchSubtree: Swift.Bool?
        /// Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, cn=admin,dc=corp, dc=example,
        ///                   dc=com.
        /// This member is required.
        public var serviceAccountUsername: Swift.String?
        /// Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to ou=Users,ou=corp, dc=corp,
        ///                   dc=example, dc=com, the search for user entries is restricted to the subtree beneath ou=Users, ou=corp, dc=corp, dc=example, dc=com.
        /// This member is required.
        public var userBase: Swift.String?
        /// Specifies the name of the LDAP attribute for the user group membership.
        public var userRoleName: Swift.String?
        /// The LDAP search filter used to find users within the userBase. The client's username is substituted into the {0} placeholder in the search filter. For example, if this option is set to (uid={0}) and the received username is janedoe, the search filter becomes (uid=janedoe) after string substitution. It will result in matching an entry like uid=janedoe, ou=Users,ou=corp, dc=corp, dc=example,
        ///                dc=com.
        /// This member is required.
        public var userSearchMatching: Swift.String?
        /// The directory search scope for the user. If set to true, scope is to search the entire subtree.
        public var userSearchSubtree: Swift.Bool?

        public init (
            hosts: [Swift.String]? = nil,
            roleBase: Swift.String? = nil,
            roleName: Swift.String? = nil,
            roleSearchMatching: Swift.String? = nil,
            roleSearchSubtree: Swift.Bool? = nil,
            serviceAccountUsername: Swift.String? = nil,
            userBase: Swift.String? = nil,
            userRoleName: Swift.String? = nil,
            userSearchMatching: Swift.String? = nil,
            userSearchSubtree: Swift.Bool? = nil
        )
        {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }
    }

}

extension ListBrokersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBrokersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBrokersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListBrokersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBrokersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBrokersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBrokersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBrokersOutputError>
}

public struct ListBrokersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBrokersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBrokersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBrokersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBrokersOutputError>
}

public struct ListBrokersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBrokersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListBrokersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBrokersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBrokersOutputError>
}

public struct ListBrokersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBrokersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListBrokersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/brokers"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBrokersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBrokersOutputError>
}

public struct ListBrokersInput: Swift.Equatable {
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBrokersInputBody: Swift.Equatable {
}

extension ListBrokersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBrokersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBrokersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBrokersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBrokersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBrokersOutputResponse(brokerSummaries: \(Swift.String(describing: brokerSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBrokersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBrokersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerSummaries = output.brokerSummaries
            self.nextToken = output.nextToken
        } else {
            self.brokerSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBrokersOutputResponse: Swift.Equatable {
    /// A list of information about all brokers.
    public var brokerSummaries: [MqClientTypes.BrokerSummary]?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        brokerSummaries: [MqClientTypes.BrokerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerSummaries = brokerSummaries
        self.nextToken = nextToken
    }
}

struct ListBrokersOutputResponseBody: Swift.Equatable {
    public let brokerSummaries: [MqClientTypes.BrokerSummary]?
    public let nextToken: Swift.String?
}

extension ListBrokersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerSummaries = "brokerSummaries"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerSummariesContainer = try containerValues.decodeIfPresent([MqClientTypes.BrokerSummary?].self, forKey: .brokerSummaries)
        var brokerSummariesDecoded0:[MqClientTypes.BrokerSummary]? = nil
        if let brokerSummariesContainer = brokerSummariesContainer {
            brokerSummariesDecoded0 = [MqClientTypes.BrokerSummary]()
            for structure0 in brokerSummariesContainer {
                if let structure0 = structure0 {
                    brokerSummariesDecoded0?.append(structure0)
                }
            }
        }
        brokerSummaries = brokerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationRevisionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationRevisionsInput(configurationId: \(Swift.String(describing: configurationId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigurationRevisionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListConfigurationRevisionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationRevisionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationRevisionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationRevisionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationRevisionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationRevisionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationRevisionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationRevisionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationRevisionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationRevisionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let configurationId = input.configurationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/configurations/\(configurationId.urlPercentEncoding())/revisions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationRevisionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationRevisionsInputBody: Swift.Equatable {
}

extension ListConfigurationRevisionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationRevisionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationRevisionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationRevisionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationRevisionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationRevisionsOutputResponse(configurationId: \(Swift.String(describing: configurationId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), revisions: \(Swift.String(describing: revisions)))"}
}

extension ListConfigurationRevisionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.configurationId = nil
            self.maxResults = nil
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListConfigurationRevisionsOutputResponse: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    public var configurationId: Swift.String?
    /// The maximum number of configuration revisions that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// The list of all revisions for the specified configuration.
    public var revisions: [MqClientTypes.ConfigurationRevision]?

    public init (
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        revisions: [MqClientTypes.ConfigurationRevision]? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListConfigurationRevisionsOutputResponseBody: Swift.Equatable {
    public let configurationId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let revisions: [MqClientTypes.ConfigurationRevision]?
}

extension ListConfigurationRevisionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "configurationId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case revisions = "revisions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([MqClientTypes.ConfigurationRevision?].self, forKey: .revisions)
        var revisionsDecoded0:[MqClientTypes.ConfigurationRevision]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [MqClientTypes.ConfigurationRevision]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

extension ListConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/configurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInput: Swift.Equatable {
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsInputBody: Swift.Equatable {
}

extension ListConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConfigurationsOutputResponse(configurations: \(Swift.String(describing: configurations)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.maxResults = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutputResponse: Swift.Equatable {
    /// The list of all revisions for the specified configuration.
    public var configurations: [MqClientTypes.Configuration]?
    /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        configurations: [MqClientTypes.Configuration]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputResponseBody: Swift.Equatable {
    public let configurations: [MqClientTypes.Configuration]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations = "configurations"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([MqClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[MqClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [MqClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersInput(brokerId: \(Swift.String(describing: brokerId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListUsersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListUsersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let brokerId = input.brokerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("brokerId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/brokers/\(brokerId.urlPercentEncoding())/users"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersOutputResponse(brokerId: \(Swift.String(describing: brokerId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), users: \(Swift.String(describing: users)))"}
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.brokerId = output.brokerId
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.brokerId = nil
            self.maxResults = nil
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// Required. The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public var maxResults: Swift.Int?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public var nextToken: Swift.String?
    /// Required. The list of all ActiveMQ usernames for the specified broker. Does not apply to RabbitMQ brokers.
    public var users: [MqClientTypes.UserSummary]?

    public init (
        brokerId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        users: [MqClientTypes.UserSummary]? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    public let brokerId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let users: [MqClientTypes.UserSummary]?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brokerId = "brokerId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case users = "users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let usersContainer = try containerValues.decodeIfPresent([MqClientTypes.UserSummary?].self, forKey: .users)
        var usersDecoded0:[MqClientTypes.UserSummary]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [MqClientTypes.UserSummary]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension MqClientTypes.Logs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audit = "audit"
        case general = "general"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audit = audit {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let general = general {
            try encodeContainer.encode(general, forKey: .general)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .audit)
        audit = auditDecoded
        let generalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .general)
        general = generalDecoded
    }
}

extension MqClientTypes.Logs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Logs(audit: \(Swift.String(describing: audit)), general: \(Swift.String(describing: general)))"}
}

extension MqClientTypes {
    /// The list of information about logs to be enabled for the specified broker.
    public struct Logs: Swift.Equatable {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
        public var audit: Swift.Bool?
        /// Enables general logging.
        public var general: Swift.Bool?

        public init (
            audit: Swift.Bool? = nil,
            general: Swift.Bool? = nil
        )
        {
            self.audit = audit
            self.general = general
        }
    }

}

extension MqClientTypes.LogsSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audit = "audit"
        case auditLogGroup = "auditLogGroup"
        case general = "general"
        case generalLogGroup = "generalLogGroup"
        case pending = "pending"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audit = audit {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let auditLogGroup = auditLogGroup {
            try encodeContainer.encode(auditLogGroup, forKey: .auditLogGroup)
        }
        if let general = general {
            try encodeContainer.encode(general, forKey: .general)
        }
        if let generalLogGroup = generalLogGroup {
            try encodeContainer.encode(generalLogGroup, forKey: .generalLogGroup)
        }
        if let pending = pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .audit)
        audit = auditDecoded
        let auditLogGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .auditLogGroup)
        auditLogGroup = auditLogGroupDecoded
        let generalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .general)
        general = generalDecoded
        let generalLogGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generalLogGroup)
        generalLogGroup = generalLogGroupDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(MqClientTypes.PendingLogs.self, forKey: .pending)
        pending = pendingDecoded
    }
}

extension MqClientTypes.LogsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LogsSummary(audit: \(Swift.String(describing: audit)), auditLogGroup: \(Swift.String(describing: auditLogGroup)), general: \(Swift.String(describing: general)), generalLogGroup: \(Swift.String(describing: generalLogGroup)), pending: \(Swift.String(describing: pending)))"}
}

extension MqClientTypes {
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    public struct LogsSummary: Swift.Equatable {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public var audit: Swift.Bool?
        /// The location of the CloudWatch Logs log group where audit logs are sent.
        public var auditLogGroup: Swift.String?
        /// Enables general logging.
        /// This member is required.
        public var general: Swift.Bool?
        /// The location of the CloudWatch Logs log group where general logs are sent.
        /// This member is required.
        public var generalLogGroup: Swift.String?
        /// The list of information about logs pending to be deployed for the specified broker.
        public var pending: MqClientTypes.PendingLogs?

        public init (
            audit: Swift.Bool? = nil,
            auditLogGroup: Swift.String? = nil,
            general: Swift.Bool? = nil,
            generalLogGroup: Swift.String? = nil,
            pending: MqClientTypes.PendingLogs? = nil
        )
        {
            self.audit = audit
            self.auditLogGroup = auditLogGroup
            self.general = general
            self.generalLogGroup = generalLogGroup
            self.pending = pending
        }
    }

}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(errorAttribute: \(Swift.String(describing: errorAttribute)), message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let errorAttribute: Swift.String?
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MqClientTypes.PendingLogs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audit = "audit"
        case general = "general"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audit = audit {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let general = general {
            try encodeContainer.encode(general, forKey: .general)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .audit)
        audit = auditDecoded
        let generalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .general)
        general = generalDecoded
    }
}

extension MqClientTypes.PendingLogs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PendingLogs(audit: \(Swift.String(describing: audit)), general: \(Swift.String(describing: general)))"}
}

extension MqClientTypes {
    /// The list of information about logs to be enabled for the specified broker.
    public struct PendingLogs: Swift.Equatable {
        /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
        public var audit: Swift.Bool?
        /// Enables general logging.
        public var general: Swift.Bool?

        public init (
            audit: Swift.Bool? = nil,
            general: Swift.Bool? = nil
        )
        {
            self.audit = audit
            self.general = general
        }
    }

}

extension RebootBrokerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootBrokerInput(brokerId: \(Swift.String(describing: brokerId)))"}
}

extension RebootBrokerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RebootBrokerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootBrokerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RebootBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RebootBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RebootBrokerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RebootBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let brokerId = input.brokerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("brokerId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/brokers/\(brokerId.urlPercentEncoding())/reboot"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RebootBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?

    public init (
        brokerId: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct RebootBrokerInputBody: Swift.Equatable {
}

extension RebootBrokerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RebootBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootBrokerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RebootBrokerOutputResponse()"}
}

extension RebootBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RebootBrokerOutputResponse: Swift.Equatable {

    public init() {}
}

struct RebootBrokerOutputResponseBody: Swift.Equatable {
}

extension RebootBrokerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MqClientTypes.SanitizationWarning: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case elementName = "elementName"
        case reason = "reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let elementName = elementName {
            try encodeContainer.encode(elementName, forKey: .elementName)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let elementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elementName)
        elementName = elementNameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(MqClientTypes.SanitizationWarningReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension MqClientTypes.SanitizationWarning: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SanitizationWarning(attributeName: \(Swift.String(describing: attributeName)), elementName: \(Swift.String(describing: elementName)), reason: \(Swift.String(describing: reason)))"}
}

extension MqClientTypes {
    /// Returns information about the XML element or attribute that was sanitized in the configuration.
    public struct SanitizationWarning: Swift.Equatable {
        /// The name of the XML attribute that has been sanitized.
        public var attributeName: Swift.String?
        /// The name of the XML element that has been sanitized.
        public var elementName: Swift.String?
        /// Required. The reason for which the XML elements or attributes were sanitized.
        /// This member is required.
        public var reason: MqClientTypes.SanitizationWarningReason?

        public init (
            attributeName: Swift.String? = nil,
            elementName: Swift.String? = nil,
            reason: MqClientTypes.SanitizationWarningReason? = nil
        )
        {
            self.attributeName = attributeName
            self.elementName = elementName
            self.reason = reason
        }
    }

}

extension MqClientTypes {
    /// The reason for which the XML elements or attributes were sanitized.
    public enum SanitizationWarningReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disallowedAttributeRemoved
        case disallowedElementRemoved
        case invalidAttributeValueRemoved
        case sdkUnknown(Swift.String)

        public static var allCases: [SanitizationWarningReason] {
            return [
                .disallowedAttributeRemoved,
                .disallowedElementRemoved,
                .invalidAttributeValueRemoved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disallowedAttributeRemoved: return "DISALLOWED_ATTRIBUTE_REMOVED"
            case .disallowedElementRemoved: return "DISALLOWED_ELEMENT_REMOVED"
            case .invalidAttributeValueRemoved: return "INVALID_ATTRIBUTE_VALUE_REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SanitizationWarningReason(rawValue: rawValue) ?? SanitizationWarningReason.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedException(errorAttribute: \(Swift.String(describing: errorAttribute)), message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: Swift.String?
    /// The explanation of the error.
    public var message: Swift.String?

    public init (
        errorAttribute: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    public let errorAttribute: Swift.String?
    public let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateBrokerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerOutputError>
}

extension UpdateBrokerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrokerInput(authenticationStrategy: \(Swift.String(describing: authenticationStrategy)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), brokerId: \(Swift.String(describing: brokerId)), configuration: \(Swift.String(describing: configuration)), engineVersion: \(Swift.String(describing: engineVersion)), hostInstanceType: \(Swift.String(describing: hostInstanceType)), ldapServerMetadata: \(Swift.String(describing: ldapServerMetadata)), logs: \(Swift.String(describing: logs)), maintenanceWindowStartTime: \(Swift.String(describing: maintenanceWindowStartTime)), securityGroups: \(Swift.String(describing: securityGroups)))"}
}

extension UpdateBrokerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case configuration = "configuration"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case securityGroups = "securityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let autoMinorVersionUpgrade = autoMinorVersionUpgrade {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let ldapServerMetadata = ldapServerMetadata {
            try encodeContainer.encode(ldapServerMetadata, forKey: .ldapServerMetadata)
        }
        if let logs = logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let maintenanceWindowStartTime = maintenanceWindowStartTime {
            try encodeContainer.encode(maintenanceWindowStartTime, forKey: .maintenanceWindowStartTime)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
    }
}

public struct UpdateBrokerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerOutputError>
}

public struct UpdateBrokerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBrokerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBrokerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerOutputError>
}

public struct UpdateBrokerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerOutputError>
}

public struct UpdateBrokerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBrokerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateBrokerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let brokerId = input.brokerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("brokerId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/brokers/\(brokerId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateBrokerInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBrokerOutputError>
}

/// Updates the broker using the specified properties.
public struct UpdateBrokerInput: Swift.Equatable {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// A list of information about the configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The broker engine version. For a list of supported engine versions, see <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html">Supported engines.
    public var engineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types">Broker instance types.
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public var securityGroups: [Swift.String]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerId: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataInput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.securityGroups = securityGroups
    }
}

struct UpdateBrokerInputBody: Swift.Equatable {
    public let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    public let autoMinorVersionUpgrade: Swift.Bool?
    public let configuration: MqClientTypes.ConfigurationId?
    public let engineVersion: Swift.String?
    public let hostInstanceType: Swift.String?
    public let ldapServerMetadata: MqClientTypes.LdapServerMetadataInput?
    public let logs: MqClientTypes.Logs?
    public let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    public let securityGroups: [Swift.String]?
}

extension UpdateBrokerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case configuration = "configuration"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case securityGroups = "securityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataInput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension UpdateBrokerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrokerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrokerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrokerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBrokerOutputResponse(authenticationStrategy: \(Swift.String(describing: authenticationStrategy)), autoMinorVersionUpgrade: \(Swift.String(describing: autoMinorVersionUpgrade)), brokerId: \(Swift.String(describing: brokerId)), configuration: \(Swift.String(describing: configuration)), engineVersion: \(Swift.String(describing: engineVersion)), hostInstanceType: \(Swift.String(describing: hostInstanceType)), ldapServerMetadata: \(Swift.String(describing: ldapServerMetadata)), logs: \(Swift.String(describing: logs)), maintenanceWindowStartTime: \(Swift.String(describing: maintenanceWindowStartTime)), securityGroups: \(Swift.String(describing: securityGroups)))"}
}

extension UpdateBrokerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBrokerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authenticationStrategy = output.authenticationStrategy
            self.autoMinorVersionUpgrade = output.autoMinorVersionUpgrade
            self.brokerId = output.brokerId
            self.configuration = output.configuration
            self.engineVersion = output.engineVersion
            self.hostInstanceType = output.hostInstanceType
            self.ldapServerMetadata = output.ldapServerMetadata
            self.logs = output.logs
            self.maintenanceWindowStartTime = output.maintenanceWindowStartTime
            self.securityGroups = output.securityGroups
        } else {
            self.authenticationStrategy = nil
            self.autoMinorVersionUpgrade = nil
            self.brokerId = nil
            self.configuration = nil
            self.engineVersion = nil
            self.hostInstanceType = nil
            self.ldapServerMetadata = nil
            self.logs = nil
            self.maintenanceWindowStartTime = nil
            self.securityGroups = nil
        }
    }
}

public struct UpdateBrokerOutputResponse: Swift.Equatable {
    /// Optional. The authentication strategy used to secure the broker. The default is SIMPLE.
    public var authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    /// The new boolean value that specifies whether broker engines automatically upgrade to new minor versions as new versions are released and supported by Amazon MQ.
    public var autoMinorVersionUpgrade: Swift.Bool?
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public var brokerId: Swift.String?
    /// The ID of the updated configuration.
    public var configuration: MqClientTypes.ConfigurationId?
    /// The broker engine version to upgrade to. For a list of supported engine versions, see <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker-engine.html">Supported engines.
    public var engineVersion: Swift.String?
    /// The broker's host instance type to upgrade to. For a list of supported instance types, see <a href="https://docs.aws.amazon.com//amazon-mq/latest/developer-guide/broker.html#broker-instance-types">Broker instance types.
    public var hostInstanceType: Swift.String?
    /// Optional. The metadata of the LDAP server used to authenticate and authorize connections to the broker. Does not apply to RabbitMQ brokers.
    public var ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    /// The list of information about logs to be enabled for the specified broker.
    public var logs: MqClientTypes.Logs?
    /// The parameters that determine the WeeklyStartTime.
    public var maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public var securityGroups: [Swift.String]?

    public init (
        authenticationStrategy: MqClientTypes.AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Swift.Bool? = nil,
        brokerId: Swift.String? = nil,
        configuration: MqClientTypes.ConfigurationId? = nil,
        engineVersion: Swift.String? = nil,
        hostInstanceType: Swift.String? = nil,
        ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput? = nil,
        logs: MqClientTypes.Logs? = nil,
        maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.securityGroups = securityGroups
    }
}

struct UpdateBrokerOutputResponseBody: Swift.Equatable {
    public let authenticationStrategy: MqClientTypes.AuthenticationStrategy?
    public let autoMinorVersionUpgrade: Swift.Bool?
    public let brokerId: Swift.String?
    public let configuration: MqClientTypes.ConfigurationId?
    public let engineVersion: Swift.String?
    public let hostInstanceType: Swift.String?
    public let ldapServerMetadata: MqClientTypes.LdapServerMetadataOutput?
    public let logs: MqClientTypes.Logs?
    public let maintenanceWindowStartTime: MqClientTypes.WeeklyStartTime?
    public let securityGroups: [Swift.String]?
}

extension UpdateBrokerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerId = "brokerId"
        case configuration = "configuration"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case securityGroups = "securityGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(MqClientTypes.AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(MqClientTypes.LdapServerMetadataOutput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(MqClientTypes.Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(MqClientTypes.WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

public struct UpdateConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

extension UpdateConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigurationInput(configurationId: \(Swift.String(describing: configurationId)), data: \(Swift.String(describing: data)), description: \(Swift.String(describing: description)))"}
}

extension UpdateConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "data"
        case description = "description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let configurationId = input.configurationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("configurationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/configurations/\(configurationId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConfigurationOutputError>
}

/// Updates the specified configuration.
public struct UpdateConfigurationInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Required. The base64-encoded XML configuration.
    /// This member is required.
    public var data: Swift.String?
    /// The description of the configuration.
    public var description: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.data = data
        self.description = description
    }
}

struct UpdateConfigurationInputBody: Swift.Equatable {
    public let data: Swift.String?
    public let description: Swift.String?
}

extension UpdateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data = "data"
        case description = "description"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConfigurationOutputResponse(arn: \(Swift.String(describing: arn)), created: \(Swift.String(describing: created)), id: \(Swift.String(describing: id)), latestRevision: \(Swift.String(describing: latestRevision)), name: \(Swift.String(describing: name)), warnings: \(Swift.String(describing: warnings)))"}
}

extension UpdateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.created = output.created
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.warnings = output.warnings
        } else {
            self.arn = nil
            self.created = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
            self.warnings = nil
        }
    }
}

public struct UpdateConfigurationOutputResponse: Swift.Equatable {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    public var arn: Swift.String?
    /// Required. The date and time of the configuration.
    public var created: ClientRuntime.Date?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public var id: Swift.String?
    /// The latest revision of the configuration.
    public var latestRevision: MqClientTypes.ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public var name: Swift.String?
    /// The list of the first 20 warnings about the configuration XML elements or attributes that were sanitized.
    public var warnings: [MqClientTypes.SanitizationWarning]?

    public init (
        arn: Swift.String? = nil,
        created: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        latestRevision: MqClientTypes.ConfigurationRevision? = nil,
        name: Swift.String? = nil,
        warnings: [MqClientTypes.SanitizationWarning]? = nil
    )
    {
        self.arn = arn
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.warnings = warnings
    }
}

struct UpdateConfigurationOutputResponseBody: Swift.Equatable {
    public let arn: Swift.String?
    public let created: ClientRuntime.Date?
    public let id: Swift.String?
    public let latestRevision: MqClientTypes.ConfigurationRevision?
    public let name: Swift.String?
    public let warnings: [MqClientTypes.SanitizationWarning]?
}

extension UpdateConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case created = "created"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case warnings = "warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(MqClientTypes.ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let warningsContainer = try containerValues.decodeIfPresent([MqClientTypes.SanitizationWarning?].self, forKey: .warnings)
        var warningsDecoded0:[MqClientTypes.SanitizationWarning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [MqClientTypes.SanitizationWarning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct UpdateUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

extension UpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserInput(brokerId: \(Swift.String(describing: brokerId)), consoleAccess: \(Swift.String(describing: consoleAccess)), groups: \(Swift.String(describing: groups)), password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension UpdateUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct UpdateUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let brokerId = input.brokerId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("brokerId is nil and needs a value for the path of this operation"))))
        }
        guard let username = input.username else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("username is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/v1/brokers/\(brokerId.urlPercentEncoding())/users/\(username.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateUserOutputError>
}

/// Updates the information for an ActiveMQ user.
public struct UpdateUserInput: Swift.Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    /// This member is required.
    public var brokerId: Swift.String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public var consoleAccess: Swift.Bool?
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public var groups: [Swift.String]?
    /// The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
    public var password: Swift.String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    /// This member is required.
    public var username: Swift.String?

    public init (
        brokerId: Swift.String? = nil,
        consoleAccess: Swift.Bool? = nil,
        groups: [Swift.String]? = nil,
        password: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.username = username
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    public let consoleAccess: Swift.Bool?
    public let groups: [Swift.String]?
    public let password: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserOutputResponse()"}
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateUserOutputResponseBody: Swift.Equatable {
}

extension UpdateUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension MqClientTypes.User: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension MqClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(consoleAccess: \(Swift.String(describing: consoleAccess)), groups: \(Swift.String(describing: groups)), password: \(Swift.String(describing: password)), username: \(Swift.String(describing: username)))"}
}

extension MqClientTypes {
    /// A user associated with the broker. For RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ web console.
    public struct User: Swift.Equatable {
        /// Enables access to the ActiveMQ Web Console for the ActiveMQ user. Does not apply to RabbitMQ brokers.
        public var consoleAccess: Swift.Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Does not apply to RabbitMQ brokers.
        public var groups: [Swift.String]?
        /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        /// This member is required.
        public var password: Swift.String?
        /// important><title>Amazon MQ for ActiveMQ</title> <para>For ActiveMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long./important> <title>Amazon MQ for RabbitMQ</title> For RabbitMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores (- . _). This value must not contain a tilde (~) character. Amazon MQ prohibts using guest as a valid usename. This value must be 2-100 characters long.</para>
        /// This member is required.
        public var username: Swift.String?

        public init (
            consoleAccess: Swift.Bool? = nil,
            groups: [Swift.String]? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.password = password
            self.username = username
        }
    }

}

extension MqClientTypes.UserPendingChanges: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case pendingChange = "pendingChange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleAccess = consoleAccess {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let pendingChange = pendingChange {
            try encodeContainer.encode(pendingChange.rawValue, forKey: .pendingChange)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let pendingChangeDecoded = try containerValues.decodeIfPresent(MqClientTypes.ChangeType.self, forKey: .pendingChange)
        pendingChange = pendingChangeDecoded
    }
}

extension MqClientTypes.UserPendingChanges: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserPendingChanges(consoleAccess: \(Swift.String(describing: consoleAccess)), groups: \(Swift.String(describing: groups)), pendingChange: \(Swift.String(describing: pendingChange)))"}
}

extension MqClientTypes {
    /// Returns information about the status of the changes pending for the ActiveMQ user.
    public struct UserPendingChanges: Swift.Equatable {
        /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
        public var consoleAccess: Swift.Bool?
        /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        public var groups: [Swift.String]?
        /// Required. The type of change pending for the ActiveMQ user.
        /// This member is required.
        public var pendingChange: MqClientTypes.ChangeType?

        public init (
            consoleAccess: Swift.Bool? = nil,
            groups: [Swift.String]? = nil,
            pendingChange: MqClientTypes.ChangeType? = nil
        )
        {
            self.consoleAccess = consoleAccess
            self.groups = groups
            self.pendingChange = pendingChange
        }
    }

}

extension MqClientTypes.UserSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pendingChange = "pendingChange"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pendingChange = pendingChange {
            try encodeContainer.encode(pendingChange.rawValue, forKey: .pendingChange)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingChangeDecoded = try containerValues.decodeIfPresent(MqClientTypes.ChangeType.self, forKey: .pendingChange)
        pendingChange = pendingChangeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension MqClientTypes.UserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserSummary(pendingChange: \(Swift.String(describing: pendingChange)), username: \(Swift.String(describing: username)))"}
}

extension MqClientTypes {
    /// Returns a list of all broker users. Does not apply to RabbitMQ brokers.
    public struct UserSummary: Swift.Equatable {
        /// The type of change pending for the broker user.
        public var pendingChange: MqClientTypes.ChangeType?
        /// Required. The username of the broker user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
        /// This member is required.
        public var username: Swift.String?

        public init (
            pendingChange: MqClientTypes.ChangeType? = nil,
            username: Swift.String? = nil
        )
        {
            self.pendingChange = pendingChange
            self.username = username
        }
    }

}

extension MqClientTypes.WeeklyStartTime: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfWeek = "dayOfWeek"
        case timeOfDay = "timeOfDay"
        case timeZone = "timeZone"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfWeek = dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let timeOfDay = timeOfDay {
            try encodeContainer.encode(timeOfDay, forKey: .timeOfDay)
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(MqClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let timeOfDayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeOfDay)
        timeOfDay = timeOfDayDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
    }
}

extension MqClientTypes.WeeklyStartTime: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WeeklyStartTime(dayOfWeek: \(Swift.String(describing: dayOfWeek)), timeOfDay: \(Swift.String(describing: timeOfDay)), timeZone: \(Swift.String(describing: timeZone)))"}
}

extension MqClientTypes {
    /// The scheduled time period relative to UTC during which Amazon MQ begins to apply pending updates or patches to the broker.
    public struct WeeklyStartTime: Swift.Equatable {
        /// Required. The day of the week.
        /// This member is required.
        public var dayOfWeek: MqClientTypes.DayOfWeek?
        /// Required. The time, in 24-hour format.
        /// This member is required.
        public var timeOfDay: Swift.String?
        /// The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
        public var timeZone: Swift.String?

        public init (
            dayOfWeek: MqClientTypes.DayOfWeek? = nil,
            timeOfDay: Swift.String? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
            self.timeZone = timeZone
        }
    }

}
