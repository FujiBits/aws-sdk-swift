// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WisdomClientTypes.AppIntegrationsConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIntegrationArn
        case objectFields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIntegrationArn = appIntegrationArn {
            try encodeContainer.encode(appIntegrationArn, forKey: .appIntegrationArn)
        }
        if let objectFields = objectFields {
            var objectFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectFields)
            for objectfieldslist0 in objectFields {
                try objectFieldsContainer.encode(objectfieldslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIntegrationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appIntegrationArn)
        appIntegrationArn = appIntegrationArnDecoded
        let objectFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .objectFields)
        var objectFieldsDecoded0:[Swift.String]? = nil
        if let objectFieldsContainer = objectFieldsContainer {
            objectFieldsDecoded0 = [Swift.String]()
            for string0 in objectFieldsContainer {
                if let string0 = string0 {
                    objectFieldsDecoded0?.append(string0)
                }
            }
        }
        objectFields = objectFieldsDecoded0
    }
}

extension WisdomClientTypes.AppIntegrationsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppIntegrationsConfiguration(appIntegrationArn: \(Swift.String(describing: appIntegrationArn)), objectFields: \(Swift.String(describing: objectFields)))"}
}

extension WisdomClientTypes {
    /// Configuration information for Amazon AppIntegrations to automatically ingest content.
    public struct AppIntegrationsConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the AppIntegrations DataIntegration to use for ingesting content.
        /// This member is required.
        public var appIntegrationArn: Swift.String?
        /// The fields from the source that are made available to your agents in Wisdom.
        ///
        ///
        ///                 For <a href="https://developer.salesforce.com/docs/atlas.en-us.knowledge_dev.meta/knowledge_dev/sforce_api_objects_knowledge__kav.htm"> Salesforce, you must include at least Id,
        ///             ArticleNumber, VersionNumber, Title,
        ///             PublishStatus, and IsDeleted.
        ///
        ///
        ///                For <a href="https://developer.servicenow.com/dev.do#!/reference/api/rome/rest/knowledge-management-api"> ServiceNow, you must include at least number,
        ///             short_description, sys_mod_count, workflow_state,
        ///           and active.
        ///
        ///
        ///          Make sure to include additional field(s); these are indexed and used to source
        ///       recommendations.
        /// This member is required.
        public var objectFields: [Swift.String]?

        public init (
            appIntegrationArn: Swift.String? = nil,
            objectFields: [Swift.String]? = nil
        )
        {
            self.appIntegrationArn = appIntegrationArn
            self.objectFields = objectFields
        }
    }

}

extension WisdomClientTypes.AssistantAssociationData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantAssociationArn
        case assistantAssociationId
        case assistantId
        case associationData
        case associationType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantAssociationArn = assistantAssociationArn {
            try encodeContainer.encode(assistantAssociationArn, forKey: .assistantAssociationArn)
        }
        if let assistantAssociationId = assistantAssociationId {
            try encodeContainer.encode(assistantAssociationId, forKey: .assistantAssociationId)
        }
        if let assistantId = assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let associationData = associationData {
            try encodeContainer.encode(associationData, forKey: .associationData)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationId)
        assistantAssociationId = assistantAssociationIdDecoded
        let assistantAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationArn)
        assistantAssociationArn = assistantAssociationArnDecoded
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let associationDataDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationOutputData.self, forKey: .associationData)
        associationData = associationDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes.AssistantAssociationData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssistantAssociationData(assistantArn: \(Swift.String(describing: assistantArn)), assistantAssociationArn: \(Swift.String(describing: assistantAssociationArn)), assistantAssociationId: \(Swift.String(describing: assistantAssociationId)), assistantId: \(Swift.String(describing: assistantId)), associationData: \(Swift.String(describing: associationData)), associationType: \(Swift.String(describing: associationType)), tags: \(Swift.String(describing: tags)))"}
}

extension WisdomClientTypes {
    /// Information about the assistant association.
    public struct AssistantAssociationData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// A union type that currently has a single argument, the knowledge base ID.
        /// This member is required.
        public var associationData: WisdomClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: WisdomClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: WisdomClientTypes.AssistantAssociationOutputData? = nil,
            associationType: WisdomClientTypes.AssociationType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }

}

extension WisdomClientTypes.AssistantAssociationInputData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgebaseid = "knowledgeBaseId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .knowledgebaseid(knowledgebaseid):
                try container.encode(knowledgebaseid, forKey: .knowledgebaseid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgebaseidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .knowledgebaseid)
        if let knowledgebaseid = knowledgebaseidDecoded {
            self = .knowledgebaseid(knowledgebaseid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension WisdomClientTypes {
    /// The data that is input into Wisdom as a result of the assistant association.
    public enum AssistantAssociationInputData: Swift.Equatable, Swift.Hashable {
        /// The the identifier of the knowledge base.
        case knowledgebaseid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes.AssistantAssociationOutputData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgebaseassociation = "knowledgeBaseAssociation"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .knowledgebaseassociation(knowledgebaseassociation):
                try container.encode(knowledgebaseassociation, forKey: .knowledgebaseassociation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgebaseassociationDecoded = try values.decodeIfPresent(WisdomClientTypes.KnowledgeBaseAssociationData.self, forKey: .knowledgebaseassociation)
        if let knowledgebaseassociation = knowledgebaseassociationDecoded {
            self = .knowledgebaseassociation(knowledgebaseassociation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension WisdomClientTypes {
    /// The data that is output as a result of the assistant association.
    public enum AssistantAssociationOutputData: Swift.Equatable {
        /// The knowledge base where output data is sent.
        case knowledgebaseassociation(WisdomClientTypes.KnowledgeBaseAssociationData)
        case sdkUnknown(Swift.String)
    }

}

extension WisdomClientTypes.AssistantAssociationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantAssociationArn
        case assistantAssociationId
        case assistantId
        case associationData
        case associationType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantAssociationArn = assistantAssociationArn {
            try encodeContainer.encode(assistantAssociationArn, forKey: .assistantAssociationArn)
        }
        if let assistantAssociationId = assistantAssociationId {
            try encodeContainer.encode(assistantAssociationId, forKey: .assistantAssociationId)
        }
        if let assistantId = assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let associationData = associationData {
            try encodeContainer.encode(associationData, forKey: .associationData)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationId)
        assistantAssociationId = assistantAssociationIdDecoded
        let assistantAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantAssociationArn)
        assistantAssociationArn = assistantAssociationArnDecoded
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let associationDataDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationOutputData.self, forKey: .associationData)
        associationData = associationDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes.AssistantAssociationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssistantAssociationSummary(assistantArn: \(Swift.String(describing: assistantArn)), assistantAssociationArn: \(Swift.String(describing: assistantAssociationArn)), assistantAssociationId: \(Swift.String(describing: assistantAssociationId)), assistantId: \(Swift.String(describing: assistantId)), associationData: \(Swift.String(describing: associationData)), associationType: \(Swift.String(describing: associationType)), tags: \(Swift.String(describing: tags)))"}
}

extension WisdomClientTypes {
    /// Summary information about the assistant association.
    public struct AssistantAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the assistant association.
        /// This member is required.
        public var assistantAssociationArn: Swift.String?
        /// The identifier of the assistant association.
        /// This member is required.
        public var assistantAssociationId: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The association data.
        /// This member is required.
        public var associationData: WisdomClientTypes.AssistantAssociationOutputData?
        /// The type of association.
        /// This member is required.
        public var associationType: WisdomClientTypes.AssociationType?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            assistantArn: Swift.String? = nil,
            assistantAssociationArn: Swift.String? = nil,
            assistantAssociationId: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            associationData: WisdomClientTypes.AssistantAssociationOutputData? = nil,
            associationType: WisdomClientTypes.AssociationType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantAssociationArn = assistantAssociationArn
            self.assistantAssociationId = assistantAssociationId
            self.assistantId = assistantId
            self.associationData = associationData
            self.associationType = associationType
            self.tags = tags
        }
    }

}

extension WisdomClientTypes.AssistantData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case description
        case name
        case serverSideEncryptionConfiguration
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantId = assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension WisdomClientTypes.AssistantData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssistantData(assistantArn: \(Swift.String(describing: assistantArn)), assistantId: \(Swift.String(describing: assistantId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension WisdomClientTypes {
    /// The assistant data.
    public struct AssistantData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The description.
        public var description: Swift.String?
        /// The name.
        /// This member is required.
        public var name: Swift.String?
        /// The KMS key used for encryption.
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: WisdomClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of assistant.
        /// This member is required.
        public var type: WisdomClientTypes.AssistantType?

        public init (
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: WisdomClientTypes.AssistantStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: WisdomClientTypes.AssistantType? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension WisdomClientTypes {
    public enum AssistantStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssistantStatus(rawValue: rawValue) ?? AssistantStatus.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes.AssistantSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case description
        case name
        case serverSideEncryptionConfiguration
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantId = assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension WisdomClientTypes.AssistantSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssistantSummary(assistantArn: \(Swift.String(describing: assistantArn)), assistantId: \(Swift.String(describing: assistantId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension WisdomClientTypes {
    /// Summary information about the assistant.
    public struct AssistantSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The description of the assistant.
        public var description: Swift.String?
        /// The name of the assistant.
        /// This member is required.
        public var name: Swift.String?
        /// The KMS key used for encryption.
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the assistant.
        /// This member is required.
        public var status: WisdomClientTypes.AssistantStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the assistant.
        /// This member is required.
        public var type: WisdomClientTypes.AssistantType?

        public init (
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: WisdomClientTypes.AssistantStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: WisdomClientTypes.AssistantType? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension WisdomClientTypes {
    public enum AssistantType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case sdkUnknown(Swift.String)

        public static var allCases: [AssistantType] {
            return [
                .agent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssistantType(rawValue: rawValue) ?? AssistantType.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes {
    public enum AssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeBase
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationType] {
            return [
                .knowledgeBase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBase: return "KNOWLEDGE_BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssociationType(rawValue: rawValue) ?? AssociationType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the
///       resource. For example, if you're using a Create API (such as
///         CreateAssistant) that accepts name, a conflicting resource (usually with the
///       same name) is being created or mutated.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WisdomClientTypes.ContentData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentArn
        case contentId
        case contentType
        case knowledgeBaseArn
        case knowledgeBaseId
        case linkOutUri
        case metadata
        case name
        case revisionId
        case status
        case tags
        case title
        case url
        case urlExpiry
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentArn = contentArn {
            try encodeContainer.encode(contentArn, forKey: .contentArn)
        }
        if let contentId = contentId {
            try encodeContainer.encode(contentId, forKey: .contentId)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let knowledgeBaseArn = knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let linkOutUri = linkOutUri {
            try encodeContainer.encode(linkOutUri, forKey: .linkOutUri)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentmetadata0) in metadata {
                try metadataContainer.encode(contentmetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let urlExpiry = urlExpiry {
            try encodeContainer.encode(urlExpiry.timeIntervalSince1970, forKey: .urlExpiry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentArn)
        contentArn = contentArnDecoded
        let contentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentId)
        contentId = contentIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentStatus.self, forKey: .status)
        status = statusDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let linkOutUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkOutUri)
        linkOutUri = linkOutUriDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
    }
}

extension WisdomClientTypes.ContentData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentData(contentArn: \(Swift.String(describing: contentArn)), contentId: \(Swift.String(describing: contentId)), contentType: \(Swift.String(describing: contentType)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), linkOutUri: \(Swift.String(describing: linkOutUri)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), title: \(Swift.String(describing: title)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// Information about the content.
    public struct ContentData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The the identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The URI of the content.
        public var linkOutUri: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the content revision.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: WisdomClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?
        /// The URL of the content.
        /// This member is required.
        public var url: Swift.String?
        /// The expiration time of the URL as an epoch timestamp.
        /// This member is required.
        public var urlExpiry: ClientRuntime.Date?

        public init (
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            linkOutUri: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: WisdomClientTypes.ContentStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            title: Swift.String? = nil,
            url: Swift.String? = nil,
            urlExpiry: ClientRuntime.Date? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.linkOutUri = linkOutUri
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

extension WisdomClientTypes.ContentReference: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentArn
        case contentId
        case knowledgeBaseArn
        case knowledgeBaseId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentArn = contentArn {
            try encodeContainer.encode(contentArn, forKey: .contentArn)
        }
        if let contentId = contentId {
            try encodeContainer.encode(contentId, forKey: .contentId)
        }
        if let knowledgeBaseArn = knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let contentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentArn)
        contentArn = contentArnDecoded
        let contentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentId)
        contentId = contentIdDecoded
    }
}

extension WisdomClientTypes.ContentReference: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentReference(contentArn: \(Swift.String(describing: contentArn)), contentId: \(Swift.String(describing: contentId)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)))"}
}

extension WisdomClientTypes {
    /// Reference information about the content.
    public struct ContentReference: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the content.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        public var contentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The the identifier of the knowledge base.
        public var knowledgeBaseId: Swift.String?

        public init (
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }
    }

}

extension WisdomClientTypes {
    public enum ContentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case updateFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentStatus(rawValue: rawValue) ?? ContentStatus.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes.ContentSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentArn
        case contentId
        case contentType
        case knowledgeBaseArn
        case knowledgeBaseId
        case metadata
        case name
        case revisionId
        case status
        case tags
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentArn = contentArn {
            try encodeContainer.encode(contentArn, forKey: .contentArn)
        }
        if let contentId = contentId {
            try encodeContainer.encode(contentId, forKey: .contentId)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let knowledgeBaseArn = knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentmetadata0) in metadata {
                try metadataContainer.encode(contentmetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentArn)
        contentArn = contentArnDecoded
        let contentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentId)
        contentId = contentIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentStatus.self, forKey: .status)
        status = statusDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes.ContentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContentSummary(contentArn: \(Swift.String(describing: contentArn)), contentId: \(Swift.String(describing: contentId)), contentType: \(Swift.String(describing: contentType)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), title: \(Swift.String(describing: title)))"}
}

extension WisdomClientTypes {
    /// Summary information about the content.
    public struct ContentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the content.
        /// This member is required.
        public var contentArn: Swift.String?
        /// The identifier of the content.
        /// This member is required.
        public var contentId: Swift.String?
        /// The media type of the content.
        /// This member is required.
        public var contentType: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The the identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// A key/value map to store attributes without affecting tagging or recommendations.
        /// For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the content.
        /// This member is required.
        public var name: Swift.String?
        /// The identifier of the revision of the content.
        /// This member is required.
        public var revisionId: Swift.String?
        /// The status of the content.
        /// This member is required.
        public var status: WisdomClientTypes.ContentStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The title of the content.
        /// This member is required.
        public var title: Swift.String?

        public init (
            contentArn: Swift.String? = nil,
            contentId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            status: WisdomClientTypes.ContentStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            title: Swift.String? = nil
        )
        {
            self.contentArn = contentArn
            self.contentId = contentId
            self.contentType = contentType
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.metadata = metadata
            self.name = name
            self.revisionId = revisionId
            self.status = status
            self.tags = tags
            self.title = title
        }
    }

}

public struct CreateAssistantAssociationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssistantAssociationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssistantAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssistantAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssistantAssociationOutputError>
}

extension CreateAssistantAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssistantAssociationInput(assistantId: \(Swift.String(describing: assistantId)), association: \(Swift.String(describing: association)), associationType: \(Swift.String(describing: associationType)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAssistantAssociationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case association
        case associationType
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let association = association {
            try encodeContainer.encode(association, forKey: .association)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAssistantAssociationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssistantAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssistantAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssistantAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssistantAssociationOutputError>
}

public struct CreateAssistantAssociationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssistantAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssistantAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssistantAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssistantAssociationOutputError>
}

public struct CreateAssistantAssociationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssistantAssociationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAssistantAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/associations"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssistantAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssistantAssociationOutputError>
}

public struct CreateAssistantAssociationInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the associated resource.
    /// This member is required.
    public var association: WisdomClientTypes.AssistantAssociationInputData?
    /// The type of association.
    /// This member is required.
    public var associationType: WisdomClientTypes.AssociationType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///    request.
    public var clientToken: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assistantId: Swift.String? = nil,
        association: WisdomClientTypes.AssistantAssociationInputData? = nil,
        associationType: WisdomClientTypes.AssociationType? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assistantId = assistantId
        self.association = association
        self.associationType = associationType
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssistantAssociationInputBody: Swift.Equatable {
    public let associationType: WisdomClientTypes.AssociationType?
    public let association: WisdomClientTypes.AssistantAssociationInputData?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateAssistantAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case association
        case associationType
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let associationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationInputData.self, forKey: .association)
        association = associationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssistantAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssistantAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssistantAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssistantAssociationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssistantAssociationOutputResponse(assistantAssociation: \(Swift.String(describing: assistantAssociation)))"}
}

extension CreateAssistantAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssistantAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistantAssociation = output.assistantAssociation
        } else {
            self.assistantAssociation = nil
        }
    }
}

public struct CreateAssistantAssociationOutputResponse: Swift.Equatable {
    /// The assistant association.
    public var assistantAssociation: WisdomClientTypes.AssistantAssociationData?

    public init (
        assistantAssociation: WisdomClientTypes.AssistantAssociationData? = nil
    )
    {
        self.assistantAssociation = assistantAssociation
    }
}

struct CreateAssistantAssociationOutputResponseBody: Swift.Equatable {
    public let assistantAssociation: WisdomClientTypes.AssistantAssociationData?
}

extension CreateAssistantAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationData.self, forKey: .assistantAssociation)
        assistantAssociation = assistantAssociationDecoded
    }
}

public struct CreateAssistantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssistantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssistantOutputError>
}

extension CreateAssistantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssistantInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateAssistantInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case serverSideEncryptionConfiguration
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateAssistantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssistantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssistantOutputError>
}

public struct CreateAssistantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssistantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssistantOutputError>
}

public struct CreateAssistantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssistantInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAssistantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/assistants"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssistantInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssistantOutputError>
}

public struct CreateAssistantInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///    request.
    public var clientToken: Swift.String?
    /// The description of the assistant.
    public var description: Swift.String?
    /// The name of the assistant.
    /// This member is required.
    public var name: Swift.String?
    /// The KMS key used for encryption.
    public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of assistant.
    /// This member is required.
    public var type: WisdomClientTypes.AssistantType?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: WisdomClientTypes.AssistantType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
        self.type = type
    }
}

struct CreateAssistantInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let name: Swift.String?
    public let type: WisdomClientTypes.AssistantType?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
}

extension CreateAssistantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case serverSideEncryptionConfiguration
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension CreateAssistantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssistantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssistantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssistantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssistantOutputResponse(assistant: \(Swift.String(describing: assistant)))"}
}

extension CreateAssistantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssistantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistant = output.assistant
        } else {
            self.assistant = nil
        }
    }
}

public struct CreateAssistantOutputResponse: Swift.Equatable {
    /// Information about the assistant.
    public var assistant: WisdomClientTypes.AssistantData?

    public init (
        assistant: WisdomClientTypes.AssistantData? = nil
    )
    {
        self.assistant = assistant
    }
}

struct CreateAssistantOutputResponseBody: Swift.Equatable {
    public let assistant: WisdomClientTypes.AssistantData?
}

extension CreateAssistantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistant
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantData.self, forKey: .assistant)
        assistant = assistantDecoded
    }
}

public struct CreateContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContentOutputError>
}

extension CreateContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContentInput(clientToken: \(Swift.String(describing: clientToken)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), overrideLinkOutUri: \(Swift.String(describing: overrideLinkOutUri)), tags: \(Swift.String(describing: tags)), title: \(Swift.String(describing: title)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension CreateContentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case metadata
        case name
        case overrideLinkOutUri
        case tags
        case title
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentmetadata0) in metadata {
                try metadataContainer.encode(contentmetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrideLinkOutUri = overrideLinkOutUri {
            try encodeContainer.encode(overrideLinkOutUri, forKey: .overrideLinkOutUri)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct CreateContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContentOutputError>
}

public struct CreateContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContentOutputError>
}

public struct CreateContentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateContentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateContentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContentOutputError>
}

public struct CreateContentInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///    request.
    public var clientToken: Swift.String?
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations.
    /// For example, when synchronizing data between an external system and Wisdom, you can store an external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String:Swift.String]?
    /// The name of the content. Each piece of content in a knowledge base must have a unique
    ///       name. You can retrieve a piece of content using only its knowledge base and its name with the
    ///         <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_SearchContent.html">SearchContent API.
    /// This member is required.
    public var name: Swift.String?
    /// The URI you want to use for the article. If the knowledge base has a templateUri, setting
    ///       this argument overrides it for this piece of content.
    public var overrideLinkOutUri: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The title of the content. If not set, the title is equal to the name.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html">StartContentUpload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.name = name
        self.overrideLinkOutUri = overrideLinkOutUri
        self.tags = tags
        self.title = title
        self.uploadId = uploadId
    }
}

struct CreateContentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let title: Swift.String?
    public let overrideLinkOutUri: Swift.String?
    public let metadata: [Swift.String:Swift.String]?
    public let uploadId: Swift.String?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case metadata
        case name
        case overrideLinkOutUri
        case tags
        case title
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let overrideLinkOutUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLinkOutUri)
        overrideLinkOutUri = overrideLinkOutUriDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContentOutputResponse(content: \(Swift.String(describing: content)))"}
}

extension CreateContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct CreateContentOutputResponse: Swift.Equatable {
    /// The content.
    public var content: WisdomClientTypes.ContentData?

    public init (
        content: WisdomClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

struct CreateContentOutputResponseBody: Swift.Equatable {
    public let content: WisdomClientTypes.ContentData?
}

extension CreateContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentData.self, forKey: .content)
        content = contentDecoded
    }
}

public struct CreateKnowledgeBaseInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKnowledgeBaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKnowledgeBaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKnowledgeBaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKnowledgeBaseOutputError>
}

extension CreateKnowledgeBaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateKnowledgeBaseInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), knowledgeBaseType: \(Swift.String(describing: knowledgeBaseType)), name: \(Swift.String(describing: name)), renderingConfiguration: \(Swift.String(describing: renderingConfiguration)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateKnowledgeBaseInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseType
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseType = knowledgeBaseType {
            try encodeContainer.encode(knowledgeBaseType.rawValue, forKey: .knowledgeBaseType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingConfiguration = renderingConfiguration {
            try encodeContainer.encode(renderingConfiguration, forKey: .renderingConfiguration)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateKnowledgeBaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKnowledgeBaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKnowledgeBaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKnowledgeBaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKnowledgeBaseOutputError>
}

public struct CreateKnowledgeBaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKnowledgeBaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateKnowledgeBaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateKnowledgeBaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKnowledgeBaseOutputError>
}

public struct CreateKnowledgeBaseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateKnowledgeBaseInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateKnowledgeBaseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/knowledgeBases"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateKnowledgeBaseInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateKnowledgeBaseOutputError>
}

public struct CreateKnowledgeBaseInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///    request.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The type of knowledge base. Only CUSTOM knowledge bases allow you to upload your own content.
    ///       EXTERNAL knowledge bases support integrations with third-party systems whose content is
    ///       synchronized automatically.
    /// This member is required.
    public var knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
    /// The name of the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// Information about how to render the content.
    public var renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
    /// The KMS key used for encryption.
    public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
    /// The source of the knowledge base content. Only set this argument for EXTERNAL knowledge
    ///       bases.
    public var sourceConfiguration: WisdomClientTypes.SourceConfiguration?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType? = nil,
        name: Swift.String? = nil,
        renderingConfiguration: WisdomClientTypes.RenderingConfiguration? = nil,
        serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
        sourceConfiguration: WisdomClientTypes.SourceConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.knowledgeBaseType = knowledgeBaseType
        self.name = name
        self.renderingConfiguration = renderingConfiguration
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
    }
}

struct CreateKnowledgeBaseInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let name: Swift.String?
    public let knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
    public let sourceConfiguration: WisdomClientTypes.SourceConfiguration?
    public let renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
    public let serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseType
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseType.self, forKey: .knowledgeBaseType)
        knowledgeBaseType = knowledgeBaseTypeDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let renderingConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RenderingConfiguration.self, forKey: .renderingConfiguration)
        renderingConfiguration = renderingConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKnowledgeBaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateKnowledgeBaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateKnowledgeBaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateKnowledgeBaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateKnowledgeBaseOutputResponse(knowledgeBase: \(Swift.String(describing: knowledgeBase)))"}
}

extension CreateKnowledgeBaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateKnowledgeBaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct CreateKnowledgeBaseOutputResponse: Swift.Equatable {
    /// The knowledge base.
    public var knowledgeBase: WisdomClientTypes.KnowledgeBaseData?

    public init (
        knowledgeBase: WisdomClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct CreateKnowledgeBaseOutputResponseBody: Swift.Equatable {
    public let knowledgeBase: WisdomClientTypes.KnowledgeBaseData?
}

extension CreateKnowledgeBaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseData.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

public struct CreateSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSessionOutputError>
}

extension CreateSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSessionInput(assistantId: \(Swift.String(describing: assistantId)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSessionOutputError>
}

public struct CreateSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSessionOutputError>
}

public struct CreateSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSessionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/sessions"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSessionOutputError>
}

public struct CreateSessionInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///    request.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name of the session.
    /// This member is required.
    public var name: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assistantId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assistantId = assistantId
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateSessionInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSessionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSessionOutputResponse(session: \(Swift.String(describing: session)))"}
}

extension CreateSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct CreateSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: WisdomClientTypes.SessionData?

    public init (
        session: WisdomClientTypes.SessionData? = nil
    )
    {
        self.session = session
    }
}

struct CreateSessionOutputResponseBody: Swift.Equatable {
    public let session: WisdomClientTypes.SessionData?
}

extension CreateSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SessionData.self, forKey: .session)
        session = sessionDecoded
    }
}

extension DeleteAssistantAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssistantAssociationInput(assistantAssociationId: \(Swift.String(describing: assistantAssociationId)), assistantId: \(Swift.String(describing: assistantId)))"}
}

extension DeleteAssistantAssociationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAssistantAssociationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssistantAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssistantAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssistantAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssistantAssociationOutputError>
}

public struct DeleteAssistantAssociationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssistantAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssistantAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssistantAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssistantAssociationOutputError>
}

public struct DeleteAssistantAssociationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssistantAssociationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAssistantAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        guard let assistantAssociationId = input.assistantAssociationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantAssociationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssistantAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssistantAssociationOutputError>
}

public struct DeleteAssistantAssociationInput: Swift.Equatable {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init (
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    )
    {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

struct DeleteAssistantAssociationInputBody: Swift.Equatable {
}

extension DeleteAssistantAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssistantAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssistantAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssistantAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssistantAssociationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssistantAssociationOutputResponse()"}
}

extension DeleteAssistantAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssistantAssociationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAssistantAssociationOutputResponseBody: Swift.Equatable {
}

extension DeleteAssistantAssociationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssistantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssistantInput(assistantId: \(Swift.String(describing: assistantId)))"}
}

extension DeleteAssistantInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAssistantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssistantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssistantOutputError>
}

public struct DeleteAssistantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssistantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssistantOutputError>
}

public struct DeleteAssistantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssistantInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAssistantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssistantInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssistantOutputError>
}

public struct DeleteAssistantInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init (
        assistantId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
    }
}

struct DeleteAssistantInputBody: Swift.Equatable {
}

extension DeleteAssistantInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssistantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssistantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssistantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssistantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssistantOutputResponse()"}
}

extension DeleteAssistantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssistantOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAssistantOutputResponseBody: Swift.Equatable {
}

extension DeleteAssistantOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteContentInput(contentId: \(Swift.String(describing: contentId)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)))"}
}

extension DeleteContentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContentOutputError>
}

public struct DeleteContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContentOutputError>
}

public struct DeleteContentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteContentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        guard let contentId = input.contentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("contentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteContentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContentOutputError>
}

public struct DeleteContentInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteContentInputBody: Swift.Equatable {
}

extension DeleteContentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteContentOutputResponse()"}
}

extension DeleteContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContentOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteContentOutputResponseBody: Swift.Equatable {
}

extension DeleteContentOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKnowledgeBaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteKnowledgeBaseInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)))"}
}

extension DeleteKnowledgeBaseInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteKnowledgeBaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteKnowledgeBaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteKnowledgeBaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteKnowledgeBaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteKnowledgeBaseOutputError>
}

public struct DeleteKnowledgeBaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteKnowledgeBaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteKnowledgeBaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteKnowledgeBaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteKnowledgeBaseOutputError>
}

public struct DeleteKnowledgeBaseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteKnowledgeBaseInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteKnowledgeBaseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteKnowledgeBaseInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteKnowledgeBaseOutputError>
}

public struct DeleteKnowledgeBaseInput: Swift.Equatable {
    /// The knowledge base to delete content from. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteKnowledgeBaseInputBody: Swift.Equatable {
}

extension DeleteKnowledgeBaseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKnowledgeBaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteKnowledgeBaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteKnowledgeBaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteKnowledgeBaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteKnowledgeBaseOutputResponse()"}
}

extension DeleteKnowledgeBaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteKnowledgeBaseOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteKnowledgeBaseOutputResponseBody: Swift.Equatable {
}

extension DeleteKnowledgeBaseOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WisdomClientTypes.Document: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentReference
        case excerpt
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentReference = contentReference {
            try encodeContainer.encode(contentReference, forKey: .contentReference)
        }
        if let excerpt = excerpt {
            try encodeContainer.encode(excerpt, forKey: .excerpt)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentReferenceDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentReference.self, forKey: .contentReference)
        contentReference = contentReferenceDecoded
        let titleDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.DocumentText.self, forKey: .title)
        title = titleDecoded
        let excerptDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.DocumentText.self, forKey: .excerpt)
        excerpt = excerptDecoded
    }
}

extension WisdomClientTypes.Document: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Document(contentReference: \(Swift.String(describing: contentReference)), excerpt: \(Swift.String(describing: excerpt)), title: \(Swift.String(describing: title)))"}
}

extension WisdomClientTypes {
    /// The document.
    public struct Document: Swift.Equatable {
        /// A reference to the content resource.
        /// This member is required.
        public var contentReference: WisdomClientTypes.ContentReference?
        /// The excerpt from the document.
        public var excerpt: WisdomClientTypes.DocumentText?
        /// The title of the document.
        public var title: WisdomClientTypes.DocumentText?

        public init (
            contentReference: WisdomClientTypes.ContentReference? = nil,
            excerpt: WisdomClientTypes.DocumentText? = nil,
            title: WisdomClientTypes.DocumentText? = nil
        )
        {
            self.contentReference = contentReference
            self.excerpt = excerpt
            self.title = title
        }
    }

}

extension WisdomClientTypes.DocumentText: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case highlights
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highlights = highlights {
            var highlightsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .highlights)
            for highlights0 in highlights {
                try highlightsContainer.encode(highlights0)
            }
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let highlightsContainer = try containerValues.decodeIfPresent([WisdomClientTypes.Highlight?].self, forKey: .highlights)
        var highlightsDecoded0:[WisdomClientTypes.Highlight]? = nil
        if let highlightsContainer = highlightsContainer {
            highlightsDecoded0 = [WisdomClientTypes.Highlight]()
            for structure0 in highlightsContainer {
                if let structure0 = structure0 {
                    highlightsDecoded0?.append(structure0)
                }
            }
        }
        highlights = highlightsDecoded0
    }
}

extension WisdomClientTypes.DocumentText: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentText(highlights: \(Swift.String(describing: highlights)), text: \"CONTENT_REDACTED\")"}
}

extension WisdomClientTypes {
    /// The text of the document.
    public struct DocumentText: Swift.Equatable {
        /// Highlights in the document text.
        public var highlights: [WisdomClientTypes.Highlight]?
        /// Text in the document.
        public var text: Swift.String?

        public init (
            highlights: [WisdomClientTypes.Highlight]? = nil,
            text: Swift.String? = nil
        )
        {
            self.highlights = highlights
            self.text = text
        }
    }

}

extension WisdomClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case `operator` = "operator"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = field {
            try encodeContainer.encode(field.rawValue, forKey: .field)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.FilterField.self, forKey: .field)
        field = fieldDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.FilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WisdomClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(field: \(Swift.String(describing: field)), operator: \(Swift.String(describing: `operator`)), value: \(Swift.String(describing: value)))"}
}

extension WisdomClientTypes {
    /// A search filter.
    public struct Filter: Swift.Equatable {
        /// The operator to use for comparing the field’s value with the provided value.
        /// This member is required.
        public var `operator`: WisdomClientTypes.FilterOperator?
        /// The field on which to filter.
        /// This member is required.
        public var field: WisdomClientTypes.FilterField?
        /// The desired field value on which to filter.
        /// This member is required.
        public var value: Swift.String?

        public init (
            `operator`: WisdomClientTypes.FilterOperator? = nil,
            field: WisdomClientTypes.FilterField? = nil,
            value: Swift.String? = nil
        )
        {
            self.`operator` = `operator`
            self.field = field
            self.value = value
        }
    }

}

extension WisdomClientTypes {
    public enum FilterField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterField] {
            return [
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterField(rawValue: rawValue) ?? FilterField.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes {
    public enum FilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterOperator(rawValue: rawValue) ?? FilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension GetAssistantAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssistantAssociationInput(assistantAssociationId: \(Swift.String(describing: assistantAssociationId)), assistantId: \(Swift.String(describing: assistantId)))"}
}

extension GetAssistantAssociationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAssistantAssociationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssistantAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssistantAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssistantAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssistantAssociationOutputError>
}

public struct GetAssistantAssociationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssistantAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssistantAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssistantAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssistantAssociationOutputError>
}

public struct GetAssistantAssociationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssistantAssociationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAssistantAssociationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssistantAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        guard let assistantAssociationId = input.assistantAssociationId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantAssociationId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/associations/\(assistantAssociationId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAssistantAssociationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssistantAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssistantAssociationOutputError>
}

public struct GetAssistantAssociationInput: Swift.Equatable {
    /// The identifier of the assistant association. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantAssociationId: Swift.String?
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init (
        assistantAssociationId: Swift.String? = nil,
        assistantId: Swift.String? = nil
    )
    {
        self.assistantAssociationId = assistantAssociationId
        self.assistantId = assistantId
    }
}

struct GetAssistantAssociationInputBody: Swift.Equatable {
}

extension GetAssistantAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssistantAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssistantAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssistantAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssistantAssociationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssistantAssociationOutputResponse(assistantAssociation: \(Swift.String(describing: assistantAssociation)))"}
}

extension GetAssistantAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssistantAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistantAssociation = output.assistantAssociation
        } else {
            self.assistantAssociation = nil
        }
    }
}

public struct GetAssistantAssociationOutputResponse: Swift.Equatable {
    /// The assistant association.
    public var assistantAssociation: WisdomClientTypes.AssistantAssociationData?

    public init (
        assistantAssociation: WisdomClientTypes.AssistantAssociationData? = nil
    )
    {
        self.assistantAssociation = assistantAssociation
    }
}

struct GetAssistantAssociationOutputResponseBody: Swift.Equatable {
    public let assistantAssociation: WisdomClientTypes.AssistantAssociationData?
}

extension GetAssistantAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantAssociation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantAssociationData.self, forKey: .assistantAssociation)
        assistantAssociation = assistantAssociationDecoded
    }
}

extension GetAssistantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssistantInput(assistantId: \(Swift.String(describing: assistantId)))"}
}

extension GetAssistantInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAssistantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssistantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssistantOutputError>
}

public struct GetAssistantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssistantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssistantOutputError>
}

public struct GetAssistantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssistantInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAssistantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAssistantInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssistantOutputError>
}

public struct GetAssistantInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?

    public init (
        assistantId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
    }
}

struct GetAssistantInputBody: Swift.Equatable {
}

extension GetAssistantInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssistantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssistantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssistantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssistantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssistantOutputResponse(assistant: \(Swift.String(describing: assistant)))"}
}

extension GetAssistantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssistantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistant = output.assistant
        } else {
            self.assistant = nil
        }
    }
}

public struct GetAssistantOutputResponse: Swift.Equatable {
    /// Information about the assistant.
    public var assistant: WisdomClientTypes.AssistantData?

    public init (
        assistant: WisdomClientTypes.AssistantData? = nil
    )
    {
        self.assistant = assistant
    }
}

struct GetAssistantOutputResponseBody: Swift.Equatable {
    public let assistant: WisdomClientTypes.AssistantData?
}

extension GetAssistantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistant
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.AssistantData.self, forKey: .assistant)
        assistant = assistantDecoded
    }
}

extension GetContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContentInput(contentId: \(Swift.String(describing: contentId)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)))"}
}

extension GetContentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContentOutputError>
}

public struct GetContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContentOutputError>
}

public struct GetContentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetContentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        guard let contentId = input.contentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("contentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetContentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContentOutputError>
}

public struct GetContentInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetContentInputBody: Swift.Equatable {
}

extension GetContentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContentOutputResponse(content: \(Swift.String(describing: content)))"}
}

extension GetContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct GetContentOutputResponse: Swift.Equatable {
    /// The content.
    public var content: WisdomClientTypes.ContentData?

    public init (
        content: WisdomClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

struct GetContentOutputResponseBody: Swift.Equatable {
    public let content: WisdomClientTypes.ContentData?
}

extension GetContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentData.self, forKey: .content)
        content = contentDecoded
    }
}

extension GetContentSummaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContentSummaryInput(contentId: \(Swift.String(describing: contentId)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)))"}
}

extension GetContentSummaryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetContentSummaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContentSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContentSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContentSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContentSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContentSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContentSummaryOutputError>
}

public struct GetContentSummaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContentSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContentSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContentSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContentSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContentSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContentSummaryOutputError>
}

public struct GetContentSummaryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContentSummaryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetContentSummaryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContentSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        guard let contentId = input.contentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("contentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())/summary"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetContentSummaryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetContentSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContentSummaryOutputError>
}

public struct GetContentSummaryInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetContentSummaryInputBody: Swift.Equatable {
}

extension GetContentSummaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetContentSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContentSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContentSummaryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContentSummaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContentSummaryOutputResponse(contentSummary: \(Swift.String(describing: contentSummary)))"}
}

extension GetContentSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContentSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentSummary = output.contentSummary
        } else {
            self.contentSummary = nil
        }
    }
}

public struct GetContentSummaryOutputResponse: Swift.Equatable {
    /// The content summary.
    public var contentSummary: WisdomClientTypes.ContentSummary?

    public init (
        contentSummary: WisdomClientTypes.ContentSummary? = nil
    )
    {
        self.contentSummary = contentSummary
    }
}

struct GetContentSummaryOutputResponseBody: Swift.Equatable {
    public let contentSummary: WisdomClientTypes.ContentSummary?
}

extension GetContentSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSummary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSummaryDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentSummary.self, forKey: .contentSummary)
        contentSummary = contentSummaryDecoded
    }
}

extension GetKnowledgeBaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKnowledgeBaseInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)))"}
}

extension GetKnowledgeBaseInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetKnowledgeBaseInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKnowledgeBaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKnowledgeBaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKnowledgeBaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKnowledgeBaseOutputError>
}

public struct GetKnowledgeBaseInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKnowledgeBaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetKnowledgeBaseInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetKnowledgeBaseInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKnowledgeBaseOutputError>
}

public struct GetKnowledgeBaseInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetKnowledgeBaseInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetKnowledgeBaseInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetKnowledgeBaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetKnowledgeBaseInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetKnowledgeBaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetKnowledgeBaseOutputError>
}

public struct GetKnowledgeBaseInput: Swift.Equatable {
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetKnowledgeBaseInputBody: Swift.Equatable {
}

extension GetKnowledgeBaseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetKnowledgeBaseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetKnowledgeBaseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKnowledgeBaseOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKnowledgeBaseOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKnowledgeBaseOutputResponse(knowledgeBase: \(Swift.String(describing: knowledgeBase)))"}
}

extension GetKnowledgeBaseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetKnowledgeBaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct GetKnowledgeBaseOutputResponse: Swift.Equatable {
    /// The knowledge base.
    public var knowledgeBase: WisdomClientTypes.KnowledgeBaseData?

    public init (
        knowledgeBase: WisdomClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct GetKnowledgeBaseOutputResponseBody: Swift.Equatable {
    public let knowledgeBase: WisdomClientTypes.KnowledgeBaseData?
}

extension GetKnowledgeBaseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseData.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

extension GetRecommendationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecommendationsInput(assistantId: \(Swift.String(describing: assistantId)), maxResults: \(Swift.String(describing: maxResults)), sessionId: \(Swift.String(describing: sessionId)), waitTimeSeconds: \(Swift.String(describing: waitTimeSeconds)))"}
}

extension GetRecommendationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRecommendationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecommendationsOutputError>
}

public struct GetRecommendationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.waitTimeSeconds != 0 {
            let waitTimeSecondsQueryItem = ClientRuntime.URLQueryItem(name: "waitTimeSeconds".urlPercentEncoding(), value: Swift.String(input.operationInput.waitTimeSeconds).urlPercentEncoding())
            input.builder.withQueryItem(waitTimeSecondsQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecommendationsOutputError>
}

public struct GetRecommendationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecommendationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetRecommendationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        guard let sessionId = input.sessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sessionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRecommendationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecommendationsOutputError>
}

public struct GetRecommendationsInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The duration (in seconds) for which the call waits for a recommendation to be made
    ///       available before returning. If a recommendation is available, the call returns sooner than
    ///         WaitTimeSeconds. If no messages are available and the wait time expires, the
    ///       call returns successfully with an empty list.
    public var waitTimeSeconds: Swift.Int

    public init (
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        sessionId: Swift.String? = nil,
        waitTimeSeconds: Swift.Int = 0
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.sessionId = sessionId
        self.waitTimeSeconds = waitTimeSeconds
    }
}

struct GetRecommendationsInputBody: Swift.Equatable {
}

extension GetRecommendationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommendationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecommendationsOutputResponse(recommendations: \(Swift.String(describing: recommendations)))"}
}

extension GetRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommendations = output.recommendations
        } else {
            self.recommendations = nil
        }
    }
}

public struct GetRecommendationsOutputResponse: Swift.Equatable {
    /// The recommendations.
    /// This member is required.
    public var recommendations: [WisdomClientTypes.RecommendationData]?

    public init (
        recommendations: [WisdomClientTypes.RecommendationData]? = nil
    )
    {
        self.recommendations = recommendations
    }
}

struct GetRecommendationsOutputResponseBody: Swift.Equatable {
    public let recommendations: [WisdomClientTypes.RecommendationData]?
}

extension GetRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationsContainer = try containerValues.decodeIfPresent([WisdomClientTypes.RecommendationData?].self, forKey: .recommendations)
        var recommendationsDecoded0:[WisdomClientTypes.RecommendationData]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [WisdomClientTypes.RecommendationData]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
    }
}

extension GetSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionInput(assistantId: \(Swift.String(describing: assistantId)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension GetSessionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionOutputError>
}

public struct GetSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionOutputError>
}

public struct GetSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        guard let sessionId = input.sessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sessionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionOutputError>
}

public struct GetSessionInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        assistantId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.sessionId = sessionId
    }
}

struct GetSessionInputBody: Swift.Equatable {
}

extension GetSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionOutputResponse(session: \(Swift.String(describing: session)))"}
}

extension GetSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct GetSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: WisdomClientTypes.SessionData?

    public init (
        session: WisdomClientTypes.SessionData? = nil
    )
    {
        self.session = session
    }
}

struct GetSessionOutputResponseBody: Swift.Equatable {
    public let session: WisdomClientTypes.SessionData?
}

extension GetSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SessionData.self, forKey: .session)
        session = sessionDecoded
    }
}

extension WisdomClientTypes.Highlight: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffsetInclusive
        case endOffsetExclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if beginOffsetInclusive != 0 {
            try encodeContainer.encode(beginOffsetInclusive, forKey: .beginOffsetInclusive)
        }
        if endOffsetExclusive != 0 {
            try encodeContainer.encode(endOffsetExclusive, forKey: .endOffsetExclusive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginOffsetInclusiveDecoded = try containerValues.decode(Swift.Int.self, forKey: .beginOffsetInclusive)
        beginOffsetInclusive = beginOffsetInclusiveDecoded
        let endOffsetExclusiveDecoded = try containerValues.decode(Swift.Int.self, forKey: .endOffsetExclusive)
        endOffsetExclusive = endOffsetExclusiveDecoded
    }
}

extension WisdomClientTypes.Highlight: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Highlight(beginOffsetInclusive: \(Swift.String(describing: beginOffsetInclusive)), endOffsetExclusive: \(Swift.String(describing: endOffsetExclusive)))"}
}

extension WisdomClientTypes {
    /// Offset specification to describe highlighting of document excerpts for rendering search
    ///       results and recommendations.
    public struct Highlight: Swift.Equatable {
        /// The offset for the start of the highlight.
        public var beginOffsetInclusive: Swift.Int
        /// The offset for the end of the highlight.
        public var endOffsetExclusive: Swift.Int

        public init (
            beginOffsetInclusive: Swift.Int = 0,
            endOffsetExclusive: Swift.Int = 0
        )
        {
            self.beginOffsetInclusive = beginOffsetInclusive
            self.endOffsetExclusive = endOffsetExclusive
        }
    }

}

extension WisdomClientTypes.KnowledgeBaseAssociationData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseArn
        case knowledgeBaseId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knowledgeBaseArn = knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
    }
}

extension WisdomClientTypes.KnowledgeBaseAssociationData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseAssociationData(knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)))"}
}

extension WisdomClientTypes {
    /// Association information about the knowledge base.
    public struct KnowledgeBaseAssociationData: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the knowledge base.
        public var knowledgeBaseArn: Swift.String?
        /// The the identifier of the knowledge base.
        public var knowledgeBaseId: Swift.String?

        public init (
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil
        )
        {
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
        }
    }

}

extension WisdomClientTypes.KnowledgeBaseData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseArn
        case knowledgeBaseId
        case knowledgeBaseType
        case lastContentModificationTime
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseArn = knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseType = knowledgeBaseType {
            try encodeContainer.encode(knowledgeBaseType.rawValue, forKey: .knowledgeBaseType)
        }
        if let lastContentModificationTime = lastContentModificationTime {
            try encodeContainer.encode(lastContentModificationTime.timeIntervalSince1970, forKey: .lastContentModificationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingConfiguration = renderingConfiguration {
            try encodeContainer.encode(renderingConfiguration, forKey: .renderingConfiguration)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseType.self, forKey: .knowledgeBaseType)
        knowledgeBaseType = knowledgeBaseTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let lastContentModificationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastContentModificationTime)
        lastContentModificationTime = lastContentModificationTimeDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let renderingConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RenderingConfiguration.self, forKey: .renderingConfiguration)
        renderingConfiguration = renderingConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes.KnowledgeBaseData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseData(description: \(Swift.String(describing: description)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), knowledgeBaseType: \(Swift.String(describing: knowledgeBaseType)), lastContentModificationTime: \(Swift.String(describing: lastContentModificationTime)), name: \(Swift.String(describing: name)), renderingConfiguration: \(Swift.String(describing: renderingConfiguration)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension WisdomClientTypes {
    /// Information about the knowledge base.
    public struct KnowledgeBaseData: Swift.Equatable {
        /// The description.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The the identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
        /// An epoch timestamp indicating the most recent content modification inside the knowledge
        ///       base. If no content exists in a knowledge base, this value is unset.
        public var lastContentModificationTime: ClientRuntime.Date?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
        /// The KMS key used for encryption.
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// Source configuration information about the knowledge base.
        public var sourceConfiguration: WisdomClientTypes.SourceConfiguration?
        /// The status of the knowledge base.
        /// This member is required.
        public var status: WisdomClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType? = nil,
            lastContentModificationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: WisdomClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: WisdomClientTypes.SourceConfiguration? = nil,
            status: WisdomClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.lastContentModificationTime = lastContentModificationTime
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }
    }

}

extension WisdomClientTypes {
    public enum KnowledgeBaseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseStatus(rawValue: rawValue) ?? KnowledgeBaseStatus.sdkUnknown(rawValue)
        }
    }
}

extension WisdomClientTypes.KnowledgeBaseSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseArn
        case knowledgeBaseId
        case knowledgeBaseType
        case name
        case renderingConfiguration
        case serverSideEncryptionConfiguration
        case sourceConfiguration
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseArn = knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseId = knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseType = knowledgeBaseType {
            try encodeContainer.encode(knowledgeBaseType.rawValue, forKey: .knowledgeBaseType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let renderingConfiguration = renderingConfiguration {
            try encodeContainer.encode(renderingConfiguration, forKey: .renderingConfiguration)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let sourceConfiguration = sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseTypeDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseType.self, forKey: .knowledgeBaseType)
        knowledgeBaseType = knowledgeBaseTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let renderingConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RenderingConfiguration.self, forKey: .renderingConfiguration)
        renderingConfiguration = renderingConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes.KnowledgeBaseSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnowledgeBaseSummary(description: \(Swift.String(describing: description)), knowledgeBaseArn: \(Swift.String(describing: knowledgeBaseArn)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), knowledgeBaseType: \(Swift.String(describing: knowledgeBaseType)), name: \(Swift.String(describing: name)), renderingConfiguration: \(Swift.String(describing: renderingConfiguration)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension WisdomClientTypes {
    /// Summary information about the knowledge base.
    public struct KnowledgeBaseSummary: Swift.Equatable {
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// The the identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The type of knowledge base.
        /// This member is required.
        public var knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// Information about how to render the content.
        public var renderingConfiguration: WisdomClientTypes.RenderingConfiguration?
        /// The KMS key used for encryption.
        public var serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration?
        /// [KEVIN]
        public var sourceConfiguration: WisdomClientTypes.SourceConfiguration?
        /// The status of the knowledge base summary.
        /// This member is required.
        public var status: WisdomClientTypes.KnowledgeBaseStatus?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseType: WisdomClientTypes.KnowledgeBaseType? = nil,
            name: Swift.String? = nil,
            renderingConfiguration: WisdomClientTypes.RenderingConfiguration? = nil,
            serverSideEncryptionConfiguration: WisdomClientTypes.ServerSideEncryptionConfiguration? = nil,
            sourceConfiguration: WisdomClientTypes.SourceConfiguration? = nil,
            status: WisdomClientTypes.KnowledgeBaseStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseType = knowledgeBaseType
            self.name = name
            self.renderingConfiguration = renderingConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.tags = tags
        }
    }

}

extension WisdomClientTypes {
    public enum KnowledgeBaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case external
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseType] {
            return [
                .custom,
                .external,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .external: return "EXTERNAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseType(rawValue: rawValue) ?? KnowledgeBaseType.sdkUnknown(rawValue)
        }
    }
}

extension ListAssistantAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssistantAssociationsInput(assistantId: \(Swift.String(describing: assistantId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssistantAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAssistantAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssistantAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssistantAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssistantAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssistantAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssistantAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssistantAssociationsOutputError>
}

public struct ListAssistantAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssistantAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssistantAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssistantAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssistantAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssistantAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssistantAssociationsOutputError>
}

public struct ListAssistantAssociationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssistantAssociationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssistantAssociationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssistantAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/associations"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssistantAssociationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssistantAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssistantAssociationsOutputError>
}

public struct ListAssistantAssociationsInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssistantAssociationsInputBody: Swift.Equatable {
}

extension ListAssistantAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssistantAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssistantAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssistantAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssistantAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssistantAssociationsOutputResponse(assistantAssociationSummaries: \(Swift.String(describing: assistantAssociationSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssistantAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssistantAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistantAssociationSummaries = output.assistantAssociationSummaries
            self.nextToken = output.nextToken
        } else {
            self.assistantAssociationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssistantAssociationsOutputResponse: Swift.Equatable {
    /// Summary information about assistant associations.
    /// This member is required.
    public var assistantAssociationSummaries: [WisdomClientTypes.AssistantAssociationSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        assistantAssociationSummaries: [WisdomClientTypes.AssistantAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantAssociationSummaries = assistantAssociationSummaries
        self.nextToken = nextToken
    }
}

struct ListAssistantAssociationsOutputResponseBody: Swift.Equatable {
    public let assistantAssociationSummaries: [WisdomClientTypes.AssistantAssociationSummary]?
    public let nextToken: Swift.String?
}

extension ListAssistantAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantAssociationSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantAssociationSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.AssistantAssociationSummary?].self, forKey: .assistantAssociationSummaries)
        var assistantAssociationSummariesDecoded0:[WisdomClientTypes.AssistantAssociationSummary]? = nil
        if let assistantAssociationSummariesContainer = assistantAssociationSummariesContainer {
            assistantAssociationSummariesDecoded0 = [WisdomClientTypes.AssistantAssociationSummary]()
            for structure0 in assistantAssociationSummariesContainer {
                if let structure0 = structure0 {
                    assistantAssociationSummariesDecoded0?.append(structure0)
                }
            }
        }
        assistantAssociationSummaries = assistantAssociationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssistantsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssistantsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssistantsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAssistantsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssistantsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssistantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssistantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssistantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssistantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssistantsOutputError>
}

public struct ListAssistantsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssistantsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssistantsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssistantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssistantsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssistantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssistantsOutputError>
}

public struct ListAssistantsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssistantsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssistantsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssistantsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/assistants"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssistantsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssistantsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssistantsOutputError>
}

public struct ListAssistantsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssistantsInputBody: Swift.Equatable {
}

extension ListAssistantsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssistantsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssistantsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssistantsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssistantsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssistantsOutputResponse(assistantSummaries: \(Swift.String(describing: assistantSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssistantsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssistantsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assistantSummaries = output.assistantSummaries
            self.nextToken = output.nextToken
        } else {
            self.assistantSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssistantsOutputResponse: Swift.Equatable {
    /// Information about the assistants.
    /// This member is required.
    public var assistantSummaries: [WisdomClientTypes.AssistantSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        assistantSummaries: [WisdomClientTypes.AssistantSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assistantSummaries = assistantSummaries
        self.nextToken = nextToken
    }
}

struct ListAssistantsOutputResponseBody: Swift.Equatable {
    public let assistantSummaries: [WisdomClientTypes.AssistantSummary]?
    public let nextToken: Swift.String?
}

extension ListAssistantsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assistantSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.AssistantSummary?].self, forKey: .assistantSummaries)
        var assistantSummariesDecoded0:[WisdomClientTypes.AssistantSummary]? = nil
        if let assistantSummariesContainer = assistantSummariesContainer {
            assistantSummariesDecoded0 = [WisdomClientTypes.AssistantSummary]()
            for structure0 in assistantSummariesContainer {
                if let structure0 = structure0 {
                    assistantSummariesDecoded0?.append(structure0)
                }
            }
        }
        assistantSummaries = assistantSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContentsInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListContentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListContentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContentsOutputError>
}

public struct ListContentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContentsOutputError>
}

public struct ListContentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContentsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListContentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListContentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListContentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContentsOutputError>
}

public struct ListContentsInput: Swift.Equatable {
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContentsInputBody: Swift.Equatable {
}

extension ListContentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListContentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContentsOutputResponse(contentSummaries: \(Swift.String(describing: contentSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListContentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentSummaries = output.contentSummaries
            self.nextToken = output.nextToken
        } else {
            self.contentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListContentsOutputResponse: Swift.Equatable {
    /// Information about the content.
    /// This member is required.
    public var contentSummaries: [WisdomClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        contentSummaries: [WisdomClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

struct ListContentsOutputResponseBody: Swift.Equatable {
    public let contentSummaries: [WisdomClientTypes.ContentSummary]?
    public let nextToken: Swift.String?
}

extension ListContentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.ContentSummary?].self, forKey: .contentSummaries)
        var contentSummariesDecoded0:[WisdomClientTypes.ContentSummary]? = nil
        if let contentSummariesContainer = contentSummariesContainer {
            contentSummariesDecoded0 = [WisdomClientTypes.ContentSummary]()
            for structure0 in contentSummariesContainer {
                if let structure0 = structure0 {
                    contentSummariesDecoded0?.append(structure0)
                }
            }
        }
        contentSummaries = contentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListKnowledgeBasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKnowledgeBasesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListKnowledgeBasesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListKnowledgeBasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKnowledgeBasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListKnowledgeBasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKnowledgeBasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListKnowledgeBasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListKnowledgeBasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKnowledgeBasesOutputError>
}

public struct ListKnowledgeBasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKnowledgeBasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListKnowledgeBasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKnowledgeBasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListKnowledgeBasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListKnowledgeBasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKnowledgeBasesOutputError>
}

public struct ListKnowledgeBasesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListKnowledgeBasesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListKnowledgeBasesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListKnowledgeBasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/knowledgeBases"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListKnowledgeBasesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListKnowledgeBasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListKnowledgeBasesOutputError>
}

public struct ListKnowledgeBasesInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesInputBody: Swift.Equatable {
}

extension ListKnowledgeBasesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListKnowledgeBasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKnowledgeBasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKnowledgeBasesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKnowledgeBasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKnowledgeBasesOutputResponse(knowledgeBaseSummaries: \(Swift.String(describing: knowledgeBaseSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListKnowledgeBasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListKnowledgeBasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBaseSummaries = output.knowledgeBaseSummaries
            self.nextToken = output.nextToken
        } else {
            self.knowledgeBaseSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListKnowledgeBasesOutputResponse: Swift.Equatable {
    /// Information about the knowledge bases.
    /// This member is required.
    public var knowledgeBaseSummaries: [WisdomClientTypes.KnowledgeBaseSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        knowledgeBaseSummaries: [WisdomClientTypes.KnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseSummaries = knowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesOutputResponseBody: Swift.Equatable {
    public let knowledgeBaseSummaries: [WisdomClientTypes.KnowledgeBaseSummary]?
    public let nextToken: Swift.String?
}

extension ListKnowledgeBasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.KnowledgeBaseSummary?].self, forKey: .knowledgeBaseSummaries)
        var knowledgeBaseSummariesDecoded0:[WisdomClientTypes.KnowledgeBaseSummary]? = nil
        if let knowledgeBaseSummariesContainer = knowledgeBaseSummariesContainer {
            knowledgeBaseSummariesDecoded0 = [WisdomClientTypes.KnowledgeBaseSummary]()
            for structure0 in knowledgeBaseSummariesContainer {
                if let structure0 = structure0 {
                    knowledgeBaseSummariesDecoded0?.append(structure0)
                }
            }
        }
        knowledgeBaseSummaries = knowledgeBaseSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags used to organize, track, or control access for this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes.NotifyRecommendationsReceivedError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case recommendationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WisdomClientTypes.NotifyRecommendationsReceivedError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyRecommendationsReceivedError(message: \(Swift.String(describing: message)), recommendationId: \(Swift.String(describing: recommendationId)))"}
}

extension WisdomClientTypes {
    /// An error occurred when creating a recommendation.
    public struct NotifyRecommendationsReceivedError: Swift.Equatable {
        /// A recommendation is causing an error.
        public var message: Swift.String?
        /// The identifier of the recommendation that is in error.
        public var recommendationId: Swift.String?

        public init (
            message: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.message = message
            self.recommendationId = recommendationId
        }
    }

}

public struct NotifyRecommendationsReceivedInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyRecommendationsReceivedInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyRecommendationsReceivedInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyRecommendationsReceivedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyRecommendationsReceivedInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyRecommendationsReceivedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyRecommendationsReceivedOutputError>
}

extension NotifyRecommendationsReceivedInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyRecommendationsReceivedInput(assistantId: \(Swift.String(describing: assistantId)), recommendationIds: \(Swift.String(describing: recommendationIds)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension NotifyRecommendationsReceivedInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for recommendationidlist0 in recommendationIds {
                try recommendationIdsContainer.encode(recommendationidlist0)
            }
        }
    }
}

public struct NotifyRecommendationsReceivedInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyRecommendationsReceivedInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyRecommendationsReceivedInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyRecommendationsReceivedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyRecommendationsReceivedInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyRecommendationsReceivedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyRecommendationsReceivedOutputError>
}

public struct NotifyRecommendationsReceivedInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyRecommendationsReceivedInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<NotifyRecommendationsReceivedInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyRecommendationsReceivedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<NotifyRecommendationsReceivedInput>
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyRecommendationsReceivedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyRecommendationsReceivedOutputError>
}

public struct NotifyRecommendationsReceivedInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "NotifyRecommendationsReceivedInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: NotifyRecommendationsReceivedInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<NotifyRecommendationsReceivedOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        guard let sessionId = input.sessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sessionId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())/recommendations/notify"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = NotifyRecommendationsReceivedInput
    public typealias MOutput = ClientRuntime.OperationOutput<NotifyRecommendationsReceivedOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<NotifyRecommendationsReceivedOutputError>
}

public struct NotifyRecommendationsReceivedInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The identifiers of the recommendations.
    /// This member is required.
    public var recommendationIds: [Swift.String]?
    /// The identifier of the session. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        assistantId: Swift.String? = nil,
        recommendationIds: [Swift.String]? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.recommendationIds = recommendationIds
        self.sessionId = sessionId
    }
}

struct NotifyRecommendationsReceivedInputBody: Swift.Equatable {
    public let recommendationIds: [Swift.String]?
}

extension NotifyRecommendationsReceivedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
    }
}

extension NotifyRecommendationsReceivedOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyRecommendationsReceivedOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyRecommendationsReceivedOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyRecommendationsReceivedOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotifyRecommendationsReceivedOutputResponse(errors: \(Swift.String(describing: errors)), recommendationIds: \(Swift.String(describing: recommendationIds)))"}
}

extension NotifyRecommendationsReceivedOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotifyRecommendationsReceivedOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.recommendationIds = output.recommendationIds
        } else {
            self.errors = nil
            self.recommendationIds = nil
        }
    }
}

public struct NotifyRecommendationsReceivedOutputResponse: Swift.Equatable {
    /// The identifiers of recommendations that are causing errors.
    public var errors: [WisdomClientTypes.NotifyRecommendationsReceivedError]?
    /// The identifiers of the recommendations.
    public var recommendationIds: [Swift.String]?

    public init (
        errors: [WisdomClientTypes.NotifyRecommendationsReceivedError]? = nil,
        recommendationIds: [Swift.String]? = nil
    )
    {
        self.errors = errors
        self.recommendationIds = recommendationIds
    }
}

struct NotifyRecommendationsReceivedOutputResponseBody: Swift.Equatable {
    public let recommendationIds: [Swift.String]?
    public let errors: [WisdomClientTypes.NotifyRecommendationsReceivedError]?
}

extension NotifyRecommendationsReceivedOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case recommendationIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([WisdomClientTypes.NotifyRecommendationsReceivedError?].self, forKey: .errors)
        var errorsDecoded0:[WisdomClientTypes.NotifyRecommendationsReceivedError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [WisdomClientTypes.NotifyRecommendationsReceivedError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension PreconditionFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreconditionFailedException(message: \(Swift.String(describing: message)))"}
}

extension PreconditionFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided revisionId does not match, indicating the content has been
///       modified since it was last read.
public struct PreconditionFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct QueryAssistantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryAssistantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<QueryAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<QueryAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<QueryAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryAssistantOutputError>
}

extension QueryAssistantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryAssistantInput(assistantId: \(Swift.String(describing: assistantId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), queryText: \(Swift.String(describing: queryText)))"}
}

extension QueryAssistantInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryText = queryText {
            try encodeContainer.encode(queryText, forKey: .queryText)
        }
    }
}

public struct QueryAssistantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryAssistantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<QueryAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<QueryAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<QueryAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryAssistantOutputError>
}

public struct QueryAssistantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryAssistantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<QueryAssistantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<QueryAssistantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<QueryAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryAssistantOutputError>
}

public struct QueryAssistantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "QueryAssistantInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: QueryAssistantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<QueryAssistantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/query"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = QueryAssistantInput
    public typealias MOutput = ClientRuntime.OperationOutput<QueryAssistantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<QueryAssistantOutputError>
}

public struct QueryAssistantInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The text to search for.
    /// This member is required.
    public var queryText: Swift.String?

    public init (
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryText = queryText
    }
}

struct QueryAssistantInputBody: Swift.Equatable {
    public let queryText: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension QueryAssistantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case queryText
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryText)
        queryText = queryTextDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension QueryAssistantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryAssistantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum QueryAssistantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryAssistantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "QueryAssistantOutputResponse(nextToken: \(Swift.String(describing: nextToken)), results: \(Swift.String(describing: results)))"}
}

extension QueryAssistantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: QueryAssistantOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
        } else {
            self.nextToken = nil
            self.results = nil
        }
    }
}

public struct QueryAssistantOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The results of the query.
    /// This member is required.
    public var results: [WisdomClientTypes.ResultData]?

    public init (
        nextToken: Swift.String? = nil,
        results: [WisdomClientTypes.ResultData]? = nil
    )
    {
        self.nextToken = nextToken
        self.results = results
    }
}

struct QueryAssistantOutputResponseBody: Swift.Equatable {
    public let results: [WisdomClientTypes.ResultData]?
    public let nextToken: Swift.String?
}

extension QueryAssistantOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case results
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([WisdomClientTypes.ResultData?].self, forKey: .results)
        var resultsDecoded0:[WisdomClientTypes.ResultData]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [WisdomClientTypes.ResultData]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WisdomClientTypes.RecommendationData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document
        case recommendationId
        case relevanceLevel
        case relevanceScore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let relevanceLevel = relevanceLevel {
            try encodeContainer.encode(relevanceLevel.rawValue, forKey: .relevanceLevel)
        }
        if relevanceScore != 0.0 {
            try encodeContainer.encode(relevanceScore, forKey: .relevanceScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let documentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.Document.self, forKey: .document)
        document = documentDecoded
        let relevanceScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .relevanceScore)
        relevanceScore = relevanceScoreDecoded
        let relevanceLevelDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.RelevanceLevel.self, forKey: .relevanceLevel)
        relevanceLevel = relevanceLevelDecoded
    }
}

extension WisdomClientTypes.RecommendationData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecommendationData(document: \(Swift.String(describing: document)), recommendationId: \(Swift.String(describing: recommendationId)), relevanceLevel: \(Swift.String(describing: relevanceLevel)), relevanceScore: \(Swift.String(describing: relevanceScore)))"}
}

extension WisdomClientTypes {
    /// Information about the recommendation.
    public struct RecommendationData: Swift.Equatable {
        /// The recommended document.
        /// This member is required.
        public var document: WisdomClientTypes.Document?
        /// The identifier of the recommendation.
        /// This member is required.
        public var recommendationId: Swift.String?
        /// The relevance level of the recommendation.
        public var relevanceLevel: WisdomClientTypes.RelevanceLevel?
        /// The relevance score of the recommendation.
        public var relevanceScore: Swift.Double

        public init (
            document: WisdomClientTypes.Document? = nil,
            recommendationId: Swift.String? = nil,
            relevanceLevel: WisdomClientTypes.RelevanceLevel? = nil,
            relevanceScore: Swift.Double = 0.0
        )
        {
            self.document = document
            self.recommendationId = recommendationId
            self.relevanceLevel = relevanceLevel
            self.relevanceScore = relevanceScore
        }
    }

}

extension WisdomClientTypes {
    public enum RelevanceLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [RelevanceLevel] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelevanceLevel(rawValue: rawValue) ?? RelevanceLevel.sdkUnknown(rawValue)
        }
    }
}

extension RemoveKnowledgeBaseTemplateUriInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveKnowledgeBaseTemplateUriInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)))"}
}

extension RemoveKnowledgeBaseTemplateUriInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RemoveKnowledgeBaseTemplateUriInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveKnowledgeBaseTemplateUriInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveKnowledgeBaseTemplateUriInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveKnowledgeBaseTemplateUriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveKnowledgeBaseTemplateUriInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveKnowledgeBaseTemplateUriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveKnowledgeBaseTemplateUriOutputError>
}

public struct RemoveKnowledgeBaseTemplateUriInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveKnowledgeBaseTemplateUriInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveKnowledgeBaseTemplateUriInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveKnowledgeBaseTemplateUriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveKnowledgeBaseTemplateUriInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveKnowledgeBaseTemplateUriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveKnowledgeBaseTemplateUriOutputError>
}

public struct RemoveKnowledgeBaseTemplateUriInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveKnowledgeBaseTemplateUriInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RemoveKnowledgeBaseTemplateUriInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveKnowledgeBaseTemplateUriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RemoveKnowledgeBaseTemplateUriInput
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveKnowledgeBaseTemplateUriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveKnowledgeBaseTemplateUriOutputError>
}

public struct RemoveKnowledgeBaseTemplateUriInput: Swift.Equatable {
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct RemoveKnowledgeBaseTemplateUriInputBody: Swift.Equatable {
}

extension RemoveKnowledgeBaseTemplateUriInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveKnowledgeBaseTemplateUriOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveKnowledgeBaseTemplateUriOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveKnowledgeBaseTemplateUriOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveKnowledgeBaseTemplateUriOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveKnowledgeBaseTemplateUriOutputResponse()"}
}

extension RemoveKnowledgeBaseTemplateUriOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveKnowledgeBaseTemplateUriOutputResponse: Swift.Equatable {

    public init() {}
}

struct RemoveKnowledgeBaseTemplateUriOutputResponseBody: Swift.Equatable {
}

extension RemoveKnowledgeBaseTemplateUriOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WisdomClientTypes.RenderingConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateUri = templateUri {
            try encodeContainer.encode(templateUri, forKey: .templateUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUri)
        templateUri = templateUriDecoded
    }
}

extension WisdomClientTypes.RenderingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RenderingConfiguration(templateUri: \(Swift.String(describing: templateUri)))"}
}

extension WisdomClientTypes {
    /// Information about how to render the content.
    public struct RenderingConfiguration: Swift.Equatable {
        /// A URI template containing exactly one variable in ${variableName} format.
        ///       This can only be set for EXTERNAL knowledge bases. For Salesforce and ServiceNow,
        ///       the variable must be one of the following:
        ///
        ///
        ///                Salesforce: Id, ArticleNumber, VersionNumber,
        ///             Title, PublishStatus, or IsDeleted
        ///
        ///
        ///
        ///                ServiceNow: number, short_description,
        ///             sys_mod_count, workflow_state, or active
        ///
        ///
        ///
        ///
        ///          The variable is replaced with the actual value for a piece of content when calling <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_GetContent.html">GetContent.
        public var templateUri: Swift.String?

        public init (
            templateUri: Swift.String? = nil
        )
        {
            self.templateUri = templateUri
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The specified resource name.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension WisdomClientTypes.ResultData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document
        case relevanceScore
        case resultId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if relevanceScore != 0.0 {
            try encodeContainer.encode(relevanceScore, forKey: .relevanceScore)
        }
        if let resultId = resultId {
            try encodeContainer.encode(resultId, forKey: .resultId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resultId)
        resultId = resultIdDecoded
        let documentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.Document.self, forKey: .document)
        document = documentDecoded
        let relevanceScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .relevanceScore)
        relevanceScore = relevanceScoreDecoded
    }
}

extension WisdomClientTypes.ResultData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResultData(document: \(Swift.String(describing: document)), relevanceScore: \(Swift.String(describing: relevanceScore)), resultId: \(Swift.String(describing: resultId)))"}
}

extension WisdomClientTypes {
    /// Information about the result.
    public struct ResultData: Swift.Equatable {
        /// The document.
        /// This member is required.
        public var document: WisdomClientTypes.Document?
        /// The relevance score of the results.
        public var relevanceScore: Swift.Double
        /// The identifier of the result data.
        /// This member is required.
        public var resultId: Swift.String?

        public init (
            document: WisdomClientTypes.Document? = nil,
            relevanceScore: Swift.Double = 0.0,
            resultId: Swift.String? = nil
        )
        {
            self.document = document
            self.relevanceScore = relevanceScore
            self.resultId = resultId
        }
    }

}

public struct SearchContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchContentOutputError>
}

extension SearchContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchContentInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchExpression: \(Swift.String(describing: searchExpression)))"}
}

extension SearchContentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchExpression = searchExpression {
            try encodeContainer.encode(searchExpression, forKey: .searchExpression)
        }
    }
}

public struct SearchContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchContentOutputError>
}

public struct SearchContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchContentOutputError>
}

public struct SearchContentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchContentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SearchContentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/search"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchContentInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchContentOutputError>
}

public struct SearchContentInput: Swift.Equatable {
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: WisdomClientTypes.SearchExpression?

    public init (
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: WisdomClientTypes.SearchExpression? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

struct SearchContentInputBody: Swift.Equatable {
    public let searchExpression: WisdomClientTypes.SearchExpression?
}

extension SearchContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchExpressionDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SearchExpression.self, forKey: .searchExpression)
        searchExpression = searchExpressionDecoded
    }
}

extension SearchContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchContentOutputResponse(contentSummaries: \(Swift.String(describing: contentSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension SearchContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentSummaries = output.contentSummaries
            self.nextToken = output.nextToken
        } else {
            self.contentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct SearchContentOutputResponse: Swift.Equatable {
    /// Summary information about the content.
    /// This member is required.
    public var contentSummaries: [WisdomClientTypes.ContentSummary]?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?

    public init (
        contentSummaries: [WisdomClientTypes.ContentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contentSummaries = contentSummaries
        self.nextToken = nextToken
    }
}

struct SearchContentOutputResponseBody: Swift.Equatable {
    public let contentSummaries: [WisdomClientTypes.ContentSummary]?
    public let nextToken: Swift.String?
}

extension SearchContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.ContentSummary?].self, forKey: .contentSummaries)
        var contentSummariesDecoded0:[WisdomClientTypes.ContentSummary]? = nil
        if let contentSummariesContainer = contentSummariesContainer {
            contentSummariesDecoded0 = [WisdomClientTypes.ContentSummary]()
            for structure0 in contentSummariesContainer {
                if let structure0 = structure0 {
                    contentSummariesDecoded0?.append(structure0)
                }
            }
        }
        contentSummaries = contentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WisdomClientTypes.SearchExpression: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([WisdomClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[WisdomClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [WisdomClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension WisdomClientTypes.SearchExpression: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchExpression(filters: \(Swift.String(describing: filters)))"}
}

extension WisdomClientTypes {
    /// The search expression.
    public struct SearchExpression: Swift.Equatable {
        /// The search expression filters.
        /// This member is required.
        public var filters: [WisdomClientTypes.Filter]?

        public init (
            filters: [WisdomClientTypes.Filter]? = nil
        )
        {
            self.filters = filters
        }
    }

}

public struct SearchSessionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchSessionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchSessionsOutputError>
}

extension SearchSessionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchSessionsInput(assistantId: \(Swift.String(describing: assistantId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), searchExpression: \(Swift.String(describing: searchExpression)))"}
}

extension SearchSessionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let searchExpression = searchExpression {
            try encodeContainer.encode(searchExpression, forKey: .searchExpression)
        }
    }
}

public struct SearchSessionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchSessionsOutputError>
}

public struct SearchSessionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchSessionsOutputError>
}

public struct SearchSessionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchSessionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SearchSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assistantId = input.assistantId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assistantId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assistants/\(assistantId.urlPercentEncoding())/searchSessions"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchSessionsOutputError>
}

public struct SearchSessionsInput: Swift.Equatable {
    /// The identifier of the Wisdom assistant. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var assistantId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous
    /// response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The search expression to filter results.
    /// This member is required.
    public var searchExpression: WisdomClientTypes.SearchExpression?

    public init (
        assistantId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        searchExpression: WisdomClientTypes.SearchExpression? = nil
    )
    {
        self.assistantId = assistantId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.searchExpression = searchExpression
    }
}

struct SearchSessionsInputBody: Swift.Equatable {
    public let searchExpression: WisdomClientTypes.SearchExpression?
}

extension SearchSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case searchExpression
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchExpressionDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.SearchExpression.self, forKey: .searchExpression)
        searchExpression = searchExpressionDecoded
    }
}

extension SearchSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchSessionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSessionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchSessionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sessionSummaries: \(Swift.String(describing: sessionSummaries)))"}
}

extension SearchSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessionSummaries = output.sessionSummaries
        } else {
            self.nextToken = nil
            self.sessionSummaries = nil
        }
    }
}

public struct SearchSessionsOutputResponse: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// Summary information about the sessions.
    /// This member is required.
    public var sessionSummaries: [WisdomClientTypes.SessionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        sessionSummaries: [WisdomClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessionSummaries = sessionSummaries
    }
}

struct SearchSessionsOutputResponseBody: Swift.Equatable {
    public let sessionSummaries: [WisdomClientTypes.SessionSummary]?
    public let nextToken: Swift.String?
}

extension SearchSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sessionSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionSummariesContainer = try containerValues.decodeIfPresent([WisdomClientTypes.SessionSummary?].self, forKey: .sessionSummaries)
        var sessionSummariesDecoded0:[WisdomClientTypes.SessionSummary]? = nil
        if let sessionSummariesContainer = sessionSummariesContainer {
            sessionSummariesDecoded0 = [WisdomClientTypes.SessionSummary]()
            for structure0 in sessionSummariesContainer {
                if let structure0 = structure0 {
                    sessionSummariesDecoded0?.append(structure0)
                }
            }
        }
        sessionSummaries = sessionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension WisdomClientTypes.ServerSideEncryptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension WisdomClientTypes.ServerSideEncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerSideEncryptionConfiguration(kmsKeyId: \(Swift.String(describing: kmsKeyId)))"}
}

extension WisdomClientTypes {
    /// The KMS key used for encryption.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// The KMS key. For information about valid ID values, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id">Key identifiers (KeyId) in the
        ///         AWS Key Management Service Developer Guide.
        public var kmsKeyId: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've exceeded your service quota. To perform the requested action, remove some of the
///       relevant resources, or use service quotas to request a service quota increase.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WisdomClientTypes.SessionData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case sessionArn
        case sessionId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sessionArn = sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WisdomClientTypes.SessionData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionData(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), sessionArn: \(Swift.String(describing: sessionArn)), sessionId: \(Swift.String(describing: sessionId)), tags: \(Swift.String(describing: tags)))"}
}

extension WisdomClientTypes {
    /// Information about the session.
    public struct SessionData: Swift.Equatable {
        /// The description of the session.
        public var description: Swift.String?
        /// The name of the session.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The tags used to organize, track, or control access for this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.sessionArn = sessionArn
            self.sessionId = sessionId
            self.tags = tags
        }
    }

}

extension WisdomClientTypes.SessionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assistantArn
        case assistantId
        case sessionArn
        case sessionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assistantArn = assistantArn {
            try encodeContainer.encode(assistantArn, forKey: .assistantArn)
        }
        if let assistantId = assistantId {
            try encodeContainer.encode(assistantId, forKey: .assistantId)
        }
        if let sessionArn = sessionArn {
            try encodeContainer.encode(sessionArn, forKey: .sessionArn)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionArn)
        sessionArn = sessionArnDecoded
        let assistantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantId)
        assistantId = assistantIdDecoded
        let assistantArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assistantArn)
        assistantArn = assistantArnDecoded
    }
}

extension WisdomClientTypes.SessionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionSummary(assistantArn: \(Swift.String(describing: assistantArn)), assistantId: \(Swift.String(describing: assistantId)), sessionArn: \(Swift.String(describing: sessionArn)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension WisdomClientTypes {
    /// Summary information about the session.
    public struct SessionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Wisdom assistant
        /// This member is required.
        public var assistantArn: Swift.String?
        /// The identifier of the Wisdom assistant.
        /// This member is required.
        public var assistantId: Swift.String?
        /// The Amazon Resource Name (ARN) of the session.
        /// This member is required.
        public var sessionArn: Swift.String?
        /// The identifier of the session.
        /// This member is required.
        public var sessionId: Swift.String?

        public init (
            assistantArn: Swift.String? = nil,
            assistantId: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            sessionId: Swift.String? = nil
        )
        {
            self.assistantArn = assistantArn
            self.assistantId = assistantId
            self.sessionArn = sessionArn
            self.sessionId = sessionId
        }
    }

}

extension WisdomClientTypes.SourceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appintegrations = "appIntegrations"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .appintegrations(appintegrations):
                try container.encode(appintegrations, forKey: .appintegrations)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let appintegrationsDecoded = try values.decodeIfPresent(WisdomClientTypes.AppIntegrationsConfiguration.self, forKey: .appintegrations)
        if let appintegrations = appintegrationsDecoded {
            self = .appintegrations(appintegrations)
            return
        }
        self = .sdkUnknown("")
    }
}

extension WisdomClientTypes {
    /// Configuration information about the external data source.
    public enum SourceConfiguration: Swift.Equatable {
        /// Configuration information for Amazon AppIntegrations to automatically ingest content.
        case appintegrations(WisdomClientTypes.AppIntegrationsConfiguration)
        case sdkUnknown(Swift.String)
    }

}

public struct StartContentUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartContentUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartContentUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartContentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartContentUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartContentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartContentUploadOutputError>
}

extension StartContentUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartContentUploadInput(contentType: \(Swift.String(describing: contentType)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)))"}
}

extension StartContentUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

public struct StartContentUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartContentUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartContentUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartContentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartContentUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartContentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartContentUploadOutputError>
}

public struct StartContentUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartContentUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartContentUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartContentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartContentUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartContentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartContentUploadOutputError>
}

public struct StartContentUploadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartContentUploadInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartContentUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartContentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/upload"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartContentUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartContentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartContentUploadOutputError>
}

public struct StartContentUploadInput: Swift.Equatable {
    /// The type of content to upload.
    /// This member is required.
    public var contentType: Swift.String?
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct StartContentUploadInputBody: Swift.Equatable {
    public let contentType: Swift.String?
}

extension StartContentUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension StartContentUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartContentUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartContentUploadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartContentUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartContentUploadOutputResponse(headersToInclude: \(Swift.String(describing: headersToInclude)), uploadId: \(Swift.String(describing: uploadId)), urlExpiry: \(Swift.String(describing: urlExpiry)), url: \"CONTENT_REDACTED\")"}
}

extension StartContentUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartContentUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.headersToInclude = output.headersToInclude
            self.uploadId = output.uploadId
            self.url = output.url
            self.urlExpiry = output.urlExpiry
        } else {
            self.headersToInclude = nil
            self.uploadId = nil
            self.url = nil
            self.urlExpiry = nil
        }
    }
}

public struct StartContentUploadOutputResponse: Swift.Equatable {
    /// The headers to include in the upload.
    /// This member is required.
    public var headersToInclude: [Swift.String:Swift.String]?
    /// The identifier of the upload.
    /// This member is required.
    public var uploadId: Swift.String?
    /// The URL of the upload.
    /// This member is required.
    public var url: Swift.String?
    /// The expiration time of the URL as an epoch timestamp.
    /// This member is required.
    public var urlExpiry: ClientRuntime.Date?

    public init (
        headersToInclude: [Swift.String:Swift.String]? = nil,
        uploadId: Swift.String? = nil,
        url: Swift.String? = nil,
        urlExpiry: ClientRuntime.Date? = nil
    )
    {
        self.headersToInclude = headersToInclude
        self.uploadId = uploadId
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

struct StartContentUploadOutputResponseBody: Swift.Equatable {
    public let uploadId: Swift.String?
    public let url: Swift.String?
    public let urlExpiry: ClientRuntime.Date?
    public let headersToInclude: [Swift.String:Swift.String]?
}

extension StartContentUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headersToInclude
        case uploadId
        case url
        case urlExpiry
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
        let headersToIncludeContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headersToInclude)
        var headersToIncludeDecoded0: [Swift.String:Swift.String]? = nil
        if let headersToIncludeContainer = headersToIncludeContainer {
            headersToIncludeDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in headersToIncludeContainer {
                if let nonemptystring0 = nonemptystring0 {
                    headersToIncludeDecoded0?[key0] = nonemptystring0
                }
            }
        }
        headersToInclude = headersToIncludeDecoded0
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for this resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Connect Wisdom throws this exception if you have too many tags in your tag set.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The specified resource name.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContentOutputError>
}

extension UpdateContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateContentInput(contentId: \(Swift.String(describing: contentId)), knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), metadata: \(Swift.String(describing: metadata)), overrideLinkOutUri: \(Swift.String(describing: overrideLinkOutUri)), removeOverrideLinkOutUri: \(Swift.String(describing: removeOverrideLinkOutUri)), revisionId: \(Swift.String(describing: revisionId)), title: \(Swift.String(describing: title)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension UpdateContentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
        case overrideLinkOutUri
        case removeOverrideLinkOutUri
        case revisionId
        case title
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, contentmetadata0) in metadata {
                try metadataContainer.encode(contentmetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let overrideLinkOutUri = overrideLinkOutUri {
            try encodeContainer.encode(overrideLinkOutUri, forKey: .overrideLinkOutUri)
        }
        if let removeOverrideLinkOutUri = removeOverrideLinkOutUri {
            try encodeContainer.encode(removeOverrideLinkOutUri, forKey: .removeOverrideLinkOutUri)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct UpdateContentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContentOutputError>
}

public struct UpdateContentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateContentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContentOutputError>
}

public struct UpdateContentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateContentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateContentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        guard let contentId = input.contentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("contentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/contents/\(contentId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateContentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateContentOutputError>
}

public struct UpdateContentInput: Swift.Equatable {
    /// The identifier of the content. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var contentId: Swift.String?
    /// The the identifier of the knowledge base. Can be either the ID or the ARN
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// A key/value map to store attributes without affecting tagging or recommendations. For
    ///       example, when synchronizing data between an external system and Wisdom, you can store an
    ///       external version identifier as metadata to utilize for determining drift.
    public var metadata: [Swift.String:Swift.String]?
    /// The URI for the article. If the knowledge base has a templateUri, setting this argument
    ///       overrides it for this piece of content. To remove an existing overrideLinkOurUri,
    ///       exclude this argument and set removeOverrideLinkOutUri to true.
    public var overrideLinkOutUri: Swift.String?
    /// Unset the existing overrideLinkOutUri if it exists.
    public var removeOverrideLinkOutUri: Swift.Bool?
    /// The revisionId of the content resource to update, taken from an earlier call
    ///       to GetContent, GetContentSummary, SearchContent, or
    ///         ListContents. If included, this argument acts as an optimistic lock to ensure
    ///       content was not modified since it was last read. If it has been modified, this API throws a
    ///         PreconditionFailedException.
    public var revisionId: Swift.String?
    /// The title of the content.
    public var title: Swift.String?
    /// A pointer to the uploaded asset. This value is returned by <a href="https://docs.aws.amazon.com/wisdom/latest/APIReference/API_StartContentUpload.html">StartContentUpload.
    ///
    public var uploadId: Swift.String?

    public init (
        contentId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        overrideLinkOutUri: Swift.String? = nil,
        removeOverrideLinkOutUri: Swift.Bool? = nil,
        revisionId: Swift.String? = nil,
        title: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.contentId = contentId
        self.knowledgeBaseId = knowledgeBaseId
        self.metadata = metadata
        self.overrideLinkOutUri = overrideLinkOutUri
        self.removeOverrideLinkOutUri = removeOverrideLinkOutUri
        self.revisionId = revisionId
        self.title = title
        self.uploadId = uploadId
    }
}

struct UpdateContentInputBody: Swift.Equatable {
    public let revisionId: Swift.String?
    public let title: Swift.String?
    public let overrideLinkOutUri: Swift.String?
    public let removeOverrideLinkOutUri: Swift.Bool?
    public let metadata: [Swift.String:Swift.String]?
    public let uploadId: Swift.String?
}

extension UpdateContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
        case overrideLinkOutUri
        case removeOverrideLinkOutUri
        case revisionId
        case title
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let overrideLinkOutUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLinkOutUri)
        overrideLinkOutUri = overrideLinkOutUriDecoded
        let removeOverrideLinkOutUriDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removeOverrideLinkOutUri)
        removeOverrideLinkOutUri = removeOverrideLinkOutUriDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in metadataContainer {
                if let nonemptystring0 = nonemptystring0 {
                    metadataDecoded0?[key0] = nonemptystring0
                }
            }
        }
        metadata = metadataDecoded0
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
    }
}

extension UpdateContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateContentOutputResponse(content: \(Swift.String(describing: content)))"}
}

extension UpdateContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateContentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

public struct UpdateContentOutputResponse: Swift.Equatable {
    /// The content.
    public var content: WisdomClientTypes.ContentData?

    public init (
        content: WisdomClientTypes.ContentData? = nil
    )
    {
        self.content = content
    }
}

struct UpdateContentOutputResponseBody: Swift.Equatable {
    public let content: WisdomClientTypes.ContentData?
}

extension UpdateContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.ContentData.self, forKey: .content)
        content = contentDecoded
    }
}

public struct UpdateKnowledgeBaseTemplateUriInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKnowledgeBaseTemplateUriInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKnowledgeBaseTemplateUriInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKnowledgeBaseTemplateUriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKnowledgeBaseTemplateUriInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKnowledgeBaseTemplateUriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKnowledgeBaseTemplateUriOutputError>
}

extension UpdateKnowledgeBaseTemplateUriInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateKnowledgeBaseTemplateUriInput(knowledgeBaseId: \(Swift.String(describing: knowledgeBaseId)), templateUri: \(Swift.String(describing: templateUri)))"}
}

extension UpdateKnowledgeBaseTemplateUriInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateUri = templateUri {
            try encodeContainer.encode(templateUri, forKey: .templateUri)
        }
    }
}

public struct UpdateKnowledgeBaseTemplateUriInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKnowledgeBaseTemplateUriInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKnowledgeBaseTemplateUriInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKnowledgeBaseTemplateUriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKnowledgeBaseTemplateUriInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKnowledgeBaseTemplateUriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKnowledgeBaseTemplateUriOutputError>
}

public struct UpdateKnowledgeBaseTemplateUriInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKnowledgeBaseTemplateUriInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateKnowledgeBaseTemplateUriInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKnowledgeBaseTemplateUriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateKnowledgeBaseTemplateUriInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKnowledgeBaseTemplateUriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKnowledgeBaseTemplateUriOutputError>
}

public struct UpdateKnowledgeBaseTemplateUriInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateKnowledgeBaseTemplateUriInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateKnowledgeBaseTemplateUriInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateKnowledgeBaseTemplateUriOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let knowledgeBaseId = input.knowledgeBaseId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("knowledgeBaseId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/knowledgeBases/\(knowledgeBaseId.urlPercentEncoding())/templateUri"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateKnowledgeBaseTemplateUriInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateKnowledgeBaseTemplateUriOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateKnowledgeBaseTemplateUriOutputError>
}

public struct UpdateKnowledgeBaseTemplateUriInput: Swift.Equatable {
    /// The the identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The template URI to update.
    /// This member is required.
    public var templateUri: Swift.String?

    public init (
        knowledgeBaseId: Swift.String? = nil,
        templateUri: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.templateUri = templateUri
    }
}

struct UpdateKnowledgeBaseTemplateUriInputBody: Swift.Equatable {
    public let templateUri: Swift.String?
}

extension UpdateKnowledgeBaseTemplateUriInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case templateUri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUri)
        templateUri = templateUriDecoded
    }
}

extension UpdateKnowledgeBaseTemplateUriOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateKnowledgeBaseTemplateUriOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateKnowledgeBaseTemplateUriOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateKnowledgeBaseTemplateUriOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateKnowledgeBaseTemplateUriOutputResponse(knowledgeBase: \(Swift.String(describing: knowledgeBase)))"}
}

extension UpdateKnowledgeBaseTemplateUriOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateKnowledgeBaseTemplateUriOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct UpdateKnowledgeBaseTemplateUriOutputResponse: Swift.Equatable {
    /// The knowledge base to update.
    public var knowledgeBase: WisdomClientTypes.KnowledgeBaseData?

    public init (
        knowledgeBase: WisdomClientTypes.KnowledgeBaseData? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct UpdateKnowledgeBaseTemplateUriOutputResponseBody: Swift.Equatable {
    public let knowledgeBase: WisdomClientTypes.KnowledgeBaseData?
}

extension UpdateKnowledgeBaseTemplateUriOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(WisdomClientTypes.KnowledgeBaseData.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
