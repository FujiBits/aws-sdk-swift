// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateRepositoryOutputError>
}

extension AssociateRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateRepositoryInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), kMSKeyDetails: \(Swift.String(describing: kMSKeyDetails)), repository: \(Swift.String(describing: repository)), tags: \(Swift.String(describing: tags)))"}
}

extension AssociateRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kMSKeyDetails = "KMSKeyDetails"
        case repository = "Repository"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let kMSKeyDetails = kMSKeyDetails {
            try encodeContainer.encode(kMSKeyDetails, forKey: .kMSKeyDetails)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct AssociateRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateRepositoryOutputError>
}

public struct AssociateRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateRepositoryOutputError>
}

public struct AssociateRepositoryInput: Swift.Equatable {
    /// <p>Amazon CodeGuru Reviewer uses this value to prevent the accidental creation of duplicate repository
    ///         associations if there are failures and retries. </p>
    public var clientRequestToken: Swift.String?
    /// <p>A <code>KMSKeyDetails</code> object that contains:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The encryption option for this repository association. It is either owned by AWS
    ///             Key Management Service (KMS) (<code>AWS_OWNED_CMK</code>) or customer managed (<code>CUSTOMER_MANAGED_CMK</code>).</p>
    ///             </li>
    ///             <li>
    ///                <p>The ID of the AWS KMS key that
    ///             is associated with this respository association.</p>
    ///             </li>
    ///          </ul>
    public let kMSKeyDetails: CodeGuruReviewerClientTypes.KMSKeyDetails?
    /// <p>The repository to associate.</p>
    public let repository: CodeGuruReviewerClientTypes.Repository?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [Swift.String:Swift.String]?

    public init (
        clientRequestToken: Swift.String? = nil,
        kMSKeyDetails: CodeGuruReviewerClientTypes.KMSKeyDetails? = nil,
        repository: CodeGuruReviewerClientTypes.Repository? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.kMSKeyDetails = kMSKeyDetails
        self.repository = repository
        self.tags = tags
    }
}

struct AssociateRepositoryInputBody: Swift.Equatable {
    public let repository: CodeGuruReviewerClientTypes.Repository?
    public let clientRequestToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let kMSKeyDetails: CodeGuruReviewerClientTypes.KMSKeyDetails?
}

extension AssociateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case kMSKeyDetails = "KMSKeyDetails"
        case repository = "Repository"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let kMSKeyDetailsDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.KMSKeyDetails.self, forKey: .kMSKeyDetails)
        kMSKeyDetails = kMSKeyDetailsDecoded
    }
}

extension AssociateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateRepositoryOutputResponse(repositoryAssociation: \(Swift.String(describing: repositoryAssociation)), tags: \(Swift.String(describing: tags)))"}
}

extension AssociateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryAssociation = output.repositoryAssociation
            self.tags = output.tags
        } else {
            self.repositoryAssociation = nil
            self.tags = nil
        }
    }
}

public struct AssociateRepositoryOutputResponse: Swift.Equatable {
    /// <p>Information about the repository association.</p>
    public let repositoryAssociation: CodeGuruReviewerClientTypes.RepositoryAssociation?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [Swift.String:Swift.String]?

    public init (
        repositoryAssociation: CodeGuruReviewerClientTypes.RepositoryAssociation? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.repositoryAssociation = repositoryAssociation
        self.tags = tags
    }
}

struct AssociateRepositoryOutputResponseBody: Swift.Equatable {
    public let repositoryAssociation: CodeGuruReviewerClientTypes.RepositoryAssociation?
    public let tags: [Swift.String:Swift.String]?
}

extension AssociateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryAssociation = "RepositoryAssociation"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAssociationDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.RepositoryAssociation.self, forKey: .repositoryAssociation)
        repositoryAssociation = repositoryAssociationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeGuruReviewerClientTypes.CodeCommitRepository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodeGuruReviewerClientTypes.CodeCommitRepository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeCommitRepository(name: \(Swift.String(describing: name)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>Information about an AWS CodeCommit repository. The CodeCommit repository must be in the same
    ///       AWS Region and AWS account where its CodeGuru Reviewer code reviews are configured. </p>
    public struct CodeCommitRepository: Swift.Equatable {
        /// <p>The name of the AWS CodeCommit repository. For more information, see
        ///          <a href="https://docs.aws.amazon.com/codecommit/latest/APIReference/API_GetRepository.html#CodeCommit-GetRepository-request-repositoryName">repositoryName</a>
        ///          in the <i>AWS CodeCommit API Reference</i>.</p>
        public let name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CodeGuruReviewerClientTypes.CodeReview: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationArn = "AssociationArn"
        case codeReviewArn = "CodeReviewArn"
        case createdTimeStamp = "CreatedTimeStamp"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case metrics = "Metrics"
        case name = "Name"
        case owner = "Owner"
        case providerType = "ProviderType"
        case pullRequestId = "PullRequestId"
        case repositoryName = "RepositoryName"
        case sourceCodeType = "SourceCodeType"
        case state = "State"
        case stateReason = "StateReason"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationArn = associationArn {
            try encodeContainer.encode(associationArn, forKey: .associationArn)
        }
        if let codeReviewArn = codeReviewArn {
            try encodeContainer.encode(codeReviewArn, forKey: .codeReviewArn)
        }
        if let createdTimeStamp = createdTimeStamp {
            try encodeContainer.encode(createdTimeStamp.timeIntervalSince1970, forKey: .createdTimeStamp)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let metrics = metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCodeType = sourceCodeType {
            try encodeContainer.encode(sourceCodeType, forKey: .sourceCodeType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let codeReviewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeReviewArn)
        codeReviewArn = codeReviewArnDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.JobState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let sourceCodeTypeDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.SourceCodeType.self, forKey: .sourceCodeType)
        sourceCodeType = sourceCodeTypeDecoded
        let associationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationArn)
        associationArn = associationArnDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension CodeGuruReviewerClientTypes.CodeReview: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeReview(associationArn: \(Swift.String(describing: associationArn)), codeReviewArn: \(Swift.String(describing: codeReviewArn)), createdTimeStamp: \(Swift.String(describing: createdTimeStamp)), lastUpdatedTimeStamp: \(Swift.String(describing: lastUpdatedTimeStamp)), metrics: \(Swift.String(describing: metrics)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), providerType: \(Swift.String(describing: providerType)), pullRequestId: \(Swift.String(describing: pullRequestId)), repositoryName: \(Swift.String(describing: repositoryName)), sourceCodeType: \(Swift.String(describing: sourceCodeType)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)), type: \(Swift.String(describing: type)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Information about a code review. A code review belongs to the associated repository that contains the reviewed code.
    ///       </p>
    public struct CodeReview: Swift.Equatable {
        /// <p>
        /// 			The Amazon Resource Name (ARN) of the
        /// 			<a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
        ///                <code>RepositoryAssociation</code>
        ///             </a> that contains
        /// 			the reviewed source code. You can retrieve associated repository ARNs by calling
        /// 			<a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
        ///                <code>ListRepositoryAssociations</code>
        ///             </a>.
        /// 		</p>
        public let associationArn: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
        ///                <code>CodeReview</code>
        ///             </a> object.
        ///       </p>
        public let codeReviewArn: Swift.String?
        /// <p>
        ///          The time, in milliseconds since the epoch, when the code review was created.
        ///       </p>
        public let createdTimeStamp: ClientRuntime.Date?
        /// <p>
        ///          The time, in milliseconds since the epoch, when the code review was last updated.
        ///       </p>
        public let lastUpdatedTimeStamp: ClientRuntime.Date?
        /// <p>
        ///          The statistics from the code review.
        ///       </p>
        public let metrics: CodeGuruReviewerClientTypes.Metrics?
        /// <p>
        ///          The name of the code review.
        ///       </p>
        public let name: Swift.String?
        /// <p>The owner of the repository. For an AWS CodeCommit repository, this is the AWS account ID of the
        ///       account that owns the repository. For a GitHub, GitHub Enterprise Server, or Bitbucket repository, this is the username for the account that owns the repository.</p>
        public let owner: Swift.String?
        /// <p>
        ///          The type of repository that contains the reviewed code (for example, GitHub or Bitbucket).
        ///       </p>
        public let providerType: CodeGuruReviewerClientTypes.ProviderType?
        /// <p>
        ///          The pull request ID for the code review.
        ///       </p>
        public let pullRequestId: Swift.String?
        /// <p>
        ///          The name of the repository.
        ///       </p>
        public let repositoryName: Swift.String?
        /// <p>
        ///          The type of the source code for the code review.
        ///       </p>
        public let sourceCodeType: CodeGuruReviewerClientTypes.SourceCodeType?
        /// <p>The valid code review states are:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Completed</code>: The code review is complete.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Pending</code>: The code review started and has not completed or failed.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Failed</code>: The code review failed.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Deleting</code>: The code review is being deleted.
        ///             </p>
        ///             </li>
        ///          </ul>
        public let state: CodeGuruReviewerClientTypes.JobState?
        /// <p>
        ///          The reason for the state of the code review.
        ///       </p>
        public let stateReason: Swift.String?
        /// <p>
        ///          The type of code review.
        ///       </p>
        public let type: CodeGuruReviewerClientTypes.ModelType?

        public init (
            associationArn: Swift.String? = nil,
            codeReviewArn: Swift.String? = nil,
            createdTimeStamp: ClientRuntime.Date? = nil,
            lastUpdatedTimeStamp: ClientRuntime.Date? = nil,
            metrics: CodeGuruReviewerClientTypes.Metrics? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            providerType: CodeGuruReviewerClientTypes.ProviderType? = nil,
            pullRequestId: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            sourceCodeType: CodeGuruReviewerClientTypes.SourceCodeType? = nil,
            state: CodeGuruReviewerClientTypes.JobState? = nil,
            stateReason: Swift.String? = nil,
            type: CodeGuruReviewerClientTypes.ModelType? = nil
        )
        {
            self.associationArn = associationArn
            self.codeReviewArn = codeReviewArn
            self.createdTimeStamp = createdTimeStamp
            self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
            self.metrics = metrics
            self.name = name
            self.owner = owner
            self.providerType = providerType
            self.pullRequestId = pullRequestId
            self.repositoryName = repositoryName
            self.sourceCodeType = sourceCodeType
            self.state = state
            self.stateReason = stateReason
            self.type = type
        }
    }

}

extension CodeGuruReviewerClientTypes.CodeReviewSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeReviewArn = "CodeReviewArn"
        case createdTimeStamp = "CreatedTimeStamp"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case metricsSummary = "MetricsSummary"
        case name = "Name"
        case owner = "Owner"
        case providerType = "ProviderType"
        case pullRequestId = "PullRequestId"
        case repositoryName = "RepositoryName"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeReviewArn = codeReviewArn {
            try encodeContainer.encode(codeReviewArn, forKey: .codeReviewArn)
        }
        if let createdTimeStamp = createdTimeStamp {
            try encodeContainer.encode(createdTimeStamp.timeIntervalSince1970, forKey: .createdTimeStamp)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let metricsSummary = metricsSummary {
            try encodeContainer.encode(metricsSummary, forKey: .metricsSummary)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let codeReviewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeReviewArn)
        codeReviewArn = codeReviewArnDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.JobState.self, forKey: .state)
        state = stateDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let metricsSummaryDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.MetricsSummary.self, forKey: .metricsSummary)
        metricsSummary = metricsSummaryDecoded
    }
}

extension CodeGuruReviewerClientTypes.CodeReviewSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeReviewSummary(codeReviewArn: \(Swift.String(describing: codeReviewArn)), createdTimeStamp: \(Swift.String(describing: createdTimeStamp)), lastUpdatedTimeStamp: \(Swift.String(describing: lastUpdatedTimeStamp)), metricsSummary: \(Swift.String(describing: metricsSummary)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), providerType: \(Swift.String(describing: providerType)), pullRequestId: \(Swift.String(describing: pullRequestId)), repositoryName: \(Swift.String(describing: repositoryName)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Information about the summary of the code review.
    ///       </p>
    public struct CodeReviewSummary: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
        ///                <code>CodeReview</code>
        ///             </a> object.
        ///       </p>
        public let codeReviewArn: Swift.String?
        /// <p>
        ///          The time, in milliseconds since the epoch, when the code review was created.
        ///       </p>
        public let createdTimeStamp: ClientRuntime.Date?
        /// <p>
        ///          The time, in milliseconds since the epoch, when the code review was last updated.
        ///       </p>
        public let lastUpdatedTimeStamp: ClientRuntime.Date?
        /// <p>
        ///          The statistics from the code review.
        ///       </p>
        public let metricsSummary: CodeGuruReviewerClientTypes.MetricsSummary?
        /// <p>
        ///          The name of the code review.
        ///       </p>
        public let name: Swift.String?
        /// <p>The owner of the repository. For an AWS CodeCommit repository, this is the AWS account ID of the
        ///       account that owns the repository. For a GitHub, GitHub Enterprise Server, or Bitbucket repository, this is the username for the account that owns the repository.</p>
        public let owner: Swift.String?
        /// <p>
        ///          The provider type of the repository association.
        ///       </p>
        public let providerType: CodeGuruReviewerClientTypes.ProviderType?
        /// <p>
        ///          The pull request ID for the code review.
        ///       </p>
        public let pullRequestId: Swift.String?
        /// <p>
        ///          The name of the repository.
        ///       </p>
        public let repositoryName: Swift.String?
        /// <p>
        ///          The state of the code review.
        ///       </p>
        ///          <p>The valid code review states are:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Completed</code>: The code review is complete.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Pending</code>: The code review started and has not completed or failed.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Failed</code>: The code review failed.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Deleting</code>: The code review is being deleted.
        ///             </p>
        ///             </li>
        ///          </ul>
        public let state: CodeGuruReviewerClientTypes.JobState?
        /// <p>
        ///          The type of the code review.
        ///       </p>
        public let type: CodeGuruReviewerClientTypes.ModelType?

        public init (
            codeReviewArn: Swift.String? = nil,
            createdTimeStamp: ClientRuntime.Date? = nil,
            lastUpdatedTimeStamp: ClientRuntime.Date? = nil,
            metricsSummary: CodeGuruReviewerClientTypes.MetricsSummary? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            providerType: CodeGuruReviewerClientTypes.ProviderType? = nil,
            pullRequestId: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            state: CodeGuruReviewerClientTypes.JobState? = nil,
            type: CodeGuruReviewerClientTypes.ModelType? = nil
        )
        {
            self.codeReviewArn = codeReviewArn
            self.createdTimeStamp = createdTimeStamp
            self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
            self.metricsSummary = metricsSummary
            self.name = name
            self.owner = owner
            self.providerType = providerType
            self.pullRequestId = pullRequestId
            self.repositoryName = repositoryName
            self.state = state
            self.type = type
        }
    }

}

extension CodeGuruReviewerClientTypes.CodeReviewType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryAnalysis = "RepositoryAnalysis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryAnalysis = repositoryAnalysis {
            try encodeContainer.encode(repositoryAnalysis, forKey: .repositoryAnalysis)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAnalysisDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.RepositoryAnalysis.self, forKey: .repositoryAnalysis)
        repositoryAnalysis = repositoryAnalysisDecoded
    }
}

extension CodeGuruReviewerClientTypes.CodeReviewType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeReviewType(repositoryAnalysis: \(Swift.String(describing: repositoryAnalysis)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          The type of a code review. There are two code review types:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PullRequest</code> - A code review that is automatically triggered by a pull request on an associated repository. Because this
    ///                type of code review is automatically generated, you cannot specify this code review type using <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CreateCodeReview">
    ///                      <code>CreateCodeReview</code>
    ///                   </a>.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    /// 					             <code>RepositoryAnalysis</code> - A code review that analyzes all code under a specified
    /// 					branch in an associated repository. The associated repository is specified using its ARN
    /// 					in <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CreateCodeReview">
    ///                      <code>CreateCodeReview</code>
    ///                   </a>. </p>
    ///             </li>
    ///          </ul>
    public struct CodeReviewType: Swift.Equatable {
        /// <p> A code review that analyzes all code under a specified branch in an associated
        /// 			repository. The associated repository is specified using its ARN in <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CreateCodeReview">
        ///                <code>CreateCodeReview</code>
        ///             </a>. </p>
        public let repositoryAnalysis: CodeGuruReviewerClientTypes.RepositoryAnalysis?

        public init (
            repositoryAnalysis: CodeGuruReviewerClientTypes.RepositoryAnalysis? = nil
        )
        {
            self.repositoryAnalysis = repositoryAnalysis
        }
    }

}

extension CodeGuruReviewerClientTypes.CommitDiffSourceCodeType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCommit = "DestinationCommit"
        case sourceCommit = "SourceCommit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommit = destinationCommit {
            try encodeContainer.encode(destinationCommit, forKey: .destinationCommit)
        }
        if let sourceCommit = sourceCommit {
            try encodeContainer.encode(sourceCommit, forKey: .sourceCommit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCommitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCommit)
        sourceCommit = sourceCommitDecoded
        let destinationCommitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCommit)
        destinationCommit = destinationCommitDecoded
    }
}

extension CodeGuruReviewerClientTypes.CommitDiffSourceCodeType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CommitDiffSourceCodeType(destinationCommit: \(Swift.String(describing: destinationCommit)), sourceCommit: \(Swift.String(describing: sourceCommit)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          A type of <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
    ///                <code>SourceCodeType</code>
    ///             </a> that
    ///          specifies the commit diff for a pull request on an associated repository.
    ///       </p>
    public struct CommitDiffSourceCodeType: Swift.Equatable {
        /// <p>
        ///          The SHA of the destination commit used to generate a commit diff.
        ///       </p>
        public let destinationCommit: Swift.String?
        /// <p>
        ///          The SHA of the source commit used to generate a commit diff.
        ///       </p>
        public let sourceCommit: Swift.String?

        public init (
            destinationCommit: Swift.String? = nil,
            sourceCommit: Swift.String? = nil
        )
        {
            self.destinationCommit = destinationCommit
            self.sourceCommit = sourceCommit
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation would cause a conflict with the current state of a service
///          resource associated with the request. Resolve the conflict before retrying this request. </p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCodeReviewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCodeReviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCodeReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCodeReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCodeReviewOutputError>
}

extension CreateCodeReviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCodeReviewInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), name: \(Swift.String(describing: name)), repositoryAssociationArn: \(Swift.String(describing: repositoryAssociationArn)), type: \(Swift.String(describing: type)))"}
}

extension CreateCodeReviewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case repositoryAssociationArn = "RepositoryAssociationArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let repositoryAssociationArn = repositoryAssociationArn {
            try encodeContainer.encode(repositoryAssociationArn, forKey: .repositoryAssociationArn)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct CreateCodeReviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCodeReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCodeReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCodeReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCodeReviewOutputError>
}

public struct CreateCodeReviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCodeReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCodeReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCodeReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCodeReviewOutputError>
}

public struct CreateCodeReviewInput: Swift.Equatable {
    /// <p>
    ///          Amazon CodeGuru Reviewer uses this value to prevent the accidental creation of duplicate code
    ///          reviews if there are failures and retries.
    ///       </p>
    public var clientRequestToken: Swift.String?
    /// <p>
    ///          The name of the code review. The name of each code review in your AWS account must be unique.
    ///       </p>
    public let name: Swift.String?
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    ///          <p>
    ///          A code review can only be created on an associated repository. This is the ARN of the
    ///          associated repository.
    ///       </p>
    public let repositoryAssociationArn: Swift.String?
    /// <p>
    ///          The type of code review to create. This is specified using a
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReviewType.html">
    ///                <code>CodeReviewType</code>
    ///             </a>
    ///          object. You can create a code review only of type <code>RepositoryAnalysis</code>.
    ///       </p>
    public let type: CodeGuruReviewerClientTypes.CodeReviewType?

    public init (
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        repositoryAssociationArn: Swift.String? = nil,
        type: CodeGuruReviewerClientTypes.CodeReviewType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.repositoryAssociationArn = repositoryAssociationArn
        self.type = type
    }
}

struct CreateCodeReviewInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let repositoryAssociationArn: Swift.String?
    public let type: CodeGuruReviewerClientTypes.CodeReviewType?
    public let clientRequestToken: Swift.String?
}

extension CreateCodeReviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case repositoryAssociationArn = "RepositoryAssociationArn"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let repositoryAssociationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryAssociationArn)
        repositoryAssociationArn = repositoryAssociationArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.CodeReviewType.self, forKey: .type)
        type = typeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateCodeReviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCodeReviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCodeReviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCodeReviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCodeReviewOutputResponse(codeReview: \(Swift.String(describing: codeReview)))"}
}

extension CreateCodeReviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCodeReviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeReview = output.codeReview
        } else {
            self.codeReview = nil
        }
    }
}

public struct CreateCodeReviewOutputResponse: Swift.Equatable {
    /// <p>
    ///          Information about a code review. A code review belongs to the associated repository that contains the reviewed code.
    ///       </p>
    public let codeReview: CodeGuruReviewerClientTypes.CodeReview?

    public init (
        codeReview: CodeGuruReviewerClientTypes.CodeReview? = nil
    )
    {
        self.codeReview = codeReview
    }
}

struct CreateCodeReviewOutputResponseBody: Swift.Equatable {
    public let codeReview: CodeGuruReviewerClientTypes.CodeReview?
}

extension CreateCodeReviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeReview = "CodeReview"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.CodeReview.self, forKey: .codeReview)
        codeReview = codeReviewDecoded
    }
}

extension DescribeCodeReviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCodeReviewInput(codeReviewArn: \(Swift.String(describing: codeReviewArn)))"}
}

extension DescribeCodeReviewInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeCodeReviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCodeReviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCodeReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCodeReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCodeReviewOutputError>
}

public struct DescribeCodeReviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCodeReviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCodeReviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCodeReviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCodeReviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCodeReviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCodeReviewOutputError>
}

public struct DescribeCodeReviewInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: Swift.String?

    public init (
        codeReviewArn: Swift.String? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
    }
}

struct DescribeCodeReviewInputBody: Swift.Equatable {
}

extension DescribeCodeReviewInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCodeReviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCodeReviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCodeReviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCodeReviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCodeReviewOutputResponse(codeReview: \(Swift.String(describing: codeReview)))"}
}

extension DescribeCodeReviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCodeReviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeReview = output.codeReview
        } else {
            self.codeReview = nil
        }
    }
}

public struct DescribeCodeReviewOutputResponse: Swift.Equatable {
    /// <p>
    ///          Information about the code review.
    ///       </p>
    public let codeReview: CodeGuruReviewerClientTypes.CodeReview?

    public init (
        codeReview: CodeGuruReviewerClientTypes.CodeReview? = nil
    )
    {
        self.codeReview = codeReview
    }
}

struct DescribeCodeReviewOutputResponseBody: Swift.Equatable {
    public let codeReview: CodeGuruReviewerClientTypes.CodeReview?
}

extension DescribeCodeReviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeReview = "CodeReview"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.CodeReview.self, forKey: .codeReview)
        codeReview = codeReviewDecoded
    }
}

extension DescribeRecommendationFeedbackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRecommendationFeedbackInput(codeReviewArn: \(Swift.String(describing: codeReviewArn)), recommendationId: \(Swift.String(describing: recommendationId)), userId: \(Swift.String(describing: userId)))"}
}

extension DescribeRecommendationFeedbackInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeRecommendationFeedbackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecommendationFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecommendationFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecommendationFeedbackOutputError>
}

public struct DescribeRecommendationFeedbackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecommendationFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let userId = input.operationInput.userId {
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "UserId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            input.builder.withQueryItem(userIdQueryItem)
        }
        if let recommendationId = input.operationInput.recommendationId {
            let recommendationIdQueryItem = ClientRuntime.URLQueryItem(name: "RecommendationId".urlPercentEncoding(), value: Swift.String(recommendationId).urlPercentEncoding())
            input.builder.withQueryItem(recommendationIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecommendationFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecommendationFeedbackOutputError>
}

public struct DescribeRecommendationFeedbackInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: Swift.String?
    /// <p>
    ///          The recommendation ID that can be used to track the provided recommendations and then to collect the feedback.
    ///       </p>
    public let recommendationId: Swift.String?
    /// <p>
    ///          Optional parameter to describe the feedback for a given user. If this is not supplied, it defaults to the user making the request.
    ///       </p>
    ///          <p>
    ///          The <code>UserId</code> is an IAM principal that can be specified as an AWS account ID or an Amazon Resource Name (ARN). For
    ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#Principal_specifying">
    ///             Specifying a Principal</a> in the <i>AWS Identity and Access Management User Guide</i>.
    ///       </p>
    public let userId: Swift.String?

    public init (
        codeReviewArn: Swift.String? = nil,
        recommendationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.recommendationId = recommendationId
        self.userId = userId
    }
}

struct DescribeRecommendationFeedbackInputBody: Swift.Equatable {
}

extension DescribeRecommendationFeedbackInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRecommendationFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecommendationFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecommendationFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecommendationFeedbackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRecommendationFeedbackOutputResponse(recommendationFeedback: \(Swift.String(describing: recommendationFeedback)))"}
}

extension DescribeRecommendationFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRecommendationFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recommendationFeedback = output.recommendationFeedback
        } else {
            self.recommendationFeedback = nil
        }
    }
}

public struct DescribeRecommendationFeedbackOutputResponse: Swift.Equatable {
    /// <p>
    ///          The recommendation feedback given by the user.
    ///       </p>
    public let recommendationFeedback: CodeGuruReviewerClientTypes.RecommendationFeedback?

    public init (
        recommendationFeedback: CodeGuruReviewerClientTypes.RecommendationFeedback? = nil
    )
    {
        self.recommendationFeedback = recommendationFeedback
    }
}

struct DescribeRecommendationFeedbackOutputResponseBody: Swift.Equatable {
    public let recommendationFeedback: CodeGuruReviewerClientTypes.RecommendationFeedback?
}

extension DescribeRecommendationFeedbackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationFeedback = "RecommendationFeedback"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationFeedbackDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.RecommendationFeedback.self, forKey: .recommendationFeedback)
        recommendationFeedback = recommendationFeedbackDecoded
    }
}

extension DescribeRepositoryAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRepositoryAssociationInput(associationArn: \(Swift.String(describing: associationArn)))"}
}

extension DescribeRepositoryAssociationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeRepositoryAssociationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoryAssociationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoryAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoryAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoryAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoryAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoryAssociationOutputError>
}

public struct DescribeRepositoryAssociationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoryAssociationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoryAssociationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoryAssociationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoryAssociationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoryAssociationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoryAssociationOutputError>
}

public struct DescribeRepositoryAssociationInput: Swift.Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let associationArn: Swift.String?

    public init (
        associationArn: Swift.String? = nil
    )
    {
        self.associationArn = associationArn
    }
}

struct DescribeRepositoryAssociationInputBody: Swift.Equatable {
}

extension DescribeRepositoryAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRepositoryAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoryAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRepositoryAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoryAssociationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRepositoryAssociationOutputResponse(repositoryAssociation: \(Swift.String(describing: repositoryAssociation)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeRepositoryAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRepositoryAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryAssociation = output.repositoryAssociation
            self.tags = output.tags
        } else {
            self.repositoryAssociation = nil
            self.tags = nil
        }
    }
}

public struct DescribeRepositoryAssociationOutputResponse: Swift.Equatable {
    /// <p>Information about the repository association.</p>
    public let repositoryAssociation: CodeGuruReviewerClientTypes.RepositoryAssociation?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [Swift.String:Swift.String]?

    public init (
        repositoryAssociation: CodeGuruReviewerClientTypes.RepositoryAssociation? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.repositoryAssociation = repositoryAssociation
        self.tags = tags
    }
}

struct DescribeRepositoryAssociationOutputResponseBody: Swift.Equatable {
    public let repositoryAssociation: CodeGuruReviewerClientTypes.RepositoryAssociation?
    public let tags: [Swift.String:Swift.String]?
}

extension DescribeRepositoryAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryAssociation = "RepositoryAssociation"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAssociationDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.RepositoryAssociation.self, forKey: .repositoryAssociation)
        repositoryAssociation = repositoryAssociationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DisassociateRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateRepositoryInput(associationArn: \(Swift.String(describing: associationArn)))"}
}

extension DisassociateRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateRepositoryOutputError>
}

public struct DisassociateRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateRepositoryOutputError>
}

public struct DisassociateRepositoryInput: Swift.Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let associationArn: Swift.String?

    public init (
        associationArn: Swift.String? = nil
    )
    {
        self.associationArn = associationArn
    }
}

struct DisassociateRepositoryInputBody: Swift.Equatable {
}

extension DisassociateRepositoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateRepositoryOutputResponse(repositoryAssociation: \(Swift.String(describing: repositoryAssociation)), tags: \(Swift.String(describing: tags)))"}
}

extension DisassociateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryAssociation = output.repositoryAssociation
            self.tags = output.tags
        } else {
            self.repositoryAssociation = nil
            self.tags = nil
        }
    }
}

public struct DisassociateRepositoryOutputResponse: Swift.Equatable {
    /// <p>Information about the disassociated repository.</p>
    public let repositoryAssociation: CodeGuruReviewerClientTypes.RepositoryAssociation?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [Swift.String:Swift.String]?

    public init (
        repositoryAssociation: CodeGuruReviewerClientTypes.RepositoryAssociation? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.repositoryAssociation = repositoryAssociation
        self.tags = tags
    }
}

struct DisassociateRepositoryOutputResponseBody: Swift.Equatable {
    public let repositoryAssociation: CodeGuruReviewerClientTypes.RepositoryAssociation?
    public let tags: [Swift.String:Swift.String]?
}

extension DisassociateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryAssociation = "RepositoryAssociation"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAssociationDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.RepositoryAssociation.self, forKey: .repositoryAssociation)
        repositoryAssociation = repositoryAssociationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeGuruReviewerClientTypes {
    public enum EncryptionOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aocmk
        case cmcmk
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionOption] {
            return [
                .aocmk,
                .cmcmk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aocmk: return "AWS_OWNED_CMK"
            case .cmcmk: return "CUSTOMER_MANAGED_CMK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionOption(rawValue: rawValue) ?? EncryptionOption.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The server encountered an internal error and is unable to complete the request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeGuruReviewerClientTypes {
    public enum JobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [JobState] {
            return [
                .completed,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobState(rawValue: rawValue) ?? JobState.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruReviewerClientTypes.KMSKeyDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionOption = "EncryptionOption"
        case kMSKeyId = "KMSKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionOption = encryptionOption {
            try encodeContainer.encode(encryptionOption.rawValue, forKey: .encryptionOption)
        }
        if let kMSKeyId = kMSKeyId {
            try encodeContainer.encode(kMSKeyId, forKey: .kMSKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let encryptionOptionDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.EncryptionOption.self, forKey: .encryptionOption)
        encryptionOption = encryptionOptionDecoded
    }
}

extension CodeGuruReviewerClientTypes.KMSKeyDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KMSKeyDetails(encryptionOption: \(Swift.String(describing: encryptionOption)), kMSKeyId: \(Swift.String(describing: kMSKeyId)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>An object that contains:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The encryption option for a repository association. It is either owned by AWS
    ///             Key Management Service (KMS) (<code>AWS_OWNED_CMK</code>) or customer managed (<code>CUSTOMER_MANAGED_CMK</code>).</p>
    ///             </li>
    ///             <li>
    ///                <p>The ID of the AWS KMS key that
    ///             is associated with a respository association.</p>
    ///             </li>
    ///          </ul>
    public struct KMSKeyDetails: Swift.Equatable {
        /// <p>The encryption option for a repository association. It is either owned by AWS
        ///             Key Management Service (KMS) (<code>AWS_OWNED_CMK</code>) or customer managed (<code>CUSTOMER_MANAGED_CMK</code>).</p>
        public let encryptionOption: CodeGuruReviewerClientTypes.EncryptionOption?
        /// <p>The ID of the AWS KMS key that is associated with a respository association.</p>
        public let kMSKeyId: Swift.String?

        public init (
            encryptionOption: CodeGuruReviewerClientTypes.EncryptionOption? = nil,
            kMSKeyId: Swift.String? = nil
        )
        {
            self.encryptionOption = encryptionOption
            self.kMSKeyId = kMSKeyId
        }
    }

}

extension ListCodeReviewsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCodeReviewsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), providerTypes: \(Swift.String(describing: providerTypes)), repositoryNames: \(Swift.String(describing: repositoryNames)), states: \(Swift.String(describing: states)), type: \(Swift.String(describing: type)))"}
}

extension ListCodeReviewsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCodeReviewsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCodeReviewsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCodeReviewsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCodeReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCodeReviewsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCodeReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCodeReviewsOutputError>
}

public struct ListCodeReviewsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCodeReviewsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCodeReviewsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCodeReviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "States".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let repositoryNames = input.operationInput.repositoryNames {
            repositoryNames.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "RepositoryNames".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "Type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let providerTypes = input.operationInput.providerTypes {
            providerTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "ProviderTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCodeReviewsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCodeReviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCodeReviewsOutputError>
}

public struct ListCodeReviewsInput: Swift.Equatable {
    /// <p>
    ///          The maximum number of results that are returned per call. The default is 100.
    ///       </p>
    public let maxResults: Swift.Int?
    /// <p>
    ///          If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    ///          Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///       </p>
    public let nextToken: Swift.String?
    /// <p>
    ///          List of provider types for filtering that needs to be applied before displaying the result. For example, <code>providerTypes=[GitHub]</code>  lists code reviews from GitHub.
    ///       </p>
    public let providerTypes: [CodeGuruReviewerClientTypes.ProviderType]?
    /// <p>
    ///          List of repository names for filtering that needs to be applied before displaying the result.
    ///       </p>
    public let repositoryNames: [Swift.String]?
    /// <p>
    ///          List of states for filtering that needs to be applied before displaying the result. For example, <code>states=[Pending]</code> lists code reviews in the Pending state.
    ///       </p>
    ///          <p>The valid code review states are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Completed</code>: The code review is complete.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Pending</code>: The code review started and has not completed or failed.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code>: The code review failed.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Deleting</code>: The code review is being deleted.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let states: [CodeGuruReviewerClientTypes.JobState]?
    /// <p>
    ///          The type of code reviews to list in the response.
    ///       </p>
    public let type: CodeGuruReviewerClientTypes.ModelType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        providerTypes: [CodeGuruReviewerClientTypes.ProviderType]? = nil,
        repositoryNames: [Swift.String]? = nil,
        states: [CodeGuruReviewerClientTypes.JobState]? = nil,
        type: CodeGuruReviewerClientTypes.ModelType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.providerTypes = providerTypes
        self.repositoryNames = repositoryNames
        self.states = states
        self.type = type
    }
}

struct ListCodeReviewsInputBody: Swift.Equatable {
}

extension ListCodeReviewsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCodeReviewsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCodeReviewsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCodeReviewsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCodeReviewsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCodeReviewsOutputResponse(codeReviewSummaries: \(Swift.String(describing: codeReviewSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCodeReviewsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCodeReviewsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.codeReviewSummaries = output.codeReviewSummaries
            self.nextToken = output.nextToken
        } else {
            self.codeReviewSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCodeReviewsOutputResponse: Swift.Equatable {
    /// <p>
    ///          A list of code reviews that meet the criteria of the request.
    ///       </p>
    public let codeReviewSummaries: [CodeGuruReviewerClientTypes.CodeReviewSummary]?
    /// <p>
    ///          Pagination token.
    ///       </p>
    public let nextToken: Swift.String?

    public init (
        codeReviewSummaries: [CodeGuruReviewerClientTypes.CodeReviewSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.codeReviewSummaries = codeReviewSummaries
        self.nextToken = nextToken
    }
}

struct ListCodeReviewsOutputResponseBody: Swift.Equatable {
    public let codeReviewSummaries: [CodeGuruReviewerClientTypes.CodeReviewSummary]?
    public let nextToken: Swift.String?
}

extension ListCodeReviewsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeReviewSummaries = "CodeReviewSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewSummariesContainer = try containerValues.decodeIfPresent([CodeGuruReviewerClientTypes.CodeReviewSummary?].self, forKey: .codeReviewSummaries)
        var codeReviewSummariesDecoded0:[CodeGuruReviewerClientTypes.CodeReviewSummary]? = nil
        if let codeReviewSummariesContainer = codeReviewSummariesContainer {
            codeReviewSummariesDecoded0 = [CodeGuruReviewerClientTypes.CodeReviewSummary]()
            for structure0 in codeReviewSummariesContainer {
                if let structure0 = structure0 {
                    codeReviewSummariesDecoded0?.append(structure0)
                }
            }
        }
        codeReviewSummaries = codeReviewSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendationFeedbackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecommendationFeedbackInput(codeReviewArn: \(Swift.String(describing: codeReviewArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), recommendationIds: \(Swift.String(describing: recommendationIds)), userIds: \(Swift.String(describing: userIds)))"}
}

extension ListRecommendationFeedbackInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRecommendationFeedbackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecommendationFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecommendationFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecommendationFeedbackOutputError>
}

public struct ListRecommendationFeedbackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecommendationFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let recommendationIds = input.operationInput.recommendationIds {
            recommendationIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "RecommendationIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let userIds = input.operationInput.userIds {
            userIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "UserIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecommendationFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecommendationFeedbackOutputError>
}

public struct ListRecommendationFeedbackInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: Swift.String?
    /// <p>
    ///          The maximum number of results that are returned per call. The default is 100.
    ///       </p>
    public let maxResults: Swift.Int?
    /// <p>
    ///          If <code>nextToken</code> is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    ///          Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///       </p>
    public let nextToken: Swift.String?
    /// <p>
    ///          Used to query the recommendation feedback for a given recommendation.
    ///       </p>
    public let recommendationIds: [Swift.String]?
    /// <p>
    ///          An AWS user's account ID or Amazon Resource Name (ARN). Use this ID to query the recommendation feedback for a code review from that user.
    ///       </p>
    ///          <p>
    ///          The <code>UserId</code> is an IAM principal that can be specified as an AWS account ID or an Amazon Resource Name (ARN). For
    ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#Principal_specifying">
    ///             Specifying a Principal</a> in the <i>AWS Identity and Access Management User Guide</i>.
    ///       </p>
    public let userIds: [Swift.String]?

    public init (
        codeReviewArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recommendationIds: [Swift.String]? = nil,
        userIds: [Swift.String]? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recommendationIds = recommendationIds
        self.userIds = userIds
    }
}

struct ListRecommendationFeedbackInputBody: Swift.Equatable {
}

extension ListRecommendationFeedbackInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecommendationFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecommendationFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecommendationFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecommendationFeedbackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecommendationFeedbackOutputResponse(nextToken: \(Swift.String(describing: nextToken)), recommendationFeedbackSummaries: \(Swift.String(describing: recommendationFeedbackSummaries)))"}
}

extension ListRecommendationFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecommendationFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendationFeedbackSummaries = output.recommendationFeedbackSummaries
        } else {
            self.nextToken = nil
            self.recommendationFeedbackSummaries = nil
        }
    }
}

public struct ListRecommendationFeedbackOutputResponse: Swift.Equatable {
    /// <p>
    ///          If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page.
    ///          Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged.
    ///       </p>
    public let nextToken: Swift.String?
    /// <p> Recommendation feedback summaries corresponding to the code review ARN. </p>
    public let recommendationFeedbackSummaries: [CodeGuruReviewerClientTypes.RecommendationFeedbackSummary]?

    public init (
        nextToken: Swift.String? = nil,
        recommendationFeedbackSummaries: [CodeGuruReviewerClientTypes.RecommendationFeedbackSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationFeedbackSummaries = recommendationFeedbackSummaries
    }
}

struct ListRecommendationFeedbackOutputResponseBody: Swift.Equatable {
    public let recommendationFeedbackSummaries: [CodeGuruReviewerClientTypes.RecommendationFeedbackSummary]?
    public let nextToken: Swift.String?
}

extension ListRecommendationFeedbackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recommendationFeedbackSummaries = "RecommendationFeedbackSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationFeedbackSummariesContainer = try containerValues.decodeIfPresent([CodeGuruReviewerClientTypes.RecommendationFeedbackSummary?].self, forKey: .recommendationFeedbackSummaries)
        var recommendationFeedbackSummariesDecoded0:[CodeGuruReviewerClientTypes.RecommendationFeedbackSummary]? = nil
        if let recommendationFeedbackSummariesContainer = recommendationFeedbackSummariesContainer {
            recommendationFeedbackSummariesDecoded0 = [CodeGuruReviewerClientTypes.RecommendationFeedbackSummary]()
            for structure0 in recommendationFeedbackSummariesContainer {
                if let structure0 = structure0 {
                    recommendationFeedbackSummariesDecoded0?.append(structure0)
                }
            }
        }
        recommendationFeedbackSummaries = recommendationFeedbackSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecommendationsInput(codeReviewArn: \(Swift.String(describing: codeReviewArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRecommendationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRecommendationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecommendationsOutputError>
}

public struct ListRecommendationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecommendationsOutputError>
}

public struct ListRecommendationsInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: Swift.String?
    /// <p>
    ///          The maximum number of results that are returned per call. The default is 100.
    ///       </p>
    public let maxResults: Swift.Int?
    /// <p>
    ///          Pagination token.
    ///       </p>
    public let nextToken: Swift.String?

    public init (
        codeReviewArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecommendationsInputBody: Swift.Equatable {
}

extension ListRecommendationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecommendationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecommendationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), recommendationSummaries: \(Swift.String(describing: recommendationSummaries)))"}
}

extension ListRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendationSummaries = output.recommendationSummaries
        } else {
            self.nextToken = nil
            self.recommendationSummaries = nil
        }
    }
}

public struct ListRecommendationsOutputResponse: Swift.Equatable {
    /// <p>
    ///          Pagination token.
    ///       </p>
    public let nextToken: Swift.String?
    /// <p>
    ///          List of recommendations for the requested code review.
    ///       </p>
    public let recommendationSummaries: [CodeGuruReviewerClientTypes.RecommendationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        recommendationSummaries: [CodeGuruReviewerClientTypes.RecommendationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationSummaries = recommendationSummaries
    }
}

struct ListRecommendationsOutputResponseBody: Swift.Equatable {
    public let recommendationSummaries: [CodeGuruReviewerClientTypes.RecommendationSummary]?
    public let nextToken: Swift.String?
}

extension ListRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case recommendationSummaries = "RecommendationSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationSummariesContainer = try containerValues.decodeIfPresent([CodeGuruReviewerClientTypes.RecommendationSummary?].self, forKey: .recommendationSummaries)
        var recommendationSummariesDecoded0:[CodeGuruReviewerClientTypes.RecommendationSummary]? = nil
        if let recommendationSummariesContainer = recommendationSummariesContainer {
            recommendationSummariesDecoded0 = [CodeGuruReviewerClientTypes.RecommendationSummary]()
            for structure0 in recommendationSummariesContainer {
                if let structure0 = structure0 {
                    recommendationSummariesDecoded0?.append(structure0)
                }
            }
        }
        recommendationSummaries = recommendationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoryAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositoryAssociationsInput(maxResults: \(Swift.String(describing: maxResults)), names: \(Swift.String(describing: names)), nextToken: \(Swift.String(describing: nextToken)), owners: \(Swift.String(describing: owners)), providerTypes: \(Swift.String(describing: providerTypes)), states: \(Swift.String(describing: states)))"}
}

extension ListRepositoryAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRepositoryAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoryAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositoryAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoryAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositoryAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoryAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoryAssociationsOutputError>
}

public struct ListRepositoryAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoryAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositoryAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoryAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "State".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let names = input.operationInput.names {
            names.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "Name".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let providerTypes = input.operationInput.providerTypes {
            providerTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "ProviderType".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let owners = input.operationInput.owners {
            owners.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "Owner".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositoryAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoryAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoryAssociationsOutputError>
}

public struct ListRepositoryAssociationsInput: Swift.Equatable {
    /// <p>The maximum number of repository association results returned by <code>ListRepositoryAssociations</code>
    ///          in paginated output. When this parameter is used, <code>ListRepositoryAssociations</code> only returns
    ///          <code>maxResults</code> results in a single page with a <code>nextToken</code> response
    ///          element. The remaining results of the initial request
    ///          can be seen by sending another <code>ListRepositoryAssociations</code> request with the returned
    ///          <code>nextToken</code> value.
    ///          This value can be between 1 and 100. If this parameter is not used, <code>ListRepositoryAssociations</code>
    ///          returns up to 100 results and a <code>nextToken</code> value if applicable. </p>
    public let maxResults: Swift.Int?
    /// <p>List of repository names to use as a filter.</p>
    public let names: [Swift.String]?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///          <code>ListRepositoryAssociations</code> request where <code>maxResults</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous results
    ///          that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>Treat this token as an opaque identifier that is only used to retrieve
    ///          the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: Swift.String?
    /// <p>List of owners to use as a filter.
    ///         For AWS CodeCommit, it is the name of the CodeCommit account that was
    ///         used to associate the repository. For other repository source providers, such as Bitbucket and GitHub Enterprise Server, this is name of the account
    ///         that was used to associate the repository. </p>
    public let owners: [Swift.String]?
    /// <p>List of provider types to use as a filter.</p>
    public let providerTypes: [CodeGuruReviewerClientTypes.ProviderType]?
    /// <p>List of repository association states to use as a filter.</p>
    ///          <p>The valid repository association states are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Associated</b>: The repository
    ///                association is complete.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Associating</b>: CodeGuru Reviewer is:
    ///             </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                      Setting up pull request notifications. This is required
    ///                      for pull requests to trigger a CodeGuru Reviewer review.
    ///                   </p>
    ///                      <note>
    ///                         <p>
    ///                         If your repository <code>ProviderType</code> is <code>GitHub</code>, <code>GitHub Enterprise Server</code>, or <code>Bitbucket</code>,
    ///                         CodeGuru Reviewer creates webhooks in your repository to trigger CodeGuru Reviewer reviews. If you delete these webhooks,
    ///                         reviews of code in your repository cannot be triggered.
    ///                      </p>
    ///                      </note>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                      Setting up source code access. This is required for CodeGuru Reviewer to securely
    ///                      clone code in your repository.
    ///                   </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Failed</b>: The repository failed to associate or disassociate.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Disassociating</b>: CodeGuru Reviewer is removing the repository's pull request notifications and
    ///                source code access.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Disassociated</b>: CodeGuru Reviewer successfully disassociated the repository. You can create a new association
    ///                with this repository if you want to review source code in it later. You can control access to code reviews created in an
    ///                associated repository with tags after it has been disassociated. For more information, see <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-ug/auth-and-access-control-using-tags.html">Using tags to control access to
    ///                associated repositories</a> in the <i>Amazon CodeGuru Reviewer User Guide</i>.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let states: [CodeGuruReviewerClientTypes.RepositoryAssociationState]?

    public init (
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        owners: [Swift.String]? = nil,
        providerTypes: [CodeGuruReviewerClientTypes.ProviderType]? = nil,
        states: [CodeGuruReviewerClientTypes.RepositoryAssociationState]? = nil
    )
    {
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
        self.owners = owners
        self.providerTypes = providerTypes
        self.states = states
    }
}

struct ListRepositoryAssociationsInputBody: Swift.Equatable {
}

extension ListRepositoryAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRepositoryAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoryAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoryAssociationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoryAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositoryAssociationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), repositoryAssociationSummaries: \(Swift.String(describing: repositoryAssociationSummaries)))"}
}

extension ListRepositoryAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRepositoryAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositoryAssociationSummaries = output.repositoryAssociationSummaries
        } else {
            self.nextToken = nil
            self.repositoryAssociationSummaries = nil
        }
    }
}

public struct ListRepositoryAssociationsOutputResponse: Swift.Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListRecommendations</code> request.
    ///          When the results of a <code>ListRecommendations</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return. </p>
    public let nextToken: Swift.String?
    /// <p>A list of repository associations that meet the criteria of the request.</p>
    public let repositoryAssociationSummaries: [CodeGuruReviewerClientTypes.RepositoryAssociationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        repositoryAssociationSummaries: [CodeGuruReviewerClientTypes.RepositoryAssociationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryAssociationSummaries = repositoryAssociationSummaries
    }
}

struct ListRepositoryAssociationsOutputResponseBody: Swift.Equatable {
    public let repositoryAssociationSummaries: [CodeGuruReviewerClientTypes.RepositoryAssociationSummary]?
    public let nextToken: Swift.String?
}

extension ListRepositoryAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case repositoryAssociationSummaries = "RepositoryAssociationSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryAssociationSummariesContainer = try containerValues.decodeIfPresent([CodeGuruReviewerClientTypes.RepositoryAssociationSummary?].self, forKey: .repositoryAssociationSummaries)
        var repositoryAssociationSummariesDecoded0:[CodeGuruReviewerClientTypes.RepositoryAssociationSummary]? = nil
        if let repositoryAssociationSummariesContainer = repositoryAssociationSummariesContainer {
            repositoryAssociationSummariesDecoded0 = [CodeGuruReviewerClientTypes.RepositoryAssociationSummary]()
            for structure0 in repositoryAssociationSummariesContainer {
                if let structure0 = structure0 {
                    repositoryAssociationSummariesDecoded0?.append(structure0)
                }
            }
        }
        repositoryAssociationSummaries = repositoryAssociationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeGuruReviewerClientTypes.Metrics: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingsCount = "FindingsCount"
        case meteredLinesOfCodeCount = "MeteredLinesOfCodeCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingsCount = findingsCount {
            try encodeContainer.encode(findingsCount, forKey: .findingsCount)
        }
        if let meteredLinesOfCodeCount = meteredLinesOfCodeCount {
            try encodeContainer.encode(meteredLinesOfCodeCount, forKey: .meteredLinesOfCodeCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meteredLinesOfCodeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .meteredLinesOfCodeCount)
        meteredLinesOfCodeCount = meteredLinesOfCodeCountDecoded
        let findingsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .findingsCount)
        findingsCount = findingsCountDecoded
    }
}

extension CodeGuruReviewerClientTypes.Metrics: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Metrics(findingsCount: \(Swift.String(describing: findingsCount)), meteredLinesOfCodeCount: \(Swift.String(describing: meteredLinesOfCodeCount)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Information about the statistics from the code review.
    ///       </p>
    public struct Metrics: Swift.Equatable {
        /// <p>
        ///          Total number of recommendations found in the code review.
        ///       </p>
        public let findingsCount: Swift.Int?
        /// <p>
        ///         Lines of code metered in the code review. For the initial code review pull request and all subsequent revisions,
        ///         this includes all lines of code in the files added to the pull request. In subsequent revisions, for files that already
        ///         existed in the pull request, this includes only the changed lines of code. In both cases, this does not include non-code lines such as comments
        ///         and import statements. For example, if you submit a pull request containing 5 files, each with 500 lines of code, and in
        ///         a subsequent revision you added a new file with 200 lines of code, and also modified a total of 25 lines across the initial 5 files,
        ///         <code>MeteredLinesOfCodeCount</code> includes the first 5 files (5 * 500 = 2,500 lines), the new file (200 lines) and the 25 changed lines of
        ///          code for a total of 2,725 lines of code.
        ///       </p>
        public let meteredLinesOfCodeCount: Swift.Int?

        public init (
            findingsCount: Swift.Int? = nil,
            meteredLinesOfCodeCount: Swift.Int? = nil
        )
        {
            self.findingsCount = findingsCount
            self.meteredLinesOfCodeCount = meteredLinesOfCodeCount
        }
    }

}

extension CodeGuruReviewerClientTypes.MetricsSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingsCount = "FindingsCount"
        case meteredLinesOfCodeCount = "MeteredLinesOfCodeCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingsCount = findingsCount {
            try encodeContainer.encode(findingsCount, forKey: .findingsCount)
        }
        if let meteredLinesOfCodeCount = meteredLinesOfCodeCount {
            try encodeContainer.encode(meteredLinesOfCodeCount, forKey: .meteredLinesOfCodeCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meteredLinesOfCodeCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .meteredLinesOfCodeCount)
        meteredLinesOfCodeCount = meteredLinesOfCodeCountDecoded
        let findingsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .findingsCount)
        findingsCount = findingsCountDecoded
    }
}

extension CodeGuruReviewerClientTypes.MetricsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MetricsSummary(findingsCount: \(Swift.String(describing: findingsCount)), meteredLinesOfCodeCount: \(Swift.String(describing: meteredLinesOfCodeCount)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Information about metrics summaries.
    ///       </p>
    public struct MetricsSummary: Swift.Equatable {
        /// <p>
        ///          Total number of recommendations found in the code review.
        ///       </p>
        public let findingsCount: Swift.Int?
        /// <p>
        ///          Lines of code metered in the code review. For the initial code review pull request and all subsequent revisions,
        ///          this includes all lines of code in the files added to the pull request. In subsequent revisions, for files that already
        ///          existed in the pull request, this includes only the changed lines of code. In both cases, this does not include non-code lines such as comments
        ///          and import statements. For example, if you submit a pull request containing 5 files, each with 500 lines of code, and in
        ///          a subsequent revision you added a new file with 200 lines of code, and also modified a total of 25 lines across the initial 5 files,
        ///          <code>MeteredLinesOfCodeCount</code> includes the first 5 files (5 * 500 = 2,500 lines), the new file (200 lines) and the 25 changed lines of
        ///          code for a total of 2,725 lines of code.
        ///       </p>
        public let meteredLinesOfCodeCount: Swift.Int?

        public init (
            findingsCount: Swift.Int? = nil,
            meteredLinesOfCodeCount: Swift.Int? = nil
        )
        {
            self.findingsCount = findingsCount
            self.meteredLinesOfCodeCount = meteredLinesOfCodeCount
        }
    }

}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in the request was not found.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeGuruReviewerClientTypes {
    public enum ProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bitbucket
        case codeCommit
        case gitHub
        case gitHubEnterpriseServer
        case sdkUnknown(Swift.String)

        public static var allCases: [ProviderType] {
            return [
                .bitbucket,
                .codeCommit,
                .gitHub,
                .gitHubEnterpriseServer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bitbucket: return "Bitbucket"
            case .codeCommit: return "CodeCommit"
            case .gitHub: return "GitHub"
            case .gitHubEnterpriseServer: return "GitHubEnterpriseServer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProviderType(rawValue: rawValue) ?? ProviderType.sdkUnknown(rawValue)
        }
    }
}

public struct PutRecommendationFeedbackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecommendationFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecommendationFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecommendationFeedbackOutputError>
}

extension PutRecommendationFeedbackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecommendationFeedbackInput(codeReviewArn: \(Swift.String(describing: codeReviewArn)), reactions: \(Swift.String(describing: reactions)), recommendationId: \(Swift.String(describing: recommendationId)))"}
}

extension PutRecommendationFeedbackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeReviewArn = "CodeReviewArn"
        case reactions = "Reactions"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeReviewArn = codeReviewArn {
            try encodeContainer.encode(codeReviewArn, forKey: .codeReviewArn)
        }
        if let reactions = reactions {
            var reactionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reactions)
            for reactions0 in reactions {
                try reactionsContainer.encode(reactions0.rawValue)
            }
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }
}

public struct PutRecommendationFeedbackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecommendationFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecommendationFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecommendationFeedbackOutputError>
}

public struct PutRecommendationFeedbackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRecommendationFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRecommendationFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRecommendationFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRecommendationFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRecommendationFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRecommendationFeedbackOutputError>
}

public struct PutRecommendationFeedbackInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
    ///                <code>CodeReview</code>
    ///             </a> object.
    ///       </p>
    public let codeReviewArn: Swift.String?
    /// <p>
    ///          List for storing reactions. Reactions are utf-8 text code for emojis. If you send an empty list it clears all your feedback.
    ///       </p>
    public let reactions: [CodeGuruReviewerClientTypes.Reaction]?
    /// <p>
    ///          The recommendation ID that can be used to track the provided recommendations and then to collect the feedback.
    ///       </p>
    public let recommendationId: Swift.String?

    public init (
        codeReviewArn: Swift.String? = nil,
        reactions: [CodeGuruReviewerClientTypes.Reaction]? = nil,
        recommendationId: Swift.String? = nil
    )
    {
        self.codeReviewArn = codeReviewArn
        self.reactions = reactions
        self.recommendationId = recommendationId
    }
}

struct PutRecommendationFeedbackInputBody: Swift.Equatable {
    public let codeReviewArn: Swift.String?
    public let recommendationId: Swift.String?
    public let reactions: [CodeGuruReviewerClientTypes.Reaction]?
}

extension PutRecommendationFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeReviewArn = "CodeReviewArn"
        case reactions = "Reactions"
        case recommendationId = "RecommendationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeReviewArn)
        codeReviewArn = codeReviewArnDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let reactionsContainer = try containerValues.decodeIfPresent([CodeGuruReviewerClientTypes.Reaction?].self, forKey: .reactions)
        var reactionsDecoded0:[CodeGuruReviewerClientTypes.Reaction]? = nil
        if let reactionsContainer = reactionsContainer {
            reactionsDecoded0 = [CodeGuruReviewerClientTypes.Reaction]()
            for string0 in reactionsContainer {
                if let string0 = string0 {
                    reactionsDecoded0?.append(string0)
                }
            }
        }
        reactions = reactionsDecoded0
    }
}

extension PutRecommendationFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRecommendationFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRecommendationFeedbackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRecommendationFeedbackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRecommendationFeedbackOutputResponse()"}
}

extension PutRecommendationFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRecommendationFeedbackOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutRecommendationFeedbackOutputResponseBody: Swift.Equatable {
}

extension PutRecommendationFeedbackOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CodeGuruReviewerClientTypes {
    public enum Reaction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case thumbsDown
        case thumbsUp
        case sdkUnknown(Swift.String)

        public static var allCases: [Reaction] {
            return [
                .thumbsDown,
                .thumbsUp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .thumbsDown: return "ThumbsDown"
            case .thumbsUp: return "ThumbsUp"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Reaction(rawValue: rawValue) ?? Reaction.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruReviewerClientTypes.RecommendationFeedback: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeReviewArn = "CodeReviewArn"
        case createdTimeStamp = "CreatedTimeStamp"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case reactions = "Reactions"
        case recommendationId = "RecommendationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeReviewArn = codeReviewArn {
            try encodeContainer.encode(codeReviewArn, forKey: .codeReviewArn)
        }
        if let createdTimeStamp = createdTimeStamp {
            try encodeContainer.encode(createdTimeStamp.timeIntervalSince1970, forKey: .createdTimeStamp)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let reactions = reactions {
            var reactionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reactions)
            for reactions0 in reactions {
                try reactionsContainer.encode(reactions0.rawValue)
            }
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeReviewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeReviewArn)
        codeReviewArn = codeReviewArnDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let reactionsContainer = try containerValues.decodeIfPresent([CodeGuruReviewerClientTypes.Reaction?].self, forKey: .reactions)
        var reactionsDecoded0:[CodeGuruReviewerClientTypes.Reaction]? = nil
        if let reactionsContainer = reactionsContainer {
            reactionsDecoded0 = [CodeGuruReviewerClientTypes.Reaction]()
            for string0 in reactionsContainer {
                if let string0 = string0 {
                    reactionsDecoded0?.append(string0)
                }
            }
        }
        reactions = reactionsDecoded0
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
    }
}

extension CodeGuruReviewerClientTypes.RecommendationFeedback: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecommendationFeedback(codeReviewArn: \(Swift.String(describing: codeReviewArn)), createdTimeStamp: \(Swift.String(describing: createdTimeStamp)), lastUpdatedTimeStamp: \(Swift.String(describing: lastUpdatedTimeStamp)), reactions: \(Swift.String(describing: reactions)), recommendationId: \(Swift.String(describing: recommendationId)), userId: \(Swift.String(describing: userId)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Information about the recommendation feedback.
    ///       </p>
    public struct RecommendationFeedback: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CodeReview.html">
        ///                <code>CodeReview</code>
        ///             </a> object.
        ///       </p>
        public let codeReviewArn: Swift.String?
        /// <p>
        ///          The time at which the feedback was created.
        ///       </p>
        public let createdTimeStamp: ClientRuntime.Date?
        /// <p>
        ///          The time at which the feedback was last updated.
        ///       </p>
        public let lastUpdatedTimeStamp: ClientRuntime.Date?
        /// <p>
        ///          List for storing reactions. Reactions are utf-8 text code for emojis. You can send an empty list to clear off all your feedback.
        ///       </p>
        public let reactions: [CodeGuruReviewerClientTypes.Reaction]?
        /// <p>
        ///          The recommendation ID that can be used to track the provided recommendations. Later on it can be used to collect the feedback.
        ///       </p>
        public let recommendationId: Swift.String?
        /// <p>
        ///          The ID of the user that made the API call.
        ///       </p>
        ///          <p>
        ///          The <code>UserId</code> is an IAM principal that can be specified as an AWS account ID or an Amazon Resource Name (ARN). For
        ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#Principal_specifying">
        ///             Specifying a Principal</a> in the <i>AWS Identity and Access Management User Guide</i>.
        ///       </p>
        public let userId: Swift.String?

        public init (
            codeReviewArn: Swift.String? = nil,
            createdTimeStamp: ClientRuntime.Date? = nil,
            lastUpdatedTimeStamp: ClientRuntime.Date? = nil,
            reactions: [CodeGuruReviewerClientTypes.Reaction]? = nil,
            recommendationId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.codeReviewArn = codeReviewArn
            self.createdTimeStamp = createdTimeStamp
            self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
            self.reactions = reactions
            self.recommendationId = recommendationId
            self.userId = userId
        }
    }

}

extension CodeGuruReviewerClientTypes.RecommendationFeedbackSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reactions = "Reactions"
        case recommendationId = "RecommendationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reactions = reactions {
            var reactionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reactions)
            for reactions0 in reactions {
                try reactionsContainer.encode(reactions0.rawValue)
            }
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let reactionsContainer = try containerValues.decodeIfPresent([CodeGuruReviewerClientTypes.Reaction?].self, forKey: .reactions)
        var reactionsDecoded0:[CodeGuruReviewerClientTypes.Reaction]? = nil
        if let reactionsContainer = reactionsContainer {
            reactionsDecoded0 = [CodeGuruReviewerClientTypes.Reaction]()
            for string0 in reactionsContainer {
                if let string0 = string0 {
                    reactionsDecoded0?.append(string0)
                }
            }
        }
        reactions = reactionsDecoded0
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension CodeGuruReviewerClientTypes.RecommendationFeedbackSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecommendationFeedbackSummary(reactions: \(Swift.String(describing: reactions)), recommendationId: \(Swift.String(describing: recommendationId)), userId: \(Swift.String(describing: userId)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Information about recommendation feedback summaries.
    ///       </p>
    public struct RecommendationFeedbackSummary: Swift.Equatable {
        /// <p>
        ///          List for storing reactions. Reactions are utf-8 text code for emojis.
        ///       </p>
        public let reactions: [CodeGuruReviewerClientTypes.Reaction]?
        /// <p>
        ///          The recommendation ID that can be used to track the provided recommendations. Later on it can be used to collect the feedback.
        ///       </p>
        public let recommendationId: Swift.String?
        /// <p>
        ///          The ID of the user that gave the feedback.
        ///       </p>
        ///          <p>
        ///          The <code>UserId</code> is an IAM principal that can be specified as an AWS account ID or an Amazon Resource Name (ARN). For
        ///          more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#Principal_specifying">
        ///             Specifying a Principal</a> in the <i>AWS Identity and Access Management User Guide</i>.
        ///       </p>
        public let userId: Swift.String?

        public init (
            reactions: [CodeGuruReviewerClientTypes.Reaction]? = nil,
            recommendationId: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.reactions = reactions
            self.recommendationId = recommendationId
            self.userId = userId
        }
    }

}

extension CodeGuruReviewerClientTypes.RecommendationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case endLine = "EndLine"
        case filePath = "FilePath"
        case recommendationId = "RecommendationId"
        case startLine = "StartLine"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endLine = endLine {
            try encodeContainer.encode(endLine, forKey: .endLine)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let startLine = startLine {
            try encodeContainer.encode(startLine, forKey: .startLine)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let startLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startLine)
        startLine = startLineDecoded
        let endLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endLine)
        endLine = endLineDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CodeGuruReviewerClientTypes.RecommendationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecommendationSummary(description: \(Swift.String(describing: description)), endLine: \(Swift.String(describing: endLine)), filePath: \(Swift.String(describing: filePath)), recommendationId: \(Swift.String(describing: recommendationId)), startLine: \(Swift.String(describing: startLine)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Information about recommendations.
    ///       </p>
    public struct RecommendationSummary: Swift.Equatable {
        /// <p>
        ///          A description of the recommendation generated by CodeGuru Reviewer for the lines of code between the start line and the end line.
        ///       </p>
        public let description: Swift.String?
        /// <p>
        ///          Last line where the recommendation is applicable in the source commit or source branch. For a single line comment the start line and end line values are the same.
        ///       </p>
        public let endLine: Swift.Int?
        /// <p>Name of the file on which a recommendation is provided.</p>
        public let filePath: Swift.String?
        /// <p>
        ///          The recommendation ID that can be used to track the provided recommendations. Later on it can be used to collect the feedback.
        ///       </p>
        public let recommendationId: Swift.String?
        /// <p>
        ///          Start line from where the recommendation is applicable in the source commit or source branch.
        ///       </p>
        public let startLine: Swift.Int?

        public init (
            description: Swift.String? = nil,
            endLine: Swift.Int? = nil,
            filePath: Swift.String? = nil,
            recommendationId: Swift.String? = nil,
            startLine: Swift.Int? = nil
        )
        {
            self.description = description
            self.endLine = endLine
            self.filePath = filePath
            self.recommendationId = recommendationId
            self.startLine = startLine
        }
    }

}

extension CodeGuruReviewerClientTypes.Repository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bitbucket = "Bitbucket"
        case codeCommit = "CodeCommit"
        case gitHubEnterpriseServer = "GitHubEnterpriseServer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitbucket = bitbucket {
            try encodeContainer.encode(bitbucket, forKey: .bitbucket)
        }
        if let codeCommit = codeCommit {
            try encodeContainer.encode(codeCommit, forKey: .codeCommit)
        }
        if let gitHubEnterpriseServer = gitHubEnterpriseServer {
            try encodeContainer.encode(gitHubEnterpriseServer, forKey: .gitHubEnterpriseServer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeCommitDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.CodeCommitRepository.self, forKey: .codeCommit)
        codeCommit = codeCommitDecoded
        let bitbucketDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.ThirdPartySourceRepository.self, forKey: .bitbucket)
        bitbucket = bitbucketDecoded
        let gitHubEnterpriseServerDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.ThirdPartySourceRepository.self, forKey: .gitHubEnterpriseServer)
        gitHubEnterpriseServer = gitHubEnterpriseServerDecoded
    }
}

extension CodeGuruReviewerClientTypes.Repository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Repository(bitbucket: \(Swift.String(describing: bitbucket)), codeCommit: \(Swift.String(describing: codeCommit)), gitHubEnterpriseServer: \(Swift.String(describing: gitHubEnterpriseServer)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Information about an associated AWS CodeCommit repository or an associated repository that is managed
    ///          by AWS CodeStar Connections (for example, Bitbucket). This <code>Repository</code> object
    ///          is not used if your source code is in an associated GitHub repository.
    ///       </p>
    public struct Repository: Swift.Equatable {
        /// <p>
        ///          Information about a Bitbucket repository.
        ///       </p>
        public let bitbucket: CodeGuruReviewerClientTypes.ThirdPartySourceRepository?
        /// <p>Information about an AWS CodeCommit repository.</p>
        public let codeCommit: CodeGuruReviewerClientTypes.CodeCommitRepository?
        /// <p>
        ///          Information about a GitHub Enterprise Server repository.
        ///       </p>
        public let gitHubEnterpriseServer: CodeGuruReviewerClientTypes.ThirdPartySourceRepository?

        public init (
            bitbucket: CodeGuruReviewerClientTypes.ThirdPartySourceRepository? = nil,
            codeCommit: CodeGuruReviewerClientTypes.CodeCommitRepository? = nil,
            gitHubEnterpriseServer: CodeGuruReviewerClientTypes.ThirdPartySourceRepository? = nil
        )
        {
            self.bitbucket = bitbucket
            self.codeCommit = codeCommit
            self.gitHubEnterpriseServer = gitHubEnterpriseServer
        }
    }

}

extension CodeGuruReviewerClientTypes.RepositoryAnalysis: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryHead = "RepositoryHead"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryHead = repositoryHead {
            try encodeContainer.encode(repositoryHead, forKey: .repositoryHead)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryHeadDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.RepositoryHeadSourceCodeType.self, forKey: .repositoryHead)
        repositoryHead = repositoryHeadDecoded
    }
}

extension CodeGuruReviewerClientTypes.RepositoryAnalysis: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryAnalysis(repositoryHead: \(Swift.String(describing: repositoryHead)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p> A code review type that analyzes all code under a specified branch in an associated
    /// 			repository. The associated repository is specified using its ARN when you call <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_CreateCodeReview">
    ///                <code>CreateCodeReview</code>
    ///             </a>. </p>
    public struct RepositoryAnalysis: Swift.Equatable {
        /// <p>
        ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
        ///                <code>SourceCodeType</code>
        ///             </a> that
        ///          specifies the tip of a branch in an associated repository.
        ///       </p>
        public let repositoryHead: CodeGuruReviewerClientTypes.RepositoryHeadSourceCodeType?

        public init (
            repositoryHead: CodeGuruReviewerClientTypes.RepositoryHeadSourceCodeType? = nil
        )
        {
            self.repositoryHead = repositoryHead
        }
    }

}

extension CodeGuruReviewerClientTypes.RepositoryAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationArn = "AssociationArn"
        case associationId = "AssociationId"
        case connectionArn = "ConnectionArn"
        case createdTimeStamp = "CreatedTimeStamp"
        case kMSKeyDetails = "KMSKeyDetails"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case name = "Name"
        case owner = "Owner"
        case providerType = "ProviderType"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationArn = associationArn {
            try encodeContainer.encode(associationArn, forKey: .associationArn)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let createdTimeStamp = createdTimeStamp {
            try encodeContainer.encode(createdTimeStamp.timeIntervalSince1970, forKey: .createdTimeStamp)
        }
        if let kMSKeyDetails = kMSKeyDetails {
            try encodeContainer.encode(kMSKeyDetails, forKey: .kMSKeyDetails)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let associationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationArn)
        associationArn = associationArnDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.RepositoryAssociationState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
        let createdTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimeStamp)
        createdTimeStamp = createdTimeStampDecoded
        let kMSKeyDetailsDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.KMSKeyDetails.self, forKey: .kMSKeyDetails)
        kMSKeyDetails = kMSKeyDetailsDecoded
    }
}

extension CodeGuruReviewerClientTypes.RepositoryAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryAssociation(associationArn: \(Swift.String(describing: associationArn)), associationId: \(Swift.String(describing: associationId)), connectionArn: \(Swift.String(describing: connectionArn)), createdTimeStamp: \(Swift.String(describing: createdTimeStamp)), kMSKeyDetails: \(Swift.String(describing: kMSKeyDetails)), lastUpdatedTimeStamp: \(Swift.String(describing: lastUpdatedTimeStamp)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), providerType: \(Swift.String(describing: providerType)), state: \(Swift.String(describing: state)), stateReason: \(Swift.String(describing: stateReason)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>Information about a repository association. The
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_DescribeRepositoryAssociation.html">
    ///                <code>DescribeRepositoryAssociation</code>
    ///             </a>
    ///          operation returns a <code>RepositoryAssociation</code> object.</p>
    public struct RepositoryAssociation: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) identifying the repository association.</p>
        public let associationArn: Swift.String?
        /// <p>The ID of the repository association.</p>
        public let associationId: Swift.String?
        /// <p>
        ///          The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection. Its format is
        ///          <code>arn:aws:codestar-connections:region-id:aws-account_id:connection/connection-id</code>. For more information, see
        ///          <a href="https://docs.aws.amazon.com/codestar-connections/latest/APIReference/API_Connection.html">
        ///                <code>Connection</code>
        ///             </a> in
        ///          the <i>AWS CodeStar Connections API Reference</i>.
        ///       </p>
        public let connectionArn: Swift.String?
        /// <p>The time, in milliseconds since the epoch, when the repository association was created.</p>
        public let createdTimeStamp: ClientRuntime.Date?
        /// <p>A <code>KMSKeyDetails</code> object that contains:</p>
        ///          <ul>
        ///             <li>
        ///                <p>The encryption option for this repository association. It is either owned by AWS
        ///             Key Management Service (KMS) (<code>AWS_OWNED_CMK</code>) or customer managed (<code>CUSTOMER_MANAGED_CMK</code>).</p>
        ///             </li>
        ///             <li>
        ///                <p>The ID of the AWS KMS key that
        ///             is associated with this respository association.</p>
        ///             </li>
        ///          </ul>
        public let kMSKeyDetails: CodeGuruReviewerClientTypes.KMSKeyDetails?
        /// <p>The time, in milliseconds since the epoch, when the repository association was last updated.</p>
        public let lastUpdatedTimeStamp: ClientRuntime.Date?
        /// <p>The name of the repository.</p>
        public let name: Swift.String?
        /// <p>The owner of the repository. For an AWS CodeCommit repository, this is the AWS account ID of the
        ///       account that owns the repository. For a GitHub, GitHub Enterprise Server, or Bitbucket repository, this is the username for the account that owns the repository.</p>
        public let owner: Swift.String?
        /// <p>The provider type of the repository association.</p>
        public let providerType: CodeGuruReviewerClientTypes.ProviderType?
        /// <p>The state of the repository association.</p>
        ///          <p>The valid repository association states are:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Associated</b>: The repository
        ///                association is complete.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Associating</b>: CodeGuru Reviewer is:
        ///             </p>
        ///                <ul>
        ///                   <li>
        ///                      <p>
        ///                      Setting up pull request notifications. This is required
        ///                      for pull requests to trigger a CodeGuru Reviewer review.
        ///                   </p>
        ///                      <note>
        ///                         <p>
        ///                         If your repository <code>ProviderType</code> is <code>GitHub</code>, <code>GitHub Enterprise Server</code>, or <code>Bitbucket</code>,
        ///                         CodeGuru Reviewer creates webhooks in your repository to trigger CodeGuru Reviewer reviews. If you delete these webhooks,
        ///                         reviews of code in your repository cannot be triggered.
        ///                      </p>
        ///                      </note>
        ///                   </li>
        ///                   <li>
        ///                      <p>
        ///                      Setting up source code access. This is required for CodeGuru Reviewer to securely
        ///                      clone code in your repository.
        ///                   </p>
        ///                   </li>
        ///                </ul>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Failed</b>: The repository failed to associate or disassociate.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Disassociating</b>: CodeGuru Reviewer is removing the repository's pull request notifications and
        ///                source code access.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Disassociated</b>: CodeGuru Reviewer successfully disassociated the repository. You can create a new association
        ///                with this repository if you want to review source code in it later. You can control access to code reviews created in an
        ///                associated repository with tags after it has been disassociated. For more information, see <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-ug/auth-and-access-control-using-tags.html">Using tags to control access to
        ///                associated repositories</a> in the <i>Amazon CodeGuru Reviewer User Guide</i>.
        ///             </p>
        ///             </li>
        ///          </ul>
        public let state: CodeGuruReviewerClientTypes.RepositoryAssociationState?
        /// <p>A description of why the repository association is in the current state.</p>
        public let stateReason: Swift.String?

        public init (
            associationArn: Swift.String? = nil,
            associationId: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            createdTimeStamp: ClientRuntime.Date? = nil,
            kMSKeyDetails: CodeGuruReviewerClientTypes.KMSKeyDetails? = nil,
            lastUpdatedTimeStamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            providerType: CodeGuruReviewerClientTypes.ProviderType? = nil,
            state: CodeGuruReviewerClientTypes.RepositoryAssociationState? = nil,
            stateReason: Swift.String? = nil
        )
        {
            self.associationArn = associationArn
            self.associationId = associationId
            self.connectionArn = connectionArn
            self.createdTimeStamp = createdTimeStamp
            self.kMSKeyDetails = kMSKeyDetails
            self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
            self.name = name
            self.owner = owner
            self.providerType = providerType
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension CodeGuruReviewerClientTypes {
    public enum RepositoryAssociationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case associating
        case disassociated
        case disassociating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositoryAssociationState] {
            return [
                .associated,
                .associating,
                .disassociated,
                .disassociating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "Associated"
            case .associating: return "Associating"
            case .disassociated: return "Disassociated"
            case .disassociating: return "Disassociating"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositoryAssociationState(rawValue: rawValue) ?? RepositoryAssociationState.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruReviewerClientTypes.RepositoryAssociationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationArn = "AssociationArn"
        case associationId = "AssociationId"
        case connectionArn = "ConnectionArn"
        case lastUpdatedTimeStamp = "LastUpdatedTimeStamp"
        case name = "Name"
        case owner = "Owner"
        case providerType = "ProviderType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationArn = associationArn {
            try encodeContainer.encode(associationArn, forKey: .associationArn)
        }
        if let associationId = associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let lastUpdatedTimeStamp = lastUpdatedTimeStamp {
            try encodeContainer.encode(lastUpdatedTimeStamp.timeIntervalSince1970, forKey: .lastUpdatedTimeStamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let providerType = providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationArn)
        associationArn = associationArnDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let lastUpdatedTimeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimeStamp)
        lastUpdatedTimeStamp = lastUpdatedTimeStampDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.RepositoryAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension CodeGuruReviewerClientTypes.RepositoryAssociationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryAssociationSummary(associationArn: \(Swift.String(describing: associationArn)), associationId: \(Swift.String(describing: associationId)), connectionArn: \(Swift.String(describing: connectionArn)), lastUpdatedTimeStamp: \(Swift.String(describing: lastUpdatedTimeStamp)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), providerType: \(Swift.String(describing: providerType)), state: \(Swift.String(describing: state)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>Summary information about a repository association. The
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>
    ///          operation returns a list of <code>RepositoryAssociationSummary</code> objects.</p>
    public struct RepositoryAssociationSummary: Swift.Equatable {
        /// <p>
        ///          The Amazon Resource Name (ARN) of the
        ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
        ///                <code>RepositoryAssociation</code>
        ///             </a> object.
        ///          You can retrieve this ARN by calling
        ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
        ///                <code>ListRepositoryAssociations</code>
        ///             </a>.
        ///       </p>
        public let associationArn: Swift.String?
        /// <p>
        ///          The repository association ID.
        ///       </p>
        public let associationId: Swift.String?
        /// <p>
        ///          The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection. Its format is
        ///          <code>arn:aws:codestar-connections:region-id:aws-account_id:connection/connection-id</code>. For more information, see
        ///          <a href="https://docs.aws.amazon.com/codestar-connections/latest/APIReference/API_Connection.html">
        ///                <code>Connection</code>
        ///             </a> in
        ///          the <i>AWS CodeStar Connections API Reference</i>.
        ///       </p>
        public let connectionArn: Swift.String?
        /// <p>The time, in milliseconds since the epoch, since the repository association
        ///         was last updated.
        ///       </p>
        public let lastUpdatedTimeStamp: ClientRuntime.Date?
        /// <p>The name of the repository association.</p>
        public let name: Swift.String?
        /// <p>The owner of the repository. For an AWS CodeCommit repository, this is the AWS account ID of the
        ///       account that owns the repository. For a GitHub, GitHub Enterprise Server, or Bitbucket repository, this is the username for the account that owns the repository.</p>
        public let owner: Swift.String?
        /// <p>The provider type of the repository association.</p>
        public let providerType: CodeGuruReviewerClientTypes.ProviderType?
        /// <p>The state of the repository association.</p>
        ///          <p>The valid repository association states are:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Associated</b>: The repository
        ///                association is complete.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Associating</b>: CodeGuru Reviewer is:
        ///             </p>
        ///                <ul>
        ///                   <li>
        ///                      <p>
        ///                      Setting up pull request notifications. This is required
        ///                      for pull requests to trigger a CodeGuru Reviewer review.
        ///                   </p>
        ///                      <note>
        ///                         <p>
        ///                         If your repository <code>ProviderType</code> is <code>GitHub</code>, <code>GitHub Enterprise Server</code>, or <code>Bitbucket</code>,
        ///                         CodeGuru Reviewer creates webhooks in your repository to trigger CodeGuru Reviewer reviews. If you delete these webhooks,
        ///                         reviews of code in your repository cannot be triggered.
        ///                      </p>
        ///                      </note>
        ///                   </li>
        ///                   <li>
        ///                      <p>
        ///                      Setting up source code access. This is required for CodeGuru Reviewer to securely
        ///                      clone code in your repository.
        ///                   </p>
        ///                   </li>
        ///                </ul>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Failed</b>: The repository failed to associate or disassociate.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Disassociating</b>: CodeGuru Reviewer is removing the repository's pull request notifications and
        ///                source code access.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Disassociated</b>: CodeGuru Reviewer successfully disassociated the repository. You can create a new association
        ///                with this repository if you want to review source code in it later. You can control access to code reviews created in an
        ///                associated repository with tags after it has been disassociated. For more information, see <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-ug/auth-and-access-control-using-tags.html">Using tags to control access to
        ///                associated repositories</a> in the <i>Amazon CodeGuru Reviewer User Guide</i>.
        ///             </p>
        ///             </li>
        ///          </ul>
        public let state: CodeGuruReviewerClientTypes.RepositoryAssociationState?

        public init (
            associationArn: Swift.String? = nil,
            associationId: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            lastUpdatedTimeStamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            providerType: CodeGuruReviewerClientTypes.ProviderType? = nil,
            state: CodeGuruReviewerClientTypes.RepositoryAssociationState? = nil
        )
        {
            self.associationArn = associationArn
            self.associationId = associationId
            self.connectionArn = connectionArn
            self.lastUpdatedTimeStamp = lastUpdatedTimeStamp
            self.name = name
            self.owner = owner
            self.providerType = providerType
            self.state = state
        }
    }

}

extension CodeGuruReviewerClientTypes.RepositoryHeadSourceCodeType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branchName = "BranchName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension CodeGuruReviewerClientTypes.RepositoryHeadSourceCodeType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryHeadSourceCodeType(branchName: \(Swift.String(describing: branchName)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
    ///                <code>SourceCodeType</code>
    ///             </a> that specifies
    ///          the tip of a branch in an associated repository.
    ///       </p>
    public struct RepositoryHeadSourceCodeType: Swift.Equatable {
        /// <p>
        ///          The name of the branch in an associated repository. The <code>RepositoryHeadSourceCodeType</code> specifies
        ///          the tip of this branch.
        ///       </p>
        public let branchName: Swift.String?

        public init (
            branchName: Swift.String? = nil
        )
        {
            self.branchName = branchName
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///          The resource specified in the request was not found.
///       </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeGuruReviewerClientTypes.SourceCodeType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitDiff = "CommitDiff"
        case repositoryHead = "RepositoryHead"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitDiff = commitDiff {
            try encodeContainer.encode(commitDiff, forKey: .commitDiff)
        }
        if let repositoryHead = repositoryHead {
            try encodeContainer.encode(repositoryHead, forKey: .repositoryHead)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitDiffDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.CommitDiffSourceCodeType.self, forKey: .commitDiff)
        commitDiff = commitDiffDecoded
        let repositoryHeadDecoded = try containerValues.decodeIfPresent(CodeGuruReviewerClientTypes.RepositoryHeadSourceCodeType.self, forKey: .repositoryHead)
        repositoryHead = repositoryHeadDecoded
    }
}

extension CodeGuruReviewerClientTypes.SourceCodeType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceCodeType(commitDiff: \(Swift.String(describing: commitDiff)), repositoryHead: \(Swift.String(describing: repositoryHead)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Specifies the source code that is analyzed in a code review. A code review can analyze the source code that is specified
    ///          using a pull request diff or a branch in an associated repository.
    ///       </p>
    public struct SourceCodeType: Swift.Equatable {
        /// <p>
        ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
        ///                <code>SourceCodeType</code>
        ///             </a> that
        ///          specifies a commit diff created by a pull request on an associated repository.
        ///       </p>
        public let commitDiff: CodeGuruReviewerClientTypes.CommitDiffSourceCodeType?
        /// <p>
        ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_SourceCodeType">
        ///                <code>SourceCodeType</code>
        ///             </a> that specifies
        ///          the tip of a branch in an associated repository.
        ///       </p>
        public let repositoryHead: CodeGuruReviewerClientTypes.RepositoryHeadSourceCodeType?

        public init (
            commitDiff: CodeGuruReviewerClientTypes.CommitDiffSourceCodeType? = nil,
            repositoryHead: CodeGuruReviewerClientTypes.RepositoryHeadSourceCodeType? = nil
        )
        {
            self.commitDiff = commitDiff
            self.repositoryHead = repositoryHead
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(tags: \(Swift.String(describing: tags)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let resourceArn: Swift.String?
    /// <p>
    /// 			An array of key-value pairs used to tag an associated repository. A tag is a custom attribute label with two parts:
    /// 		</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>A <i>tag key</i> (for example, <code>CostCenter</code>,
    /// 					<code>Environment</code>, <code>Project</code>, or <code>Secret</code>). Tag
    /// 					keys are case sensitive.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>An optional field known as a <i>tag value</i> (for example,
    /// 					<code>111122223333</code>, <code>Production</code>, or a team name).
    /// 					Omitting the tag value is the same as using an empty string. Like tag keys, tag
    /// 					values are case sensitive.</p>
    /// 			         </li>
    ///          </ul>
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CodeGuruReviewerClientTypes.ThirdPartySourceRepository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case name = "Name"
        case owner = "Owner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension CodeGuruReviewerClientTypes.ThirdPartySourceRepository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThirdPartySourceRepository(connectionArn: \(Swift.String(describing: connectionArn)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)))"}
}

extension CodeGuruReviewerClientTypes {
    /// <p>
    ///          Information about a third-party source repository connected to CodeGuru Reviewer.
    ///       </p>
    public struct ThirdPartySourceRepository: Swift.Equatable {
        /// <p>
        ///          The Amazon Resource Name (ARN) of an AWS CodeStar Connections connection. Its format is
        ///          <code>arn:aws:codestar-connections:region-id:aws-account_id:connection/connection-id</code>. For more information, see
        ///          <a href="https://docs.aws.amazon.com/codestar-connections/latest/APIReference/API_Connection.html">
        ///                <code>Connection</code>
        ///             </a> in
        ///          the <i>AWS CodeStar Connections API Reference</i>.
        ///       </p>
        public let connectionArn: Swift.String?
        /// <p>
        ///          The name of the third party source repository.
        ///       </p>
        public let name: Swift.String?
        /// <p>
        ///          The owner of the repository. For a GitHub, GitHub Enterprise, or Bitbucket repository,
        ///          this is the username for the account that owns the repository.
        ///       </p>
        public let owner: Swift.String?

        public init (
            connectionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil
        )
        {
            self.connectionArn = connectionArn
            self.name = name
            self.owner = owner
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeGuruReviewerClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pullRequest
        case repositoryAnalysis
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .pullRequest,
                .repositoryAnalysis,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pullRequest: return "PullRequest"
            case .repositoryAnalysis: return "RepositoryAnalysis"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(tagKeys: \(Swift.String(describing: tagKeys)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_RepositoryAssociation.html">
    ///                <code>RepositoryAssociation</code>
    ///             </a> object.
    ///          You can retrieve this ARN by calling
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/reviewer-api/API_ListRepositoryAssociations.html">
    ///                <code>ListRepositoryAssociations</code>
    ///             </a>.
    ///       </p>
    public let resourceArn: Swift.String?
    /// <p>A list of the keys for each tag you want to remove from an associated repository.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the specified constraints.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
