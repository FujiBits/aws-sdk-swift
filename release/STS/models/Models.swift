// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssumeRoleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleOutputError>
}

extension AssumeRoleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleInput(durationSeconds: \(Swift.String(describing: durationSeconds)), externalId: \(Swift.String(describing: externalId)), policy: \(Swift.String(describing: policy)), policyArns: \(Swift.String(describing: policyArns)), roleArn: \(Swift.String(describing: roleArn)), roleSessionName: \(Swift.String(describing: roleSessionName)), serialNumber: \(Swift.String(describing: serialNumber)), sourceIdentity: \(Swift.String(describing: sourceIdentity)), tags: \(Swift.String(describing: tags)), tokenCode: \(Swift.String(describing: tokenCode)), transitiveTagKeys: \(Swift.String(describing: transitiveTagKeys)))"}
}

extension AssumeRoleInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let externalId = externalId {
            try container.encode(externalId, forKey: ClientRuntime.Key("ExternalId"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let roleSessionName = roleSessionName {
            try container.encode(roleSessionName, forKey: ClientRuntime.Key("RoleSessionName"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let sourceIdentity = sourceIdentity {
            try container.encode(sourceIdentity, forKey: ClientRuntime.Key("SourceIdentity"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tokenCode = tokenCode {
            try container.encode(tokenCode, forKey: ClientRuntime.Key("TokenCode"))
        }
        if let transitiveTagKeys = transitiveTagKeys {
            var transitiveTagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TransitiveTagKeys"))
            for (index0, tagkeytype0) in transitiveTagKeys.enumerated() {
                try transitiveTagKeysContainer.encode(tagkeytype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AssumeRole", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AssumeRoleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleOutputError>
}

public struct AssumeRoleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleOutputError>
}

public struct AssumeRoleInput: Swift.Equatable {
    /// <p>The duration, in seconds, of the role session. The value specified can can range from
    ///          900 seconds (15 minutes) up to the maximum session duration that is set for the role. The
    ///          maximum session duration setting can have a value from 1 hour to 12 hours. If you specify a
    ///          value higher than this setting or the administrator setting (whichever is lower), the
    ///          operation fails. For example, if you specify a session duration of 12 hours, but your
    ///          administrator set the maximum session duration to 6 hours, your operation fails. To learn
    ///          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    ///             Maximum Session Duration Setting for a Role</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>By default, the value is set to <code>3600</code> seconds. </p>
    ///          <note>
    ///             <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
    ///             session that you might request using the returned credentials. The request to the
    ///             federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
    ///             parameter that specifies the maximum length of the console session. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    ///                that Enables Federated Users to Access the AWS Management Console</a> in the
    ///                <i>IAM User Guide</i>.</p>
    ///          </note>
    public let durationSeconds: Swift.Int?
    /// <p>A unique identifier that might be required when you assume a role in another account. If
    ///          the administrator of the account to which the role belongs provided you with an external
    ///          ID, then provide that value in the <code>ExternalId</code> parameter. This value can be any
    ///          string, such as a passphrase or account number. A cross-account role is usually set up to
    ///          trust everyone in an account. Therefore, the administrator of the trusting account might
    ///          send an external ID to the administrator of the trusted account. That way, only someone
    ///          with the ID can assume the role, rather than everyone in the account. For more information
    ///          about the external ID, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html">How to Use an External ID
    ///             When Granting Access to Your AWS Resources to a Third Party</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of
    ///     characters consisting of upper- and lower-case alphanumeric characters with no spaces.
    ///     You can also include underscores or any of the following characters: =,.@:/-</p>
    public let externalId: Swift.String?
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    ///          <p>This parameter is optional. Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    ///          <p>The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policy: Swift.String?
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    ///          managed session policies. The policies must exist in the same account as the role.</p>
    ///          <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    ///          plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    ///             Service Namespaces</a> in the AWS General Reference.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///
    ///          <p>Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    public let policyArns: [StsClientTypes.PolicyDescriptorType]?
    /// <p>The Amazon Resource Name (ARN) of the role to assume.</p>
    public let roleArn: Swift.String?
    /// <p>An identifier for the assumed role session.</p>
    ///          <p>Use the role session name to uniquely identify a session when the same role is assumed
    ///          by different principals or for different reasons. In cross-account scenarios, the role
    ///          session name is visible to, and can be logged by the account that owns the role. The role
    ///          session name is also used in the ARN of the assumed role principal. This means that
    ///          subsequent cross-account API requests that use the temporary security credentials will
    ///          expose the role session name to the external account in their AWS CloudTrail logs.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let roleSessionName: Swift.String?
    /// <p>The identification number of the MFA device that is associated with the user who is
    ///          making the <code>AssumeRole</code> call. Specify this value if the trust policy of the role
    ///          being assumed includes a condition that requires MFA authentication. The value is either
    ///          the serial number for a hardware device (such as <code>GAHT12345678</code>) or an Amazon
    ///          Resource Name (ARN) for a virtual device (such as
    ///             <code>arn:aws:iam::123456789012:mfa/user</code>).</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let serialNumber: Swift.String?
    /// <p>The source identity specified by the principal that is calling the
    ///             <code>AssumeRole</code> operation.</p>
    ///          <p>You can require users to specify a source identity when they assume a role. You do this
    ///          by using the <code>sts:SourceIdentity</code> condition key in a role trust policy. You can
    ///          use source identity information in AWS CloudTrail logs to determine who took actions with a role.
    ///          You can use the <code>aws:SourceIdentity</code> condition key to further control access to
    ///          AWS resources based on the value of source identity. For more information about using
    ///          source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles</a> in the
    ///          <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of upper-
    ///          and lower-case alphanumeric characters with no spaces. You can also include underscores or
    ///          any of the following characters: =,.@-. You cannot use a value that begins with the text
    ///          <code>aws:</code>. This prefix is reserved for AWS internal
    ///          use.</p>
    public let sourceIdentity: Swift.String?
    /// <p>A list of session tags that you want to pass. Each session tag consists of a key name
    ///          and an associated value. For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging AWS STS
    ///             Sessions</a> in the <i>IAM User Guide</i>.</p>
    ///          <p>This parameter is optional. You can pass up to 50 session tags. The plaintext session
    ///          tag keys can’t exceed 128 characters, and the values can’t exceed 256 characters. For these
    ///          and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    ///             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
    ///
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///          <p>You can pass a session tag with the same key as a tag that is already
    ///          attached to the role. When you do, session tags override a role tag with the same key. </p>
    ///          <p>Tag key–value pairs are not case sensitive, but case is preserved. This means that you
    ///          cannot have separate <code>Department</code> and <code>department</code> tag keys. Assume
    ///          that the role has the <code>Department</code>=<code>Marketing</code> tag and you pass the
    ///             <code>department</code>=<code>engineering</code> session tag. <code>Department</code>
    ///          and <code>department</code> are not saved as separate tags, and the session tag passed in
    ///          the request takes precedence over the role tag.</p>
    ///          <p>Additionally, if you used temporary credentials to perform this operation, the new
    ///          session inherits any transitive session tags from the calling session. If you pass a
    ///          session tag with the same key as an inherited tag, the operation fails. To view the
    ///          inherited tags for a session, see the AWS CloudTrail logs. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/session-tags.html#id_session-tags_ctlogs">Viewing Session Tags in CloudTrail</a> in the
    ///          <i>IAM User Guide</i>.</p>
    public let tags: [StsClientTypes.Tag]?
    /// <p>The value provided by the MFA device, if the trust policy of the role being assumed
    ///          requires MFA. (In other words, if the policy includes a condition that tests for MFA). If
    ///          the role being assumed requires MFA and if the <code>TokenCode</code> value is missing or
    ///          expired, the <code>AssumeRole</code> call returns an "access denied" error.</p>
    ///          <p>The format for this parameter, as described by its regex pattern, is a sequence of six
    ///          numeric digits.</p>
    public let tokenCode: Swift.String?
    /// <p>A list of keys for session tags that you want to set as transitive. If you set a tag key
    ///          as transitive, the corresponding key and value passes to subsequent sessions in a role
    ///          chain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_role-chaining">Chaining Roles
    ///             with Session Tags</a> in the <i>IAM User Guide</i>.</p>
    ///          <p>This parameter is optional. When you set session tags as transitive, the session policy
    ///          and session tags packed binary limit is not affected.</p>
    ///          <p>If you choose not to specify a transitive tag key, then no tags are passed from this
    ///          session to any subsequent sessions.</p>
    public let transitiveTagKeys: [Swift.String]?

    public init (
        durationSeconds: Swift.Int? = nil,
        externalId: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyArns: [StsClientTypes.PolicyDescriptorType]? = nil,
        roleArn: Swift.String? = nil,
        roleSessionName: Swift.String? = nil,
        serialNumber: Swift.String? = nil,
        sourceIdentity: Swift.String? = nil,
        tags: [StsClientTypes.Tag]? = nil,
        tokenCode: Swift.String? = nil,
        transitiveTagKeys: [Swift.String]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.externalId = externalId
        self.policy = policy
        self.policyArns = policyArns
        self.roleArn = roleArn
        self.roleSessionName = roleSessionName
        self.serialNumber = serialNumber
        self.sourceIdentity = sourceIdentity
        self.tags = tags
        self.tokenCode = tokenCode
        self.transitiveTagKeys = transitiveTagKeys
    }
}

extension AssumeRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssumeRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLargeException" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssumeRoleOutputError: Swift.Error, Swift.Equatable {
    case expiredTokenException(ExpiredTokenException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeRoleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleOutputResponse(assumedRoleUser: \(Swift.String(describing: assumedRoleUser)), credentials: \(Swift.String(describing: credentials)), packedPolicySize: \(Swift.String(describing: packedPolicySize)), sourceIdentity: \(Swift.String(describing: sourceIdentity)))"}
}

extension AssumeRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssumeRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assumedRoleUser = output.assumedRoleUser
            self.credentials = output.credentials
            self.packedPolicySize = output.packedPolicySize
            self.sourceIdentity = output.sourceIdentity
        } else {
            self.assumedRoleUser = nil
            self.credentials = nil
            self.packedPolicySize = nil
            self.sourceIdentity = nil
        }
    }
}

/// <p>Contains the response to a successful <a>AssumeRole</a> request, including
///       temporary AWS credentials that can be used to make AWS requests. </p>
public struct AssumeRoleOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) and the assumed role ID, which are identifiers that you
    ///          can use to refer to the resulting temporary security credentials. For example, you can
    ///          reference these credentials as a principal in a resource-based policy by using the ARN or
    ///          assumed role ID. The ARN and ID include the <code>RoleSessionName</code> that you specified
    ///          when you called <code>AssumeRole</code>. </p>
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    /// <p>The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security (or session) token.</p>
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: StsClientTypes.Credentials?
    /// <p>A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.</p>
    public let packedPolicySize: Swift.Int?
    /// <p>The source identity specified by the principal that is calling the
    ///             <code>AssumeRole</code> operation.</p>
    ///          <p>You can require users to specify a source identity when they assume a role. You do this
    ///          by using the <code>sts:SourceIdentity</code> condition key in a role trust policy. You can
    ///          use source identity information in AWS CloudTrail logs to determine who took actions with a role.
    ///          You can use the <code>aws:SourceIdentity</code> condition key to further control access to
    ///          AWS resources based on the value of source identity. For more information about using
    ///          source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles</a> in the
    ///          <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of upper-
    ///          and lower-case alphanumeric characters with no spaces. You can also include underscores or
    ///          any of the following characters: =,.@-</p>
    public let sourceIdentity: Swift.String?

    public init (
        assumedRoleUser: StsClientTypes.AssumedRoleUser? = nil,
        credentials: StsClientTypes.Credentials? = nil,
        packedPolicySize: Swift.Int? = nil,
        sourceIdentity: Swift.String? = nil
    )
    {
        self.assumedRoleUser = assumedRoleUser
        self.credentials = credentials
        self.packedPolicySize = packedPolicySize
        self.sourceIdentity = sourceIdentity
    }
}

struct AssumeRoleOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    public let packedPolicySize: Swift.Int?
    public let sourceIdentity: Swift.String?
}

extension AssumeRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumedRoleUser = "AssumedRoleUser"
        case credentials = "Credentials"
        case packedPolicySize = "PackedPolicySize"
        case sourceIdentity = "SourceIdentity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AssumeRoleResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let assumedRoleUserDecoded = try containerValues.decodeIfPresent(StsClientTypes.AssumedRoleUser.self, forKey: .assumedRoleUser)
        assumedRoleUser = assumedRoleUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
        let sourceIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentity)
        sourceIdentity = sourceIdentityDecoded
    }
}

public struct AssumeRoleWithSAMLInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithSAMLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithSAMLOutputError>
}

extension AssumeRoleWithSAMLInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleWithSAMLInput(durationSeconds: \(Swift.String(describing: durationSeconds)), policy: \(Swift.String(describing: policy)), policyArns: \(Swift.String(describing: policyArns)), principalArn: \(Swift.String(describing: principalArn)), roleArn: \(Swift.String(describing: roleArn)), sAMLAssertion: \(Swift.String(describing: sAMLAssertion)))"}
}

extension AssumeRoleWithSAMLInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let principalArn = principalArn {
            try container.encode(principalArn, forKey: ClientRuntime.Key("PrincipalArn"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let sAMLAssertion = sAMLAssertion {
            try container.encode(sAMLAssertion, forKey: ClientRuntime.Key("SAMLAssertion"))
        }
        try container.encode("AssumeRoleWithSAML", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AssumeRoleWithSAMLInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithSAMLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithSAMLOutputError>
}

public struct AssumeRoleWithSAMLInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithSAMLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithSAMLInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithSAMLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithSAMLOutputError>
}

public struct AssumeRoleWithSAMLInput: Swift.Equatable {
    /// <p>The duration, in seconds, of the role session. Your role session lasts for the duration
    ///          that you specify for the <code>DurationSeconds</code> parameter, or until the time
    ///          specified in the SAML authentication response's <code>SessionNotOnOrAfter</code> value,
    ///          whichever is shorter. You can provide a <code>DurationSeconds</code> value from 900 seconds
    ///          (15 minutes) up to the maximum session duration setting for the role. This setting can have
    ///          a value from 1 hour to 12 hours. If you specify a value higher than this setting, the
    ///          operation fails. For example, if you specify a session duration of 12 hours, but your
    ///          administrator set the maximum session duration to 6 hours, your operation fails. To learn
    ///          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    ///             Maximum Session Duration Setting for a Role</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>By default, the value is set to <code>3600</code> seconds. </p>
    ///          <note>
    ///             <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
    ///             session that you might request using the returned credentials. The request to the
    ///             federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
    ///             parameter that specifies the maximum length of the console session. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    ///                that Enables Federated Users to Access the AWS Management Console</a> in the
    ///                <i>IAM User Guide</i>.</p>
    ///          </note>
    public let durationSeconds: Swift.Int?
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    ///          <p>This parameter is optional. Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>. </p>
    ///          <p>The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policy: Swift.String?
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    ///          managed session policies. The policies must exist in the same account as the role.</p>
    ///          <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    ///          plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    ///             Service Namespaces</a> in the AWS General Reference.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///
    ///          <p>Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    public let policyArns: [StsClientTypes.PolicyDescriptorType]?
    /// <p>The Amazon Resource Name (ARN) of the SAML provider in IAM that describes the
    ///          IdP.</p>
    public let principalArn: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
    public let roleArn: Swift.String?
    /// <p>The base64 encoded SAML authentication response provided by the IdP.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/create-role-saml-IdP-tasks.html">Configuring a Relying Party and
    ///             Adding Claims</a> in the <i>IAM User Guide</i>. </p>
    public let sAMLAssertion: Swift.String?

    public init (
        durationSeconds: Swift.Int? = nil,
        policy: Swift.String? = nil,
        policyArns: [StsClientTypes.PolicyDescriptorType]? = nil,
        principalArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sAMLAssertion: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.policy = policy
        self.policyArns = policyArns
        self.principalArn = principalArn
        self.roleArn = roleArn
        self.sAMLAssertion = sAMLAssertion
    }
}

extension AssumeRoleWithSAMLOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssumeRoleWithSAMLOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IDPRejectedClaimException" : self = .iDPRejectedClaimException(try IDPRejectedClaimException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIdentityTokenException" : self = .invalidIdentityTokenException(try InvalidIdentityTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLargeException" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssumeRoleWithSAMLOutputError: Swift.Error, Swift.Equatable {
    case expiredTokenException(ExpiredTokenException)
    case iDPRejectedClaimException(IDPRejectedClaimException)
    case invalidIdentityTokenException(InvalidIdentityTokenException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeRoleWithSAMLOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleWithSAMLOutputResponse(assumedRoleUser: \(Swift.String(describing: assumedRoleUser)), audience: \(Swift.String(describing: audience)), credentials: \(Swift.String(describing: credentials)), issuer: \(Swift.String(describing: issuer)), nameQualifier: \(Swift.String(describing: nameQualifier)), packedPolicySize: \(Swift.String(describing: packedPolicySize)), sourceIdentity: \(Swift.String(describing: sourceIdentity)), subject: \(Swift.String(describing: subject)), subjectType: \(Swift.String(describing: subjectType)))"}
}

extension AssumeRoleWithSAMLOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssumeRoleWithSAMLOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assumedRoleUser = output.assumedRoleUser
            self.audience = output.audience
            self.credentials = output.credentials
            self.issuer = output.issuer
            self.nameQualifier = output.nameQualifier
            self.packedPolicySize = output.packedPolicySize
            self.sourceIdentity = output.sourceIdentity
            self.subject = output.subject
            self.subjectType = output.subjectType
        } else {
            self.assumedRoleUser = nil
            self.audience = nil
            self.credentials = nil
            self.issuer = nil
            self.nameQualifier = nil
            self.packedPolicySize = nil
            self.sourceIdentity = nil
            self.subject = nil
            self.subjectType = nil
        }
    }
}

/// <p>Contains the response to a successful <a>AssumeRoleWithSAML</a> request,
///       including temporary AWS credentials that can be used to make AWS requests. </p>
public struct AssumeRoleWithSAMLOutputResponse: Swift.Equatable {
    /// <p>The identifiers for the temporary security credentials that the operation
    ///          returns.</p>
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    /// <p> The value of the <code>Recipient</code> attribute of the
    ///             <code>SubjectConfirmationData</code> element of the SAML assertion. </p>
    public let audience: Swift.String?
    /// <p>The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security (or session) token.</p>
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: StsClientTypes.Credentials?
    /// <p>The value of the <code>Issuer</code> element of the SAML assertion.</p>
    public let issuer: Swift.String?
    /// <p>A hash value based on the concatenation of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The <code>Issuer</code> response value.</p>
    ///             </li>
    ///             <li>
    ///                <p>The AWS account ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>The friendly name (the last part of the ARN) of the SAML provider in IAM.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The combination of <code>NameQualifier</code> and <code>Subject</code> can be used to
    ///          uniquely identify a federated user.</p>
    ///          <p>The following pseudocode shows how the hash value is calculated:</p>
    ///          <p>
    ///             <code>BASE64 ( SHA1 ( "https://example.com/saml" + "123456789012" + "/MySAMLIdP" ) )</code>
    ///          </p>
    public let nameQualifier: Swift.String?
    /// <p>A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.</p>
    public let packedPolicySize: Swift.Int?
    /// <p>The value in the <code>SourceIdentity</code> attribute in the SAML assertion. </p>
    ///          <p>You can require users to set a source identity value when they assume a role. You do
    ///          this by using the <code>sts:SourceIdentity</code> condition key in a role trust policy.
    ///          That way, actions that are taken with the role are associated with that user. After the
    ///          source identity is set, the value cannot be changed. It is present in the request for all
    ///          actions that are taken by the role and persists across <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts#iam-term-role-chaining">chained
    ///             role</a> sessions. You can configure your SAML identity provider to use an attribute
    ///          associated with your users, like user name or email, as the source identity when calling
    ///             <code>AssumeRoleWithSAML</code>. You do this by adding an attribute to the SAML
    ///          assertion. For more information about using source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles</a> in the
    ///          <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let sourceIdentity: Swift.String?
    /// <p>The value of the <code>NameID</code> element in the <code>Subject</code> element of the
    ///          SAML assertion.</p>
    public let subject: Swift.String?
    /// <p> The format of the name ID, as defined by the <code>Format</code> attribute in the
    ///             <code>NameID</code> element of the SAML assertion. Typical examples of the format are
    ///             <code>transient</code> or <code>persistent</code>. </p>
    ///          <p> If the format includes the prefix
    ///             <code>urn:oasis:names:tc:SAML:2.0:nameid-format</code>, that prefix is removed. For
    ///          example, <code>urn:oasis:names:tc:SAML:2.0:nameid-format:transient</code> is returned as
    ///             <code>transient</code>. If the format includes any other prefix, the format is returned
    ///          with no modifications.</p>
    public let subjectType: Swift.String?

    public init (
        assumedRoleUser: StsClientTypes.AssumedRoleUser? = nil,
        audience: Swift.String? = nil,
        credentials: StsClientTypes.Credentials? = nil,
        issuer: Swift.String? = nil,
        nameQualifier: Swift.String? = nil,
        packedPolicySize: Swift.Int? = nil,
        sourceIdentity: Swift.String? = nil,
        subject: Swift.String? = nil,
        subjectType: Swift.String? = nil
    )
    {
        self.assumedRoleUser = assumedRoleUser
        self.audience = audience
        self.credentials = credentials
        self.issuer = issuer
        self.nameQualifier = nameQualifier
        self.packedPolicySize = packedPolicySize
        self.sourceIdentity = sourceIdentity
        self.subject = subject
        self.subjectType = subjectType
    }
}

struct AssumeRoleWithSAMLOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    public let packedPolicySize: Swift.Int?
    public let subject: Swift.String?
    public let subjectType: Swift.String?
    public let issuer: Swift.String?
    public let audience: Swift.String?
    public let nameQualifier: Swift.String?
    public let sourceIdentity: Swift.String?
}

extension AssumeRoleWithSAMLOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumedRoleUser = "AssumedRoleUser"
        case audience = "Audience"
        case credentials = "Credentials"
        case issuer = "Issuer"
        case nameQualifier = "NameQualifier"
        case packedPolicySize = "PackedPolicySize"
        case sourceIdentity = "SourceIdentity"
        case subject = "Subject"
        case subjectType = "SubjectType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AssumeRoleWithSAMLResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let assumedRoleUserDecoded = try containerValues.decodeIfPresent(StsClientTypes.AssumedRoleUser.self, forKey: .assumedRoleUser)
        assumedRoleUser = assumedRoleUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let subjectTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectType)
        subjectType = subjectTypeDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let audienceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audience)
        audience = audienceDecoded
        let nameQualifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nameQualifier)
        nameQualifier = nameQualifierDecoded
        let sourceIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentity)
        sourceIdentity = sourceIdentityDecoded
    }
}

public struct AssumeRoleWithWebIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithWebIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithWebIdentityOutputError>
}

extension AssumeRoleWithWebIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleWithWebIdentityInput(durationSeconds: \(Swift.String(describing: durationSeconds)), policy: \(Swift.String(describing: policy)), policyArns: \(Swift.String(describing: policyArns)), providerId: \(Swift.String(describing: providerId)), roleArn: \(Swift.String(describing: roleArn)), roleSessionName: \(Swift.String(describing: roleSessionName)), webIdentityToken: \(Swift.String(describing: webIdentityToken)))"}
}

extension AssumeRoleWithWebIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let providerId = providerId {
            try container.encode(providerId, forKey: ClientRuntime.Key("ProviderId"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let roleSessionName = roleSessionName {
            try container.encode(roleSessionName, forKey: ClientRuntime.Key("RoleSessionName"))
        }
        if let webIdentityToken = webIdentityToken {
            try container.encode(webIdentityToken, forKey: ClientRuntime.Key("WebIdentityToken"))
        }
        try container.encode("AssumeRoleWithWebIdentity", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct AssumeRoleWithWebIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithWebIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithWebIdentityOutputError>
}

public struct AssumeRoleWithWebIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssumeRoleWithWebIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssumeRoleWithWebIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssumeRoleWithWebIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssumeRoleWithWebIdentityOutputError>
}

public struct AssumeRoleWithWebIdentityInput: Swift.Equatable {
    /// <p>The duration, in seconds, of the role session. The value can range from 900 seconds (15
    ///          minutes) up to the maximum session duration setting for the role. This setting can have a
    ///          value from 1 hour to 12 hours. If you specify a value higher than this setting, the
    ///          operation fails. For example, if you specify a session duration of 12 hours, but your
    ///          administrator set the maximum session duration to 6 hours, your operation fails. To learn
    ///          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    ///             Maximum Session Duration Setting for a Role</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>By default, the value is set to <code>3600</code> seconds. </p>
    ///          <note>
    ///             <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
    ///             session that you might request using the returned credentials. The request to the
    ///             federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
    ///             parameter that specifies the maximum length of the console session. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    ///                that Enables Federated Users to Access the AWS Management Console</a> in the
    ///                <i>IAM User Guide</i>.</p>
    ///          </note>
    public let durationSeconds: Swift.Int?
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    ///          <p>This parameter is optional. Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    ///          <p>The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policy: Swift.String?
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    ///          managed session policies. The policies must exist in the same account as the role.</p>
    ///          <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    ///          plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    ///             Service Namespaces</a> in the AWS General Reference.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///
    ///          <p>Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    public let policyArns: [StsClientTypes.PolicyDescriptorType]?
    /// <p>The fully qualified host component of the domain name of the identity provider.</p>
    ///          <p>Specify this value only for OAuth 2.0 access tokens. Currently
    ///             <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the only supported
    ///          identity providers for OAuth 2.0 access tokens. Do not include URL schemes and port
    ///          numbers.</p>
    ///          <p>Do not specify this value for OpenID Connect ID tokens.</p>
    public let providerId: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
    public let roleArn: Swift.String?
    /// <p>An identifier for the assumed role session. Typically, you pass the name or identifier
    ///          that is associated with the user who is using your application. That way, the temporary
    ///          security credentials that your application will use are associated with that user. This
    ///          session name is included as part of the ARN and assumed role ID in the
    ///             <code>AssumedRoleUser</code> response element.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let roleSessionName: Swift.String?
    /// <p>The OAuth 2.0 access token or OpenID Connect ID token that is provided by the identity
    ///          provider. Your application must get this token by authenticating the user who is using your
    ///          application with a web identity provider before the application makes an
    ///             <code>AssumeRoleWithWebIdentity</code> call. </p>
    public let webIdentityToken: Swift.String?

    public init (
        durationSeconds: Swift.Int? = nil,
        policy: Swift.String? = nil,
        policyArns: [StsClientTypes.PolicyDescriptorType]? = nil,
        providerId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        roleSessionName: Swift.String? = nil,
        webIdentityToken: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.policy = policy
        self.policyArns = policyArns
        self.providerId = providerId
        self.roleArn = roleArn
        self.roleSessionName = roleSessionName
        self.webIdentityToken = webIdentityToken
    }
}

extension AssumeRoleWithWebIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssumeRoleWithWebIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IDPCommunicationErrorException" : self = .iDPCommunicationErrorException(try IDPCommunicationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IDPRejectedClaimException" : self = .iDPRejectedClaimException(try IDPRejectedClaimException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIdentityTokenException" : self = .invalidIdentityTokenException(try InvalidIdentityTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLargeException" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssumeRoleWithWebIdentityOutputError: Swift.Error, Swift.Equatable {
    case expiredTokenException(ExpiredTokenException)
    case iDPCommunicationErrorException(IDPCommunicationErrorException)
    case iDPRejectedClaimException(IDPRejectedClaimException)
    case invalidIdentityTokenException(InvalidIdentityTokenException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeRoleWithWebIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumeRoleWithWebIdentityOutputResponse(assumedRoleUser: \(Swift.String(describing: assumedRoleUser)), audience: \(Swift.String(describing: audience)), credentials: \(Swift.String(describing: credentials)), packedPolicySize: \(Swift.String(describing: packedPolicySize)), provider: \(Swift.String(describing: provider)), sourceIdentity: \(Swift.String(describing: sourceIdentity)), subjectFromWebIdentityToken: \(Swift.String(describing: subjectFromWebIdentityToken)))"}
}

extension AssumeRoleWithWebIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssumeRoleWithWebIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assumedRoleUser = output.assumedRoleUser
            self.audience = output.audience
            self.credentials = output.credentials
            self.packedPolicySize = output.packedPolicySize
            self.provider = output.provider
            self.sourceIdentity = output.sourceIdentity
            self.subjectFromWebIdentityToken = output.subjectFromWebIdentityToken
        } else {
            self.assumedRoleUser = nil
            self.audience = nil
            self.credentials = nil
            self.packedPolicySize = nil
            self.provider = nil
            self.sourceIdentity = nil
            self.subjectFromWebIdentityToken = nil
        }
    }
}

/// <p>Contains the response to a successful <a>AssumeRoleWithWebIdentity</a>
///       request, including temporary AWS credentials that can be used to make AWS requests. </p>
public struct AssumeRoleWithWebIdentityOutputResponse: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) and the assumed role ID, which are identifiers that you
    ///          can use to refer to the resulting temporary security credentials. For example, you can
    ///          reference these credentials as a principal in a resource-based policy by using the ARN or
    ///          assumed role ID. The ARN and ID include the <code>RoleSessionName</code> that you specified
    ///          when you called <code>AssumeRole</code>. </p>
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    /// <p>The intended audience (also known as client ID) of the web identity token. This is
    ///          traditionally the client identifier issued to the application that requested the web
    ///          identity token.</p>
    public let audience: Swift.String?
    /// <p>The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security token.</p>
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: StsClientTypes.Credentials?
    /// <p>A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.</p>
    public let packedPolicySize: Swift.Int?
    /// <p> The issuing authority of the web identity token presented. For OpenID Connect ID
    ///          tokens, this contains the value of the <code>iss</code> field. For OAuth 2.0 access tokens,
    ///          this contains the value of the <code>ProviderId</code> parameter that was passed in the
    ///             <code>AssumeRoleWithWebIdentity</code> request.</p>
    public let provider: Swift.String?
    /// <p>The value of the source identity that is returned in the JSON web token (JWT) from the
    ///          identity provider.</p>
    ///          <p>You can require users to set a source identity value when they assume a role. You do
    ///          this by using the <code>sts:SourceIdentity</code> condition key in a role trust policy.
    ///          That way, actions that are taken with the role are associated with that user. After the
    ///          source identity is set, the value cannot be changed. It is present in the request for all
    ///          actions that are taken by the role and persists across <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts#iam-term-role-chaining">chained
    ///             role</a> sessions. You can configure your identity provider to use an attribute
    ///          associated with your users, like user name or email, as the source identity when calling
    ///             <code>AssumeRoleWithWebIdentity</code>. You do this by adding a claim to the JSON web
    ///          token. To learn more about OIDC tokens and claims, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-with-identity-providers.html">Using Tokens with User Pools</a> in the <i>Amazon Cognito Developer Guide</i>.
    ///          For more information about using source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles</a> in the
    ///          <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let sourceIdentity: Swift.String?
    /// <p>The unique user identifier that is returned by the identity provider. This identifier is
    ///          associated with the <code>WebIdentityToken</code> that was submitted with the
    ///             <code>AssumeRoleWithWebIdentity</code> call. The identifier is typically unique to the
    ///          user and the application that acquired the <code>WebIdentityToken</code> (pairwise
    ///          identifier). For OpenID Connect ID tokens, this field contains the value returned by the
    ///          identity provider as the token's <code>sub</code> (Subject) claim. </p>
    public let subjectFromWebIdentityToken: Swift.String?

    public init (
        assumedRoleUser: StsClientTypes.AssumedRoleUser? = nil,
        audience: Swift.String? = nil,
        credentials: StsClientTypes.Credentials? = nil,
        packedPolicySize: Swift.Int? = nil,
        provider: Swift.String? = nil,
        sourceIdentity: Swift.String? = nil,
        subjectFromWebIdentityToken: Swift.String? = nil
    )
    {
        self.assumedRoleUser = assumedRoleUser
        self.audience = audience
        self.credentials = credentials
        self.packedPolicySize = packedPolicySize
        self.provider = provider
        self.sourceIdentity = sourceIdentity
        self.subjectFromWebIdentityToken = subjectFromWebIdentityToken
    }
}

struct AssumeRoleWithWebIdentityOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
    public let subjectFromWebIdentityToken: Swift.String?
    public let assumedRoleUser: StsClientTypes.AssumedRoleUser?
    public let packedPolicySize: Swift.Int?
    public let provider: Swift.String?
    public let audience: Swift.String?
    public let sourceIdentity: Swift.String?
}

extension AssumeRoleWithWebIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumedRoleUser = "AssumedRoleUser"
        case audience = "Audience"
        case credentials = "Credentials"
        case packedPolicySize = "PackedPolicySize"
        case provider = "Provider"
        case sourceIdentity = "SourceIdentity"
        case subjectFromWebIdentityToken = "SubjectFromWebIdentityToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("AssumeRoleWithWebIdentityResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let subjectFromWebIdentityTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectFromWebIdentityToken)
        subjectFromWebIdentityToken = subjectFromWebIdentityTokenDecoded
        let assumedRoleUserDecoded = try containerValues.decodeIfPresent(StsClientTypes.AssumedRoleUser.self, forKey: .assumedRoleUser)
        assumedRoleUser = assumedRoleUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let audienceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audience)
        audience = audienceDecoded
        let sourceIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIdentity)
        sourceIdentity = sourceIdentityDecoded
    }
}

extension StsClientTypes.AssumedRoleUser: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assumedRoleId = "AssumedRoleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let assumedRoleId = assumedRoleId {
            try container.encode(assumedRoleId, forKey: ClientRuntime.Key("AssumedRoleId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assumedRoleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumedRoleId)
        assumedRoleId = assumedRoleIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StsClientTypes.AssumedRoleUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssumedRoleUser(arn: \(Swift.String(describing: arn)), assumedRoleId: \(Swift.String(describing: assumedRoleId)))"}
}

extension StsClientTypes {
    /// <p>The identifiers for the temporary security credentials that the operation
    ///          returns.</p>
    public struct AssumedRoleUser: Swift.Equatable {
        /// <p>The ARN of the temporary security credentials that are returned from the <a>AssumeRole</a> action. For more information about ARNs and how to use them in
        ///          policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM Identifiers</a> in the
        ///             <i>IAM User Guide</i>.</p>
        public let arn: Swift.String?
        /// <p>A unique identifier that contains the role ID and the role session name of the role that
        ///          is being assumed. The role ID is generated by AWS when the role is created.</p>
        public let assumedRoleId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            assumedRoleId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.assumedRoleId = assumedRoleId
        }
    }

}

extension StsClientTypes.Credentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretAccessKey = "SecretAccessKey"
        case sessionToken = "SessionToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        if let expiration = expiration {
            try container.encode(ClientRuntime.TimestampWrapper(expiration, format: .dateTime), forKey: ClientRuntime.Key("expiration"))
        }
        if let secretAccessKey = secretAccessKey {
            try container.encode(secretAccessKey, forKey: ClientRuntime.Key("SecretAccessKey"))
        }
        if let sessionToken = sessionToken {
            try container.encode(sessionToken, forKey: ClientRuntime.Key("SessionToken"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiration)
        var expirationBuffer:ClientRuntime.Date? = nil
        if let expirationDecoded = expirationDecoded {
            expirationBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(expirationDecoded, format: .dateTime)
        }
        expiration = expirationBuffer
    }
}

extension StsClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credentials(accessKeyId: \(Swift.String(describing: accessKeyId)), expiration: \(Swift.String(describing: expiration)), secretAccessKey: \(Swift.String(describing: secretAccessKey)), sessionToken: \(Swift.String(describing: sessionToken)))"}
}

extension StsClientTypes {
    /// <p>AWS credentials for API authentication.</p>
    public struct Credentials: Swift.Equatable {
        /// <p>The access key ID that identifies the temporary security credentials.</p>
        public let accessKeyId: Swift.String?
        /// <p>The date on which the current credentials expire.</p>
        public let expiration: ClientRuntime.Date?
        /// <p>The secret access key that can be used to sign requests.</p>
        public let secretAccessKey: Swift.String?
        /// <p>The token that users must pass to the service API to use the temporary
        ///          credentials.</p>
        public let sessionToken: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            expiration: ClientRuntime.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

public struct DecodeAuthorizationMessageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecodeAuthorizationMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecodeAuthorizationMessageOutputError>
}

extension DecodeAuthorizationMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecodeAuthorizationMessageInput(encodedMessage: \(Swift.String(describing: encodedMessage)))"}
}

extension DecodeAuthorizationMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let encodedMessage = encodedMessage {
            try container.encode(encodedMessage, forKey: ClientRuntime.Key("EncodedMessage"))
        }
        try container.encode("DecodeAuthorizationMessage", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct DecodeAuthorizationMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecodeAuthorizationMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecodeAuthorizationMessageOutputError>
}

public struct DecodeAuthorizationMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DecodeAuthorizationMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DecodeAuthorizationMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DecodeAuthorizationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DecodeAuthorizationMessageOutputError>
}

public struct DecodeAuthorizationMessageInput: Swift.Equatable {
    /// <p>The encoded message that was returned with the response.</p>
    public let encodedMessage: Swift.String?

    public init (
        encodedMessage: Swift.String? = nil
    )
    {
        self.encodedMessage = encodedMessage
    }
}

extension DecodeAuthorizationMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DecodeAuthorizationMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAuthorizationMessageException" : self = .invalidAuthorizationMessageException(try InvalidAuthorizationMessageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DecodeAuthorizationMessageOutputError: Swift.Error, Swift.Equatable {
    case invalidAuthorizationMessageException(InvalidAuthorizationMessageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecodeAuthorizationMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecodeAuthorizationMessageOutputResponse(decodedMessage: \(Swift.String(describing: decodedMessage)))"}
}

extension DecodeAuthorizationMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DecodeAuthorizationMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.decodedMessage = output.decodedMessage
        } else {
            self.decodedMessage = nil
        }
    }
}

/// <p>A document that contains additional information about the authorization status of a
///       request from an encoded message that is returned in response to an AWS request.</p>
public struct DecodeAuthorizationMessageOutputResponse: Swift.Equatable {
    /// <p>An XML document that contains the decoded message.</p>
    public let decodedMessage: Swift.String?

    public init (
        decodedMessage: Swift.String? = nil
    )
    {
        self.decodedMessage = decodedMessage
    }
}

struct DecodeAuthorizationMessageOutputResponseBody: Swift.Equatable {
    public let decodedMessage: Swift.String?
}

extension DecodeAuthorizationMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decodedMessage = "DecodedMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DecodeAuthorizationMessageResult"))
        let decodedMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decodedMessage)
        decodedMessage = decodedMessageDecoded
    }
}

extension ExpiredTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpiredTokenException(message: \(Swift.String(describing: message)))"}
}

extension ExpiredTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<ExpiredTokenExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The web identity token that was passed is expired or is not valid. Get a new identity
///             token from the identity provider and then retry the request.</p>
public struct ExpiredTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ExpiredTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StsClientTypes.FederatedUser: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case federatedUserId = "FederatedUserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("Arn"))
        }
        if let federatedUserId = federatedUserId {
            try container.encode(federatedUserId, forKey: ClientRuntime.Key("FederatedUserId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let federatedUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .federatedUserId)
        federatedUserId = federatedUserIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StsClientTypes.FederatedUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FederatedUser(arn: \(Swift.String(describing: arn)), federatedUserId: \(Swift.String(describing: federatedUserId)))"}
}

extension StsClientTypes {
    /// <p>Identifiers for the federated user that is associated with the credentials.</p>
    public struct FederatedUser: Swift.Equatable {
        /// <p>The ARN that specifies the federated user that is associated with the credentials. For
        ///          more information about ARNs and how to use them in policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
        ///             Identifiers</a> in the <i>IAM User Guide</i>. </p>
        public let arn: Swift.String?
        /// <p>The string that identifies the federated user associated with the credentials, similar
        ///          to the unique ID of an IAM user.</p>
        public let federatedUserId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            federatedUserId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.federatedUserId = federatedUserId
        }
    }

}

public struct GetAccessKeyInfoInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessKeyInfoInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessKeyInfoOutputError>
}

extension GetAccessKeyInfoInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessKeyInfoInput(accessKeyId: \(Swift.String(describing: accessKeyId)))"}
}

extension GetAccessKeyInfoInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: ClientRuntime.Key("AccessKeyId"))
        }
        try container.encode("GetAccessKeyInfo", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetAccessKeyInfoInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessKeyInfoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessKeyInfoOutputError>
}

public struct GetAccessKeyInfoInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessKeyInfoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessKeyInfoInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessKeyInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessKeyInfoOutputError>
}

public struct GetAccessKeyInfoInput: Swift.Equatable {
    /// <p>The identifier of an access key.</p>
    ///         <p>This parameter allows (through its regex pattern) a string of characters that can
    ///             consist of any upper- or lowercase letter or digit.</p>
    public let accessKeyId: Swift.String?

    public init (
        accessKeyId: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
    }
}

extension GetAccessKeyInfoOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessKeyInfoOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessKeyInfoOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessKeyInfoOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessKeyInfoOutputResponse(account: \(Swift.String(describing: account)))"}
}

extension GetAccessKeyInfoOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccessKeyInfoOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
        } else {
            self.account = nil
        }
    }
}

public struct GetAccessKeyInfoOutputResponse: Swift.Equatable {
    /// <p>The number used to identify the AWS account.</p>
    public let account: Swift.String?

    public init (
        account: Swift.String? = nil
    )
    {
        self.account = account
    }
}

struct GetAccessKeyInfoOutputResponseBody: Swift.Equatable {
    public let account: Swift.String?
}

extension GetAccessKeyInfoOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetAccessKeyInfoResult"))
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
    }
}

public struct GetCallerIdentityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCallerIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCallerIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCallerIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCallerIdentityOutputError>
}

extension GetCallerIdentityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCallerIdentityInput()"}
}

extension GetCallerIdentityInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetCallerIdentity", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetCallerIdentityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCallerIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCallerIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCallerIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCallerIdentityOutputError>
}

public struct GetCallerIdentityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCallerIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCallerIdentityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCallerIdentityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCallerIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCallerIdentityOutputError>
}

public struct GetCallerIdentityInput: Swift.Equatable {

    public init() {}
}

extension GetCallerIdentityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCallerIdentityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCallerIdentityOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCallerIdentityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCallerIdentityOutputResponse(account: \(Swift.String(describing: account)), arn: \(Swift.String(describing: arn)), userId: \(Swift.String(describing: userId)))"}
}

extension GetCallerIdentityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCallerIdentityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.account = output.account
            self.arn = output.arn
            self.userId = output.userId
        } else {
            self.account = nil
            self.arn = nil
            self.userId = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetCallerIdentity</a> request,
///          including information about the entity making the request.</p>
public struct GetCallerIdentityOutputResponse: Swift.Equatable {
    /// <p>The AWS account ID number of the account that owns or contains the calling
    ///          entity.</p>
    public let account: Swift.String?
    /// <p>The AWS ARN associated with the calling entity.</p>
    public let arn: Swift.String?
    /// <p>The unique identifier of the calling entity. The exact value depends on the type of
    ///          entity that is making the call. The values returned are those listed in the <b>aws:userid</b> column in the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable">Principal
    ///             table</a> found on the <b>Policy Variables</b> reference
    ///          page in the <i>IAM User Guide</i>.</p>
    public let userId: Swift.String?

    public init (
        account: Swift.String? = nil,
        arn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.account = account
        self.arn = arn
        self.userId = userId
    }
}

struct GetCallerIdentityOutputResponseBody: Swift.Equatable {
    public let userId: Swift.String?
    public let account: Swift.String?
    public let arn: Swift.String?
}

extension GetCallerIdentityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case arn = "Arn"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetCallerIdentityResult"))
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct GetFederationTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFederationTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFederationTokenOutputError>
}

extension GetFederationTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFederationTokenInput(durationSeconds: \(Swift.String(describing: durationSeconds)), name: \(Swift.String(describing: name)), policy: \(Swift.String(describing: policy)), policyArns: \(Swift.String(describing: policyArns)), tags: \(Swift.String(describing: tags)))"}
}

extension GetFederationTokenInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: ClientRuntime.Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetFederationToken", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetFederationTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFederationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFederationTokenOutputError>
}

public struct GetFederationTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFederationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFederationTokenOutputError>
}

public struct GetFederationTokenInput: Swift.Equatable {
    /// <p>The duration, in seconds, that the session should last. Acceptable durations for
    ///          federation sessions range from 900 seconds (15 minutes) to 129,600 seconds (36 hours), with
    ///          43,200 seconds (12 hours) as the default. Sessions obtained using AWS account root user
    ///          credentials are restricted to a maximum of 3,600 seconds (one hour). If the specified
    ///          duration is longer than one hour, the session obtained by using root user credentials
    ///          defaults to one hour.</p>
    public let durationSeconds: Swift.Int?
    /// <p>The name of the federated user. The name is used as an identifier for the temporary
    ///          security credentials (such as <code>Bob</code>). For example, you can reference the
    ///          federated user name in a resource-based policy, such as in an Amazon S3 bucket policy.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let name: Swift.String?
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    ///          <p>You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy</a> to
    ///          this operation. You can pass a single JSON policy document to use as an inline session
    ///          policy. You can also specify up to 10 managed policies to use as managed session
    ///          policies.</p>
    ///          <p>This parameter is optional. However, if you do not pass any session policies, then the
    ///          resulting federated user session has no permissions.</p>
    ///          <p>When you pass session policies, the session permissions are the intersection of the
    ///          IAM user policies and the session policies that you pass. This gives you a way to further
    ///          restrict the permissions for a federated user. You cannot use session policies to grant
    ///          more permissions than those that are defined in the permissions policy of the IAM user.
    ///          For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies</a> in
    ///          the <i>IAM User Guide</i>.</p>
    ///          <p>The resulting credentials can be used to access a resource that has a resource-based
    ///          policy. If that policy specifically references the federated user session in the
    ///             <code>Principal</code> element of the policy, the session has the permissions allowed by
    ///          the policy. These permissions are granted in addition to the permissions that are granted
    ///          by the session policies.</p>
    ///          <p>The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policy: Swift.String?
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as a
    ///          managed session policy. The policies must exist in the same account as the IAM user that
    ///          is requesting federated access.</p>
    ///          <p>You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy</a> to
    ///          this operation. You can pass a single JSON policy document to use as an inline session
    ///          policy. You can also specify up to 10 managed policies to use as managed session policies.
    ///          The plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. You can provide up to 10 managed policy ARNs. For more information about ARNs,
    ///          see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    ///             Resource Names (ARNs) and AWS Service Namespaces</a> in the AWS General Reference.</p>
    ///          <p>This parameter is optional. However, if you do not pass any session policies, then the
    ///          resulting federated user session has no permissions.</p>
    ///          <p>When you pass session policies, the session permissions are the intersection of the
    ///          IAM user policies and the session policies that you pass. This gives you a way to further
    ///          restrict the permissions for a federated user. You cannot use session policies to grant
    ///          more permissions than those that are defined in the permissions policy of the IAM user.
    ///          For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies</a> in
    ///          the <i>IAM User Guide</i>.</p>
    ///          <p>The resulting credentials can be used to access a resource that has a resource-based
    ///          policy. If that policy specifically references the federated user session in the
    ///             <code>Principal</code> element of the policy, the session has the permissions allowed by
    ///          the policy. These permissions are granted in addition to the permissions that are granted
    ///          by the session policies.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policyArns: [StsClientTypes.PolicyDescriptorType]?
    /// <p>A list of session tags. Each session tag consists of a key name and an associated value.
    ///          For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>This parameter is optional. You can pass up to 50 session tags. The plaintext session
    ///          tag keys can’t exceed 128 characters and the values can’t exceed 256 characters. For these
    ///          and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    ///             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
    ///
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///          <p>You can pass a session tag with the same key as a tag that is already
    ///          attached to the user you are federating. When you do, session tags override a user tag with
    ///          the same key. </p>
    ///          <p>Tag key–value pairs are not case sensitive, but case is preserved. This means that you
    ///          cannot have separate <code>Department</code> and <code>department</code> tag keys. Assume
    ///          that the role has the <code>Department</code>=<code>Marketing</code> tag and you pass the
    ///             <code>department</code>=<code>engineering</code> session tag. <code>Department</code>
    ///          and <code>department</code> are not saved as separate tags, and the session tag passed in
    ///          the request takes precedence over the role tag.</p>
    public let tags: [StsClientTypes.Tag]?

    public init (
        durationSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        policyArns: [StsClientTypes.PolicyDescriptorType]? = nil,
        tags: [StsClientTypes.Tag]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.name = name
        self.policy = policy
        self.policyArns = policyArns
        self.tags = tags
    }
}

extension GetFederationTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFederationTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLargeException" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFederationTokenOutputError: Swift.Error, Swift.Equatable {
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFederationTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFederationTokenOutputResponse(credentials: \(Swift.String(describing: credentials)), federatedUser: \(Swift.String(describing: federatedUser)), packedPolicySize: \(Swift.String(describing: packedPolicySize)))"}
}

extension GetFederationTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFederationTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.federatedUser = output.federatedUser
            self.packedPolicySize = output.packedPolicySize
        } else {
            self.credentials = nil
            self.federatedUser = nil
            self.packedPolicySize = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetFederationToken</a> request,
///       including temporary AWS credentials that can be used to make AWS requests. </p>
public struct GetFederationTokenOutputResponse: Swift.Equatable {
    /// <p>The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security (or session) token.</p>
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: StsClientTypes.Credentials?
    /// <p>Identifiers for the federated user associated with the credentials (such as
    ///             <code>arn:aws:sts::123456789012:federated-user/Bob</code> or
    ///             <code>123456789012:Bob</code>). You can use the federated user's ARN in your
    ///          resource-based policies, such as an Amazon S3 bucket policy. </p>
    public let federatedUser: StsClientTypes.FederatedUser?
    /// <p>A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.</p>
    public let packedPolicySize: Swift.Int?

    public init (
        credentials: StsClientTypes.Credentials? = nil,
        federatedUser: StsClientTypes.FederatedUser? = nil,
        packedPolicySize: Swift.Int? = nil
    )
    {
        self.credentials = credentials
        self.federatedUser = federatedUser
        self.packedPolicySize = packedPolicySize
    }
}

struct GetFederationTokenOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
    public let federatedUser: StsClientTypes.FederatedUser?
    public let packedPolicySize: Swift.Int?
}

extension GetFederationTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
        case federatedUser = "FederatedUser"
        case packedPolicySize = "PackedPolicySize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetFederationTokenResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let federatedUserDecoded = try containerValues.decodeIfPresent(StsClientTypes.FederatedUser.self, forKey: .federatedUser)
        federatedUser = federatedUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
    }
}

public struct GetSessionTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = ClientRuntime.HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionTokenOutputError>
}

extension GetSessionTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionTokenInput(durationSeconds: \(Swift.String(describing: durationSeconds)), serialNumber: \(Swift.String(describing: serialNumber)), tokenCode: \(Swift.String(describing: tokenCode)))"}
}

extension GetSessionTokenInput: Swift.Encodable, ClientRuntime.Reflection {
    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: ClientRuntime.Key("DurationSeconds"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: ClientRuntime.Key("SerialNumber"))
        }
        if let tokenCode = tokenCode {
            try container.encode(tokenCode, forKey: ClientRuntime.Key("TokenCode"))
        }
        try container.encode("GetSessionToken", forKey:ClientRuntime.Key("Action"))
        try container.encode("2011-06-15", forKey:ClientRuntime.Key("Version"))
    }
}

public struct GetSessionTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionTokenOutputError>
}

public struct GetSessionTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSessionTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSessionTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSessionTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSessionTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSessionTokenOutputError>
}

public struct GetSessionTokenInput: Swift.Equatable {
    /// <p>The duration, in seconds, that the credentials should remain valid. Acceptable
    ///             durations for IAM user sessions range from 900 seconds (15 minutes) to 129,600 seconds
    ///             (36 hours), with 43,200 seconds (12 hours) as the default. Sessions for AWS account
    ///             owners are restricted to a maximum of 3,600 seconds (one hour). If the duration is
    ///             longer than one hour, the session for AWS account owners defaults to one hour.</p>
    public let durationSeconds: Swift.Int?
    /// <p>The identification number of the MFA device that is associated with the IAM user who
    ///             is making the <code>GetSessionToken</code> call. Specify this value if the IAM user
    ///             has a policy that requires MFA authentication. The value is either the serial number for
    ///             a hardware device (such as <code>GAHT12345678</code>) or an Amazon Resource Name (ARN)
    ///             for a virtual device (such as <code>arn:aws:iam::123456789012:mfa/user</code>). You can
    ///             find the device for an IAM user by going to the AWS Management Console and viewing the user's
    ///             security credentials. </p>
    ///         <p>The regex used to validate this parameter is a string of
    ///     characters consisting of upper- and lower-case alphanumeric characters with no spaces.
    ///     You can also include underscores or any of the following characters: =,.@:/-</p>
    public let serialNumber: Swift.String?
    /// <p>The value provided by the MFA device, if MFA is required. If any policy requires the
    ///             IAM user to submit an MFA code, specify this value. If MFA authentication is required,
    ///             the user must provide a code when requesting a set of temporary security credentials. A
    ///             user who fails to provide the code receives an "access denied" response when requesting
    ///             resources that require MFA authentication.</p>
    ///         <p>The format for this parameter, as described by its regex pattern, is a sequence of six
    ///             numeric digits.</p>
    public let tokenCode: Swift.String?

    public init (
        durationSeconds: Swift.Int? = nil,
        serialNumber: Swift.String? = nil,
        tokenCode: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.serialNumber = serialNumber
        self.tokenCode = tokenCode
    }
}

extension GetSessionTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSessionTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSessionTokenOutputError: Swift.Error, Swift.Equatable {
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionTokenOutputResponse(credentials: \(Swift.String(describing: credentials)))"}
}

extension GetSessionTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSessionTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetSessionToken</a> request,
///       including temporary AWS credentials that can be used to make AWS requests. </p>
public struct GetSessionTokenOutputResponse: Swift.Equatable {
    /// <p>The temporary security credentials, which include an access key ID, a secret access
    ///             key, and a security (or session) token.</p>
    ///
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: StsClientTypes.Credentials?

    public init (
        credentials: StsClientTypes.Credentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct GetSessionTokenOutputResponseBody: Swift.Equatable {
    public let credentials: StsClientTypes.Credentials?
}

extension GetSessionTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("GetSessionTokenResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(StsClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

extension IDPCommunicationErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IDPCommunicationErrorException(message: \(Swift.String(describing: message)))"}
}

extension IDPCommunicationErrorException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<IDPCommunicationErrorExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be fulfilled because the identity provider (IDP) that
///             was asked to verify the incoming identity token could not be reached. This is often a
///             transient error caused by network conditions. Retry the request a limited number of
///             times so that you don't exceed the request rate. If the error persists, the
///             identity provider might be down or not responding.</p>
public struct IDPCommunicationErrorException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IDPCommunicationErrorExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IDPCommunicationErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IDPRejectedClaimException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IDPRejectedClaimException(message: \(Swift.String(describing: message)))"}
}

extension IDPRejectedClaimException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<IDPRejectedClaimExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The identity provider (IdP) reported that authentication failed. This might be because
///             the claim is invalid.</p>
///         <p>If this error is returned for the <code>AssumeRoleWithWebIdentity</code> operation, it
///             can also mean that the claim has expired or has been explicitly revoked. </p>
public struct IDPRejectedClaimException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IDPRejectedClaimExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IDPRejectedClaimExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAuthorizationMessageException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidAuthorizationMessageException(message: \(Swift.String(describing: message)))"}
}

extension InvalidAuthorizationMessageException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidAuthorizationMessageExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The error returned if the message passed to <code>DecodeAuthorizationMessage</code>
///             was invalid. This can happen if the token contains invalid characters, such as
///             linebreaks. </p>
public struct InvalidAuthorizationMessageException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAuthorizationMessageExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidAuthorizationMessageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIdentityTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidIdentityTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidIdentityTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<InvalidIdentityTokenExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The web identity token that was passed could not be validated by AWS. Get a new
///             identity token from the identity provider and then retry the request.</p>
public struct InvalidIdentityTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIdentityTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidIdentityTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedPolicyDocumentException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MalformedPolicyDocumentException(message: \(Swift.String(describing: message)))"}
}

extension MalformedPolicyDocumentException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<MalformedPolicyDocumentExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the policy document was malformed. The error message
///             describes the specific error.</p>
public struct MalformedPolicyDocumentException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MalformedPolicyDocumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PackedPolicyTooLargeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PackedPolicyTooLargeException(message: \(Swift.String(describing: message)))"}
}

extension PackedPolicyTooLargeException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<PackedPolicyTooLargeExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the total packed size of the session policies and
///             session tags combined was too large. An AWS conversion compresses the session policy
///             document, session policy ARNs, and session tags into a packed binary format that has a
///             separate limit. The error message indicates by percentage how close the policies and
///             tags are to the upper size limit. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in
///             the <i>IAM User Guide</i>.</p>
///         <p>You could receive this error even though you meet other defined session policy and
///             session tag limits. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">IAM and STS Entity
///                 Character Limits</a> in the <i>IAM User Guide</i>.</p>
public struct PackedPolicyTooLargeException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PackedPolicyTooLargeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PackedPolicyTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StsClientTypes.PolicyDescriptorType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: ClientRuntime.Key("arn"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension StsClientTypes.PolicyDescriptorType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyDescriptorType(arn: \(Swift.String(describing: arn)))"}
}

extension StsClientTypes {
    /// <p>A reference to the IAM managed policy that is passed as a session policy for a role
    ///          session or a federated user session.</p>
    public struct PolicyDescriptorType: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the IAM managed policy to use as a session policy
        ///          for the role. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
        ///             Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
        public let arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension RegionDisabledException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegionDisabledException(message: \(Swift.String(describing: message)))"}
}

extension RegionDisabledException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ErrorResponseContainer<RegionDisabledExceptionBody> = try responseDecoder.decode(responseBody: data)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>STS is not activated in the requested region for the account that is being asked to
///             generate credentials. The account administrator must use the IAM console to activate STS
///             in that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
///                 Deactivating AWS STS in an AWS Region</a> in the <i>IAM User
///                     Guide</i>.</p>
public struct RegionDisabledException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RegionDisabledExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RegionDisabledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StsClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension StsClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension StsClientTypes {
    /// <p>You can pass custom key-value pair attributes when you assume a role or federate a user.
    ///          These are called session tags. You can then use the session tags to control access to
    ///          resources. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging AWS STS Sessions</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key for a session tag.</p>
        ///          <p>You can pass up to 50 session tags. The plain text session tag keys can’t exceed 128
        ///          characters. For these and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
        ///             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
        public let key: Swift.String?
        /// <p>The value for a session tag.</p>
        ///          <p>You can pass up to 50 session tags. The plain text session tag values can’t exceed 256
        ///          characters. For these and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
        ///             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}
