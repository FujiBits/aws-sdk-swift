// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IotEventsDataClientTypes.AcknowledgeActionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IotEventsDataClientTypes.AcknowledgeActionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcknowledgeActionConfiguration(note: \(Swift.String(describing: note)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains the configuration information of an acknowledge action.</p>
    public struct AcknowledgeActionConfiguration: Swift.Equatable {
        /// <p>The note that you can leave when you acknowledge the alarm.</p>
        public let note: Swift.String?

        public init (
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }

}

extension IotEventsDataClientTypes.AcknowledgeAlarmActionRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IotEventsDataClientTypes.AcknowledgeAlarmActionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcknowledgeAlarmActionRequest(alarmModelName: \(Swift.String(describing: alarmModelName)), keyValue: \(Swift.String(describing: keyValue)), note: \(Swift.String(describing: note)), requestId: \(Swift.String(describing: requestId)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information needed to acknowledge the alarm.</p>
    public struct AcknowledgeAlarmActionRequest: Swift.Equatable {
        /// <p>The name of the alarm model.</p>
        public let alarmModelName: Swift.String?
        /// <p>The value of the key used as a filter to select only the alarms associated with the
        /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
        public let keyValue: Swift.String?
        /// <p>The note that you can leave when you acknowledge the alarm.</p>
        public let note: Swift.String?
        /// <p>The request ID. Each ID must be unique within each batch.</p>
        public let requestId: Swift.String?

        public init (
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }

}

extension IotEventsDataClientTypes.Alarm: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case alarmModelVersion
        case alarmState
        case creationTime
        case keyValue
        case lastUpdateTime
        case severity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmModelVersion = alarmModelVersion {
            try encodeContainer.encode(alarmModelVersion, forKey: .alarmModelVersion)
        }
        if let alarmState = alarmState {
            try encodeContainer.encode(alarmState, forKey: .alarmState)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let severity = severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let alarmStateDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.AlarmState.self, forKey: .alarmState)
        alarmState = alarmStateDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .severity)
        severity = severityDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IotEventsDataClientTypes.Alarm: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Alarm(alarmModelName: \(Swift.String(describing: alarmModelName)), alarmModelVersion: \(Swift.String(describing: alarmModelVersion)), alarmState: \(Swift.String(describing: alarmState)), creationTime: \(Swift.String(describing: creationTime)), keyValue: \(Swift.String(describing: keyValue)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), severity: \(Swift.String(describing: severity)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains information about an alarm.</p>
    public struct Alarm: Swift.Equatable {
        /// <p>The name of the alarm model.</p>
        public let alarmModelName: Swift.String?
        /// <p>The version of the alarm model.</p>
        public let alarmModelVersion: Swift.String?
        /// <p>Contains information about the current state of the alarm.</p>
        public let alarmState: IotEventsDataClientTypes.AlarmState?
        /// <p>The time the alarm was created, in the Unix epoch format.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The value of the key used as a filter to select only the alarms associated with the
        /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
        public let keyValue: Swift.String?
        /// <p>The time the alarm was last updated, in the Unix epoch format.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>A non-negative integer that reflects the severity level of the alarm.</p>
        public let severity: Swift.Int?

        public init (
            alarmModelName: Swift.String? = nil,
            alarmModelVersion: Swift.String? = nil,
            alarmState: IotEventsDataClientTypes.AlarmState? = nil,
            creationTime: ClientRuntime.Date? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            severity: Swift.Int? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.alarmState = alarmState
            self.creationTime = creationTime
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.severity = severity
        }
    }

}

extension IotEventsDataClientTypes.AlarmState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerAction
        case ruleEvaluation
        case stateName
        case systemEvent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerAction = customerAction {
            try encodeContainer.encode(customerAction, forKey: .customerAction)
        }
        if let ruleEvaluation = ruleEvaluation {
            try encodeContainer.encode(ruleEvaluation, forKey: .ruleEvaluation)
        }
        if let stateName = stateName {
            try encodeContainer.encode(stateName.rawValue, forKey: .stateName)
        }
        if let systemEvent = systemEvent {
            try encodeContainer.encode(systemEvent, forKey: .systemEvent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.AlarmStateName.self, forKey: .stateName)
        stateName = stateNameDecoded
        let ruleEvaluationDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.RuleEvaluation.self, forKey: .ruleEvaluation)
        ruleEvaluation = ruleEvaluationDecoded
        let customerActionDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.CustomerAction.self, forKey: .customerAction)
        customerAction = customerActionDecoded
        let systemEventDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.SystemEvent.self, forKey: .systemEvent)
        systemEvent = systemEventDecoded
    }
}

extension IotEventsDataClientTypes.AlarmState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmState(customerAction: \(Swift.String(describing: customerAction)), ruleEvaluation: \(Swift.String(describing: ruleEvaluation)), stateName: \(Swift.String(describing: stateName)), systemEvent: \(Swift.String(describing: systemEvent)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains information about the current state of the alarm.</p>
    public struct AlarmState: Swift.Equatable {
        /// <p>Contains information about the action that you can take to respond to the alarm.</p>
        public let customerAction: IotEventsDataClientTypes.CustomerAction?
        /// <p>Information needed to evaluate data.</p>
        public let ruleEvaluation: IotEventsDataClientTypes.RuleEvaluation?
        /// <p>The name of the alarm state. The state name can be one of the following values:</p>
        ///          <ul>
        ///             <li>
        /// 		             <p>
        ///                   <code>DISABLED</code> - When the alarm is in the <code>DISABLED</code> state,
        /// 		it isn't ready to evaluate data. To enable the alarm,
        /// 		you must change the alarm to the <code>NORMAL</code> state.</p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>NORMAL</code> - When the alarm is in the <code>NORMAL</code> state,
        /// 		it's ready to evaluate data.</p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>ACTIVE</code> - If the alarm is in the <code>ACTIVE</code> state,
        /// 		the alarm is invoked.</p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>ACKNOWLEDGED</code> - When the alarm is in the <code>ACKNOWLEDGED</code> state,
        /// 		the alarm was invoked and you acknowledged the alarm.</p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>SNOOZE_DISABLED</code> - When the alarm is in the <code>SNOOZE_DISABLED</code> state,
        /// 		the alarm is disabled for a specified period of time. After the snooze time,
        /// 		the alarm automatically changes to the <code>NORMAL</code> state. </p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>LATCHED</code> - When the alarm is in the <code>LATCHED</code> state,
        /// 		the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range.
        /// 		To change the alarm to the <code>NORMAL</code> state, you must acknowledge the alarm.</p>
        /// 	           </li>
        ///          </ul>
        public let stateName: IotEventsDataClientTypes.AlarmStateName?
        /// <p>Contains information about alarm state changes.</p>
        public let systemEvent: IotEventsDataClientTypes.SystemEvent?

        public init (
            customerAction: IotEventsDataClientTypes.CustomerAction? = nil,
            ruleEvaluation: IotEventsDataClientTypes.RuleEvaluation? = nil,
            stateName: IotEventsDataClientTypes.AlarmStateName? = nil,
            systemEvent: IotEventsDataClientTypes.SystemEvent? = nil
        )
        {
            self.customerAction = customerAction
            self.ruleEvaluation = ruleEvaluation
            self.stateName = stateName
            self.systemEvent = systemEvent
        }
    }

}

extension IotEventsDataClientTypes {
    public enum AlarmStateName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledged
        case active
        case disabled
        case latched
        case normal
        case snoozeDisabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmStateName] {
            return [
                .acknowledged,
                .active,
                .disabled,
                .latched,
                .normal,
                .snoozeDisabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "ACKNOWLEDGED"
            case .active: return "ACTIVE"
            case .disabled: return "DISABLED"
            case .latched: return "LATCHED"
            case .normal: return "NORMAL"
            case .snoozeDisabled: return "SNOOZE_DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlarmStateName(rawValue: rawValue) ?? AlarmStateName.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsDataClientTypes.AlarmSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case alarmModelVersion
        case creationTime
        case keyValue
        case lastUpdateTime
        case stateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let alarmModelVersion = alarmModelVersion {
            try encodeContainer.encode(alarmModelVersion, forKey: .alarmModelVersion)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let stateName = stateName {
            try encodeContainer.encode(stateName.rawValue, forKey: .stateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let alarmModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelVersion)
        alarmModelVersion = alarmModelVersionDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let stateNameDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.AlarmStateName.self, forKey: .stateName)
        stateName = stateNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IotEventsDataClientTypes.AlarmSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlarmSummary(alarmModelName: \(Swift.String(describing: alarmModelName)), alarmModelVersion: \(Swift.String(describing: alarmModelVersion)), creationTime: \(Swift.String(describing: creationTime)), keyValue: \(Swift.String(describing: keyValue)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), stateName: \(Swift.String(describing: stateName)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains a summary of an alarm.</p>
    public struct AlarmSummary: Swift.Equatable {
        /// <p>The name of the alarm model.</p>
        public let alarmModelName: Swift.String?
        /// <p>The version of the alarm model.</p>
        public let alarmModelVersion: Swift.String?
        /// <p>The time the alarm was created, in the Unix epoch format.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The value of the key used as a filter to select only the alarms associated with the
        /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
        public let keyValue: Swift.String?
        /// <p>The time the alarm was last updated, in the Unix epoch format.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The name of the alarm state. The state name can be one of the following values:</p>
        ///          <ul>
        ///             <li>
        /// 		             <p>
        ///                   <code>DISABLED</code> - When the alarm is in the <code>DISABLED</code> state,
        /// 		it isn't ready to evaluate data. To enable the alarm,
        /// 		you must change the alarm to the <code>NORMAL</code> state.</p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>NORMAL</code> - When the alarm is in the <code>NORMAL</code> state,
        /// 		it's ready to evaluate data.</p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>ACTIVE</code> - If the alarm is in the <code>ACTIVE</code> state,
        /// 		the alarm is invoked.</p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>ACKNOWLEDGED</code> - When the alarm is in the <code>ACKNOWLEDGED</code> state,
        /// 		the alarm was invoked and you acknowledged the alarm.</p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>SNOOZE_DISABLED</code> - When the alarm is in the <code>SNOOZE_DISABLED</code> state,
        /// 		the alarm is disabled for a specified period of time. After the snooze time,
        /// 		the alarm automatically changes to the <code>NORMAL</code> state. </p>
        /// 	           </li>
        ///             <li>
        /// 		             <p>
        ///                   <code>LATCHED</code> - When the alarm is in the <code>LATCHED</code> state,
        /// 		the alarm was invoked. However, the data that the alarm is currently evaluating is within the specified range.
        /// 		To change the alarm to the <code>NORMAL</code> state, you must acknowledge the alarm.</p>
        /// 	           </li>
        ///          </ul>
        public let stateName: IotEventsDataClientTypes.AlarmStateName?

        public init (
            alarmModelName: Swift.String? = nil,
            alarmModelVersion: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            stateName: IotEventsDataClientTypes.AlarmStateName? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.alarmModelVersion = alarmModelVersion
            self.creationTime = creationTime
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.stateName = stateName
        }
    }

}

public struct BatchAcknowledgeAlarmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAcknowledgeAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAcknowledgeAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAcknowledgeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAcknowledgeAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAcknowledgeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAcknowledgeAlarmOutputError>
}

extension BatchAcknowledgeAlarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAcknowledgeAlarmInput(acknowledgeActionRequests: \(Swift.String(describing: acknowledgeActionRequests)))"}
}

extension BatchAcknowledgeAlarmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgeActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgeActionRequests = acknowledgeActionRequests {
            var acknowledgeActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acknowledgeActionRequests)
            for acknowledgealarmactionrequests0 in acknowledgeActionRequests {
                try acknowledgeActionRequestsContainer.encode(acknowledgealarmactionrequests0)
            }
        }
    }
}

public struct BatchAcknowledgeAlarmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAcknowledgeAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAcknowledgeAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAcknowledgeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAcknowledgeAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAcknowledgeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAcknowledgeAlarmOutputError>
}

public struct BatchAcknowledgeAlarmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAcknowledgeAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAcknowledgeAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAcknowledgeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAcknowledgeAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAcknowledgeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAcknowledgeAlarmOutputError>
}

public struct BatchAcknowledgeAlarmInput: Swift.Equatable {
    /// <p>The list of acknowledge action requests. You can specify up to 10 requests per operation.</p>
    public let acknowledgeActionRequests: [IotEventsDataClientTypes.AcknowledgeAlarmActionRequest]?

    public init (
        acknowledgeActionRequests: [IotEventsDataClientTypes.AcknowledgeAlarmActionRequest]? = nil
    )
    {
        self.acknowledgeActionRequests = acknowledgeActionRequests
    }
}

struct BatchAcknowledgeAlarmInputBody: Swift.Equatable {
    public let acknowledgeActionRequests: [IotEventsDataClientTypes.AcknowledgeAlarmActionRequest]?
}

extension BatchAcknowledgeAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgeActionRequests
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acknowledgeActionRequestsContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.AcknowledgeAlarmActionRequest?].self, forKey: .acknowledgeActionRequests)
        var acknowledgeActionRequestsDecoded0:[IotEventsDataClientTypes.AcknowledgeAlarmActionRequest]? = nil
        if let acknowledgeActionRequestsContainer = acknowledgeActionRequestsContainer {
            acknowledgeActionRequestsDecoded0 = [IotEventsDataClientTypes.AcknowledgeAlarmActionRequest]()
            for structure0 in acknowledgeActionRequestsContainer {
                if let structure0 = structure0 {
                    acknowledgeActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        acknowledgeActionRequests = acknowledgeActionRequestsDecoded0
    }
}

extension BatchAcknowledgeAlarmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAcknowledgeAlarmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAcknowledgeAlarmOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAcknowledgeAlarmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAcknowledgeAlarmOutputResponse(errorEntries: \(Swift.String(describing: errorEntries)))"}
}

extension BatchAcknowledgeAlarmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchAcknowledgeAlarmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchAcknowledgeAlarmOutputResponse: Swift.Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchAcknowledgeAlarmOutputResponseBody: Swift.Equatable {
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchAcknowledgeAlarmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension IotEventsDataClientTypes.BatchAlarmActionErrorEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IotEventsDataClientTypes.BatchAlarmActionErrorEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAlarmActionErrorEntry(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), requestId: \(Swift.String(describing: requestId)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains error messages associated with one of the following requests:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchAcknowledgeAlarm.html">BatchAcknowledgeAlarm</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchDisableAlarm.html">BatchDisableAlarm</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchEnableAlarm.html">BatchEnableAlarm</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchResetAlarm.html">BatchResetAlarm</a>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchSnoozeAlarm.html">BatchSnoozeAlarm</a>
    ///                </p>
    ///             </li>
    ///          </ul>
    public struct BatchAlarmActionErrorEntry: Swift.Equatable {
        /// <p>The error code.</p>
        public let errorCode: IotEventsDataClientTypes.ErrorCode?
        /// <p>A message that describes the error.</p>
        public let errorMessage: Swift.String?
        /// <p>The request ID. Each ID must be unique within each batch.</p>
        public let requestId: Swift.String?

        public init (
            errorCode: IotEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.requestId = requestId
        }
    }

}

public struct BatchDisableAlarmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisableAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisableAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisableAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisableAlarmOutputError>
}

extension BatchDisableAlarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisableAlarmInput(disableActionRequests: \(Swift.String(describing: disableActionRequests)))"}
}

extension BatchDisableAlarmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disableActionRequests = disableActionRequests {
            var disableActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disableActionRequests)
            for disablealarmactionrequests0 in disableActionRequests {
                try disableActionRequestsContainer.encode(disablealarmactionrequests0)
            }
        }
    }
}

public struct BatchDisableAlarmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisableAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisableAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisableAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisableAlarmOutputError>
}

public struct BatchDisableAlarmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisableAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisableAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisableAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisableAlarmOutputError>
}

public struct BatchDisableAlarmInput: Swift.Equatable {
    /// <p>The list of disable action requests. You can specify up to 10 requests per operation.</p>
    public let disableActionRequests: [IotEventsDataClientTypes.DisableAlarmActionRequest]?

    public init (
        disableActionRequests: [IotEventsDataClientTypes.DisableAlarmActionRequest]? = nil
    )
    {
        self.disableActionRequests = disableActionRequests
    }
}

struct BatchDisableAlarmInputBody: Swift.Equatable {
    public let disableActionRequests: [IotEventsDataClientTypes.DisableAlarmActionRequest]?
}

extension BatchDisableAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disableActionRequests
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableActionRequestsContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.DisableAlarmActionRequest?].self, forKey: .disableActionRequests)
        var disableActionRequestsDecoded0:[IotEventsDataClientTypes.DisableAlarmActionRequest]? = nil
        if let disableActionRequestsContainer = disableActionRequestsContainer {
            disableActionRequestsDecoded0 = [IotEventsDataClientTypes.DisableAlarmActionRequest]()
            for structure0 in disableActionRequestsContainer {
                if let structure0 = structure0 {
                    disableActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        disableActionRequests = disableActionRequestsDecoded0
    }
}

extension BatchDisableAlarmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisableAlarmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisableAlarmOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisableAlarmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisableAlarmOutputResponse(errorEntries: \(Swift.String(describing: errorEntries)))"}
}

extension BatchDisableAlarmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDisableAlarmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchDisableAlarmOutputResponse: Swift.Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchDisableAlarmOutputResponseBody: Swift.Equatable {
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchDisableAlarmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

public struct BatchEnableAlarmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchEnableAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchEnableAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchEnableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchEnableAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchEnableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchEnableAlarmOutputError>
}

extension BatchEnableAlarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchEnableAlarmInput(enableActionRequests: \(Swift.String(describing: enableActionRequests)))"}
}

extension BatchEnableAlarmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableActionRequests = enableActionRequests {
            var enableActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enableActionRequests)
            for enablealarmactionrequests0 in enableActionRequests {
                try enableActionRequestsContainer.encode(enablealarmactionrequests0)
            }
        }
    }
}

public struct BatchEnableAlarmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchEnableAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchEnableAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchEnableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchEnableAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchEnableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchEnableAlarmOutputError>
}

public struct BatchEnableAlarmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchEnableAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchEnableAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchEnableAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchEnableAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchEnableAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchEnableAlarmOutputError>
}

public struct BatchEnableAlarmInput: Swift.Equatable {
    /// <p>The list of enable action requests. You can specify up to 10 requests per operation.</p>
    public let enableActionRequests: [IotEventsDataClientTypes.EnableAlarmActionRequest]?

    public init (
        enableActionRequests: [IotEventsDataClientTypes.EnableAlarmActionRequest]? = nil
    )
    {
        self.enableActionRequests = enableActionRequests
    }
}

struct BatchEnableAlarmInputBody: Swift.Equatable {
    public let enableActionRequests: [IotEventsDataClientTypes.EnableAlarmActionRequest]?
}

extension BatchEnableAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableActionRequests
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableActionRequestsContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.EnableAlarmActionRequest?].self, forKey: .enableActionRequests)
        var enableActionRequestsDecoded0:[IotEventsDataClientTypes.EnableAlarmActionRequest]? = nil
        if let enableActionRequestsContainer = enableActionRequestsContainer {
            enableActionRequestsDecoded0 = [IotEventsDataClientTypes.EnableAlarmActionRequest]()
            for structure0 in enableActionRequestsContainer {
                if let structure0 = structure0 {
                    enableActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        enableActionRequests = enableActionRequestsDecoded0
    }
}

extension BatchEnableAlarmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchEnableAlarmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchEnableAlarmOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchEnableAlarmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchEnableAlarmOutputResponse(errorEntries: \(Swift.String(describing: errorEntries)))"}
}

extension BatchEnableAlarmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchEnableAlarmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchEnableAlarmOutputResponse: Swift.Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchEnableAlarmOutputResponseBody: Swift.Equatable {
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchEnableAlarmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension IotEventsDataClientTypes.BatchPutMessageErrorEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case messageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IotEventsDataClientTypes.BatchPutMessageErrorEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutMessageErrorEntry(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), messageId: \(Swift.String(describing: messageId)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains information about the errors encountered.</p>
    public struct BatchPutMessageErrorEntry: Swift.Equatable {
        /// <p>The error code.</p>
        public let errorCode: IotEventsDataClientTypes.ErrorCode?
        /// <p>A message that describes the error.</p>
        public let errorMessage: Swift.String?
        /// <p>The ID of the message that caused the error. (See the value corresponding to the
        ///         <code>"messageId"</code> key in the <code>"message"</code> object.)</p>
        public let messageId: Swift.String?

        public init (
            errorCode: IotEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }
    }

}

public struct BatchPutMessageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutMessageOutputError>
}

extension BatchPutMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutMessageInput(messages: \(Swift.String(describing: messages)))"}
}

extension BatchPutMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for messages0 in messages {
                try messagesContainer.encode(messages0)
            }
        }
    }
}

public struct BatchPutMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutMessageOutputError>
}

public struct BatchPutMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutMessageOutputError>
}

public struct BatchPutMessageInput: Swift.Equatable {
    /// <p>The list of messages to send. Each message has the following format: <code>'{ "messageId":
    ///         "string", "inputName": "string", "payload": "string"}'</code>
    ///          </p>
    public let messages: [IotEventsDataClientTypes.Message]?

    public init (
        messages: [IotEventsDataClientTypes.Message]? = nil
    )
    {
        self.messages = messages
    }
}

struct BatchPutMessageInputBody: Swift.Equatable {
    public let messages: [IotEventsDataClientTypes.Message]?
}

extension BatchPutMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[IotEventsDataClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [IotEventsDataClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
    }
}

extension BatchPutMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutMessageOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutMessageOutputResponse(batchPutMessageErrorEntries: \(Swift.String(describing: batchPutMessageErrorEntries)))"}
}

extension BatchPutMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchPutMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchPutMessageErrorEntries = output.batchPutMessageErrorEntries
        } else {
            self.batchPutMessageErrorEntries = nil
        }
    }
}

public struct BatchPutMessageOutputResponse: Swift.Equatable {
    /// <p>A list of any errors encountered when sending the messages.</p>
    public let batchPutMessageErrorEntries: [IotEventsDataClientTypes.BatchPutMessageErrorEntry]?

    public init (
        batchPutMessageErrorEntries: [IotEventsDataClientTypes.BatchPutMessageErrorEntry]? = nil
    )
    {
        self.batchPutMessageErrorEntries = batchPutMessageErrorEntries
    }
}

struct BatchPutMessageOutputResponseBody: Swift.Equatable {
    public let batchPutMessageErrorEntries: [IotEventsDataClientTypes.BatchPutMessageErrorEntry]?
}

extension BatchPutMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPutMessageErrorEntries = "BatchPutMessageErrorEntries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchPutMessageErrorEntriesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.BatchPutMessageErrorEntry?].self, forKey: .batchPutMessageErrorEntries)
        var batchPutMessageErrorEntriesDecoded0:[IotEventsDataClientTypes.BatchPutMessageErrorEntry]? = nil
        if let batchPutMessageErrorEntriesContainer = batchPutMessageErrorEntriesContainer {
            batchPutMessageErrorEntriesDecoded0 = [IotEventsDataClientTypes.BatchPutMessageErrorEntry]()
            for structure0 in batchPutMessageErrorEntriesContainer {
                if let structure0 = structure0 {
                    batchPutMessageErrorEntriesDecoded0?.append(structure0)
                }
            }
        }
        batchPutMessageErrorEntries = batchPutMessageErrorEntriesDecoded0
    }
}

public struct BatchResetAlarmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchResetAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchResetAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchResetAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchResetAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchResetAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchResetAlarmOutputError>
}

extension BatchResetAlarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchResetAlarmInput(resetActionRequests: \(Swift.String(describing: resetActionRequests)))"}
}

extension BatchResetAlarmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resetActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resetActionRequests = resetActionRequests {
            var resetActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resetActionRequests)
            for resetalarmactionrequests0 in resetActionRequests {
                try resetActionRequestsContainer.encode(resetalarmactionrequests0)
            }
        }
    }
}

public struct BatchResetAlarmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchResetAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchResetAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchResetAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchResetAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchResetAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchResetAlarmOutputError>
}

public struct BatchResetAlarmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchResetAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchResetAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchResetAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchResetAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchResetAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchResetAlarmOutputError>
}

public struct BatchResetAlarmInput: Swift.Equatable {
    /// <p>The list of reset action requests. You can specify up to 10 requests per operation.</p>
    public let resetActionRequests: [IotEventsDataClientTypes.ResetAlarmActionRequest]?

    public init (
        resetActionRequests: [IotEventsDataClientTypes.ResetAlarmActionRequest]? = nil
    )
    {
        self.resetActionRequests = resetActionRequests
    }
}

struct BatchResetAlarmInputBody: Swift.Equatable {
    public let resetActionRequests: [IotEventsDataClientTypes.ResetAlarmActionRequest]?
}

extension BatchResetAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resetActionRequests
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resetActionRequestsContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.ResetAlarmActionRequest?].self, forKey: .resetActionRequests)
        var resetActionRequestsDecoded0:[IotEventsDataClientTypes.ResetAlarmActionRequest]? = nil
        if let resetActionRequestsContainer = resetActionRequestsContainer {
            resetActionRequestsDecoded0 = [IotEventsDataClientTypes.ResetAlarmActionRequest]()
            for structure0 in resetActionRequestsContainer {
                if let structure0 = structure0 {
                    resetActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        resetActionRequests = resetActionRequestsDecoded0
    }
}

extension BatchResetAlarmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchResetAlarmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchResetAlarmOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchResetAlarmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchResetAlarmOutputResponse(errorEntries: \(Swift.String(describing: errorEntries)))"}
}

extension BatchResetAlarmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchResetAlarmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchResetAlarmOutputResponse: Swift.Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchResetAlarmOutputResponseBody: Swift.Equatable {
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchResetAlarmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

public struct BatchSnoozeAlarmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchSnoozeAlarmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchSnoozeAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchSnoozeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchSnoozeAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchSnoozeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchSnoozeAlarmOutputError>
}

extension BatchSnoozeAlarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchSnoozeAlarmInput(snoozeActionRequests: \(Swift.String(describing: snoozeActionRequests)))"}
}

extension BatchSnoozeAlarmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snoozeActionRequests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snoozeActionRequests = snoozeActionRequests {
            var snoozeActionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snoozeActionRequests)
            for snoozealarmactionrequests0 in snoozeActionRequests {
                try snoozeActionRequestsContainer.encode(snoozealarmactionrequests0)
            }
        }
    }
}

public struct BatchSnoozeAlarmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchSnoozeAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchSnoozeAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchSnoozeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchSnoozeAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchSnoozeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchSnoozeAlarmOutputError>
}

public struct BatchSnoozeAlarmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchSnoozeAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchSnoozeAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchSnoozeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchSnoozeAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchSnoozeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchSnoozeAlarmOutputError>
}

public struct BatchSnoozeAlarmInput: Swift.Equatable {
    /// <p>The list of snooze action requests. You can specify up to 10 requests per operation.</p>
    public let snoozeActionRequests: [IotEventsDataClientTypes.SnoozeAlarmActionRequest]?

    public init (
        snoozeActionRequests: [IotEventsDataClientTypes.SnoozeAlarmActionRequest]? = nil
    )
    {
        self.snoozeActionRequests = snoozeActionRequests
    }
}

struct BatchSnoozeAlarmInputBody: Swift.Equatable {
    public let snoozeActionRequests: [IotEventsDataClientTypes.SnoozeAlarmActionRequest]?
}

extension BatchSnoozeAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snoozeActionRequests
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snoozeActionRequestsContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.SnoozeAlarmActionRequest?].self, forKey: .snoozeActionRequests)
        var snoozeActionRequestsDecoded0:[IotEventsDataClientTypes.SnoozeAlarmActionRequest]? = nil
        if let snoozeActionRequestsContainer = snoozeActionRequestsContainer {
            snoozeActionRequestsDecoded0 = [IotEventsDataClientTypes.SnoozeAlarmActionRequest]()
            for structure0 in snoozeActionRequestsContainer {
                if let structure0 = structure0 {
                    snoozeActionRequestsDecoded0?.append(structure0)
                }
            }
        }
        snoozeActionRequests = snoozeActionRequestsDecoded0
    }
}

extension BatchSnoozeAlarmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchSnoozeAlarmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchSnoozeAlarmOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchSnoozeAlarmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchSnoozeAlarmOutputResponse(errorEntries: \(Swift.String(describing: errorEntries)))"}
}

extension BatchSnoozeAlarmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchSnoozeAlarmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchSnoozeAlarmOutputResponse: Swift.Equatable {
    /// <p>A list of errors associated with the request, or <code>null</code> if there are no errors.
    /// Each error entry contains an entry ID that helps you identify the entry that failed.</p>
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?

    public init (
        errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchSnoozeAlarmOutputResponseBody: Swift.Equatable {
    public let errorEntries: [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]?
}

extension BatchSnoozeAlarmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.BatchAlarmActionErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IotEventsDataClientTypes.BatchAlarmActionErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IotEventsDataClientTypes.BatchAlarmActionErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension IotEventsDataClientTypes.BatchUpdateDetectorErrorEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case messageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IotEventsDataClientTypes.BatchUpdateDetectorErrorEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateDetectorErrorEntry(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), messageId: \(Swift.String(describing: messageId)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information about the error that occurred when attempting to update a detector.</p>
    public struct BatchUpdateDetectorErrorEntry: Swift.Equatable {
        /// <p>The error code.</p>
        public let errorCode: IotEventsDataClientTypes.ErrorCode?
        /// <p>A message that describes the error.</p>
        public let errorMessage: Swift.String?
        /// <p>The <code>"messageId"</code> of the update request that caused the error. (The value of
        ///       the <code>"messageId"</code> in the update request <code>"Detector"</code> object.)</p>
        public let messageId: Swift.String?

        public init (
            errorCode: IotEventsDataClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            messageId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.messageId = messageId
        }
    }

}

public struct BatchUpdateDetectorInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdateDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdateDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateDetectorOutputError>
}

extension BatchUpdateDetectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateDetectorInput(detectors: \(Swift.String(describing: detectors)))"}
}

extension BatchUpdateDetectorInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectors = detectors {
            var detectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectors)
            for updatedetectorrequests0 in detectors {
                try detectorsContainer.encode(updatedetectorrequests0)
            }
        }
    }
}

public struct BatchUpdateDetectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdateDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdateDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateDetectorOutputError>
}

public struct BatchUpdateDetectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchUpdateDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchUpdateDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchUpdateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchUpdateDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchUpdateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchUpdateDetectorOutputError>
}

public struct BatchUpdateDetectorInput: Swift.Equatable {
    /// <p>The list of detectors (instances) to update, along with the values to update.</p>
    public let detectors: [IotEventsDataClientTypes.UpdateDetectorRequest]?

    public init (
        detectors: [IotEventsDataClientTypes.UpdateDetectorRequest]? = nil
    )
    {
        self.detectors = detectors
    }
}

struct BatchUpdateDetectorInputBody: Swift.Equatable {
    public let detectors: [IotEventsDataClientTypes.UpdateDetectorRequest]?
}

extension BatchUpdateDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorsContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.UpdateDetectorRequest?].self, forKey: .detectors)
        var detectorsDecoded0:[IotEventsDataClientTypes.UpdateDetectorRequest]? = nil
        if let detectorsContainer = detectorsContainer {
            detectorsDecoded0 = [IotEventsDataClientTypes.UpdateDetectorRequest]()
            for structure0 in detectorsContainer {
                if let structure0 = structure0 {
                    detectorsDecoded0?.append(structure0)
                }
            }
        }
        detectors = detectorsDecoded0
    }
}

extension BatchUpdateDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUpdateDetectorOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateDetectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchUpdateDetectorOutputResponse(batchUpdateDetectorErrorEntries: \(Swift.String(describing: batchUpdateDetectorErrorEntries)))"}
}

extension BatchUpdateDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchUpdateDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchUpdateDetectorErrorEntries = output.batchUpdateDetectorErrorEntries
        } else {
            self.batchUpdateDetectorErrorEntries = nil
        }
    }
}

public struct BatchUpdateDetectorOutputResponse: Swift.Equatable {
    /// <p>A list of those detector updates that resulted in errors. (If an error is listed here, the
    ///       specific update did not occur.)</p>
    public let batchUpdateDetectorErrorEntries: [IotEventsDataClientTypes.BatchUpdateDetectorErrorEntry]?

    public init (
        batchUpdateDetectorErrorEntries: [IotEventsDataClientTypes.BatchUpdateDetectorErrorEntry]? = nil
    )
    {
        self.batchUpdateDetectorErrorEntries = batchUpdateDetectorErrorEntries
    }
}

struct BatchUpdateDetectorOutputResponseBody: Swift.Equatable {
    public let batchUpdateDetectorErrorEntries: [IotEventsDataClientTypes.BatchUpdateDetectorErrorEntry]?
}

extension BatchUpdateDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchUpdateDetectorErrorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchUpdateDetectorErrorEntriesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.BatchUpdateDetectorErrorEntry?].self, forKey: .batchUpdateDetectorErrorEntries)
        var batchUpdateDetectorErrorEntriesDecoded0:[IotEventsDataClientTypes.BatchUpdateDetectorErrorEntry]? = nil
        if let batchUpdateDetectorErrorEntriesContainer = batchUpdateDetectorErrorEntriesContainer {
            batchUpdateDetectorErrorEntriesDecoded0 = [IotEventsDataClientTypes.BatchUpdateDetectorErrorEntry]()
            for structure0 in batchUpdateDetectorErrorEntriesContainer {
                if let structure0 = structure0 {
                    batchUpdateDetectorErrorEntriesDecoded0?.append(structure0)
                }
            }
        }
        batchUpdateDetectorErrorEntries = batchUpdateDetectorErrorEntriesDecoded0
    }
}

extension IotEventsDataClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equal
        case greater
        case greaterOrEqual
        case less
        case lessOrEqual
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equal,
                .greater,
                .greaterOrEqual,
                .less,
                .lessOrEqual,
                .notEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greater: return "GREATER"
            case .greaterOrEqual: return "GREATER_OR_EQUAL"
            case .less: return "LESS"
            case .lessOrEqual: return "LESS_OR_EQUAL"
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsDataClientTypes.CustomerAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acknowledgeActionConfiguration
        case actionName
        case disableActionConfiguration
        case enableActionConfiguration
        case resetActionConfiguration
        case snoozeActionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acknowledgeActionConfiguration = acknowledgeActionConfiguration {
            try encodeContainer.encode(acknowledgeActionConfiguration, forKey: .acknowledgeActionConfiguration)
        }
        if let actionName = actionName {
            try encodeContainer.encode(actionName.rawValue, forKey: .actionName)
        }
        if let disableActionConfiguration = disableActionConfiguration {
            try encodeContainer.encode(disableActionConfiguration, forKey: .disableActionConfiguration)
        }
        if let enableActionConfiguration = enableActionConfiguration {
            try encodeContainer.encode(enableActionConfiguration, forKey: .enableActionConfiguration)
        }
        if let resetActionConfiguration = resetActionConfiguration {
            try encodeContainer.encode(resetActionConfiguration, forKey: .resetActionConfiguration)
        }
        if let snoozeActionConfiguration = snoozeActionConfiguration {
            try encodeContainer.encode(snoozeActionConfiguration, forKey: .snoozeActionConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.CustomerActionName.self, forKey: .actionName)
        actionName = actionNameDecoded
        let snoozeActionConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.SnoozeActionConfiguration.self, forKey: .snoozeActionConfiguration)
        snoozeActionConfiguration = snoozeActionConfigurationDecoded
        let enableActionConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.EnableActionConfiguration.self, forKey: .enableActionConfiguration)
        enableActionConfiguration = enableActionConfigurationDecoded
        let disableActionConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.DisableActionConfiguration.self, forKey: .disableActionConfiguration)
        disableActionConfiguration = disableActionConfigurationDecoded
        let acknowledgeActionConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.AcknowledgeActionConfiguration.self, forKey: .acknowledgeActionConfiguration)
        acknowledgeActionConfiguration = acknowledgeActionConfigurationDecoded
        let resetActionConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.ResetActionConfiguration.self, forKey: .resetActionConfiguration)
        resetActionConfiguration = resetActionConfigurationDecoded
    }
}

extension IotEventsDataClientTypes.CustomerAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerAction(acknowledgeActionConfiguration: \(Swift.String(describing: acknowledgeActionConfiguration)), actionName: \(Swift.String(describing: actionName)), disableActionConfiguration: \(Swift.String(describing: disableActionConfiguration)), enableActionConfiguration: \(Swift.String(describing: enableActionConfiguration)), resetActionConfiguration: \(Swift.String(describing: resetActionConfiguration)), snoozeActionConfiguration: \(Swift.String(describing: snoozeActionConfiguration)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains information about the action that you can take to respond to the alarm.</p>
    public struct CustomerAction: Swift.Equatable {
        /// <p>Contains the configuration information of an acknowledge action.</p>
        public let acknowledgeActionConfiguration: IotEventsDataClientTypes.AcknowledgeActionConfiguration?
        /// <p>The name of the action. The action name can be one of the following values:</p>
        ///          <ul>
        ///             <li>
        /// 			            <p>
        ///                   <code>SNOOZE</code> - When you snooze the alarm, the alarm state changes to <code>SNOOZE_DISABLED</code>.</p>
        /// 		          </li>
        ///             <li>
        /// 			            <p>
        ///                   <code>ENABLE</code> - When you enable the alarm, the alarm state changes to <code>NORMAL</code>.</p>
        /// 		          </li>
        ///             <li>
        /// 			            <p>
        ///                   <code>DISABLE</code> - When you disable the alarm, the alarm state changes to <code>DISABLED</code>.</p>
        /// 		          </li>
        ///             <li>
        /// 			            <p>
        ///                   <code>ACKNOWLEDGE</code> - When you acknowledge the alarm, the alarm state changes to <code>ACKNOWLEDGED</code>.</p>
        /// 		          </li>
        ///             <li>
        /// 			            <p>
        ///                   <code>RESET</code> - When you reset the alarm, the alarm state changes to <code>NORMAL</code>.</p>
        /// 		          </li>
        ///          </ul>
        ///          <p>For more information, see the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_AlarmState.html">AlarmState</a> API.</p>
        public let actionName: IotEventsDataClientTypes.CustomerActionName?
        /// <p>Contains the configuration information of a disable action.</p>
        public let disableActionConfiguration: IotEventsDataClientTypes.DisableActionConfiguration?
        /// <p>Contains the configuration information of an enable action.</p>
        public let enableActionConfiguration: IotEventsDataClientTypes.EnableActionConfiguration?
        /// <p>Contains the configuration information of a reset action.</p>
        public let resetActionConfiguration: IotEventsDataClientTypes.ResetActionConfiguration?
        /// <p>Contains the configuration information of a snooze action.</p>
        public let snoozeActionConfiguration: IotEventsDataClientTypes.SnoozeActionConfiguration?

        public init (
            acknowledgeActionConfiguration: IotEventsDataClientTypes.AcknowledgeActionConfiguration? = nil,
            actionName: IotEventsDataClientTypes.CustomerActionName? = nil,
            disableActionConfiguration: IotEventsDataClientTypes.DisableActionConfiguration? = nil,
            enableActionConfiguration: IotEventsDataClientTypes.EnableActionConfiguration? = nil,
            resetActionConfiguration: IotEventsDataClientTypes.ResetActionConfiguration? = nil,
            snoozeActionConfiguration: IotEventsDataClientTypes.SnoozeActionConfiguration? = nil
        )
        {
            self.acknowledgeActionConfiguration = acknowledgeActionConfiguration
            self.actionName = actionName
            self.disableActionConfiguration = disableActionConfiguration
            self.enableActionConfiguration = enableActionConfiguration
            self.resetActionConfiguration = resetActionConfiguration
            self.snoozeActionConfiguration = snoozeActionConfiguration
        }
    }

}

extension IotEventsDataClientTypes {
    public enum CustomerActionName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledge
        case disable
        case enable
        case reset
        case snooze
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerActionName] {
            return [
                .acknowledge,
                .disable,
                .enable,
                .reset,
                .snooze,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledge: return "ACKNOWLEDGE"
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case .reset: return "RESET"
            case .snooze: return "SNOOZE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomerActionName(rawValue: rawValue) ?? CustomerActionName.sdkUnknown(rawValue)
        }
    }
}

extension DescribeAlarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAlarmInput(alarmModelName: \(Swift.String(describing: alarmModelName)), keyValue: \(Swift.String(describing: keyValue)))"}
}

extension DescribeAlarmInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAlarmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlarmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlarmOutputError>
}

public struct DescribeAlarmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlarmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAlarmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlarmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyValue = input.operationInput.keyValue {
            let keyValueQueryItem = ClientRuntime.URLQueryItem(name: "keyValue".urlPercentEncoding(), value: Swift.String(keyValue).urlPercentEncoding())
            input.builder.withQueryItem(keyValueQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAlarmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlarmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlarmOutputError>
}

public struct DescribeAlarmInput: Swift.Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: Swift.String?
    /// <p>The value of the key used as a filter to select only the alarms associated with the
    /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
    public let keyValue: Swift.String?

    public init (
        alarmModelName: Swift.String? = nil,
        keyValue: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.keyValue = keyValue
    }
}

struct DescribeAlarmInputBody: Swift.Equatable {
}

extension DescribeAlarmInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAlarmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlarmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAlarmOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlarmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAlarmOutputResponse(alarm: \(Swift.String(describing: alarm)))"}
}

extension DescribeAlarmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAlarmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarm = output.alarm
        } else {
            self.alarm = nil
        }
    }
}

public struct DescribeAlarmOutputResponse: Swift.Equatable {
    /// <p>Contains information about an alarm.</p>
    public let alarm: IotEventsDataClientTypes.Alarm?

    public init (
        alarm: IotEventsDataClientTypes.Alarm? = nil
    )
    {
        self.alarm = alarm
    }
}

struct DescribeAlarmOutputResponseBody: Swift.Equatable {
    public let alarm: IotEventsDataClientTypes.Alarm?
}

extension DescribeAlarmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarm
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.Alarm.self, forKey: .alarm)
        alarm = alarmDecoded
    }
}

extension DescribeDetectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDetectorInput(detectorModelName: \(Swift.String(describing: detectorModelName)), keyValue: \(Swift.String(describing: keyValue)))"}
}

extension DescribeDetectorInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDetectorInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDetectorOutputError>
}

public struct DescribeDetectorInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDetectorInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyValue = input.operationInput.keyValue {
            let keyValueQueryItem = ClientRuntime.URLQueryItem(name: "keyValue".urlPercentEncoding(), value: Swift.String(keyValue).urlPercentEncoding())
            input.builder.withQueryItem(keyValueQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDetectorInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDetectorOutputError>
}

public struct DescribeDetectorInput: Swift.Equatable {
    /// <p>The name of the detector model whose detectors (instances) you want information
    ///       about.</p>
    public let detectorModelName: Swift.String?
    /// <p>A filter used to limit results to detectors (instances) created because of the given key
    ///       ID.</p>
    public let keyValue: Swift.String?

    public init (
        detectorModelName: Swift.String? = nil,
        keyValue: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.keyValue = keyValue
    }
}

struct DescribeDetectorInputBody: Swift.Equatable {
}

extension DescribeDetectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDetectorOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDetectorOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDetectorOutputResponse(detector: \(Swift.String(describing: detector)))"}
}

extension DescribeDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detector = output.detector
        } else {
            self.detector = nil
        }
    }
}

public struct DescribeDetectorOutputResponse: Swift.Equatable {
    /// <p>Information about the detector (instance).</p>
    public let detector: IotEventsDataClientTypes.Detector?

    public init (
        detector: IotEventsDataClientTypes.Detector? = nil
    )
    {
        self.detector = detector
    }
}

struct DescribeDetectorOutputResponseBody: Swift.Equatable {
    public let detector: IotEventsDataClientTypes.Detector?
}

extension DescribeDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detector
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.Detector.self, forKey: .detector)
        detector = detectorDecoded
    }
}

extension IotEventsDataClientTypes.Detector: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelName
        case detectorModelVersion
        case keyValue
        case lastUpdateTime
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.DetectorState.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IotEventsDataClientTypes.Detector: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Detector(creationTime: \(Swift.String(describing: creationTime)), detectorModelName: \(Swift.String(describing: detectorModelName)), detectorModelVersion: \(Swift.String(describing: detectorModelVersion)), keyValue: \(Swift.String(describing: keyValue)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), state: \(Swift.String(describing: state)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information about the detector (instance).</p>
    public struct Detector: Swift.Equatable {
        /// <p>The time the detector (instance) was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The name of the detector model that created this detector (instance).</p>
        public let detectorModelName: Swift.String?
        /// <p>The version of the detector model that created this detector (instance).</p>
        public let detectorModelVersion: Swift.String?
        /// <p>The value of the key (identifying the device or system) that caused the creation of this
        ///       detector (instance).</p>
        public let keyValue: Swift.String?
        /// <p>The time the detector (instance) was last updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The current state of the detector (instance).</p>
        public let state: IotEventsDataClientTypes.DetectorState?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            state: IotEventsDataClientTypes.DetectorState? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.state = state
        }
    }

}

extension IotEventsDataClientTypes.DetectorState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateName
        case timers
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateName = stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
        if let timers = timers {
            var timersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timers)
            for timers0 in timers {
                try timersContainer.encode(timers0)
            }
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for variables0 in variables {
                try variablesContainer.encode(variables0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateName)
        stateName = stateNameDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.Variable?].self, forKey: .variables)
        var variablesDecoded0:[IotEventsDataClientTypes.Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IotEventsDataClientTypes.Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let timersContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.Timer?].self, forKey: .timers)
        var timersDecoded0:[IotEventsDataClientTypes.Timer]? = nil
        if let timersContainer = timersContainer {
            timersDecoded0 = [IotEventsDataClientTypes.Timer]()
            for structure0 in timersContainer {
                if let structure0 = structure0 {
                    timersDecoded0?.append(structure0)
                }
            }
        }
        timers = timersDecoded0
    }
}

extension IotEventsDataClientTypes.DetectorState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorState(stateName: \(Swift.String(describing: stateName)), timers: \(Swift.String(describing: timers)), variables: \(Swift.String(describing: variables)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information about the current state of the detector instance.</p>
    public struct DetectorState: Swift.Equatable {
        /// <p>The name of the state.</p>
        public let stateName: Swift.String?
        /// <p>The current state of the detector's timers.</p>
        public let timers: [IotEventsDataClientTypes.Timer]?
        /// <p>The current values of the detector's variables.</p>
        public let variables: [IotEventsDataClientTypes.Variable]?

        public init (
            stateName: Swift.String? = nil,
            timers: [IotEventsDataClientTypes.Timer]? = nil,
            variables: [IotEventsDataClientTypes.Variable]? = nil
        )
        {
            self.stateName = stateName
            self.timers = timers
            self.variables = variables
        }
    }

}

extension IotEventsDataClientTypes.DetectorStateDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateName
        case timers
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateName = stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
        if let timers = timers {
            var timersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timers)
            for timerdefinitions0 in timers {
                try timersContainer.encode(timerdefinitions0)
            }
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for variabledefinitions0 in variables {
                try variablesContainer.encode(variabledefinitions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateName)
        stateName = stateNameDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.VariableDefinition?].self, forKey: .variables)
        var variablesDecoded0:[IotEventsDataClientTypes.VariableDefinition]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IotEventsDataClientTypes.VariableDefinition]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let timersContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.TimerDefinition?].self, forKey: .timers)
        var timersDecoded0:[IotEventsDataClientTypes.TimerDefinition]? = nil
        if let timersContainer = timersContainer {
            timersDecoded0 = [IotEventsDataClientTypes.TimerDefinition]()
            for structure0 in timersContainer {
                if let structure0 = structure0 {
                    timersDecoded0?.append(structure0)
                }
            }
        }
        timers = timersDecoded0
    }
}

extension IotEventsDataClientTypes.DetectorStateDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorStateDefinition(stateName: \(Swift.String(describing: stateName)), timers: \(Swift.String(describing: timers)), variables: \(Swift.String(describing: variables)))"}
}

extension IotEventsDataClientTypes {
    /// <p>The new state, variable values, and timer settings of the detector (instance).</p>
    public struct DetectorStateDefinition: Swift.Equatable {
        /// <p>The name of the new state of the detector (instance).</p>
        public let stateName: Swift.String?
        /// <p>The new values of the detector's timers. Any timer whose value isn't specified is cleared,
        ///       and its timeout event won't occur.</p>
        public let timers: [IotEventsDataClientTypes.TimerDefinition]?
        /// <p>The new values of the detector's variables. Any variable whose value isn't specified is
        ///       cleared.</p>
        public let variables: [IotEventsDataClientTypes.VariableDefinition]?

        public init (
            stateName: Swift.String? = nil,
            timers: [IotEventsDataClientTypes.TimerDefinition]? = nil,
            variables: [IotEventsDataClientTypes.VariableDefinition]? = nil
        )
        {
            self.stateName = stateName
            self.timers = timers
            self.variables = variables
        }
    }

}

extension IotEventsDataClientTypes.DetectorStateSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stateName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stateName = stateName {
            try encodeContainer.encode(stateName, forKey: .stateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateName)
        stateName = stateNameDecoded
    }
}

extension IotEventsDataClientTypes.DetectorStateSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorStateSummary(stateName: \(Swift.String(describing: stateName)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information about the detector state.</p>
    public struct DetectorStateSummary: Swift.Equatable {
        /// <p>The name of the state.</p>
        public let stateName: Swift.String?

        public init (
            stateName: Swift.String? = nil
        )
        {
            self.stateName = stateName
        }
    }

}

extension IotEventsDataClientTypes.DetectorSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case detectorModelName
        case detectorModelVersion
        case keyValue
        case lastUpdateTime
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let detectorModelVersion = detectorModelVersion {
            try encodeContainer.encode(detectorModelVersion, forKey: .detectorModelVersion)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let detectorModelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelVersion)
        detectorModelVersion = detectorModelVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.DetectorStateSummary.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension IotEventsDataClientTypes.DetectorSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectorSummary(creationTime: \(Swift.String(describing: creationTime)), detectorModelName: \(Swift.String(describing: detectorModelName)), detectorModelVersion: \(Swift.String(describing: detectorModelVersion)), keyValue: \(Swift.String(describing: keyValue)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), state: \(Swift.String(describing: state)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information about the detector (instance).</p>
    public struct DetectorSummary: Swift.Equatable {
        /// <p>The time the detector (instance) was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The name of the detector model that created this detector (instance).</p>
        public let detectorModelName: Swift.String?
        /// <p>The version of the detector model that created this detector (instance).</p>
        public let detectorModelVersion: Swift.String?
        /// <p>The value of the key (identifying the device or system) that caused the creation of this
        ///       detector (instance).</p>
        public let keyValue: Swift.String?
        /// <p>The time the detector (instance) was last updated.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The current state of the detector (instance).</p>
        public let state: IotEventsDataClientTypes.DetectorStateSummary?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            detectorModelName: Swift.String? = nil,
            detectorModelVersion: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            state: IotEventsDataClientTypes.DetectorStateSummary? = nil
        )
        {
            self.creationTime = creationTime
            self.detectorModelName = detectorModelName
            self.detectorModelVersion = detectorModelVersion
            self.keyValue = keyValue
            self.lastUpdateTime = lastUpdateTime
            self.state = state
        }
    }

}

extension IotEventsDataClientTypes.DisableActionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IotEventsDataClientTypes.DisableActionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableActionConfiguration(note: \(Swift.String(describing: note)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains the configuration information of a disable action.</p>
    public struct DisableActionConfiguration: Swift.Equatable {
        /// <p>The note that you can leave when you disable the alarm.</p>
        public let note: Swift.String?

        public init (
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }

}

extension IotEventsDataClientTypes.DisableAlarmActionRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IotEventsDataClientTypes.DisableAlarmActionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableAlarmActionRequest(alarmModelName: \(Swift.String(describing: alarmModelName)), keyValue: \(Swift.String(describing: keyValue)), note: \(Swift.String(describing: note)), requestId: \(Swift.String(describing: requestId)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information used to disable the alarm.</p>
    public struct DisableAlarmActionRequest: Swift.Equatable {
        /// <p>The name of the alarm model.</p>
        public let alarmModelName: Swift.String?
        /// <p>The value of the key used as a filter to select only the alarms associated with the
        /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
        public let keyValue: Swift.String?
        /// <p>The note that you can leave when you disable the alarm.</p>
        public let note: Swift.String?
        /// <p>The request ID. Each ID must be unique within each batch.</p>
        public let requestId: Swift.String?

        public init (
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }

}

extension IotEventsDataClientTypes.EnableActionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IotEventsDataClientTypes.EnableActionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableActionConfiguration(note: \(Swift.String(describing: note)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains the configuration information of an enable action.</p>
    public struct EnableActionConfiguration: Swift.Equatable {
        /// <p>The note that you can leave when you enable the alarm.</p>
        public let note: Swift.String?

        public init (
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }

}

extension IotEventsDataClientTypes.EnableAlarmActionRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IotEventsDataClientTypes.EnableAlarmActionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableAlarmActionRequest(alarmModelName: \(Swift.String(describing: alarmModelName)), keyValue: \(Swift.String(describing: keyValue)), note: \(Swift.String(describing: note)), requestId: \(Swift.String(describing: requestId)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information needed to enable the alarm.</p>
    public struct EnableAlarmActionRequest: Swift.Equatable {
        /// <p>The name of the alarm model.</p>
        public let alarmModelName: Swift.String?
        /// <p>The value of the key used as a filter to select only the alarms associated with the
        /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
        public let keyValue: Swift.String?
        /// <p>The note that you can leave when you enable the alarm.</p>
        public let note: Swift.String?
        /// <p>The request ID. Each ID must be unique within each batch.</p>
        public let requestId: Swift.String?

        public init (
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }

}

extension IotEventsDataClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalfailureexception
        case invalidrequestexception
        case resourcenotfoundexception
        case serviceunavailableexception
        case throttlingexception
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalfailureexception,
                .invalidrequestexception,
                .resourcenotfoundexception,
                .serviceunavailableexception,
                .throttlingexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalfailureexception: return "InternalFailureException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .serviceunavailableexception: return "ServiceUnavailableException"
            case .throttlingexception: return "ThrottlingException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsDataClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stateChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .stateChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stateChange: return "STATE_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(message: \(Swift.String(describing: message)))"}
}

extension InternalFailureException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal failure occurred.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was invalid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAlarmsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlarmsInput(alarmModelName: \(Swift.String(describing: alarmModelName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAlarmsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAlarmsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlarmsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlarmsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmsOutputError>
}

public struct ListAlarmsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAlarmsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAlarmsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAlarmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAlarmsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAlarmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAlarmsOutputError>
}

public struct ListAlarmsInput: Swift.Equatable {
    /// <p>The name of the alarm model.</p>
    public let alarmModelName: Swift.String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        alarmModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmModelName = alarmModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAlarmsInputBody: Swift.Equatable {
}

extension ListAlarmsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAlarmsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAlarmsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAlarmsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAlarmsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAlarmsOutputResponse(alarmSummaries: \(Swift.String(describing: alarmSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAlarmsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAlarmsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarmSummaries = output.alarmSummaries
            self.nextToken = output.nextToken
        } else {
            self.alarmSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAlarmsOutputResponse: Swift.Equatable {
    /// <p>A list that summarizes each alarm.</p>
    public let alarmSummaries: [IotEventsDataClientTypes.AlarmSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: Swift.String?

    public init (
        alarmSummaries: [IotEventsDataClientTypes.AlarmSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alarmSummaries = alarmSummaries
        self.nextToken = nextToken
    }
}

struct ListAlarmsOutputResponseBody: Swift.Equatable {
    public let alarmSummaries: [IotEventsDataClientTypes.AlarmSummary]?
    public let nextToken: Swift.String?
}

extension ListAlarmsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmSummariesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.AlarmSummary?].self, forKey: .alarmSummaries)
        var alarmSummariesDecoded0:[IotEventsDataClientTypes.AlarmSummary]? = nil
        if let alarmSummariesContainer = alarmSummariesContainer {
            alarmSummariesDecoded0 = [IotEventsDataClientTypes.AlarmSummary]()
            for structure0 in alarmSummariesContainer {
                if let structure0 = structure0 {
                    alarmSummariesDecoded0?.append(structure0)
                }
            }
        }
        alarmSummaries = alarmSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDetectorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDetectorsInput(detectorModelName: \(Swift.String(describing: detectorModelName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), stateName: \(Swift.String(describing: stateName)))"}
}

extension ListDetectorsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDetectorsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDetectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDetectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDetectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDetectorsOutputError>
}

public struct ListDetectorsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDetectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDetectorsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stateName = input.operationInput.stateName {
            let stateNameQueryItem = ClientRuntime.URLQueryItem(name: "stateName".urlPercentEncoding(), value: Swift.String(stateName).urlPercentEncoding())
            input.builder.withQueryItem(stateNameQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDetectorsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDetectorsOutputError>
}

public struct ListDetectorsInput: Swift.Equatable {
    /// <p>The name of the detector model whose detectors (instances) are listed.</p>
    public let detectorModelName: Swift.String?
    /// <p>The maximum number of results to be returned per request.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that you can use to return the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>A filter that limits results to those detectors (instances) in the given state.</p>
    public let stateName: Swift.String?

    public init (
        detectorModelName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stateName: Swift.String? = nil
    )
    {
        self.detectorModelName = detectorModelName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateName = stateName
    }
}

struct ListDetectorsInputBody: Swift.Equatable {
}

extension ListDetectorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectorsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDetectorsOutputResponse(detectorSummaries: \(Swift.String(describing: detectorSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorSummaries = output.detectorSummaries
            self.nextToken = output.nextToken
        } else {
            self.detectorSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorsOutputResponse: Swift.Equatable {
    /// <p>A list of summary information about the detectors (instances).</p>
    public let detectorSummaries: [IotEventsDataClientTypes.DetectorSummary]?
    /// <p>The token that you can use to return the next set of results,
    /// or <code>null</code> if there are no more results.</p>
    public let nextToken: Swift.String?

    public init (
        detectorSummaries: [IotEventsDataClientTypes.DetectorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorSummaries = detectorSummaries
        self.nextToken = nextToken
    }
}

struct ListDetectorsOutputResponseBody: Swift.Equatable {
    public let detectorSummaries: [IotEventsDataClientTypes.DetectorSummary]?
    public let nextToken: Swift.String?
}

extension ListDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorSummariesContainer = try containerValues.decodeIfPresent([IotEventsDataClientTypes.DetectorSummary?].self, forKey: .detectorSummaries)
        var detectorSummariesDecoded0:[IotEventsDataClientTypes.DetectorSummary]? = nil
        if let detectorSummariesContainer = detectorSummariesContainer {
            detectorSummariesDecoded0 = [IotEventsDataClientTypes.DetectorSummary]()
            for structure0 in detectorSummariesContainer {
                if let structure0 = structure0 {
                    detectorSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorSummaries = detectorSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IotEventsDataClientTypes.Message: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputName
        case messageId
        case payload
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputName = inputName {
            try encodeContainer.encode(inputName, forKey: .inputName)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let inputNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputName)
        inputName = inputNameDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .payload)
        payload = payloadDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.TimestampValue.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension IotEventsDataClientTypes.Message: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Message(inputName: \(Swift.String(describing: inputName)), messageId: \(Swift.String(describing: messageId)), payload: \(Swift.String(describing: payload)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information about a message.</p>
    public struct Message: Swift.Equatable {
        /// <p>The name of the input into which the message payload is transformed.</p>
        public let inputName: Swift.String?
        /// <p>The ID to assign to the message. Within each batch sent, each <code>"messageId"</code>
        ///       must be unique.</p>
        public let messageId: Swift.String?
        /// <p>The payload of the message. This can be a JSON string or a Base-64-encoded string
        ///       representing binary data (in which case you must decode it).</p>
        public let payload: ClientRuntime.Data?
        /// <p>The timestamp associated with the message.</p>
        public let timestamp: IotEventsDataClientTypes.TimestampValue?

        public init (
            inputName: Swift.String? = nil,
            messageId: Swift.String? = nil,
            payload: ClientRuntime.Data? = nil,
            timestamp: IotEventsDataClientTypes.TimestampValue? = nil
        )
        {
            self.inputName = inputName
            self.messageId = messageId
            self.payload = payload
            self.timestamp = timestamp
        }
    }

}

extension IotEventsDataClientTypes.ResetActionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IotEventsDataClientTypes.ResetActionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetActionConfiguration(note: \(Swift.String(describing: note)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains the configuration information of a reset action.</p>
    public struct ResetActionConfiguration: Swift.Equatable {
        /// <p>The note that you can leave when you reset the alarm.</p>
        public let note: Swift.String?

        public init (
            note: Swift.String? = nil
        )
        {
            self.note = note
        }
    }

}

extension IotEventsDataClientTypes.ResetAlarmActionRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IotEventsDataClientTypes.ResetAlarmActionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetAlarmActionRequest(alarmModelName: \(Swift.String(describing: alarmModelName)), keyValue: \(Swift.String(describing: keyValue)), note: \(Swift.String(describing: note)), requestId: \(Swift.String(describing: requestId)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information needed to reset the alarm.</p>
    public struct ResetAlarmActionRequest: Swift.Equatable {
        /// <p>The name of the alarm model.</p>
        public let alarmModelName: Swift.String?
        /// <p>The value of the key used as a filter to select only the alarms associated with the
        /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
        public let keyValue: Swift.String?
        /// <p>The note that you can leave when you reset the alarm.</p>
        public let note: Swift.String?
        /// <p>The request ID. Each ID must be unique within each batch.</p>
        public let requestId: Swift.String?

        public init (
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotEventsDataClientTypes.RuleEvaluation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleRuleEvaluation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleRuleEvaluation = simpleRuleEvaluation {
            try encodeContainer.encode(simpleRuleEvaluation, forKey: .simpleRuleEvaluation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleRuleEvaluationDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.SimpleRuleEvaluation.self, forKey: .simpleRuleEvaluation)
        simpleRuleEvaluation = simpleRuleEvaluationDecoded
    }
}

extension IotEventsDataClientTypes.RuleEvaluation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleEvaluation(simpleRuleEvaluation: \(Swift.String(describing: simpleRuleEvaluation)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information needed to evaluate data.</p>
    public struct RuleEvaluation: Swift.Equatable {
        /// <p>Information needed to compare two values with a comparison operator.</p>
        public let simpleRuleEvaluation: IotEventsDataClientTypes.SimpleRuleEvaluation?

        public init (
            simpleRuleEvaluation: IotEventsDataClientTypes.SimpleRuleEvaluation? = nil
        )
        {
            self.simpleRuleEvaluation = simpleRuleEvaluation
        }
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is currently unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotEventsDataClientTypes.SimpleRuleEvaluation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputPropertyValue
        case `operator` = "operator"
        case thresholdValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputPropertyValue = inputPropertyValue {
            try encodeContainer.encode(inputPropertyValue, forKey: .inputPropertyValue)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let thresholdValue = thresholdValue {
            try encodeContainer.encode(thresholdValue, forKey: .thresholdValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPropertyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPropertyValue)
        inputPropertyValue = inputPropertyValueDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.ComparisonOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let thresholdValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thresholdValue)
        thresholdValue = thresholdValueDecoded
    }
}

extension IotEventsDataClientTypes.SimpleRuleEvaluation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SimpleRuleEvaluation(inputPropertyValue: \(Swift.String(describing: inputPropertyValue)), operator: \(Swift.String(describing: `operator`)), thresholdValue: \(Swift.String(describing: thresholdValue)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information needed to compare two values with a comparison operator.</p>
    public struct SimpleRuleEvaluation: Swift.Equatable {
        /// <p>The comparison operator.</p>
        public let `operator`: IotEventsDataClientTypes.ComparisonOperator?
        /// <p>The value of the input property, on the left side of the comparison operator.</p>
        public let inputPropertyValue: Swift.String?
        /// <p>The threshold value, on the right side of the comparison operator.</p>
        public let thresholdValue: Swift.String?

        public init (
            `operator`: IotEventsDataClientTypes.ComparisonOperator? = nil,
            inputPropertyValue: Swift.String? = nil,
            thresholdValue: Swift.String? = nil
        )
        {
            self.`operator` = `operator`
            self.inputPropertyValue = inputPropertyValue
            self.thresholdValue = thresholdValue
        }
    }

}

extension IotEventsDataClientTypes.SnoozeActionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case note
        case snoozeDuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let snoozeDuration = snoozeDuration {
            try encodeContainer.encode(snoozeDuration, forKey: .snoozeDuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snoozeDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snoozeDuration)
        snoozeDuration = snoozeDurationDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
    }
}

extension IotEventsDataClientTypes.SnoozeActionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnoozeActionConfiguration(note: \(Swift.String(describing: note)), snoozeDuration: \(Swift.String(describing: snoozeDuration)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains the configuration information of a snooze action.</p>
    public struct SnoozeActionConfiguration: Swift.Equatable {
        /// <p>The note that you can leave when you snooze the alarm.</p>
        public let note: Swift.String?
        /// <p>The snooze time in seconds. The alarm automatically changes to the <code>NORMAL</code> state after this duration.</p>
        public let snoozeDuration: Swift.Int?

        public init (
            note: Swift.String? = nil,
            snoozeDuration: Swift.Int? = nil
        )
        {
            self.note = note
            self.snoozeDuration = snoozeDuration
        }
    }

}

extension IotEventsDataClientTypes.SnoozeAlarmActionRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmModelName
        case keyValue
        case note
        case requestId
        case snoozeDuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmModelName = alarmModelName {
            try encodeContainer.encode(alarmModelName, forKey: .alarmModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let note = note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let snoozeDuration = snoozeDuration {
            try encodeContainer.encode(snoozeDuration, forKey: .snoozeDuration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let alarmModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmModelName)
        alarmModelName = alarmModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
        let snoozeDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snoozeDuration)
        snoozeDuration = snoozeDurationDecoded
    }
}

extension IotEventsDataClientTypes.SnoozeAlarmActionRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnoozeAlarmActionRequest(alarmModelName: \(Swift.String(describing: alarmModelName)), keyValue: \(Swift.String(describing: keyValue)), note: \(Swift.String(describing: note)), requestId: \(Swift.String(describing: requestId)), snoozeDuration: \(Swift.String(describing: snoozeDuration)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information needed to snooze the alarm.</p>
    public struct SnoozeAlarmActionRequest: Swift.Equatable {
        /// <p>The name of the alarm model.</p>
        public let alarmModelName: Swift.String?
        /// <p>The value of the key used as a filter to select only the alarms associated with the
        /// <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_CreateAlarmModel.html#iotevents-CreateAlarmModel-request-key">key</a>.</p>
        public let keyValue: Swift.String?
        /// <p>The note that you can leave when you snooze the alarm.</p>
        public let note: Swift.String?
        /// <p>The request ID. Each ID must be unique within each batch.</p>
        public let requestId: Swift.String?
        /// <p>The snooze time in seconds. The alarm automatically changes to the <code>NORMAL</code> state after this duration.</p>
        public let snoozeDuration: Swift.Int?

        public init (
            alarmModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            note: Swift.String? = nil,
            requestId: Swift.String? = nil,
            snoozeDuration: Swift.Int? = nil
        )
        {
            self.alarmModelName = alarmModelName
            self.keyValue = keyValue
            self.note = note
            self.requestId = requestId
            self.snoozeDuration = snoozeDuration
        }
    }

}

extension IotEventsDataClientTypes.StateChangeConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case triggerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
    }
}

extension IotEventsDataClientTypes.StateChangeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StateChangeConfiguration(triggerType: \(Swift.String(describing: triggerType)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains the configuration information of alarm state changes.</p>
    public struct StateChangeConfiguration: Swift.Equatable {
        /// <p>The trigger type. If the value is <code>SNOOZE_TIMEOUT</code>, the snooze duration ends
        ///       and the alarm automatically changes to the <code>NORMAL</code> state.</p>
        public let triggerType: IotEventsDataClientTypes.TriggerType?

        public init (
            triggerType: IotEventsDataClientTypes.TriggerType? = nil
        )
        {
            self.triggerType = triggerType
        }
    }

}

extension IotEventsDataClientTypes.SystemEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventType
        case stateChangeConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let stateChangeConfiguration = stateChangeConfiguration {
            try encodeContainer.encode(stateChangeConfiguration, forKey: .stateChangeConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let stateChangeConfigurationDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.StateChangeConfiguration.self, forKey: .stateChangeConfiguration)
        stateChangeConfiguration = stateChangeConfigurationDecoded
    }
}

extension IotEventsDataClientTypes.SystemEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SystemEvent(eventType: \(Swift.String(describing: eventType)), stateChangeConfiguration: \(Swift.String(describing: stateChangeConfiguration)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains information about alarm state changes.</p>
    public struct SystemEvent: Swift.Equatable {
        /// <p>The event type. If the value is <code>STATE_CHANGE</code>, the event contains information
        ///       about alarm state changes.</p>
        public let eventType: IotEventsDataClientTypes.EventType?
        /// <p>Contains the configuration information of alarm state changes.</p>
        public let stateChangeConfiguration: IotEventsDataClientTypes.StateChangeConfiguration?

        public init (
            eventType: IotEventsDataClientTypes.EventType? = nil,
            stateChangeConfiguration: IotEventsDataClientTypes.StateChangeConfiguration? = nil
        )
        {
            self.eventType = eventType
            self.stateChangeConfiguration = stateChangeConfiguration
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be completed due to throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message for the exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IotEventsDataClientTypes.Timer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension IotEventsDataClientTypes.Timer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Timer(name: \(Swift.String(describing: name)), timestamp: \(Swift.String(describing: timestamp)))"}
}

extension IotEventsDataClientTypes {
    /// <p>The current state of a timer.</p>
    public struct Timer: Swift.Equatable {
        /// <p>The name of the timer.</p>
        public let name: Swift.String?
        /// <p>The number of seconds which have elapsed on the timer.</p>
        public let timestamp: ClientRuntime.Date?

        public init (
            name: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.name = name
            self.timestamp = timestamp
        }
    }

}

extension IotEventsDataClientTypes.TimerDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case seconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let seconds = seconds {
            try encodeContainer.encode(seconds, forKey: .seconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let secondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .seconds)
        seconds = secondsDecoded
    }
}

extension IotEventsDataClientTypes.TimerDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimerDefinition(name: \(Swift.String(describing: name)), seconds: \(Swift.String(describing: seconds)))"}
}

extension IotEventsDataClientTypes {
    /// <p>The new setting of a timer.</p>
    public struct TimerDefinition: Swift.Equatable {
        /// <p>The name of the timer.</p>
        public let name: Swift.String?
        /// <p>The new setting of the timer (the number of seconds before the timer elapses).</p>
        public let seconds: Swift.Int?

        public init (
            name: Swift.String? = nil,
            seconds: Swift.Int? = nil
        )
        {
            self.name = name
            self.seconds = seconds
        }
    }

}

extension IotEventsDataClientTypes.TimestampValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeInMillis
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeInMillis = timeInMillis {
            try encodeContainer.encode(timeInMillis, forKey: .timeInMillis)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeInMillis)
        timeInMillis = timeInMillisDecoded
    }
}

extension IotEventsDataClientTypes.TimestampValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimestampValue(timeInMillis: \(Swift.String(describing: timeInMillis)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Contains information about a timestamp.</p>
    public struct TimestampValue: Swift.Equatable {
        /// <p>The value of the timestamp, in the Unix epoch format.</p>
        public let timeInMillis: Swift.Int?

        public init (
            timeInMillis: Swift.Int? = nil
        )
        {
            self.timeInMillis = timeInMillis
        }
    }

}

extension IotEventsDataClientTypes {
    public enum TriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case snoozeTimeout
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .snoozeTimeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .snoozeTimeout: return "SNOOZE_TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
        }
    }
}

extension IotEventsDataClientTypes.UpdateDetectorRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorModelName
        case keyValue
        case messageId
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorModelName = detectorModelName {
            try encodeContainer.encode(detectorModelName, forKey: .detectorModelName)
        }
        if let keyValue = keyValue {
            try encodeContainer.encode(keyValue, forKey: .keyValue)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let detectorModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorModelName)
        detectorModelName = detectorModelNameDecoded
        let keyValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyValue)
        keyValue = keyValueDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IotEventsDataClientTypes.DetectorStateDefinition.self, forKey: .state)
        state = stateDecoded
    }
}

extension IotEventsDataClientTypes.UpdateDetectorRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDetectorRequest(detectorModelName: \(Swift.String(describing: detectorModelName)), keyValue: \(Swift.String(describing: keyValue)), messageId: \(Swift.String(describing: messageId)), state: \(Swift.String(describing: state)))"}
}

extension IotEventsDataClientTypes {
    /// <p>Information used to update the detector (instance).</p>
    public struct UpdateDetectorRequest: Swift.Equatable {
        /// <p>The name of the detector model that created the detectors (instances).</p>
        public let detectorModelName: Swift.String?
        /// <p>The value of the input key attribute (identifying the device or system) that caused the
        ///       creation of this detector (instance).</p>
        public let keyValue: Swift.String?
        /// <p>The ID to assign to the detector update <code>"message"</code>. Each
        ///         <code>"messageId"</code> must be unique within each batch sent.</p>
        public let messageId: Swift.String?
        /// <p>The new state, variable values, and timer settings of the detector (instance).</p>
        public let state: IotEventsDataClientTypes.DetectorStateDefinition?

        public init (
            detectorModelName: Swift.String? = nil,
            keyValue: Swift.String? = nil,
            messageId: Swift.String? = nil,
            state: IotEventsDataClientTypes.DetectorStateDefinition? = nil
        )
        {
            self.detectorModelName = detectorModelName
            self.keyValue = keyValue
            self.messageId = messageId
            self.state = state
        }
    }

}

extension IotEventsDataClientTypes.Variable: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IotEventsDataClientTypes.Variable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Variable(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension IotEventsDataClientTypes {
    /// <p>The current state of the variable.</p>
    public struct Variable: Swift.Equatable {
        /// <p>The name of the variable.</p>
        public let name: Swift.String?
        /// <p>The current value of the variable.</p>
        public let value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IotEventsDataClientTypes.VariableDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IotEventsDataClientTypes.VariableDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VariableDefinition(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension IotEventsDataClientTypes {
    /// <p>The new value of the variable.</p>
    public struct VariableDefinition: Swift.Equatable {
        /// <p>The name of the variable.</p>
        public let name: Swift.String?
        /// <p>The new value of the variable.</p>
        public let value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}
