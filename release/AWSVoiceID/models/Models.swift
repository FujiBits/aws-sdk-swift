// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient permissions to perform this action. Check the error message and try
///             again.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIdClientTypes.AuthenticationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceThreshold = "AcceptanceThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptanceThreshold = acceptanceThreshold {
            try encodeContainer.encode(acceptanceThreshold, forKey: .acceptanceThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptanceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceptanceThreshold)
        acceptanceThreshold = acceptanceThresholdDecoded
    }
}

extension VoiceIdClientTypes.AuthenticationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthenticationConfiguration(acceptanceThreshold: \(Swift.String(describing: acceptanceThreshold)))"}
}

extension VoiceIdClientTypes {
    /// The configuration used to authenticate a speaker during a session.
    public struct AuthenticationConfiguration: Swift.Equatable {
        /// The minimum threshold needed to successfully authenticate a speaker.
        /// This member is required.
        public var acceptanceThreshold: Swift.Int?

        public init (
            acceptanceThreshold: Swift.Int? = nil
        )
        {
            self.acceptanceThreshold = acceptanceThreshold
        }
    }

}

extension VoiceIdClientTypes {
    public enum AuthenticationDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case notEnoughSpeech
        case reject
        case speakerIdNotProvided
        case speakerNotEnrolled
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationDecision] {
            return [
                .accept,
                .notEnoughSpeech,
                .reject,
                .speakerIdNotProvided,
                .speakerNotEnrolled,
                .speakerOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case .reject: return "REJECT"
            case .speakerIdNotProvided: return "SPEAKER_ID_NOT_PROVIDED"
            case .speakerNotEnrolled: return "SPEAKER_NOT_ENROLLED"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationDecision(rawValue: rawValue) ?? AuthenticationDecision.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.AuthenticationResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioAggregationEndedAt = "AudioAggregationEndedAt"
        case audioAggregationStartedAt = "AudioAggregationStartedAt"
        case authenticationResultId = "AuthenticationResultId"
        case configuration = "Configuration"
        case customerSpeakerId = "CustomerSpeakerId"
        case decision = "Decision"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioAggregationEndedAt = audioAggregationEndedAt {
            try encodeContainer.encode(audioAggregationEndedAt.timeIntervalSince1970, forKey: .audioAggregationEndedAt)
        }
        if let audioAggregationStartedAt = audioAggregationStartedAt {
            try encodeContainer.encode(audioAggregationStartedAt.timeIntervalSince1970, forKey: .audioAggregationStartedAt)
        }
        if let authenticationResultId = authenticationResultId {
            try encodeContainer.encode(authenticationResultId, forKey: .authenticationResultId)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let customerSpeakerId = customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let decision = decision {
            try encodeContainer.encode(decision.rawValue, forKey: .decision)
        }
        if let generatedSpeakerId = generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationResultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationResultId)
        authenticationResultId = authenticationResultIdDecoded
        let audioAggregationStartedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .audioAggregationStartedAt)
        audioAggregationStartedAt = audioAggregationStartedAtDecoded
        let audioAggregationEndedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .audioAggregationEndedAt)
        audioAggregationEndedAt = audioAggregationEndedAtDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let decisionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.AuthenticationDecision.self, forKey: .decision)
        decision = decisionDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .score)
        score = scoreDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.AuthenticationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension VoiceIdClientTypes.AuthenticationResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthenticationResult(audioAggregationEndedAt: \(Swift.String(describing: audioAggregationEndedAt)), audioAggregationStartedAt: \(Swift.String(describing: audioAggregationStartedAt)), authenticationResultId: \(Swift.String(describing: authenticationResultId)), configuration: \(Swift.String(describing: configuration)), customerSpeakerId: \(Swift.String(describing: customerSpeakerId)), decision: \(Swift.String(describing: decision)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), score: \(Swift.String(describing: score)))"}
}

extension VoiceIdClientTypes {
    /// The authentication result produced by Voice ID, processed against the current session state and streamed
    ///             audio of the speaker.
    public struct AuthenticationResult: Swift.Equatable {
        /// A timestamp indicating when audio aggregation ended for this authentication result.
        public var audioAggregationEndedAt: ClientRuntime.Date?
        /// A timestamp indicating when audio aggregation started for this authentication result.
        public var audioAggregationStartedAt: ClientRuntime.Date?
        /// The unique identifier for this authentication result. Because there can be multiple authentications
        ///             for a given session, this field helps to identify if the returned result is from a previous streaming
        ///             activity or a new result. Note that in absence of any new streaming activity,
        ///             AcceptanceThreshold changes, or SpeakerId changes, Voice ID
        ///             always returns cached Authentication Result for this API.
        public var authenticationResultId: Swift.String?
        /// The AuthenticationConfiguration used to generate this authentication result.
        public var configuration: VoiceIdClientTypes.AuthenticationConfiguration?
        /// The client-provided identifier for the speaker whose authentication result is produced. Only present if a
        ///             SpeakerId is provided for the session.
        public var customerSpeakerId: Swift.String?
        /// The authentication decision produced by Voice ID, processed against the current session state and streamed
        ///             audio of the speaker.
        public var decision: VoiceIdClientTypes.AuthenticationDecision?
        /// The service-generated identifier for the speaker whose authentication result is produced.
        public var generatedSpeakerId: Swift.String?
        /// The authentication score for the speaker whose authentication result is produced. This value is
        ///             only present if the authentication decision is either ACCEPT or REJECT.
        public var score: Swift.Int?

        public init (
            audioAggregationEndedAt: ClientRuntime.Date? = nil,
            audioAggregationStartedAt: ClientRuntime.Date? = nil,
            authenticationResultId: Swift.String? = nil,
            configuration: VoiceIdClientTypes.AuthenticationConfiguration? = nil,
            customerSpeakerId: Swift.String? = nil,
            decision: VoiceIdClientTypes.AuthenticationDecision? = nil,
            generatedSpeakerId: Swift.String? = nil,
            score: Swift.Int? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.authenticationResultId = authenticationResultId
            self.configuration = configuration
            self.customerSpeakerId = customerSpeakerId
            self.decision = decision
            self.generatedSpeakerId = generatedSpeakerId
            self.score = score
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(conflictType: \(Swift.String(describing: conflictType)), message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.conflictType = output.conflictType
            self.message = output.message
        } else {
            self.conflictType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to a conflict. Check the ConflictType and error message for
///             more details.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The type of conflict which caused a ConflictException. Possible types and the corresponding error messages
    ///             are as follows:
    ///
    ///
    ///
    ///                   DOMAIN_NOT_ACTIVE: The domain is not active.
    ///
    ///
    ///
    ///                   CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT: You cannot change the speaker ID after an enrollment has been requested.
    ///
    ///
    ///
    ///                   ENROLLMENT_ALREADY_EXISTS: There is already an enrollment for this session.
    ///
    ///
    ///
    ///                   SPEAKER_NOT_SET: You must set the speaker ID before requesting an enrollment.
    ///
    ///
    ///
    ///                   SPEAKER_OPTED_OUT: You cannot request an enrollment for an opted out speaker.
    ///
    ///
    ///
    ///                   CONCURRENT_CHANGES: The request could not be processed as the resource was modified by another request during execution.
    ///
    ///
    public var conflictType: VoiceIdClientTypes.ConflictType?
    public var message: Swift.String?

    public init (
        conflictType: VoiceIdClientTypes.ConflictType? = nil,
        message: Swift.String? = nil
    )
    {
        self.conflictType = conflictType
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let conflictType: VoiceIdClientTypes.ConflictType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictType = "ConflictType"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let conflictTypeDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ConflictType.self, forKey: .conflictType)
        conflictType = conflictTypeDecoded
    }
}

extension VoiceIdClientTypes {
    public enum ConflictType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anotherActiveStream
        case cannotChangeSpeakerAfterEnrollment
        case concurrentChanges
        case domainNotActive
        case enrollmentAlreadyExists
        case speakerNotSet
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictType] {
            return [
                .anotherActiveStream,
                .cannotChangeSpeakerAfterEnrollment,
                .concurrentChanges,
                .domainNotActive,
                .enrollmentAlreadyExists,
                .speakerNotSet,
                .speakerOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anotherActiveStream: return "ANOTHER_ACTIVE_STREAM"
            case .cannotChangeSpeakerAfterEnrollment: return "CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT"
            case .concurrentChanges: return "CONCURRENT_CHANGES"
            case .domainNotActive: return "DOMAIN_NOT_ACTIVE"
            case .enrollmentAlreadyExists: return "ENROLLMENT_ALREADY_EXISTS"
            case .speakerNotSet: return "SPEAKER_NOT_SET"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictType(rawValue: rawValue) ?? ConflictType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

extension CreateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInput: Swift.Equatable {
    /// The idempotency token for creating a new domain. If not provided, Amazon Web Services SDK populates
    ///             this field.
    public var clientToken: Swift.String?
    /// A brief description of this domain.
    public var description: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS Key Identifier, to be used by Voice ID for
    ///             the server-side encryption of your data. Refer to <a href="https://docs.aws.amazon.com/connect/latest/adminguide/encryption-at-rest.html#encryption-at-rest-voiceid">
    ///                 Amazon Connect VoiceID encryption at rest for more details on how the KMS Key is used.
    ///
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
    /// A list of tags you want added to the domain.
    public var tags: [VoiceIdClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [VoiceIdClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
    public let clientToken: Swift.String?
    public let tags: [VoiceIdClientTypes.Tag]?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIdClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIdClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainOutputResponse(domain: \(Swift.String(describing: domain)))"}
}

extension CreateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct CreateDomainOutputResponse: Swift.Equatable {
    /// Information about the newly created domain.
    public var domain: VoiceIdClientTypes.Domain?

    public init (
        domain: VoiceIdClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct CreateDomainOutputResponseBody: Swift.Equatable {
    public let domain: VoiceIdClientTypes.Domain?
}

extension CreateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DeleteDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDomainInput(domainId: \(Swift.String(describing: domainId)))"}
}

extension DeleteDomainInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInput: Swift.Equatable {
    /// The identifier of the domain you want to delete.
    /// This member is required.
    public var domainId: Swift.String?

    public init (
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDomainOutputResponse()"}
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDomainOutputResponseBody: Swift.Equatable {
}

extension DeleteDomainOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFraudsterInput(domainId: \(Swift.String(describing: domainId)), fraudsterId: \(Swift.String(describing: fraudsterId)))"}
}

extension DeleteFraudsterInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteFraudsterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFraudsterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFraudsterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFraudsterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFraudsterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFraudsterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFraudsterOutputError>
}

public struct DeleteFraudsterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFraudsterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFraudsterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFraudsterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFraudsterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFraudsterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFraudsterOutputError>
}

public struct DeleteFraudsterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFraudsterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteFraudsterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFraudsterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFraudsterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFraudsterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFraudsterOutputError>
}

public struct DeleteFraudsterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFraudsterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteFraudsterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFraudsterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFraudsterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFraudsterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFraudsterOutputError>
}

public struct DeleteFraudsterInput: Swift.Equatable {
    /// The identifier of the domain containing the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you want to delete.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

struct DeleteFraudsterInputBody: Swift.Equatable {
}

extension DeleteFraudsterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFraudsterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFraudsterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFraudsterOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFraudsterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFraudsterOutputResponse()"}
}

extension DeleteFraudsterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFraudsterOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFraudsterOutputResponseBody: Swift.Equatable {
}

extension DeleteFraudsterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \(Swift.String(describing: speakerId)))"}
}

extension DeleteSpeakerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSpeakerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSpeakerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSpeakerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSpeakerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSpeakerOutputError>
}

public struct DeleteSpeakerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSpeakerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSpeakerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSpeakerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSpeakerOutputError>
}

public struct DeleteSpeakerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSpeakerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteSpeakerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSpeakerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSpeakerOutputError>
}

public struct DeleteSpeakerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSpeakerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteSpeakerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSpeakerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSpeakerOutputError>
}

public struct DeleteSpeakerInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want to delete.
    /// This member is required.
    public var speakerId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct DeleteSpeakerInputBody: Swift.Equatable {
}

extension DeleteSpeakerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSpeakerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSpeakerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSpeakerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSpeakerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSpeakerOutputResponse()"}
}

extension DeleteSpeakerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSpeakerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSpeakerOutputResponseBody: Swift.Equatable {
}

extension DeleteSpeakerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainInput(domainId: \(Swift.String(describing: domainId)))"}
}

extension DescribeDomainInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInput: Swift.Equatable {
    /// The identifier of the domain you are describing.
    /// This member is required.
    public var domainId: Swift.String?

    public init (
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
}

extension DescribeDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainOutputResponse(domain: \(Swift.String(describing: domain)))"}
}

extension DescribeDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DescribeDomainOutputResponse: Swift.Equatable {
    /// Information about the specified domain.
    public var domain: VoiceIdClientTypes.Domain?

    public init (
        domain: VoiceIdClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct DescribeDomainOutputResponseBody: Swift.Equatable {
    public let domain: VoiceIdClientTypes.Domain?
}

extension DescribeDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DescribeFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFraudsterInput(domainId: \(Swift.String(describing: domainId)), fraudsterId: \(Swift.String(describing: fraudsterId)))"}
}

extension DescribeFraudsterInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeFraudsterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFraudsterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFraudsterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFraudsterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFraudsterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFraudsterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFraudsterOutputError>
}

public struct DescribeFraudsterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFraudsterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFraudsterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFraudsterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFraudsterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFraudsterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFraudsterOutputError>
}

public struct DescribeFraudsterInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFraudsterInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeFraudsterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFraudsterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFraudsterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFraudsterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFraudsterOutputError>
}

public struct DescribeFraudsterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFraudsterInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeFraudsterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFraudsterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFraudsterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFraudsterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFraudsterOutputError>
}

public struct DescribeFraudsterInput: Swift.Equatable {
    /// The identifier of the domain containing the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you are describing.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

struct DescribeFraudsterInputBody: Swift.Equatable {
}

extension DescribeFraudsterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFraudsterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFraudsterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFraudsterOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFraudsterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFraudsterOutputResponse(fraudster: \(Swift.String(describing: fraudster)))"}
}

extension DescribeFraudsterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFraudsterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fraudster = output.fraudster
        } else {
            self.fraudster = nil
        }
    }
}

public struct DescribeFraudsterOutputResponse: Swift.Equatable {
    /// Information about the specified fraudster.
    public var fraudster: VoiceIdClientTypes.Fraudster?

    public init (
        fraudster: VoiceIdClientTypes.Fraudster? = nil
    )
    {
        self.fraudster = fraudster
    }
}

struct DescribeFraudsterOutputResponseBody: Swift.Equatable {
    public let fraudster: VoiceIdClientTypes.Fraudster?
}

extension DescribeFraudsterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudster = "Fraudster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudsterDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Fraudster.self, forKey: .fraudster)
        fraudster = fraudsterDecoded
    }
}

extension DescribeFraudsterRegistrationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFraudsterRegistrationJobInput(domainId: \(Swift.String(describing: domainId)), jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeFraudsterRegistrationJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeFraudsterRegistrationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFraudsterRegistrationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFraudsterRegistrationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFraudsterRegistrationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFraudsterRegistrationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFraudsterRegistrationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFraudsterRegistrationJobOutputError>
}

public struct DescribeFraudsterRegistrationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFraudsterRegistrationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFraudsterRegistrationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFraudsterRegistrationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFraudsterRegistrationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFraudsterRegistrationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFraudsterRegistrationJobOutputError>
}

public struct DescribeFraudsterRegistrationJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFraudsterRegistrationJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeFraudsterRegistrationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFraudsterRegistrationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFraudsterRegistrationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFraudsterRegistrationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFraudsterRegistrationJobOutputError>
}

public struct DescribeFraudsterRegistrationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFraudsterRegistrationJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeFraudsterRegistrationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFraudsterRegistrationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFraudsterRegistrationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFraudsterRegistrationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFraudsterRegistrationJobOutputError>
}

public struct DescribeFraudsterRegistrationJobInput: Swift.Equatable {
    /// The identifier for the domain containing the fraudster registration job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier for the fraudster registration job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

struct DescribeFraudsterRegistrationJobInputBody: Swift.Equatable {
}

extension DescribeFraudsterRegistrationJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFraudsterRegistrationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFraudsterRegistrationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFraudsterRegistrationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFraudsterRegistrationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFraudsterRegistrationJobOutputResponse(job: \(Swift.String(describing: job)))"}
}

extension DescribeFraudsterRegistrationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFraudsterRegistrationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeFraudsterRegistrationJobOutputResponse: Swift.Equatable {
    /// Contains details about the specified fraudster registration job.
    public var job: VoiceIdClientTypes.FraudsterRegistrationJob?

    public init (
        job: VoiceIdClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

struct DescribeFraudsterRegistrationJobOutputResponseBody: Swift.Equatable {
    public let job: VoiceIdClientTypes.FraudsterRegistrationJob?
}

extension DescribeFraudsterRegistrationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudsterRegistrationJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSpeakerEnrollmentJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSpeakerEnrollmentJobInput(domainId: \(Swift.String(describing: domainId)), jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeSpeakerEnrollmentJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeSpeakerEnrollmentJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSpeakerEnrollmentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSpeakerEnrollmentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSpeakerEnrollmentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSpeakerEnrollmentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSpeakerEnrollmentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSpeakerEnrollmentJobOutputError>
}

public struct DescribeSpeakerEnrollmentJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSpeakerEnrollmentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSpeakerEnrollmentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSpeakerEnrollmentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSpeakerEnrollmentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSpeakerEnrollmentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSpeakerEnrollmentJobOutputError>
}

public struct DescribeSpeakerEnrollmentJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSpeakerEnrollmentJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeSpeakerEnrollmentJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSpeakerEnrollmentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSpeakerEnrollmentJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSpeakerEnrollmentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSpeakerEnrollmentJobOutputError>
}

public struct DescribeSpeakerEnrollmentJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSpeakerEnrollmentJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeSpeakerEnrollmentJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSpeakerEnrollmentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSpeakerEnrollmentJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSpeakerEnrollmentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSpeakerEnrollmentJobOutputError>
}

public struct DescribeSpeakerEnrollmentJobInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker enrollment job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker enrollment job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

struct DescribeSpeakerEnrollmentJobInputBody: Swift.Equatable {
}

extension DescribeSpeakerEnrollmentJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSpeakerEnrollmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSpeakerEnrollmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSpeakerEnrollmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSpeakerEnrollmentJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSpeakerEnrollmentJobOutputResponse(job: \(Swift.String(describing: job)))"}
}

extension DescribeSpeakerEnrollmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSpeakerEnrollmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeSpeakerEnrollmentJobOutputResponse: Swift.Equatable {
    /// Contains details about the specified speaker enrollment job.
    public var job: VoiceIdClientTypes.SpeakerEnrollmentJob?

    public init (
        job: VoiceIdClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

struct DescribeSpeakerEnrollmentJobOutputResponseBody: Swift.Equatable {
    public let job: VoiceIdClientTypes.SpeakerEnrollmentJob?
}

extension DescribeSpeakerEnrollmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerEnrollmentJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \(Swift.String(describing: speakerId)))"}
}

extension DescribeSpeakerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeSpeakerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSpeakerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSpeakerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSpeakerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSpeakerOutputError>
}

public struct DescribeSpeakerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSpeakerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSpeakerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSpeakerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSpeakerOutputError>
}

public struct DescribeSpeakerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSpeakerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeSpeakerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSpeakerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSpeakerOutputError>
}

public struct DescribeSpeakerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSpeakerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeSpeakerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSpeakerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSpeakerOutputError>
}

public struct DescribeSpeakerInput: Swift.Equatable {
    /// The identifier of the domain that contains the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you are describing.
    /// This member is required.
    public var speakerId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct DescribeSpeakerInputBody: Swift.Equatable {
}

extension DescribeSpeakerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSpeakerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSpeakerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSpeakerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSpeakerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSpeakerOutputResponse(speaker: \(Swift.String(describing: speaker)))"}
}

extension DescribeSpeakerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSpeakerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.speaker = output.speaker
        } else {
            self.speaker = nil
        }
    }
}

public struct DescribeSpeakerOutputResponse: Swift.Equatable {
    /// Information about the specified speaker.
    public var speaker: VoiceIdClientTypes.Speaker?

    public init (
        speaker: VoiceIdClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

struct DescribeSpeakerOutputResponseBody: Swift.Equatable {
    public let speaker: VoiceIdClientTypes.Speaker?
}

extension DescribeSpeakerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speaker = "Speaker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Speaker.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

extension VoiceIdClientTypes.Domain: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case domainId = "DomainId"
        case domainStatus = "DomainStatus"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainStatus = domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIdClientTypes.Domain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Domain(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), domainId: \(Swift.String(describing: domainId)), domainStatus: \(Swift.String(describing: domainStatus)), name: \(Swift.String(describing: name)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension VoiceIdClientTypes {
    /// Contains all the information about a domain.
    public struct Domain: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp at which the domain is created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided description of the domain.
        public var description: Swift.String?
        /// The service-generated identifier for the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIdClientTypes.DomainStatus?
        /// The client-provided name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS Key Identifier you want Voice ID to use
        ///             to encrypt your data.
        public var serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
        /// The timestamp showing the domain's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIdClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIdClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .pending,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.DomainSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case domainId = "DomainId"
        case domainStatus = "DomainStatus"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainStatus = domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIdClientTypes.DomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), domainId: \(Swift.String(describing: domainId)), domainStatus: \(Swift.String(describing: domainStatus)), name: \(Swift.String(describing: name)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension VoiceIdClientTypes {
    /// Contains a summary of information about a domain.
    public struct DomainSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp showing when the domain is created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided description of the domain.
        public var description: Swift.String?
        /// The service-generated identifier for the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIdClientTypes.DomainStatus?
        /// The client-provided name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS Key Identifier you want Voice ID to use
        ///             to encrypt your data..
        public var serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
        /// The timestamp showing the domain's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIdClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIdClientTypes {
    public enum DuplicateRegistrationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registerAsNew
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [DuplicateRegistrationAction] {
            return [
                .registerAsNew,
                .skip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registerAsNew: return "REGISTER_AS_NEW"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DuplicateRegistrationAction(rawValue: rawValue) ?? DuplicateRegistrationAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.EnrollmentConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case existingEnrollmentAction = "ExistingEnrollmentAction"
        case fraudDetectionConfig = "FraudDetectionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let existingEnrollmentAction = existingEnrollmentAction {
            try encodeContainer.encode(existingEnrollmentAction.rawValue, forKey: .existingEnrollmentAction)
        }
        if let fraudDetectionConfig = fraudDetectionConfig {
            try encodeContainer.encode(fraudDetectionConfig, forKey: .fraudDetectionConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let existingEnrollmentActionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ExistingEnrollmentAction.self, forKey: .existingEnrollmentAction)
        existingEnrollmentAction = existingEnrollmentActionDecoded
        let fraudDetectionConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.EnrollmentJobFraudDetectionConfig.self, forKey: .fraudDetectionConfig)
        fraudDetectionConfig = fraudDetectionConfigDecoded
    }
}

extension VoiceIdClientTypes.EnrollmentConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnrollmentConfig(existingEnrollmentAction: \(Swift.String(describing: existingEnrollmentAction)), fraudDetectionConfig: \(Swift.String(describing: fraudDetectionConfig)))"}
}

extension VoiceIdClientTypes {
    /// Contains configurations defining enrollment behavior for the batch job.
    public struct EnrollmentConfig: Swift.Equatable {
        ///  The action to take when the specified speaker is already enrolled in the specified domain. The default
        ///             value is SKIP, which skips the enrollment for the existing speaker. Setting the value to
        ///             OVERWRITE replaces the existing voice prints and enrollment audio stored for that speaker
        ///             with new data generated from the latest audio.
        public var existingEnrollmentAction: VoiceIdClientTypes.ExistingEnrollmentAction?
        /// The fraud detection configuration to use for the speaker enrollment job.
        public var fraudDetectionConfig: VoiceIdClientTypes.EnrollmentJobFraudDetectionConfig?

        public init (
            existingEnrollmentAction: VoiceIdClientTypes.ExistingEnrollmentAction? = nil,
            fraudDetectionConfig: VoiceIdClientTypes.EnrollmentJobFraudDetectionConfig? = nil
        )
        {
            self.existingEnrollmentAction = existingEnrollmentAction
            self.fraudDetectionConfig = fraudDetectionConfig
        }
    }

}

extension VoiceIdClientTypes.EnrollmentJobFraudDetectionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudDetectionAction = "FraudDetectionAction"
        case riskThreshold = "RiskThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fraudDetectionAction = fraudDetectionAction {
            try encodeContainer.encode(fraudDetectionAction.rawValue, forKey: .fraudDetectionAction)
        }
        if let riskThreshold = riskThreshold {
            try encodeContainer.encode(riskThreshold, forKey: .riskThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudDetectionActionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudDetectionAction.self, forKey: .fraudDetectionAction)
        fraudDetectionAction = fraudDetectionActionDecoded
        let riskThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskThreshold)
        riskThreshold = riskThresholdDecoded
    }
}

extension VoiceIdClientTypes.EnrollmentJobFraudDetectionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnrollmentJobFraudDetectionConfig(fraudDetectionAction: \(Swift.String(describing: fraudDetectionAction)), riskThreshold: \(Swift.String(describing: riskThreshold)))"}
}

extension VoiceIdClientTypes {
    /// The configuration defining the action to take when a speaker is flagged by the fraud detection system
    ///             during a batch speaker enrollment job, and the risk threshold to use for identification.
    public struct EnrollmentJobFraudDetectionConfig: Swift.Equatable {
        /// The action to take when the given speaker is flagged by the fraud detection system. The default value is
        ///             FAIL, which fails the speaker enrollment. Changing this value to IGNORE
        ///             results in the speaker being enrolled even if they are flagged by the fraud detection system.
        public var fraudDetectionAction: VoiceIdClientTypes.FraudDetectionAction?
        /// Threshold value for determining whether the speaker is a high risk to be fraudulent. If the detected risk
        ///             score calculated by Voice ID is greater than or equal to the threshold, the speaker is considered a fraudster.
        public var riskThreshold: Swift.Int?

        public init (
            fraudDetectionAction: VoiceIdClientTypes.FraudDetectionAction? = nil,
            riskThreshold: Swift.Int? = nil
        )
        {
            self.fraudDetectionAction = fraudDetectionAction
            self.riskThreshold = riskThreshold
        }
    }

}

extension EvaluateSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluateSessionInput(domainId: \(Swift.String(describing: domainId)), sessionNameOrId: \(Swift.String(describing: sessionNameOrId)))"}
}

extension EvaluateSessionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct EvaluateSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EvaluateSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EvaluateSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EvaluateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EvaluateSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EvaluateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EvaluateSessionOutputError>
}

public struct EvaluateSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EvaluateSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EvaluateSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EvaluateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EvaluateSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EvaluateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EvaluateSessionOutputError>
}

public struct EvaluateSessionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EvaluateSessionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: EvaluateSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EvaluateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = EvaluateSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<EvaluateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EvaluateSessionOutputError>
}

public struct EvaluateSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EvaluateSessionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: EvaluateSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EvaluateSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = EvaluateSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<EvaluateSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EvaluateSessionOutputError>
}

public struct EvaluateSessionInput: Swift.Equatable {
    /// The identifier of the domain where the session started.
    /// This member is required.
    public var domainId: Swift.String?
    /// The session identifier, or name of the session, that you want to evaluate. In Voice ID
    ///             integration, this is the Contact-Id.
    /// This member is required.
    public var sessionNameOrId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        sessionNameOrId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.sessionNameOrId = sessionNameOrId
    }
}

struct EvaluateSessionInputBody: Swift.Equatable {
}

extension EvaluateSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EvaluateSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EvaluateSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EvaluateSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EvaluateSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluateSessionOutputResponse(authenticationResult: \(Swift.String(describing: authenticationResult)), domainId: \(Swift.String(describing: domainId)), fraudDetectionResult: \(Swift.String(describing: fraudDetectionResult)), sessionId: \(Swift.String(describing: sessionId)), sessionName: \(Swift.String(describing: sessionName)), streamingStatus: \(Swift.String(describing: streamingStatus)))"}
}

extension EvaluateSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EvaluateSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authenticationResult = output.authenticationResult
            self.domainId = output.domainId
            self.fraudDetectionResult = output.fraudDetectionResult
            self.sessionId = output.sessionId
            self.sessionName = output.sessionName
            self.streamingStatus = output.streamingStatus
        } else {
            self.authenticationResult = nil
            self.domainId = nil
            self.fraudDetectionResult = nil
            self.sessionId = nil
            self.sessionName = nil
            self.streamingStatus = nil
        }
    }
}

public struct EvaluateSessionOutputResponse: Swift.Equatable {
    /// Details resulting from the authentication process, such as authentication decision and
    ///             authentication score.
    public var authenticationResult: VoiceIdClientTypes.AuthenticationResult?
    /// The identifier of the domain containing the session.
    public var domainId: Swift.String?
    /// Details resulting from the fraud detection process, such as fraud detection decision and risk score.
    public var fraudDetectionResult: VoiceIdClientTypes.FraudDetectionResult?
    /// The service-generated identifier of the session.
    public var sessionId: Swift.String?
    /// The client-provided name of the session.
    public var sessionName: Swift.String?
    /// The current status of audio streaming for this session. This field is useful to infer next steps when
    ///             the Authentication or Fraud Detection results are empty or the decision is NOT_ENOUGH_SPEECH.
    ///             In this situation, if the StreamingStatus is ONGOING/PENDING_CONFIGURATION, it can
    ///             mean that the client should call the API again later, once Voice ID has enough audio to produce a result.
    ///             If the decision remains NOT_ENOUGH_SPEECH even after StreamingStatus is ENDED,
    ///             it means that the previously streamed session did not have enough speech to perform evaluation, and a new
    ///             streaming session is needed to try again.
    public var streamingStatus: VoiceIdClientTypes.StreamingStatus?

    public init (
        authenticationResult: VoiceIdClientTypes.AuthenticationResult? = nil,
        domainId: Swift.String? = nil,
        fraudDetectionResult: VoiceIdClientTypes.FraudDetectionResult? = nil,
        sessionId: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        streamingStatus: VoiceIdClientTypes.StreamingStatus? = nil
    )
    {
        self.authenticationResult = authenticationResult
        self.domainId = domainId
        self.fraudDetectionResult = fraudDetectionResult
        self.sessionId = sessionId
        self.sessionName = sessionName
        self.streamingStatus = streamingStatus
    }
}

struct EvaluateSessionOutputResponseBody: Swift.Equatable {
    public let domainId: Swift.String?
    public let sessionId: Swift.String?
    public let sessionName: Swift.String?
    public let streamingStatus: VoiceIdClientTypes.StreamingStatus?
    public let authenticationResult: VoiceIdClientTypes.AuthenticationResult?
    public let fraudDetectionResult: VoiceIdClientTypes.FraudDetectionResult?
}

extension EvaluateSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationResult = "AuthenticationResult"
        case domainId = "DomainId"
        case fraudDetectionResult = "FraudDetectionResult"
        case sessionId = "SessionId"
        case sessionName = "SessionName"
        case streamingStatus = "StreamingStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionName)
        sessionName = sessionNameDecoded
        let streamingStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.StreamingStatus.self, forKey: .streamingStatus)
        streamingStatus = streamingStatusDecoded
        let authenticationResultDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.AuthenticationResult.self, forKey: .authenticationResult)
        authenticationResult = authenticationResultDecoded
        let fraudDetectionResultDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudDetectionResult.self, forKey: .fraudDetectionResult)
        fraudDetectionResult = fraudDetectionResultDecoded
    }
}

extension VoiceIdClientTypes {
    public enum ExistingEnrollmentAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case overwrite
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistingEnrollmentAction] {
            return [
                .overwrite,
                .skip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .overwrite: return "OVERWRITE"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExistingEnrollmentAction(rawValue: rawValue) ?? ExistingEnrollmentAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.FailureDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIdClientTypes.FailureDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailureDetails(message: \(Swift.String(describing: message)), statusCode: \(Swift.String(describing: statusCode)))"}
}

extension VoiceIdClientTypes {
    /// Contains error details for a failed batch job.
    public struct FailureDetails: Swift.Equatable {
        /// A description of the error that caused the batch job failure.
        public var message: Swift.String?
        /// An HTTP status code representing the nature of the error.
        public var statusCode: Swift.Int?

        public init (
            message: Swift.String? = nil,
            statusCode: Swift.Int? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

extension VoiceIdClientTypes {
    public enum FraudDetectionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionAction] {
            return [
                .fail,
                .ignore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionAction(rawValue: rawValue) ?? FraudDetectionAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.FraudDetectionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case riskThreshold = "RiskThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let riskThreshold = riskThreshold {
            try encodeContainer.encode(riskThreshold, forKey: .riskThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskThreshold)
        riskThreshold = riskThresholdDecoded
    }
}

extension VoiceIdClientTypes.FraudDetectionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudDetectionConfiguration(riskThreshold: \(Swift.String(describing: riskThreshold)))"}
}

extension VoiceIdClientTypes {
    /// The configuration used for performing fraud detection over a speaker during a session.
    public struct FraudDetectionConfiguration: Swift.Equatable {
        /// Threshold value for determining whether the speaker is a fraudster. If the detected risk score
        ///             calculated by Voice ID is higher than the threshold, the speaker is considered a fraudster.
        /// This member is required.
        public var riskThreshold: Swift.Int?

        public init (
            riskThreshold: Swift.Int? = nil
        )
        {
            self.riskThreshold = riskThreshold
        }
    }

}

extension VoiceIdClientTypes {
    public enum FraudDetectionDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case highRisk
        case lowRisk
        case notEnoughSpeech
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionDecision] {
            return [
                .highRisk,
                .lowRisk,
                .notEnoughSpeech,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .highRisk: return "HIGH_RISK"
            case .lowRisk: return "LOW_RISK"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionDecision(rawValue: rawValue) ?? FraudDetectionDecision.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes {
    public enum FraudDetectionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knownFraudster
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionReason] {
            return [
                .knownFraudster,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knownFraudster: return "KNOWN_FRAUDSTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionReason(rawValue: rawValue) ?? FraudDetectionReason.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.FraudDetectionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioAggregationEndedAt = "AudioAggregationEndedAt"
        case audioAggregationStartedAt = "AudioAggregationStartedAt"
        case configuration = "Configuration"
        case decision = "Decision"
        case fraudDetectionResultId = "FraudDetectionResultId"
        case reasons = "Reasons"
        case riskDetails = "RiskDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioAggregationEndedAt = audioAggregationEndedAt {
            try encodeContainer.encode(audioAggregationEndedAt.timeIntervalSince1970, forKey: .audioAggregationEndedAt)
        }
        if let audioAggregationStartedAt = audioAggregationStartedAt {
            try encodeContainer.encode(audioAggregationStartedAt.timeIntervalSince1970, forKey: .audioAggregationStartedAt)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let decision = decision {
            try encodeContainer.encode(decision.rawValue, forKey: .decision)
        }
        if let fraudDetectionResultId = fraudDetectionResultId {
            try encodeContainer.encode(fraudDetectionResultId, forKey: .fraudDetectionResultId)
        }
        if let reasons = reasons {
            var reasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reasons)
            for frauddetectionreasons0 in reasons {
                try reasonsContainer.encode(frauddetectionreasons0.rawValue)
            }
        }
        if let riskDetails = riskDetails {
            try encodeContainer.encode(riskDetails, forKey: .riskDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudDetectionResultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudDetectionResultId)
        fraudDetectionResultId = fraudDetectionResultIdDecoded
        let audioAggregationStartedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .audioAggregationStartedAt)
        audioAggregationStartedAt = audioAggregationStartedAtDecoded
        let audioAggregationEndedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .audioAggregationEndedAt)
        audioAggregationEndedAt = audioAggregationEndedAtDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudDetectionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let decisionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudDetectionDecision.self, forKey: .decision)
        decision = decisionDecoded
        let reasonsContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.FraudDetectionReason?].self, forKey: .reasons)
        var reasonsDecoded0:[VoiceIdClientTypes.FraudDetectionReason]? = nil
        if let reasonsContainer = reasonsContainer {
            reasonsDecoded0 = [VoiceIdClientTypes.FraudDetectionReason]()
            for string0 in reasonsContainer {
                if let string0 = string0 {
                    reasonsDecoded0?.append(string0)
                }
            }
        }
        reasons = reasonsDecoded0
        let riskDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudRiskDetails.self, forKey: .riskDetails)
        riskDetails = riskDetailsDecoded
    }
}

extension VoiceIdClientTypes.FraudDetectionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudDetectionResult(audioAggregationEndedAt: \(Swift.String(describing: audioAggregationEndedAt)), audioAggregationStartedAt: \(Swift.String(describing: audioAggregationStartedAt)), configuration: \(Swift.String(describing: configuration)), decision: \(Swift.String(describing: decision)), fraudDetectionResultId: \(Swift.String(describing: fraudDetectionResultId)), reasons: \(Swift.String(describing: reasons)), riskDetails: \(Swift.String(describing: riskDetails)))"}
}

extension VoiceIdClientTypes {
    /// The fraud detection result produced by Voice ID, processed against the current session state and streamed
    ///             audio of the speaker.
    public struct FraudDetectionResult: Swift.Equatable {
        /// A timestamp indicating when audio aggregation ended for this fraud detection result.
        public var audioAggregationEndedAt: ClientRuntime.Date?
        /// A timestamp indicating when audio aggregation started for this fraud detection result.
        public var audioAggregationStartedAt: ClientRuntime.Date?
        /// The FraudDetectionConfiguration used to generate this fraud detection result.
        public var configuration: VoiceIdClientTypes.FraudDetectionConfiguration?
        /// The fraud detection decision produced by Voice ID, processed against the current session state and
        ///             streamed audio of the speaker.
        public var decision: VoiceIdClientTypes.FraudDetectionDecision?
        /// The unique identifier for this fraud detection result. Given there can be multiple fraud detections
        ///             for a given session, this field helps in identifying if the returned result is from previous streaming
        ///             activity or a new result. Note that in the absence of any new streaming activity or risk threshold
        ///             changes, Voice ID always returns cached Fraud Detection result for this API.
        public var fraudDetectionResultId: Swift.String?
        /// The reason speaker was flagged by the fraud detection system. This is only be populated if fraud
        ///             detection Decision is HIGH_RISK, and only has one possible value:
        ///             KNOWN_FRAUDSTER.
        public var reasons: [VoiceIdClientTypes.FraudDetectionReason]?
        /// Details about each risk analyzed for this speaker.
        public var riskDetails: VoiceIdClientTypes.FraudRiskDetails?

        public init (
            audioAggregationEndedAt: ClientRuntime.Date? = nil,
            audioAggregationStartedAt: ClientRuntime.Date? = nil,
            configuration: VoiceIdClientTypes.FraudDetectionConfiguration? = nil,
            decision: VoiceIdClientTypes.FraudDetectionDecision? = nil,
            fraudDetectionResultId: Swift.String? = nil,
            reasons: [VoiceIdClientTypes.FraudDetectionReason]? = nil,
            riskDetails: VoiceIdClientTypes.FraudRiskDetails? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.configuration = configuration
            self.decision = decision
            self.fraudDetectionResultId = fraudDetectionResultId
            self.reasons = reasons
            self.riskDetails = riskDetails
        }
    }

}

extension VoiceIdClientTypes.FraudRiskDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knownFraudsterRisk = "KnownFraudsterRisk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knownFraudsterRisk = knownFraudsterRisk {
            try encodeContainer.encode(knownFraudsterRisk, forKey: .knownFraudsterRisk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knownFraudsterRiskDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.KnownFraudsterRisk.self, forKey: .knownFraudsterRisk)
        knownFraudsterRisk = knownFraudsterRiskDecoded
    }
}

extension VoiceIdClientTypes.FraudRiskDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudRiskDetails(knownFraudsterRisk: \(Swift.String(describing: knownFraudsterRisk)))"}
}

extension VoiceIdClientTypes {
    /// Details regarding various fraud risk analyses performed against the current session state and streamed
    ///             audio of the speaker.
    public struct FraudRiskDetails: Swift.Equatable {
        /// The details resulting from 'Known Fraudster Risk' analysis of the speaker.
        /// This member is required.
        public var knownFraudsterRisk: VoiceIdClientTypes.KnownFraudsterRisk?

        public init (
            knownFraudsterRisk: VoiceIdClientTypes.KnownFraudsterRisk? = nil
        )
        {
            self.knownFraudsterRisk = knownFraudsterRisk
        }
    }

}

extension VoiceIdClientTypes.Fraudster: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case generatedFraudsterId = "GeneratedFraudsterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedFraudsterId = generatedFraudsterId {
            try encodeContainer.encode(generatedFraudsterId, forKey: .generatedFraudsterId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let generatedFraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFraudsterId)
        generatedFraudsterId = generatedFraudsterIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension VoiceIdClientTypes.Fraudster: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Fraudster(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), generatedFraudsterId: \(Swift.String(describing: generatedFraudsterId)))"}
}

extension VoiceIdClientTypes {
    /// Contains all the information about a fraudster.
    public struct Fraudster: Swift.Equatable {
        /// The timestamp when Voice ID identified the fraudster.
        public var createdAt: ClientRuntime.Date?
        /// The identifier for the domain containing the fraudster.
        public var domainId: Swift.String?
        /// The service-generated identifier for the fraudster.
        public var generatedFraudsterId: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            generatedFraudsterId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.generatedFraudsterId = generatedFraudsterId
        }
    }

}

extension VoiceIdClientTypes.FraudsterRegistrationJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let registrationConfig = registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIdClientTypes.FraudsterRegistrationJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudsterRegistrationJob(createdAt: \(Swift.String(describing: createdAt)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), registrationConfig: \(Swift.String(describing: registrationConfig)))"}
}

extension VoiceIdClientTypes {
    /// Contains all the information about a fraudster registration job.
    public struct FraudsterRegistrationJob: Swift.Equatable {
        /// A timestamp showing the creation time of the fraudster registration job.
        public var createdAt: ClientRuntime.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets
        ///             to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain containing the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp showing when the fraudster registration job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration
        ///             job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of
        ///             COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual
        ///             registration requests that failed.
        public var failureDetails: VoiceIdClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list
        ///             of fraudster registration job requests.
        public var inputDataConfig: VoiceIdClientTypes.InputDataConfig?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provied name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIdClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus?
        /// The output data config containing the S3 location where you want Voice ID to write your job output
        ///             file; you must also include a KMS Key ID in order to encrypt the file.
        public var outputDataConfig: VoiceIdClientTypes.OutputDataConfig?
        /// The registration config containing details such as the action to take when a duplicate fraudster is
        ///             detected, and the similarity threshold to use for detecting a duplicate fraudster.
        public var registrationConfig: VoiceIdClientTypes.RegistrationConfig?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIdClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIdClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIdClientTypes.JobProgress? = nil,
            jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus? = nil,
            outputDataConfig: VoiceIdClientTypes.OutputDataConfig? = nil,
            registrationConfig: VoiceIdClientTypes.RegistrationConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
            self.registrationConfig = registrationConfig
        }
    }

}

extension VoiceIdClientTypes {
    public enum FraudsterRegistrationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudsterRegistrationJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudsterRegistrationJobStatus(rawValue: rawValue) ?? FraudsterRegistrationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.FraudsterRegistrationJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIdClientTypes.FraudsterRegistrationJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudsterRegistrationJobSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)))"}
}

extension VoiceIdClientTypes {
    /// Contains a summary of information about a fraudster registration job.
    public struct FraudsterRegistrationJobSummary: Swift.Equatable {
        /// A timestamp showing when the fraudster registration job is created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain containing the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp showing when the fraudster registration job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration
        ///             job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of
        ///             COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual
        ///             registration requests that failed.
        public var failureDetails: VoiceIdClientTypes.FailureDetails?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provied name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIdClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIdClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIdClientTypes.JobProgress? = nil,
            jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }

}

extension VoiceIdClientTypes.InputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension VoiceIdClientTypes.InputDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputDataConfig(s3Uri: \(Swift.String(describing: s3Uri)))"}
}

extension VoiceIdClientTypes {
    /// The configuration containing input file information for a batch job.
    public struct InputDataConfig: Swift.Equatable {
        /// The S3 location for the input manifest file that contains the list of individual enrollment or registration
        ///             job requests.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to an unknown error on the server side.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIdClientTypes.JobProgress: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentComplete = "PercentComplete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentComplete = percentComplete {
            try encodeContainer.encode(percentComplete, forKey: .percentComplete)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentCompleteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentComplete)
        percentComplete = percentCompleteDecoded
    }
}

extension VoiceIdClientTypes.JobProgress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobProgress(percentComplete: \(Swift.String(describing: percentComplete)))"}
}

extension VoiceIdClientTypes {
    /// Indicates the completion progress for a batch job.
    public struct JobProgress: Swift.Equatable {
        /// Shows the completed percentage of enrollment or registration requests listed in the input file.
        public var percentComplete: Swift.Int?

        public init (
            percentComplete: Swift.Int? = nil
        )
        {
            self.percentComplete = percentComplete
        }
    }

}

extension VoiceIdClientTypes.KnownFraudsterRisk: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedFraudsterId = "GeneratedFraudsterId"
        case riskScore = "RiskScore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedFraudsterId = generatedFraudsterId {
            try encodeContainer.encode(generatedFraudsterId, forKey: .generatedFraudsterId)
        }
        if let riskScore = riskScore {
            try encodeContainer.encode(riskScore, forKey: .riskScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskScore)
        riskScore = riskScoreDecoded
        let generatedFraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFraudsterId)
        generatedFraudsterId = generatedFraudsterIdDecoded
    }
}

extension VoiceIdClientTypes.KnownFraudsterRisk: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KnownFraudsterRisk(generatedFraudsterId: \(Swift.String(describing: generatedFraudsterId)), riskScore: \(Swift.String(describing: riskScore)))"}
}

extension VoiceIdClientTypes {
    /// Contains details produced as a result of performing known fraudster risk analysis on a speaker.
    public struct KnownFraudsterRisk: Swift.Equatable {
        /// The identifier of the fraudster that is the closest match to the speaker. If there are no fraudsters
        ///             registered in a given domain, or if there are no fraudsters with a non-zero RiskScore, this value is
        ///             null.
        public var generatedFraudsterId: Swift.String?
        /// The score indicating the likelihood the speaker is a known fraudster.
        /// This member is required.
        public var riskScore: Swift.Int?

        public init (
            generatedFraudsterId: Swift.String? = nil,
            riskScore: Swift.Int? = nil
        )
        {
            self.generatedFraudsterId = generatedFraudsterId
            self.riskScore = riskScore
        }
    }

}

extension ListDomainsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDomainsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDomainsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDomainsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDomainsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDomainsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDomainsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use NextToken to obtain
    ///             further pages of results. The default is 100; the maximum allowed page size is also 100.
    ///
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken
    ///             is a unique pagination token for each page. Make the call again using the returned token to retrieve the
    ///             next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    ///
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
}

extension ListDomainsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainsOutputResponse(domainSummaries: \(Swift.String(describing: domainSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainSummaries = output.domainSummaries
            self.nextToken = output.nextToken
        } else {
            self.domainSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Swift.Equatable {
    /// A list containing details about each domain in the Amazon Web Services account.
    public var domainSummaries: [VoiceIdClientTypes.DomainSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken
    ///             is a unique pagination token for each page. Make the call again using the returned token to retrieve the
    ///             next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    ///
    public var nextToken: Swift.String?

    public init (
        domainSummaries: [VoiceIdClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainSummaries = domainSummaries
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Swift.Equatable {
    public let domainSummaries: [VoiceIdClientTypes.DomainSummary]?
    public let nextToken: Swift.String?
}

extension ListDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainSummaries = "DomainSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainSummariesContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.DomainSummary?].self, forKey: .domainSummaries)
        var domainSummariesDecoded0:[VoiceIdClientTypes.DomainSummary]? = nil
        if let domainSummariesContainer = domainSummariesContainer {
            domainSummariesDecoded0 = [VoiceIdClientTypes.DomainSummary]()
            for structure0 in domainSummariesContainer {
                if let structure0 = structure0 {
                    domainSummariesDecoded0?.append(structure0)
                }
            }
        }
        domainSummaries = domainSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFraudsterRegistrationJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFraudsterRegistrationJobsInput(domainId: \(Swift.String(describing: domainId)), jobStatus: \(Swift.String(describing: jobStatus)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFraudsterRegistrationJobsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFraudsterRegistrationJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFraudsterRegistrationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFraudsterRegistrationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFraudsterRegistrationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFraudsterRegistrationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFraudsterRegistrationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFraudsterRegistrationJobsOutputError>
}

public struct ListFraudsterRegistrationJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFraudsterRegistrationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFraudsterRegistrationJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFraudsterRegistrationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFraudsterRegistrationJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFraudsterRegistrationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFraudsterRegistrationJobsOutputError>
}

public struct ListFraudsterRegistrationJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFraudsterRegistrationJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListFraudsterRegistrationJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFraudsterRegistrationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFraudsterRegistrationJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFraudsterRegistrationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFraudsterRegistrationJobsOutputError>
}

public struct ListFraudsterRegistrationJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFraudsterRegistrationJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListFraudsterRegistrationJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFraudsterRegistrationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFraudsterRegistrationJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFraudsterRegistrationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFraudsterRegistrationJobsOutputError>
}

public struct ListFraudsterRegistrationJobsInput: Swift.Equatable {
    /// The identifier of the domain containing the fraudster registration Jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your fraudster registration job.
    public var jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain
    ///             further pages of results. The default is 100; the maximum allowed page size is also 100.
    ///
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken
    ///             is a unique pagination token for each page. Make the call again using the returned token to retrieve the
    ///             next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    ///
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobStatus: VoiceIdClientTypes.FraudsterRegistrationJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFraudsterRegistrationJobsInputBody: Swift.Equatable {
}

extension ListFraudsterRegistrationJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFraudsterRegistrationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFraudsterRegistrationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFraudsterRegistrationJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFraudsterRegistrationJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFraudsterRegistrationJobsOutputResponse(jobSummaries: \(Swift.String(describing: jobSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFraudsterRegistrationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFraudsterRegistrationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListFraudsterRegistrationJobsOutputResponse: Swift.Equatable {
    /// A list containing details about each specified fraudster registration job.
    public var jobSummaries: [VoiceIdClientTypes.FraudsterRegistrationJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken
    ///             is a unique pagination token for each page. Make the call again using the returned token to retrieve the
    ///             next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    ///
    public var nextToken: Swift.String?

    public init (
        jobSummaries: [VoiceIdClientTypes.FraudsterRegistrationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListFraudsterRegistrationJobsOutputResponseBody: Swift.Equatable {
    public let jobSummaries: [VoiceIdClientTypes.FraudsterRegistrationJobSummary]?
    public let nextToken: Swift.String?
}

extension ListFraudsterRegistrationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries = "JobSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.FraudsterRegistrationJobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[VoiceIdClientTypes.FraudsterRegistrationJobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [VoiceIdClientTypes.FraudsterRegistrationJobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakerEnrollmentJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSpeakerEnrollmentJobsInput(domainId: \(Swift.String(describing: domainId)), jobStatus: \(Swift.String(describing: jobStatus)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSpeakerEnrollmentJobsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSpeakerEnrollmentJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSpeakerEnrollmentJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSpeakerEnrollmentJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSpeakerEnrollmentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSpeakerEnrollmentJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSpeakerEnrollmentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSpeakerEnrollmentJobsOutputError>
}

public struct ListSpeakerEnrollmentJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSpeakerEnrollmentJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSpeakerEnrollmentJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSpeakerEnrollmentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSpeakerEnrollmentJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSpeakerEnrollmentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSpeakerEnrollmentJobsOutputError>
}

public struct ListSpeakerEnrollmentJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSpeakerEnrollmentJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSpeakerEnrollmentJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSpeakerEnrollmentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSpeakerEnrollmentJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSpeakerEnrollmentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSpeakerEnrollmentJobsOutputError>
}

public struct ListSpeakerEnrollmentJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSpeakerEnrollmentJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSpeakerEnrollmentJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSpeakerEnrollmentJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSpeakerEnrollmentJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSpeakerEnrollmentJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSpeakerEnrollmentJobsOutputError>
}

public struct ListSpeakerEnrollmentJobsInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker enrollment jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your speaker enrollment Job.
    public var jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain
    ///             further pages of results. The default is 100; the maximum allowed page size is also 100.
    ///
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken
    ///             is a unique pagination token for each page. Make the call again using the returned token to retrieve the
    ///             next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    ///
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSpeakerEnrollmentJobsInputBody: Swift.Equatable {
}

extension ListSpeakerEnrollmentJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSpeakerEnrollmentJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSpeakerEnrollmentJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSpeakerEnrollmentJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSpeakerEnrollmentJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSpeakerEnrollmentJobsOutputResponse(jobSummaries: \(Swift.String(describing: jobSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSpeakerEnrollmentJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSpeakerEnrollmentJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListSpeakerEnrollmentJobsOutputResponse: Swift.Equatable {
    /// A list containing details about each specified speaker enrollment job.
    public var jobSummaries: [VoiceIdClientTypes.SpeakerEnrollmentJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken
    ///             is a unique pagination token for each page. Make the call again using the returned token to retrieve the
    ///             next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    ///
    public var nextToken: Swift.String?

    public init (
        jobSummaries: [VoiceIdClientTypes.SpeakerEnrollmentJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListSpeakerEnrollmentJobsOutputResponseBody: Swift.Equatable {
    public let jobSummaries: [VoiceIdClientTypes.SpeakerEnrollmentJobSummary]?
    public let nextToken: Swift.String?
}

extension ListSpeakerEnrollmentJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries = "JobSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.SpeakerEnrollmentJobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[VoiceIdClientTypes.SpeakerEnrollmentJobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [VoiceIdClientTypes.SpeakerEnrollmentJobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSpeakersInput(domainId: \(Swift.String(describing: domainId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSpeakersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSpeakersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSpeakersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSpeakersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSpeakersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSpeakersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSpeakersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSpeakersOutputError>
}

public struct ListSpeakersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSpeakersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSpeakersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSpeakersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSpeakersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSpeakersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSpeakersOutputError>
}

public struct ListSpeakersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSpeakersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListSpeakersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSpeakersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSpeakersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSpeakersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSpeakersOutputError>
}

public struct ListSpeakersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSpeakersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListSpeakersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSpeakersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSpeakersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSpeakersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSpeakersOutputError>
}

public struct ListSpeakersInput: Swift.Equatable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain
    ///             further pages of results. The default is 100; the maximum allowed page size is also 100.
    ///
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken
    ///             is a unique pagination token for each page. Make the call again using the returned token to retrieve the
    ///             next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    ///
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSpeakersInputBody: Swift.Equatable {
}

extension ListSpeakersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSpeakersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSpeakersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSpeakersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSpeakersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSpeakersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), speakerSummaries: \(Swift.String(describing: speakerSummaries)))"}
}

extension ListSpeakersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSpeakersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.speakerSummaries = output.speakerSummaries
        } else {
            self.nextToken = nil
            self.speakerSummaries = nil
        }
    }
}

public struct ListSpeakersOutputResponse: Swift.Equatable {
    /// If NextToken is returned, there are more results available. The value of NextToken
    ///             is a unique pagination token for each page. Make the call again using the returned token to retrieve the
    ///             next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    ///
    public var nextToken: Swift.String?
    /// A list containing details about each speaker in the Amazon Web Services account.
    ///
    public var speakerSummaries: [VoiceIdClientTypes.SpeakerSummary]?

    public init (
        nextToken: Swift.String? = nil,
        speakerSummaries: [VoiceIdClientTypes.SpeakerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.speakerSummaries = speakerSummaries
    }
}

struct ListSpeakersOutputResponseBody: Swift.Equatable {
    public let speakerSummaries: [VoiceIdClientTypes.SpeakerSummary]?
    public let nextToken: Swift.String?
}

extension ListSpeakersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case speakerSummaries = "SpeakerSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSummariesContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.SpeakerSummary?].self, forKey: .speakerSummaries)
        var speakerSummariesDecoded0:[VoiceIdClientTypes.SpeakerSummary]? = nil
        if let speakerSummariesContainer = speakerSummariesContainer {
            speakerSummariesDecoded0 = [VoiceIdClientTypes.SpeakerSummary]()
            for structure0 in speakerSummariesContainer {
                if let structure0 = structure0 {
                    speakerSummariesDecoded0?.append(structure0)
                }
            }
        }
        speakerSummaries = speakerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource for which you want to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags associated with the specified resource.
    public var tags: [VoiceIdClientTypes.Tag]?

    public init (
        tags: [VoiceIdClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [VoiceIdClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIdClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIdClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OptOutSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptOutSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \(Swift.String(describing: speakerId)))"}
}

extension OptOutSpeakerInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct OptOutSpeakerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OptOutSpeakerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<OptOutSpeakerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OptOutSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<OptOutSpeakerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<OptOutSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OptOutSpeakerOutputError>
}

public struct OptOutSpeakerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OptOutSpeakerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<OptOutSpeakerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OptOutSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<OptOutSpeakerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<OptOutSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OptOutSpeakerOutputError>
}

public struct OptOutSpeakerInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OptOutSpeakerInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: OptOutSpeakerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OptOutSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = OptOutSpeakerInput
    public typealias MOutput = ClientRuntime.OperationOutput<OptOutSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OptOutSpeakerOutputError>
}

public struct OptOutSpeakerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "OptOutSpeakerInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: OptOutSpeakerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<OptOutSpeakerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = OptOutSpeakerInput
    public typealias MOutput = ClientRuntime.OperationOutput<OptOutSpeakerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<OptOutSpeakerOutputError>
}

public struct OptOutSpeakerInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want opted-out.
    /// This member is required.
    public var speakerId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct OptOutSpeakerInputBody: Swift.Equatable {
}

extension OptOutSpeakerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension OptOutSpeakerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension OptOutSpeakerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum OptOutSpeakerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OptOutSpeakerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptOutSpeakerOutputResponse(speaker: \(Swift.String(describing: speaker)))"}
}

extension OptOutSpeakerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OptOutSpeakerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.speaker = output.speaker
        } else {
            self.speaker = nil
        }
    }
}

public struct OptOutSpeakerOutputResponse: Swift.Equatable {
    /// Details about the opted-out speaker.
    public var speaker: VoiceIdClientTypes.Speaker?

    public init (
        speaker: VoiceIdClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

struct OptOutSpeakerOutputResponseBody: Swift.Equatable {
    public let speaker: VoiceIdClientTypes.Speaker?
}

extension OptOutSpeakerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speaker = "Speaker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Speaker.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

extension VoiceIdClientTypes.OutputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension VoiceIdClientTypes.OutputDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputDataConfig(kmsKeyId: \(Swift.String(describing: kmsKeyId)), s3Uri: \(Swift.String(describing: s3Uri)))"}
}

extension VoiceIdClientTypes {
    /// The configuration containing output file information for a batch job.
    public struct OutputDataConfig: Swift.Equatable {
        /// the identifier of the KMS key you want Voice ID to use to encrypt the output file of the fraudster
        ///             registration job.
        public var kmsKeyId: Swift.String?
        /// The S3 path of the folder to which Voice ID writes the job output file, which has a
        ///             *.out extension. For example, if the input file name is input-file.json and
        ///             the output folder path is s3://output-bucket/output-folder, the full output file path is
        ///             s3://output-bucket/output-folder/job-Id/input-file.json.out.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension VoiceIdClientTypes.RegistrationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duplicateRegistrationAction = "DuplicateRegistrationAction"
        case fraudsterSimilarityThreshold = "FraudsterSimilarityThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duplicateRegistrationAction = duplicateRegistrationAction {
            try encodeContainer.encode(duplicateRegistrationAction.rawValue, forKey: .duplicateRegistrationAction)
        }
        if let fraudsterSimilarityThreshold = fraudsterSimilarityThreshold {
            try encodeContainer.encode(fraudsterSimilarityThreshold, forKey: .fraudsterSimilarityThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let duplicateRegistrationActionDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.DuplicateRegistrationAction.self, forKey: .duplicateRegistrationAction)
        duplicateRegistrationAction = duplicateRegistrationActionDecoded
        let fraudsterSimilarityThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fraudsterSimilarityThreshold)
        fraudsterSimilarityThreshold = fraudsterSimilarityThresholdDecoded
    }
}

extension VoiceIdClientTypes.RegistrationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegistrationConfig(duplicateRegistrationAction: \(Swift.String(describing: duplicateRegistrationAction)), fraudsterSimilarityThreshold: \(Swift.String(describing: fraudsterSimilarityThreshold)))"}
}

extension VoiceIdClientTypes {
    /// The configuration definining the action to take when a duplicate fraudster is detected, and the
    ///             similarity threshold to use for detecting a duplicate fraudster during a batch fraudster registration job.
    public struct RegistrationConfig: Swift.Equatable {
        /// The action to take when a fraudster is identified as a duplicate. The default action is
        ///             SKIP, which skips registering the duplicate fraudster. Setting the value to
        ///             REGISTER_AS_NEW always registers a new fraudster into the specified domain.
        public var duplicateRegistrationAction: VoiceIdClientTypes.DuplicateRegistrationAction?
        /// The minimum similarity score between the new and old fraudsters in order to consider the new
        ///             fraudster a duplicate.
        public var fraudsterSimilarityThreshold: Swift.Int?

        public init (
            duplicateRegistrationAction: VoiceIdClientTypes.DuplicateRegistrationAction? = nil,
            fraudsterSimilarityThreshold: Swift.Int? = nil
        )
        {
            self.duplicateRegistrationAction = duplicateRegistrationAction
            self.fraudsterSimilarityThreshold = fraudsterSimilarityThreshold
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource cannot be found. Check the ResourceType and error message for
///             more details.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The type of resource which cannot not be found. Possible types are BATCH_JOB, COMPLIANCE_CONSENT,
    ///             DOMAIN, FRAUDSTER, SESSION and SPEAKER.
    public var resourceType: VoiceIdClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceType: VoiceIdClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceType: VoiceIdClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension VoiceIdClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case batchJob
        case complianceConsent
        case domain
        case fraudster
        case session
        case speaker
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .batchJob,
                .complianceConsent,
                .domain,
                .fraudster,
                .session,
                .speaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .batchJob: return "BATCH_JOB"
            case .complianceConsent: return "COMPLIANCE_CONSENT"
            case .domain: return "DOMAIN"
            case .fraudster: return "FRAUDSTER"
            case .session: return "SESSION"
            case .speaker: return "SPEAKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.ServerSideEncryptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension VoiceIdClientTypes.ServerSideEncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerSideEncryptionConfiguration(kmsKeyId: \(Swift.String(describing: kmsKeyId)))"}
}

extension VoiceIdClientTypes {
    /// The configuration containing information about the customer-managed KMS Key used for encrypting
    ///             customer data.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// The identifier of the KMS Key you want Voice ID to use to encrypt your data.
        /// This member is required.
        public var kmsKeyId: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeded the service quota. Refer to <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#voiceid-quotas">Voice ID Service
///             Quotas and try your request again.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIdClientTypes.Speaker: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case customerSpeakerId = "CustomerSpeakerId"
        case domainId = "DomainId"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let customerSpeakerId = customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedSpeakerId = generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIdClientTypes.Speaker: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Speaker(createdAt: \(Swift.String(describing: createdAt)), customerSpeakerId: \(Swift.String(describing: customerSpeakerId)), domainId: \(Swift.String(describing: domainId)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension VoiceIdClientTypes {
    /// Contains all the information about a speaker.
    public struct Speaker: Swift.Equatable {
        /// A timestamp showing when the speaker is created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The current status of the speaker.
        public var status: VoiceIdClientTypes.SpeakerStatus?
        /// A timestamp showing the speaker's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            status: VoiceIdClientTypes.SpeakerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIdClientTypes.SpeakerEnrollmentJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case enrollmentConfig = "EnrollmentConfig"
        case failureDetails = "FailureDetails"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let enrollmentConfig = enrollmentConfig {
            try encodeContainer.encode(enrollmentConfig, forKey: .enrollmentConfig)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let enrollmentConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.EnrollmentConfig.self, forKey: .enrollmentConfig)
        enrollmentConfig = enrollmentConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIdClientTypes.SpeakerEnrollmentJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerEnrollmentJob(createdAt: \(Swift.String(describing: createdAt)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), enrollmentConfig: \(Swift.String(describing: enrollmentConfig)), failureDetails: \(Swift.String(describing: failureDetails)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), outputDataConfig: \(Swift.String(describing: outputDataConfig)))"}
}

extension VoiceIdClientTypes {
    /// Contains all the information about a speaker enrollment job.
    public struct SpeakerEnrollmentJob: Swift.Equatable {
        /// A timestamp showing the creation of the speaker enrollment job.
        public var createdAt: ClientRuntime.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets
        ///             to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp showing when the speaker enrollment job ended.
        public var endedAt: ClientRuntime.Date?
        /// The configuration that defines the action to take when the speaker is already enrolled in Voice ID, and the
        ///             FraudDetectionConfig to use.
        public var enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration
        ///             job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of
        ///             COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual
        ///             registration requests that failed.
        public var failureDetails: VoiceIdClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list
        ///             of speaker enrollment job requests.
        public var inputDataConfig: VoiceIdClientTypes.InputDataConfig?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details on job progress. This field shows the completed percentage of registration
        ///             requests listed in the input file.
        public var jobProgress: VoiceIdClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus?
        /// The output data config containing the S3 location where Voice ID writes the job output file; you must
        ///             also include a KMS Key ID to encrypt the file.
        public var outputDataConfig: VoiceIdClientTypes.OutputDataConfig?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig? = nil,
            failureDetails: VoiceIdClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIdClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIdClientTypes.JobProgress? = nil,
            jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus? = nil,
            outputDataConfig: VoiceIdClientTypes.OutputDataConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.enrollmentConfig = enrollmentConfig
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
        }
    }

}

extension VoiceIdClientTypes {
    public enum SpeakerEnrollmentJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerEnrollmentJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeakerEnrollmentJobStatus(rawValue: rawValue) ?? SpeakerEnrollmentJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.SpeakerEnrollmentJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = endedAt {
            try encodeContainer.encode(endedAt.timeIntervalSince1970, forKey: .endedAt)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIdClientTypes.SpeakerEnrollmentJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerEnrollmentJobSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)))"}
}

extension VoiceIdClientTypes {
    /// Contains a summary of information about a speaker enrollment job.
    public struct SpeakerEnrollmentJobSummary: Swift.Equatable {
        /// A timestamp showing the creation time of the speaker enrollment job.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp showing when the speaker enrollment job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration
        ///             job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of
        ///             COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual
        ///             registration requests that failed.
        public var failureDetails: VoiceIdClientTypes.FailureDetails?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details regarding job progress. This field shows the completed percentage of enrollment
        ///             requests listed in the input file.
        public var jobProgress: VoiceIdClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIdClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIdClientTypes.JobProgress? = nil,
            jobStatus: VoiceIdClientTypes.SpeakerEnrollmentJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }

}

extension VoiceIdClientTypes {
    public enum SpeakerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enrolled
        case expired
        case optedOut
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerStatus] {
            return [
                .enrolled,
                .expired,
                .optedOut,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enrolled: return "ENROLLED"
            case .expired: return "EXPIRED"
            case .optedOut: return "OPTED_OUT"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeakerStatus(rawValue: rawValue) ?? SpeakerStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.SpeakerSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case customerSpeakerId = "CustomerSpeakerId"
        case domainId = "DomainId"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let customerSpeakerId = customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let domainId = domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedSpeakerId = generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIdClientTypes.SpeakerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerSummary(createdAt: \(Swift.String(describing: createdAt)), customerSpeakerId: \(Swift.String(describing: customerSpeakerId)), domainId: \(Swift.String(describing: domainId)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension VoiceIdClientTypes {
    /// Contains a summary of information about a speaker.
    public struct SpeakerSummary: Swift.Equatable {
        /// A timestamp showing the speaker's creation time.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The current status of the speaker.
        public var status: VoiceIdClientTypes.SpeakerStatus?
        /// A timestamp showing the speaker's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            status: VoiceIdClientTypes.SpeakerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

public struct StartFraudsterRegistrationJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFraudsterRegistrationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFraudsterRegistrationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFraudsterRegistrationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFraudsterRegistrationJobOutputError>
}

extension StartFraudsterRegistrationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFraudsterRegistrationJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobName: \(Swift.String(describing: jobName)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), registrationConfig: \(Swift.String(describing: registrationConfig)))"}
}

extension StartFraudsterRegistrationJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let registrationConfig = registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
    }
}

public struct StartFraudsterRegistrationJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFraudsterRegistrationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFraudsterRegistrationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFraudsterRegistrationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFraudsterRegistrationJobOutputError>
}

public struct StartFraudsterRegistrationJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFraudsterRegistrationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFraudsterRegistrationJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFraudsterRegistrationJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFraudsterRegistrationJobOutputError>
}

public struct StartFraudsterRegistrationJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFraudsterRegistrationJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartFraudsterRegistrationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartFraudsterRegistrationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFraudsterRegistrationJobOutputError>
}

public struct StartFraudsterRegistrationJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFraudsterRegistrationJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartFraudsterRegistrationJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartFraudsterRegistrationJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartFraudsterRegistrationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFraudsterRegistrationJobOutputError>
}

public struct StartFraudsterRegistrationJobInput: Swift.Equatable {
    /// The idempotency token for starting a new fraudster registration job. If not provided, Amazon Web Services
    ///             SDK populates this field.
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets
    ///             to read the input manifest file and write the Job output file. Refer to the
    ///             <a href="https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-fraudster-watchlist.html">Create and
    ///                 edit a fraudster watchlist documentation for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain containing the fraudster registration job and in which the fraudsters are
    ///             registered.
    /// This member is required.
    public var domainId: Swift.String?
    /// The input data config containing an S3 URI for the input manifest file that contains the list
    ///             of fraudster registration requests.
    /// This member is required.
    public var inputDataConfig: VoiceIdClientTypes.InputDataConfig?
    /// The name of the new fraudster registration job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must
    ///             also include a KMS Key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIdClientTypes.OutputDataConfig?
    /// The registration config containing details such as the action to take when a duplicate fraudster is
    ///             detected, and the similarity threshold to use for detecting a duplicate fraudster.
    public var registrationConfig: VoiceIdClientTypes.RegistrationConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        inputDataConfig: VoiceIdClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIdClientTypes.OutputDataConfig? = nil,
        registrationConfig: VoiceIdClientTypes.RegistrationConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.registrationConfig = registrationConfig
    }
}

struct StartFraudsterRegistrationJobInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let jobName: Swift.String?
    public let dataAccessRoleArn: Swift.String?
    public let registrationConfig: VoiceIdClientTypes.RegistrationConfig?
    public let inputDataConfig: VoiceIdClientTypes.InputDataConfig?
    public let outputDataConfig: VoiceIdClientTypes.OutputDataConfig?
}

extension StartFraudsterRegistrationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
    }
}

extension StartFraudsterRegistrationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFraudsterRegistrationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFraudsterRegistrationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFraudsterRegistrationJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFraudsterRegistrationJobOutputResponse(job: \(Swift.String(describing: job)))"}
}

extension StartFraudsterRegistrationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFraudsterRegistrationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartFraudsterRegistrationJobOutputResponse: Swift.Equatable {
    /// Details about the started fraudster registration job.
    public var job: VoiceIdClientTypes.FraudsterRegistrationJob?

    public init (
        job: VoiceIdClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

struct StartFraudsterRegistrationJobOutputResponseBody: Swift.Equatable {
    public let job: VoiceIdClientTypes.FraudsterRegistrationJob?
}

extension StartFraudsterRegistrationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.FraudsterRegistrationJob.self, forKey: .job)
        job = jobDecoded
    }
}

public struct StartSpeakerEnrollmentJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSpeakerEnrollmentJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSpeakerEnrollmentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSpeakerEnrollmentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSpeakerEnrollmentJobOutputError>
}

extension StartSpeakerEnrollmentJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSpeakerEnrollmentJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), enrollmentConfig: \(Swift.String(describing: enrollmentConfig)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobName: \(Swift.String(describing: jobName)), outputDataConfig: \(Swift.String(describing: outputDataConfig)))"}
}

extension StartSpeakerEnrollmentJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case enrollmentConfig = "EnrollmentConfig"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let enrollmentConfig = enrollmentConfig {
            try encodeContainer.encode(enrollmentConfig, forKey: .enrollmentConfig)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartSpeakerEnrollmentJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSpeakerEnrollmentJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSpeakerEnrollmentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSpeakerEnrollmentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSpeakerEnrollmentJobOutputError>
}

public struct StartSpeakerEnrollmentJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSpeakerEnrollmentJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartSpeakerEnrollmentJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartSpeakerEnrollmentJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSpeakerEnrollmentJobOutputError>
}

public struct StartSpeakerEnrollmentJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSpeakerEnrollmentJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartSpeakerEnrollmentJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartSpeakerEnrollmentJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSpeakerEnrollmentJobOutputError>
}

public struct StartSpeakerEnrollmentJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartSpeakerEnrollmentJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartSpeakerEnrollmentJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartSpeakerEnrollmentJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartSpeakerEnrollmentJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartSpeakerEnrollmentJobOutputError>
}

public struct StartSpeakerEnrollmentJobInput: Swift.Equatable {
    /// The idempotency token for starting a new speaker enrollment Job. If not provided, Amazon Web Services
    ///             SDK populates this field.
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets
    ///             to read the input manifest file and write the job output file. Refer to <a href="https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-batch-enrollment.html">Batch enrollment using audio data from prior
    ///                 calls documentation for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain that contains the speaker enrollment job and in which the speakers are
    ///             enrolled.
    ///
    /// This member is required.
    public var domainId: Swift.String?
    /// The enrollment config that contains details such as the action to take when a speaker is already
    ///             enrolled in the Voice ID system or when a speaker is identified as a fraudster.
    public var enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig?
    /// The input data config containing the S3 location for the input manifest file that contains the list of
    ///             speaker enrollment requests.
    /// This member is required.
    public var inputDataConfig: VoiceIdClientTypes.InputDataConfig?
    /// A name for your speaker enrollment job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must
    ///             also include a KMS Key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIdClientTypes.OutputDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig? = nil,
        inputDataConfig: VoiceIdClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIdClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.enrollmentConfig = enrollmentConfig
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

struct StartSpeakerEnrollmentJobInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let jobName: Swift.String?
    public let dataAccessRoleArn: Swift.String?
    public let enrollmentConfig: VoiceIdClientTypes.EnrollmentConfig?
    public let inputDataConfig: VoiceIdClientTypes.InputDataConfig?
    public let outputDataConfig: VoiceIdClientTypes.OutputDataConfig?
}

extension StartSpeakerEnrollmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case enrollmentConfig = "EnrollmentConfig"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let enrollmentConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.EnrollmentConfig.self, forKey: .enrollmentConfig)
        enrollmentConfig = enrollmentConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
    }
}

extension StartSpeakerEnrollmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSpeakerEnrollmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSpeakerEnrollmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSpeakerEnrollmentJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSpeakerEnrollmentJobOutputResponse(job: \(Swift.String(describing: job)))"}
}

extension StartSpeakerEnrollmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartSpeakerEnrollmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartSpeakerEnrollmentJobOutputResponse: Swift.Equatable {
    /// Details about the started speaker enrollment job.
    public var job: VoiceIdClientTypes.SpeakerEnrollmentJob?

    public init (
        job: VoiceIdClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

struct StartSpeakerEnrollmentJobOutputResponseBody: Swift.Equatable {
    public let job: VoiceIdClientTypes.SpeakerEnrollmentJob?
}

extension StartSpeakerEnrollmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.SpeakerEnrollmentJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension VoiceIdClientTypes {
    public enum StreamingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ended
        case ongoing
        case pendingConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingStatus] {
            return [
                .ended,
                .ongoing,
                .pendingConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ended: return "ENDED"
            case .ongoing: return "ONGOING"
            case .pendingConfiguration: return "PENDING_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingStatus(rawValue: rawValue) ?? StreamingStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIdClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension VoiceIdClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension VoiceIdClientTypes {
    /// A tag that can be assigned to a Voice ID resource.
    public struct Tag: Swift.Equatable {
        /// The first part of a key:value pair that forms a tag associated with a given resource. For example,
        ///             in the tag ‘Department’:’Sales’, the key is 'Department'.
        ///
        /// This member is required.
        public var key: Swift.String?
        /// The second part of a key:value pair that forms a tag associated with a given resource. For example,
        ///             in the tag ‘Department’:’Sales’, the value is 'Sales'.
        ///
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to assign to the specified resource.
    /// This member is required.
    public var tags: [VoiceIdClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [VoiceIdClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [VoiceIdClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIdClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIdClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIdClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling. Please slow down your request rate. Refer to
///             <a href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html##voiceid-api-quotas">
///                 Amazon Connect Voice ID Service API throttling quotas
///              and try your request again.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainOutputError>
}

extension UpdateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainInput(description: \(Swift.String(describing: description)), domainId: \(Swift.String(describing: domainId)), name: \(Swift.String(describing: name)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)))"}
}

extension UpdateDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
    }
}

public struct UpdateDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainOutputError>
}

public struct UpdateDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainOutputError>
}

public struct UpdateDomainInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainOutputError>
}

public struct UpdateDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDomainInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDomainOutputError>
}

public struct UpdateDomainInput: Swift.Equatable {
    /// A brief description about this domain.
    public var description: Swift.String?
    /// The identifier of the domain to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS Key Identifier, to be used by Voice ID for the server-side
    ///             encryption of your data. Note that all the existing data in the domain are still encrypted using the
    ///             existing key, only the data added to domain after updating the key is encrypted using the new key.
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?

    public init (
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

struct UpdateDomainInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let serverSideEncryptionConfiguration: VoiceIdClientTypes.ServerSideEncryptionConfiguration?
}

extension UpdateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension UpdateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainOutputResponse(domain: \(Swift.String(describing: domain)))"}
}

extension UpdateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct UpdateDomainOutputResponse: Swift.Equatable {
    /// Details about the updated domain
    public var domain: VoiceIdClientTypes.Domain?

    public init (
        domain: VoiceIdClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct UpdateDomainOutputResponseBody: Swift.Equatable {
    public let domain: VoiceIdClientTypes.Domain?
}

extension UpdateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIdClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed one or more validations; check the error message for more details.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
