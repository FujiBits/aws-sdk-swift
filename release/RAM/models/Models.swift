// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptResourceShareInvitationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptResourceShareInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptResourceShareInvitationOutputError>
}

extension AcceptResourceShareInvitationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptResourceShareInvitationInput(clientToken: \(Swift.String(describing: clientToken)), resourceShareInvitationArn: \(Swift.String(describing: resourceShareInvitationArn)))"}
}

extension AcceptResourceShareInvitationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

public struct AcceptResourceShareInvitationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptResourceShareInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptResourceShareInvitationOutputError>
}

public struct AcceptResourceShareInvitationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptResourceShareInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptResourceShareInvitationOutputError>
}

public struct AcceptResourceShareInvitationInput: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the invitation.</p>
    public let resourceShareInvitationArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct AcceptResourceShareInvitationInputBody: Swift.Equatable {
    public let resourceShareInvitationArn: Swift.String?
    public let clientToken: Swift.String?
}

extension AcceptResourceShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AcceptResourceShareInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptResourceShareInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyAcceptedException" : self = .resourceShareInvitationAlreadyAcceptedException(try ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyRejectedException" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationArnNotFoundException" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationExpiredException" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptResourceShareInvitationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareInvitationAlreadyAcceptedException(ResourceShareInvitationAlreadyAcceptedException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptResourceShareInvitationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptResourceShareInvitationOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShareInvitation: \(Swift.String(describing: resourceShareInvitation)))"}
}

extension AcceptResourceShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct AcceptResourceShareInvitationOutputResponse: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>Information about the invitation.</p>
    public let resourceShareInvitation: RamClientTypes.ResourceShareInvitation?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitation: RamClientTypes.ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct AcceptResourceShareInvitationOutputResponseBody: Swift.Equatable {
    public let resourceShareInvitation: RamClientTypes.ResourceShareInvitation?
    public let clientToken: Swift.String?
}

extension AcceptResourceShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct AssociateResourceShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceShareOutputError>
}

extension AssociateResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceShareInput(clientToken: \(Swift.String(describing: clientToken)), principals: \(Swift.String(describing: principals)), resourceArns: \(Swift.String(describing: resourceArns)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension AssociateResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct AssociateResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceShareOutputError>
}

public struct AssociateResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceShareOutputError>
}

public struct AssociateResourceShareInput: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>The principals to associate with the resource share. The possible values are IDs of
    ///        	AWS accounts, and the ARNs of organizational units (OU) or organizations from AWS
    ///        	Organizations.</p>
    public let principals: [Swift.String]?
    /// <p>The Amazon Resource Names (ARN) of the resources.</p>
    public let resourceArns: [Swift.String]?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
    }
}

struct AssociateResourceShareInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let resourceArns: [Swift.String]?
    public let principals: [Swift.String]?
    public let clientToken: Swift.String?
}

extension AssociateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceededException" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShareAssociations: \(Swift.String(describing: resourceShareAssociations)))"}
}

extension AssociateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct AssociateResourceShareOutputResponse: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>Information about the associations.</p>
    public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct AssociateResourceShareOutputResponseBody: Swift.Equatable {
    public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?
    public let clientToken: Swift.String?
}

extension AssociateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RamClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RamClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct AssociateResourceSharePermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceSharePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceSharePermissionOutputError>
}

extension AssociateResourceSharePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceSharePermissionInput(clientToken: \(Swift.String(describing: clientToken)), permissionArn: \(Swift.String(describing: permissionArn)), replace: \(Swift.String(describing: replace)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension AssociateResourceSharePermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case replace
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let replace = replace {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct AssociateResourceSharePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceSharePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceSharePermissionOutputError>
}

public struct AssociateResourceSharePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateResourceSharePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateResourceSharePermissionOutputError>
}

public struct AssociateResourceSharePermissionInput: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>The ARN of the AWS RAM permission to associate with the resource share.</p>
    public let permissionArn: Swift.String?
    /// <p>Indicates whether the permission should replace the permissions that are currently
    ///         	associated with the resource share. Use <code>true</code> to replace the current permissions.
    ///         	Use <code>false</code> to add the permission to the current permission.</p>
    public let replace: Swift.Bool?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        replace: Swift.Bool? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.replace = replace
        self.resourceShareArn = resourceShareArn
    }
}

struct AssociateResourceSharePermissionInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let permissionArn: Swift.String?
    public let replace: Swift.Bool?
    public let clientToken: Swift.String?
}

extension AssociateResourceSharePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case replace
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let replaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceSharePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceSharePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateResourceSharePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceSharePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateResourceSharePermissionOutputResponse(clientToken: \(Swift.String(describing: clientToken)), returnValue: \(Swift.String(describing: returnValue)))"}
}

extension AssociateResourceSharePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct AssociateResourceSharePermissionOutputResponse: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct AssociateResourceSharePermissionOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
    public let clientToken: Swift.String?
}

extension AssociateResourceSharePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct CreateResourceShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceShareOutputError>
}

extension CreateResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceShareInput(allowExternalPrincipals: \(Swift.String(describing: allowExternalPrincipals)), clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), permissionArns: \(Swift.String(describing: permissionArns)), principals: \(Swift.String(describing: principals)), resourceArns: \(Swift.String(describing: resourceArns)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionArns = permissionArns {
            var permissionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionArns)
            for permissionarnlist0 in permissionArns {
                try permissionArnsContainer.encode(permissionarnlist0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceShareOutputError>
}

public struct CreateResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceShareOutputError>
}

public struct CreateResourceShareInput: Swift.Equatable {
    /// <p>Indicates whether principals outside your AWS organization can be associated with a resource share.</p>
    public let allowExternalPrincipals: Swift.Bool?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>The name of the resource share.</p>
    public let name: Swift.String?
    /// <p>The ARNs of the permissions to associate with the resource share. If you do not specify an ARN
    /// 			for the permission, AWS RAM automatically attaches the default version of the permission
    /// 			for each resource type.</p>
    public let permissionArns: [Swift.String]?
    /// <p>The principals to associate with the resource share. The possible values are IDs of AWS accounts,
    ///           the ARN of an OU or organization from AWS Organizations.</p>
    public let principals: [Swift.String]?
    /// <p>The Amazon Resource Names (ARN) of the resources to associate with the resource share.</p>
    public let resourceArns: [Swift.String]?
    /// <p>One or more tags.</p>
    public let tags: [RamClientTypes.Tag]?

    public init (
        allowExternalPrincipals: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionArns: [Swift.String]? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        tags: [RamClientTypes.Tag]? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.permissionArns = permissionArns
        self.principals = principals
        self.resourceArns = resourceArns
        self.tags = tags
    }
}

struct CreateResourceShareInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let resourceArns: [Swift.String]?
    public let principals: [Swift.String]?
    public let tags: [RamClientTypes.Tag]?
    public let allowExternalPrincipals: Swift.Bool?
    public let clientToken: Swift.String?
    public let permissionArns: [Swift.String]?
}

extension CreateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([RamClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RamClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RamClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionArns)
        var permissionArnsDecoded0:[Swift.String]? = nil
        if let permissionArnsContainer = permissionArnsContainer {
            permissionArnsDecoded0 = [Swift.String]()
            for string0 in permissionArnsContainer {
                if let string0 = string0 {
                    permissionArnsDecoded0?.append(string0)
                }
            }
        }
        permissionArns = permissionArnsDecoded0
    }
}

extension CreateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceededException" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolationException" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShare: \(Swift.String(describing: resourceShare)))"}
}

extension CreateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct CreateResourceShareOutputResponse: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>Information about the resource share.</p>
    public let resourceShare: RamClientTypes.ResourceShare?

    public init (
        clientToken: Swift.String? = nil,
        resourceShare: RamClientTypes.ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct CreateResourceShareOutputResponseBody: Swift.Equatable {
    public let resourceShare: RamClientTypes.ResourceShare?
    public let clientToken: Swift.String?
}

extension CreateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShare
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceShareInput(clientToken: \(Swift.String(describing: clientToken)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension DeleteResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceShareOutputError>
}

public struct DeleteResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceShareArn = input.operationInput.resourceShareArn {
            let resourceShareArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: Swift.String(resourceShareArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceShareArnQueryItem)
        }
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceShareOutputError>
}

public struct DeleteResourceShareInput: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareArn = resourceShareArn
    }
}

struct DeleteResourceShareInputBody: Swift.Equatable {
}

extension DeleteResourceShareInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), returnValue: \(Swift.String(describing: returnValue)))"}
}

extension DeleteResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DeleteResourceShareOutputResponse: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DeleteResourceShareOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
    public let clientToken: Swift.String?
}

extension DeleteResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct DisassociateResourceShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceShareOutputError>
}

extension DisassociateResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceShareInput(clientToken: \(Swift.String(describing: clientToken)), principals: \(Swift.String(describing: principals)), resourceArns: \(Swift.String(describing: resourceArns)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension DisassociateResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct DisassociateResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceShareOutputError>
}

public struct DisassociateResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceShareOutputError>
}

public struct DisassociateResourceShareInput: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>The principals.</p>
    public let principals: [Swift.String]?
    /// <p>The Amazon Resource Names (ARNs) of the resources.</p>
    public let resourceArns: [Swift.String]?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
    }
}

struct DisassociateResourceShareInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let resourceArns: [Swift.String]?
    public let principals: [Swift.String]?
    public let clientToken: Swift.String?
}

extension DisassociateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceededException" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShareAssociations: \(Swift.String(describing: resourceShareAssociations)))"}
}

extension DisassociateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct DisassociateResourceShareOutputResponse: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>Information about the associations.</p>
    public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct DisassociateResourceShareOutputResponseBody: Swift.Equatable {
    public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?
    public let clientToken: Swift.String?
}

extension DisassociateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RamClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RamClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct DisassociateResourceSharePermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceSharePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceSharePermissionOutputError>
}

extension DisassociateResourceSharePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceSharePermissionInput(clientToken: \(Swift.String(describing: clientToken)), permissionArn: \(Swift.String(describing: permissionArn)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension DisassociateResourceSharePermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct DisassociateResourceSharePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceSharePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceSharePermissionOutputError>
}

public struct DisassociateResourceSharePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateResourceSharePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateResourceSharePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateResourceSharePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateResourceSharePermissionOutputError>
}

public struct DisassociateResourceSharePermissionInput: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>The ARN of the permission to disassociate from the resource share.</p>
    public let permissionArn: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.resourceShareArn = resourceShareArn
    }
}

struct DisassociateResourceSharePermissionInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let permissionArn: Swift.String?
    public let clientToken: Swift.String?
}

extension DisassociateResourceSharePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceSharePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceSharePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateResourceSharePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceSharePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateResourceSharePermissionOutputResponse(clientToken: \(Swift.String(describing: clientToken)), returnValue: \(Swift.String(describing: returnValue)))"}
}

extension DisassociateResourceSharePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DisassociateResourceSharePermissionOutputResponse: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DisassociateResourceSharePermissionOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
    public let clientToken: Swift.String?
}

extension DisassociateResourceSharePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableSharingWithAwsOrganizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableSharingWithAwsOrganizationInput()"}
}

extension EnableSharingWithAwsOrganizationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct EnableSharingWithAwsOrganizationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableSharingWithAwsOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableSharingWithAwsOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableSharingWithAwsOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableSharingWithAwsOrganizationOutputError>
}

public struct EnableSharingWithAwsOrganizationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableSharingWithAwsOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableSharingWithAwsOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableSharingWithAwsOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableSharingWithAwsOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableSharingWithAwsOrganizationOutputError>
}

public struct EnableSharingWithAwsOrganizationInput: Swift.Equatable {

    public init() {}
}

struct EnableSharingWithAwsOrganizationInputBody: Swift.Equatable {
}

extension EnableSharingWithAwsOrganizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableSharingWithAwsOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableSharingWithAwsOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableSharingWithAwsOrganizationOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableSharingWithAwsOrganizationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableSharingWithAwsOrganizationOutputResponse(returnValue: \(Swift.String(describing: returnValue)))"}
}

extension EnableSharingWithAwsOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EnableSharingWithAwsOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct EnableSharingWithAwsOrganizationOutputResponse: Swift.Equatable {
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Swift.Bool?

    public init (
        returnValue: Swift.Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct EnableSharingWithAwsOrganizationOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
}

extension EnableSharingWithAwsOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

public struct GetPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPermissionOutputError>
}

extension GetPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPermissionInput(permissionArn: \(Swift.String(describing: permissionArn)), permissionVersion: \(Swift.String(describing: permissionVersion)))"}
}

extension GetPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionArn
        case permissionVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionArn = permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
    }
}

public struct GetPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPermissionOutputError>
}

public struct GetPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPermissionOutputError>
}

public struct GetPermissionInput: Swift.Equatable {
    /// <p>The ARN of the permission.</p>
    public let permissionArn: Swift.String?
    /// <p>The identifier for the version of the permission.</p>
    public let permissionVersion: Swift.Int?

    public init (
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil
    )
    {
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
    }
}

struct GetPermissionInputBody: Swift.Equatable {
    public let permissionArn: Swift.String?
    public let permissionVersion: Swift.Int?
}

extension GetPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionArn
        case permissionVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
    }
}

extension GetPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPermissionOutputResponse(permission: \(Swift.String(describing: permission)))"}
}

extension GetPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permission = output.permission
        } else {
            self.permission = nil
        }
    }
}

public struct GetPermissionOutputResponse: Swift.Equatable {
    /// <p>Information about the permission.</p>
    public let permission: RamClientTypes.ResourceSharePermissionDetail?

    public init (
        permission: RamClientTypes.ResourceSharePermissionDetail? = nil
    )
    {
        self.permission = permission
    }
}

struct GetPermissionOutputResponseBody: Swift.Equatable {
    public let permission: RamClientTypes.ResourceSharePermissionDetail?
}

extension GetPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permission
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceSharePermissionDetail.self, forKey: .permission)
        permission = permissionDecoded
    }
}

public struct GetResourcePoliciesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePoliciesOutputError>
}

extension GetResourcePoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePoliciesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principal: \(Swift.String(describing: principal)), resourceArns: \(Swift.String(describing: resourceArns)))"}
}

extension GetResourcePoliciesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
    }
}

public struct GetResourcePoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourcePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The principal.</p>
    public let principal: Swift.String?
    /// <p>The Amazon Resource Names (ARN) of the resources.</p>
    public let resourceArns: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
    }
}

struct GetResourcePoliciesInputBody: Swift.Equatable {
    public let resourceArns: [Swift.String]?
    public let principal: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetResourcePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourcePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnNotFoundException" : self = .resourceArnNotFoundException(try ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePoliciesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceArnNotFoundException(ResourceArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePoliciesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), policies: \(Swift.String(describing: policies)))"}
}

extension GetResourcePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policies = output.policies
        } else {
            self.nextToken = nil
            self.policies = nil
        }
    }
}

public struct GetResourcePoliciesOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>A key policy document, in JSON format.</p>
    public let policies: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        policies: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.policies = policies
    }
}

struct GetResourcePoliciesOutputResponseBody: Swift.Equatable {
    public let policies: [Swift.String]?
    public let nextToken: Swift.String?
}

extension GetResourcePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case policies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .policies)
        var policiesDecoded0:[Swift.String]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Swift.String]()
            for string0 in policiesContainer {
                if let string0 = string0 {
                    policiesDecoded0?.append(string0)
                }
            }
        }
        policies = policiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceShareAssociationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareAssociationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareAssociationsOutputError>
}

extension GetResourceShareAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceShareAssociationsInput(associationStatus: \(Swift.String(describing: associationStatus)), associationType: \(Swift.String(describing: associationType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principal: \(Swift.String(describing: principal)), resourceArn: \(Swift.String(describing: resourceArn)), resourceShareArns: \(Swift.String(describing: resourceShareArns)))"}
}

extension GetResourceShareAssociationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatus = associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
    }
}

public struct GetResourceShareAssociationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareAssociationsOutputError>
}

public struct GetResourceShareAssociationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareAssociationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareAssociationsOutputError>
}

public struct GetResourceShareAssociationsInput: Swift.Equatable {
    /// <p>The association status.</p>
    public let associationStatus: RamClientTypes.ResourceShareAssociationStatus?
    /// <p>The association type. Specify <code>PRINCIPAL</code> to list the principals that are
    ///    		associated with the specified resource share. Specify <code>RESOURCE</code> to list
    ///    		the resources that are associated with the specified resource share.</p>
    public let associationType: RamClientTypes.ResourceShareAssociationType?
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The principal. You cannot specify this parameter if the association type is
    ///      	<code>RESOURCE</code>.</p>
    public let principal: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the resource. You cannot specify this parameter if the
    ///       	association type is <code>PRINCIPAL</code>.</p>
    public let resourceArn: Swift.String?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [Swift.String]?

    public init (
        associationStatus: RamClientTypes.ResourceShareAssociationStatus? = nil,
        associationType: RamClientTypes.ResourceShareAssociationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceShareArns: [Swift.String]? = nil
    )
    {
        self.associationStatus = associationStatus
        self.associationType = associationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArn = resourceArn
        self.resourceShareArns = resourceShareArns
    }
}

struct GetResourceShareAssociationsInputBody: Swift.Equatable {
    public let associationType: RamClientTypes.ResourceShareAssociationType?
    public let resourceShareArns: [Swift.String]?
    public let resourceArn: Swift.String?
    public let principal: Swift.String?
    public let associationStatus: RamClientTypes.ResourceShareAssociationStatus?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetResourceShareAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationTypeDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareAssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceShareAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceShareAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceShareAssociationsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceShareAssociationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceShareAssociationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceShareAssociations: \(Swift.String(describing: resourceShareAssociations)))"}
}

extension GetResourceShareAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceShareAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.nextToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct GetResourceShareAssociationsOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>Information about the associations.</p>
    public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?

    public init (
        nextToken: Swift.String? = nil,
        resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct GetResourceShareAssociationsOutputResponseBody: Swift.Equatable {
    public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?
    public let nextToken: Swift.String?
}

extension GetResourceShareAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShareAssociations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RamClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RamClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceShareInvitationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareInvitationsOutputError>
}

extension GetResourceShareInvitationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceShareInvitationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceShareArns: \(Swift.String(describing: resourceShareArns)), resourceShareInvitationArns: \(Swift.String(describing: resourceShareInvitationArns)))"}
}

extension GetResourceShareInvitationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceShareInvitationArns = resourceShareInvitationArns {
            var resourceShareInvitationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareInvitationArns)
            for resourceshareinvitationarnlist0 in resourceShareInvitationArns {
                try resourceShareInvitationArnsContainer.encode(resourceshareinvitationarnlist0)
            }
        }
    }
}

public struct GetResourceShareInvitationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareInvitationsOutputError>
}

public struct GetResourceShareInvitationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceShareInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceShareInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceShareInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceShareInvitationsOutputError>
}

public struct GetResourceShareInvitationsInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [Swift.String]?
    /// <p>The Amazon Resource Names (ARN) of the invitations.</p>
    public let resourceShareInvitationArns: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceShareInvitationArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArns = resourceShareArns
        self.resourceShareInvitationArns = resourceShareInvitationArns
    }
}

struct GetResourceShareInvitationsInputBody: Swift.Equatable {
    public let resourceShareInvitationArns: [Swift.String]?
    public let resourceShareArns: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetResourceShareInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareInvitationArns)
        var resourceShareInvitationArnsDecoded0:[Swift.String]? = nil
        if let resourceShareInvitationArnsContainer = resourceShareInvitationArnsContainer {
            resourceShareInvitationArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareInvitationArnsContainer {
                if let string0 = string0 {
                    resourceShareInvitationArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareInvitationArns = resourceShareInvitationArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceShareInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceShareInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationArnNotFoundException" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceShareInvitationsOutputError: Swift.Error, Swift.Equatable {
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceShareInvitationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceShareInvitationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceShareInvitations: \(Swift.String(describing: resourceShareInvitations)))"}
}

extension GetResourceShareInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceShareInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShareInvitations = output.resourceShareInvitations
        } else {
            self.nextToken = nil
            self.resourceShareInvitations = nil
        }
    }
}

public struct GetResourceShareInvitationsOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>Information about the invitations.</p>
    public let resourceShareInvitations: [RamClientTypes.ResourceShareInvitation]?

    public init (
        nextToken: Swift.String? = nil,
        resourceShareInvitations: [RamClientTypes.ResourceShareInvitation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareInvitations = resourceShareInvitations
    }
}

struct GetResourceShareInvitationsOutputResponseBody: Swift.Equatable {
    public let resourceShareInvitations: [RamClientTypes.ResourceShareInvitation]?
    public let nextToken: Swift.String?
}

extension GetResourceShareInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShareInvitations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareInvitation?].self, forKey: .resourceShareInvitations)
        var resourceShareInvitationsDecoded0:[RamClientTypes.ResourceShareInvitation]? = nil
        if let resourceShareInvitationsContainer = resourceShareInvitationsContainer {
            resourceShareInvitationsDecoded0 = [RamClientTypes.ResourceShareInvitation]()
            for structure0 in resourceShareInvitationsContainer {
                if let structure0 = structure0 {
                    resourceShareInvitationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareInvitations = resourceShareInvitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetResourceSharesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSharesOutputError>
}

extension GetResourceSharesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceSharesInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), resourceOwner: \(Swift.String(describing: resourceOwner)), resourceShareArns: \(Swift.String(describing: resourceShareArns)), resourceShareStatus: \(Swift.String(describing: resourceShareStatus)), tagFilters: \(Swift.String(describing: tagFilters)))"}
}

extension GetResourceSharesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceShareStatus = resourceShareStatus {
            try encodeContainer.encode(resourceShareStatus.rawValue, forKey: .resourceShareStatus)
        }
        if let tagFilters = tagFilters {
            var tagFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagFilters)
            for tagfilters0 in tagFilters {
                try tagFiltersContainer.encode(tagfilters0)
            }
        }
    }
}

public struct GetResourceSharesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSharesOutputError>
}

public struct GetResourceSharesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSharesOutputError>
}

public struct GetResourceSharesInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The name of the resource share.</p>
    public let name: Swift.String?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The type of owner.</p>
    public let resourceOwner: RamClientTypes.ResourceOwner?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [Swift.String]?
    /// <p>The status of the resource share.</p>
    public let resourceShareStatus: RamClientTypes.ResourceShareStatus?
    /// <p>One or more tag filters.</p>
    public let tagFilters: [RamClientTypes.TagFilter]?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceOwner: RamClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceShareStatus: RamClientTypes.ResourceShareStatus? = nil,
        tagFilters: [RamClientTypes.TagFilter]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceShareStatus = resourceShareStatus
        self.tagFilters = tagFilters
    }
}

struct GetResourceSharesInputBody: Swift.Equatable {
    public let resourceShareArns: [Swift.String]?
    public let resourceShareStatus: RamClientTypes.ResourceShareStatus?
    public let resourceOwner: RamClientTypes.ResourceOwner?
    public let name: Swift.String?
    public let tagFilters: [RamClientTypes.TagFilter]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension GetResourceSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceShareStatusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareStatus.self, forKey: .resourceShareStatus)
        resourceShareStatus = resourceShareStatusDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagFiltersContainer = try containerValues.decodeIfPresent([RamClientTypes.TagFilter?].self, forKey: .tagFilters)
        var tagFiltersDecoded0:[RamClientTypes.TagFilter]? = nil
        if let tagFiltersContainer = tagFiltersContainer {
            tagFiltersDecoded0 = [RamClientTypes.TagFilter]()
            for structure0 in tagFiltersContainer {
                if let structure0 = structure0 {
                    tagFiltersDecoded0?.append(structure0)
                }
            }
        }
        tagFilters = tagFiltersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceSharesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceSharesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceSharesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceShares: \(Swift.String(describing: resourceShares)))"}
}

extension GetResourceSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShares = output.resourceShares
        } else {
            self.nextToken = nil
            self.resourceShares = nil
        }
    }
}

public struct GetResourceSharesOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>Information about the resource shares.</p>
    public let resourceShares: [RamClientTypes.ResourceShare]?

    public init (
        nextToken: Swift.String? = nil,
        resourceShares: [RamClientTypes.ResourceShare]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShares = resourceShares
    }
}

struct GetResourceSharesOutputResponseBody: Swift.Equatable {
    public let resourceShares: [RamClientTypes.ResourceShare]?
    public let nextToken: Swift.String?
}

extension GetResourceSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShares
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSharesContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShare?].self, forKey: .resourceShares)
        var resourceSharesDecoded0:[RamClientTypes.ResourceShare]? = nil
        if let resourceSharesContainer = resourceSharesContainer {
            resourceSharesDecoded0 = [RamClientTypes.ResourceShare]()
            for structure0 in resourceSharesContainer {
                if let structure0 = structure0 {
                    resourceSharesDecoded0?.append(structure0)
                }
            }
        }
        resourceShares = resourceSharesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IdempotentParameterMismatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdempotentParameterMismatchException(message: \(Swift.String(describing: message)))"}
}

extension IdempotentParameterMismatchException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A client token input parameter was reused with an operation, but at least one of
///         the other input parameters is different from the previous call to the operation.</p>
public struct IdempotentParameterMismatchException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClientTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidClientTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidClientTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A client token is not valid.</p>
public struct InvalidClientTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClientTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClientTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidMaxResultsException(message: \(Swift.String(describing: message)))"}
}

extension InvalidMaxResultsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified value for MaxResults is not valid.</p>
public struct InvalidMaxResultsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidMaxResultsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified value for NextToken is not valid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A parameter is not valid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceTypeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidResourceTypeException(message: \(Swift.String(describing: message)))"}
}

extension InvalidResourceTypeException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource type is not valid.</p>
public struct InvalidResourceTypeException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceTypeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidResourceTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateTransitionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStateTransitionException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStateTransitionException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStateTransitionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested state transition is not valid.</p>
public struct InvalidStateTransitionException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateTransitionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStateTransitionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListPendingInvitationResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPendingInvitationResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPendingInvitationResourcesOutputError>
}

extension ListPendingInvitationResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPendingInvitationResourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceShareInvitationArn: \(Swift.String(describing: resourceShareInvitationArn)))"}
}

extension ListPendingInvitationResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

public struct ListPendingInvitationResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPendingInvitationResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPendingInvitationResourcesOutputError>
}

public struct ListPendingInvitationResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPendingInvitationResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPendingInvitationResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPendingInvitationResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPendingInvitationResourcesOutputError>
}

public struct ListPendingInvitationResourcesInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the invitation.</p>
    public let resourceShareInvitationArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct ListPendingInvitationResourcesInputBody: Swift.Equatable {
    public let resourceShareInvitationArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPendingInvitationResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPendingInvitationResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPendingInvitationResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyRejectedException" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationArnNotFoundException" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationExpiredException" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPendingInvitationResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPendingInvitationResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPendingInvitationResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resources: \(Swift.String(describing: resources)))"}
}

extension ListPendingInvitationResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPendingInvitationResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListPendingInvitationResourcesOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>Information about the resources included the resource share.</p>
    public let resources: [RamClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [RamClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListPendingInvitationResourcesOutputResponseBody: Swift.Equatable {
    public let resources: [RamClientTypes.Resource]?
    public let nextToken: Swift.String?
}

extension ListPendingInvitationResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([RamClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[RamClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RamClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

extension ListPermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPermissionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListPermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct ListPermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPermissionsOutputError>
}

public struct ListPermissionsInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>Specifies the resource type for which to list permissions. For example, to list only
    /// 		permissions that apply to EC2 subnets, specify <code>ec2:Subnet</code>.</p>
    public let resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListPermissionsInputBody: Swift.Equatable {
    public let resourceType: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPermissionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPermissionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), permissions: \(Swift.String(describing: permissions)))"}
}

extension ListPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionsOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>Information about the permissions.</p>
    public let permissions: [RamClientTypes.ResourceSharePermissionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [RamClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionsOutputResponseBody: Swift.Equatable {
    public let permissions: [RamClientTypes.ResourceSharePermissionSummary]?
    public let nextToken: Swift.String?
}

extension ListPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RamClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RamClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPrincipalsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPrincipalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPrincipalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsOutputError>
}

extension ListPrincipalsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPrincipalsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principals: \(Swift.String(describing: principals)), resourceArn: \(Swift.String(describing: resourceArn)), resourceOwner: \(Swift.String(describing: resourceOwner)), resourceShareArns: \(Swift.String(describing: resourceShareArns)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListPrincipalsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principalarnoridlist0 in principals {
                try principalsContainer.encode(principalarnoridlist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct ListPrincipalsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPrincipalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPrincipalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsOutputError>
}

public struct ListPrincipalsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPrincipalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPrincipalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsOutputError>
}

public struct ListPrincipalsInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The principals.</p>
    public let principals: [Swift.String]?
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: Swift.String?
    /// <p>The type of owner.</p>
    public let resourceOwner: RamClientTypes.ResourceOwner?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [Swift.String]?
    /// <p>The resource type.</p>
    ///    	     <p>Valid values: <code>acm-pca:CertificateAuthority</code> | <code>appmesh:Mesh</code> | <code>codebuild:Project</code> | <code>codebuild:ReportGroup</code> | <code>ec2:CapacityReservation</code> | <code>ec2:DedicatedHost</code> | <code>ec2:LocalGatewayRouteTable</code> | <code>ec2:PrefixList</code> | <code>ec2:Subnet</code> | <code>ec2:TrafficMirrorTarget</code> | <code>ec2:TransitGateway</code> | <code>imagebuilder:Component</code> | <code>imagebuilder:Image</code> | <code>imagebuilder:ImageRecipe</code> | <code>imagebuilder:ContainerRecipe</code> | <code>glue:Catalog</code> | <code>glue:Database</code> | <code>glue:Table</code> | <code>license-manager:LicenseConfiguration</code> I <code>network-firewall:FirewallPolicy</code> | <code>network-firewall:StatefulRuleGroup</code> | <code>network-firewall:StatelessRuleGroup</code> | <code>outposts:Outpost</code> | <code>resource-groups:Group</code> | <code>rds:Cluster</code> | <code>route53resolver:FirewallRuleGroup</code> |<code>route53resolver:ResolverQueryLogConfig</code> | <code>route53resolver:ResolverRule</code>
    ///          </p>
    public let resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        resourceOwner: RamClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principals = principals
        self.resourceArn = resourceArn
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListPrincipalsInputBody: Swift.Equatable {
    public let resourceOwner: RamClientTypes.ResourceOwner?
    public let resourceArn: Swift.String?
    public let principals: [Swift.String]?
    public let resourceType: Swift.String?
    public let resourceShareArns: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPrincipalsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPrincipalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPrincipalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPrincipalsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPrincipalsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPrincipalsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), principals: \(Swift.String(describing: principals)))"}
}

extension ListPrincipalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPrincipalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.principals = output.principals
        } else {
            self.nextToken = nil
            self.principals = nil
        }
    }
}

public struct ListPrincipalsOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>The principals.</p>
    public let principals: [RamClientTypes.Principal]?

    public init (
        nextToken: Swift.String? = nil,
        principals: [RamClientTypes.Principal]? = nil
    )
    {
        self.nextToken = nextToken
        self.principals = principals
    }
}

struct ListPrincipalsOutputResponseBody: Swift.Equatable {
    public let principals: [RamClientTypes.Principal]?
    public let nextToken: Swift.String?
}

extension ListPrincipalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case principals
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([RamClientTypes.Principal?].self, forKey: .principals)
        var principalsDecoded0:[RamClientTypes.Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [RamClientTypes.Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceSharePermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSharePermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSharePermissionsOutputError>
}

extension ListResourceSharePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceSharePermissionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension ListResourceSharePermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct ListResourceSharePermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSharePermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSharePermissionsOutputError>
}

public struct ListResourceSharePermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSharePermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceSharePermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSharePermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSharePermissionsOutputError>
}

public struct ListResourceSharePermissionsInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArn = resourceShareArn
    }
}

struct ListResourceSharePermissionsInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListResourceSharePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceSharePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceSharePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceSharePermissionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceSharePermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceSharePermissionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), permissions: \(Swift.String(describing: permissions)))"}
}

extension ListResourceSharePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceSharePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListResourceSharePermissionsOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>The permissions associated with the resource share.</p>
    public let permissions: [RamClientTypes.ResourceSharePermissionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [RamClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListResourceSharePermissionsOutputResponseBody: Swift.Equatable {
    public let permissions: [RamClientTypes.ResourceSharePermissionSummary]?
    public let nextToken: Swift.String?
}

extension ListResourceSharePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RamClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RamClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceTypesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceTypesOutputError>
}

extension ListResourceTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceTypesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListResourceTypesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResourceTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceTypesOutputError>
}

public struct ListResourceTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceTypesOutputError>
}

public struct ListResourceTypesInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceTypesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceTypesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceTypes: \(Swift.String(describing: resourceTypes)))"}
}

extension ListResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceTypes = output.resourceTypes
        } else {
            self.nextToken = nil
            self.resourceTypes = nil
        }
    }
}

public struct ListResourceTypesOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>The shareable resource types supported by AWS RAM.</p>
    public let resourceTypes: [RamClientTypes.ServiceNameAndResourceType]?

    public init (
        nextToken: Swift.String? = nil,
        resourceTypes: [RamClientTypes.ServiceNameAndResourceType]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
    }
}

struct ListResourceTypesOutputResponseBody: Swift.Equatable {
    public let resourceTypes: [RamClientTypes.ServiceNameAndResourceType]?
    public let nextToken: Swift.String?
}

extension ListResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceTypes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([RamClientTypes.ServiceNameAndResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[RamClientTypes.ServiceNameAndResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [RamClientTypes.ServiceNameAndResourceType]()
            for structure0 in resourceTypesContainer {
                if let structure0 = structure0 {
                    resourceTypesDecoded0?.append(structure0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

extension ListResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principal: \(Swift.String(describing: principal)), resourceArns: \(Swift.String(describing: resourceArns)), resourceOwner: \(Swift.String(describing: resourceOwner)), resourceShareArns: \(Swift.String(describing: resourceShareArns)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for resourcesharearnlist0 in resourceShareArns {
                try resourceShareArnsContainer.encode(resourcesharearnlist0)
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

public struct ListResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInput: Swift.Equatable {
    /// <p>The maximum number of results to return with a single call.
    ///   To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: Swift.String?
    /// <p>The principal.</p>
    public let principal: Swift.String?
    /// <p>The Amazon Resource Names (ARN) of the resources.</p>
    public let resourceArns: [Swift.String]?
    /// <p>The type of owner.</p>
    public let resourceOwner: RamClientTypes.ResourceOwner?
    /// <p>The Amazon Resource Names (ARN) of the resource shares.</p>
    public let resourceShareArns: [Swift.String]?
    /// <p>The resource type.</p>
    ///    	     <p>Valid values: <code>acm-pca:CertificateAuthority</code> | <code>appmesh:Mesh</code> | <code>codebuild:Project</code> | <code>codebuild:ReportGroup</code> | <code>ec2:CapacityReservation</code> | <code>ec2:DedicatedHost</code> | <code>ec2:LocalGatewayRouteTable</code> | <code>ec2:PrefixList</code> | <code>ec2:Subnet</code> | <code>ec2:TrafficMirrorTarget</code> | <code>ec2:TransitGateway</code> | <code>imagebuilder:Component</code> | <code>imagebuilder:Image</code> | <code>imagebuilder:ImageRecipe</code> | <code>imagebuilder:ContainerRecipe</code> | <code>glue:Catalog</code> | <code>glue:Database</code> | <code>glue:Table</code> | <code>license-manager:LicenseConfiguration</code> I <code>network-firewall:FirewallPolicy</code> | <code>network-firewall:StatefulRuleGroup</code> | <code>network-firewall:StatelessRuleGroup</code> | <code>outposts:Outpost</code> | <code>resource-groups:Group</code> | <code>rds:Cluster</code> | <code>route53resolver:FirewallRuleGroup</code> |<code>route53resolver:ResolverQueryLogConfig</code> | <code>route53resolver:ResolverRule</code>
    ///          </p>
    public let resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceOwner: RamClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    public let resourceOwner: RamClientTypes.ResourceOwner?
    public let principal: Swift.String?
    public let resourceType: Swift.String?
    public let resourceArns: [Swift.String]?
    public let resourceShareArns: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceTypeException" : self = .invalidResourceTypeException(try InvalidResourceTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceTypeException(InvalidResourceTypeException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resources: \(Swift.String(describing: resources)))"}
}

extension ListResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Swift.Equatable {
    /// <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: Swift.String?
    /// <p>Information about the resources.</p>
    public let resources: [RamClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [RamClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Swift.Equatable {
    public let resources: [RamClientTypes.Resource]?
    public let nextToken: Swift.String?
}

extension ListResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([RamClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[RamClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RamClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MalformedArnException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MalformedArnException(message: \(Swift.String(describing: message)))"}
}

extension MalformedArnException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MalformedArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The format of an Amazon Resource Name (ARN) is not valid.</p>
public struct MalformedArnException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedArnExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MalformedArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MissingRequiredParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MissingRequiredParameterException(message: \(Swift.String(describing: message)))"}
}

extension MissingRequiredParameterException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MissingRequiredParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A required input parameter is missing.</p>
public struct MissingRequiredParameterException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MissingRequiredParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MissingRequiredParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotPermittedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationNotPermittedException(message: \(Swift.String(describing: message)))"}
}

extension OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation is not permitted.</p>
public struct OperationNotPermittedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes.Principal: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case external
        case id
        case lastUpdatedTime
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let external = external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension RamClientTypes.Principal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Principal(creationTime: \(Swift.String(describing: creationTime)), external: \(Swift.String(describing: external)), id: \(Swift.String(describing: id)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension RamClientTypes {
    /// <p>Describes a principal for use with AWS Resource Access Manager.</p>
    public struct Principal: Swift.Equatable {
        /// <p>The time when the principal was associated with the resource share.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>Indicates whether the principal belongs to the same AWS organization as the AWS account that owns the resource share.</p>
        public let external: Swift.Bool?
        /// <p>The ID of the principal.</p>
        public let id: Swift.String?
        /// <p>The time when the association was last updated.</p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
        public let resourceShareArn: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            external: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceShareArn: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.external = external
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
        }
    }

}

extension PromoteResourceShareCreatedFromPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteResourceShareCreatedFromPolicyInput(resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension PromoteResourceShareCreatedFromPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct PromoteResourceShareCreatedFromPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteResourceShareCreatedFromPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteResourceShareCreatedFromPolicyOutputError>
}

public struct PromoteResourceShareCreatedFromPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PromoteResourceShareCreatedFromPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceShareArn = input.operationInput.resourceShareArn {
            let resourceShareArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: Swift.String(resourceShareArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceShareArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PromoteResourceShareCreatedFromPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PromoteResourceShareCreatedFromPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PromoteResourceShareCreatedFromPolicyOutputError>
}

public struct PromoteResourceShareCreatedFromPolicyInput: Swift.Equatable {
    /// <p>The ARN of the resource share to promote.</p>
    public let resourceShareArn: Swift.String?

    public init (
        resourceShareArn: Swift.String? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
    }
}

struct PromoteResourceShareCreatedFromPolicyInputBody: Swift.Equatable {
}

extension PromoteResourceShareCreatedFromPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PromoteResourceShareCreatedFromPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PromoteResourceShareCreatedFromPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PromoteResourceShareCreatedFromPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteResourceShareCreatedFromPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromoteResourceShareCreatedFromPolicyOutputResponse(returnValue: \(Swift.String(describing: returnValue)))"}
}

extension PromoteResourceShareCreatedFromPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PromoteResourceShareCreatedFromPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct PromoteResourceShareCreatedFromPolicyOutputResponse: Swift.Equatable {
    /// <p>Indicates whether the request succeeded.</p>
    public let returnValue: Swift.Bool?

    public init (
        returnValue: Swift.Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct PromoteResourceShareCreatedFromPolicyOutputResponseBody: Swift.Equatable {
    public let returnValue: Swift.Bool?
}

extension PromoteResourceShareCreatedFromPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

public struct RejectResourceShareInvitationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectResourceShareInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectResourceShareInvitationOutputError>
}

extension RejectResourceShareInvitationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectResourceShareInvitationInput(clientToken: \(Swift.String(describing: clientToken)), resourceShareInvitationArn: \(Swift.String(describing: resourceShareInvitationArn)))"}
}

extension RejectResourceShareInvitationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

public struct RejectResourceShareInvitationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectResourceShareInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectResourceShareInvitationOutputError>
}

public struct RejectResourceShareInvitationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectResourceShareInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectResourceShareInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectResourceShareInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectResourceShareInvitationOutputError>
}

public struct RejectResourceShareInvitationInput: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the invitation.</p>
    public let resourceShareInvitationArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct RejectResourceShareInvitationInputBody: Swift.Equatable {
    public let resourceShareInvitationArn: Swift.String?
    public let clientToken: Swift.String?
}

extension RejectResourceShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RejectResourceShareInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectResourceShareInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyAcceptedException" : self = .resourceShareInvitationAlreadyAcceptedException(try ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationAlreadyRejectedException" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationArnNotFoundException" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareInvitationExpiredException" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectResourceShareInvitationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareInvitationAlreadyAcceptedException(ResourceShareInvitationAlreadyAcceptedException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectResourceShareInvitationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectResourceShareInvitationOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShareInvitation: \(Swift.String(describing: resourceShareInvitation)))"}
}

extension RejectResourceShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RejectResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct RejectResourceShareInvitationOutputResponse: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>Information about the invitation.</p>
    public let resourceShareInvitation: RamClientTypes.ResourceShareInvitation?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitation: RamClientTypes.ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct RejectResourceShareInvitationOutputResponseBody: Swift.Equatable {
    public let resourceShareInvitation: RamClientTypes.ResourceShareInvitation?
    public let clientToken: Swift.String?
}

extension RejectResourceShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RamClientTypes.Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case lastUpdatedTime
        case resourceGroupArn
        case resourceShareArn
        case status
        case statusMessage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceGroupArn = resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension RamClientTypes.Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Resource(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), resourceGroupArn: \(Swift.String(describing: resourceGroupArn)), resourceShareArn: \(Swift.String(describing: resourceShareArn)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), type: \(Swift.String(describing: type)))"}
}

extension RamClientTypes {
    /// <p>Describes a resource associated with a resource share.</p>
    public struct Resource: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the resource.</p>
        public let arn: Swift.String?
        /// <p>The time when the resource was associated with the resource share.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The time when the association was last updated.</p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>The ARN of the resource group. This value is returned only if the resource is a resource
        /// 			group.</p>
        public let resourceGroupArn: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
        public let resourceShareArn: Swift.String?
        /// <p>The status of the resource.</p>
        public let status: RamClientTypes.ResourceStatus?
        /// <p>A message about the status of the resource.</p>
        public let statusMessage: Swift.String?
        /// <p>The resource type.</p>
        public let type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceGroupArn: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            status: RamClientTypes.ResourceStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceGroupArn = resourceGroupArn
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension ResourceArnNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceArnNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceArnNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Amazon Resource Name (ARN) was not found.</p>
public struct ResourceArnNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceArnNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceArnNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes {
    public enum ResourceOwner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case otherAccounts
        case `self`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceOwner] {
            return [
                .otherAccounts,
                .self,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .otherAccounts: return "OTHER-ACCOUNTS"
            case .self: return "SELF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceOwner(rawValue: rawValue) ?? ResourceOwner.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes.ResourceShare: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case creationTime
        case featureSet
        case lastUpdatedTime
        case name
        case owningAccountId
        case resourceShareArn
        case status
        case statusMessage
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let featureSet = featureSet {
            try encodeContainer.encode(featureSet.rawValue, forKey: .featureSet)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningAccountId = owningAccountId {
            try encodeContainer.encode(owningAccountId, forKey: .owningAccountId)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let owningAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningAccountId)
        owningAccountId = owningAccountIdDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RamClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RamClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RamClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let featureSetDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareFeatureSet.self, forKey: .featureSet)
        featureSet = featureSetDecoded
    }
}

extension RamClientTypes.ResourceShare: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShare(allowExternalPrincipals: \(Swift.String(describing: allowExternalPrincipals)), creationTime: \(Swift.String(describing: creationTime)), featureSet: \(Swift.String(describing: featureSet)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), owningAccountId: \(Swift.String(describing: owningAccountId)), resourceShareArn: \(Swift.String(describing: resourceShareArn)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), tags: \(Swift.String(describing: tags)))"}
}

extension RamClientTypes {
    /// <p>Describes a resource share.</p>
    public struct ResourceShare: Swift.Equatable {
        /// <p>Indicates whether principals outside your AWS organization can be associated with a resource share.</p>
        public let allowExternalPrincipals: Swift.Bool?
        /// <p>The time when the resource share was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>Indicates how the resource share was created. Possible values include:</p>
        /// 	        <ul>
        ///             <li>
        /// 			            <p>
        ///                   <code>CREATED_FROM_POLICY</code> - Indicates that the resource share was created from an AWS Identity
        /// 					and Access Management (AWS IAM) policy attached to a resource. These resource shares are
        /// 					visible only to the AWS account that created it. They cannot be modified in
        /// 					AWS RAM.</p>
        /// 		          </li>
        ///             <li>
        /// 			            <p>
        ///                   <code>PROMOTING_TO_STANDARD</code> - The resource share is in the process
        /// 				of being promoted. For more information, see
        /// 				<a>PromoteResourceShareCreatedFromPolicy</a>.</p>
        /// 		          </li>
        ///             <li>
        /// 			            <p>
        ///                   <code>STANDARD</code> - Indicates that the resource share was created in AWS RAM using the console or
        /// 					APIs. These resource shares are visible to all principals. They can be modified
        /// 					in AWS RAM.</p>
        /// 		          </li>
        ///          </ul>
        public let featureSet: RamClientTypes.ResourceShareFeatureSet?
        /// <p>The time when the resource share was last updated.</p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>The name of the resource share.</p>
        public let name: Swift.String?
        /// <p>The ID of the AWS account that owns the resource share.</p>
        public let owningAccountId: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
        public let resourceShareArn: Swift.String?
        /// <p>The status of the resource share.</p>
        public let status: RamClientTypes.ResourceShareStatus?
        /// <p>A message about the status of the resource share.</p>
        public let statusMessage: Swift.String?
        /// <p>The tags for the resource share.</p>
        public let tags: [RamClientTypes.Tag]?

        public init (
            allowExternalPrincipals: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            featureSet: RamClientTypes.ResourceShareFeatureSet? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owningAccountId: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            status: RamClientTypes.ResourceShareStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [RamClientTypes.Tag]? = nil
        )
        {
            self.allowExternalPrincipals = allowExternalPrincipals
            self.creationTime = creationTime
            self.featureSet = featureSet
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.owningAccountId = owningAccountId
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension RamClientTypes.ResourceShareAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedEntity
        case associationType
        case creationTime
        case external
        case lastUpdatedTime
        case resourceShareArn
        case resourceShareName
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedEntity = associatedEntity {
            try encodeContainer.encode(associatedEntity, forKey: .associatedEntity)
        }
        if let associationType = associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let external = external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareName = resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let associatedEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedEntity)
        associatedEntity = associatedEntityDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension RamClientTypes.ResourceShareAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareAssociation(associatedEntity: \(Swift.String(describing: associatedEntity)), associationType: \(Swift.String(describing: associationType)), creationTime: \(Swift.String(describing: creationTime)), external: \(Swift.String(describing: external)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), resourceShareArn: \(Swift.String(describing: resourceShareArn)), resourceShareName: \(Swift.String(describing: resourceShareName)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)))"}
}

extension RamClientTypes {
    /// <p>Describes an association with a resource share.</p>
    public struct ResourceShareAssociation: Swift.Equatable {
        /// <p>The associated entity. For resource associations, this is the ARN of the resource.
        ///        For principal associations, this is the ID of an AWS account or the ARN of an OU or
        ///        organization from AWS Organizations.</p>
        public let associatedEntity: Swift.String?
        /// <p>The association type.</p>
        public let associationType: RamClientTypes.ResourceShareAssociationType?
        /// <p>The time when the association was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>Indicates whether the principal belongs to the same AWS organization as the AWS account that owns the resource share.</p>
        public let external: Swift.Bool?
        /// <p>The time when the association was last updated.</p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
        public let resourceShareArn: Swift.String?
        /// <p>The name of the resource share.</p>
        public let resourceShareName: Swift.String?
        /// <p>The status of the association.</p>
        public let status: RamClientTypes.ResourceShareAssociationStatus?
        /// <p>A message about the status of the association.</p>
        public let statusMessage: Swift.String?

        public init (
            associatedEntity: Swift.String? = nil,
            associationType: RamClientTypes.ResourceShareAssociationType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            external: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareName: Swift.String? = nil,
            status: RamClientTypes.ResourceShareAssociationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.associatedEntity = associatedEntity
            self.associationType = associationType
            self.creationTime = creationTime
            self.external = external
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
            self.resourceShareName = resourceShareName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension RamClientTypes {
    public enum ResourceShareAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case associating
        case disassociated
        case disassociating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareAssociationStatus] {
            return [
                .associated,
                .associating,
                .disassociated,
                .disassociating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .associating: return "ASSOCIATING"
            case .disassociated: return "DISASSOCIATED"
            case .disassociating: return "DISASSOCIATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareAssociationStatus(rawValue: rawValue) ?? ResourceShareAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes {
    public enum ResourceShareAssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case principal
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareAssociationType] {
            return [
                .principal,
                .resource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .principal: return "PRINCIPAL"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareAssociationType(rawValue: rawValue) ?? ResourceShareAssociationType.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes {
    public enum ResourceShareFeatureSet: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdFromPolicy
        case promotingToStandard
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareFeatureSet] {
            return [
                .createdFromPolicy,
                .promotingToStandard,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdFromPolicy: return "CREATED_FROM_POLICY"
            case .promotingToStandard: return "PROMOTING_TO_STANDARD"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareFeatureSet(rawValue: rawValue) ?? ResourceShareFeatureSet.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes.ResourceShareInvitation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationTimestamp
        case receiverAccountId
        case resourceShareArn
        case resourceShareAssociations
        case resourceShareInvitationArn
        case resourceShareName
        case senderAccountId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationTimestamp = invitationTimestamp {
            try encodeContainer.encode(invitationTimestamp.timeIntervalSince1970, forKey: .invitationTimestamp)
        }
        if let receiverAccountId = receiverAccountId {
            try encodeContainer.encode(receiverAccountId, forKey: .receiverAccountId)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareAssociations = resourceShareAssociations {
            var resourceShareAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareAssociations)
            for resourceshareassociationlist0 in resourceShareAssociations {
                try resourceShareAssociationsContainer.encode(resourceshareassociationlist0)
            }
        }
        if let resourceShareInvitationArn = resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
        if let resourceShareName = resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let senderAccountId = senderAccountId {
            try encodeContainer.encode(senderAccountId, forKey: .senderAccountId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let senderAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderAccountId)
        senderAccountId = senderAccountIdDecoded
        let receiverAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiverAccountId)
        receiverAccountId = receiverAccountIdDecoded
        let invitationTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .invitationTimestamp)
        invitationTimestamp = invitationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShareInvitationStatus.self, forKey: .status)
        status = statusDecoded
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RamClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RamClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RamClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
    }
}

extension RamClientTypes.ResourceShareInvitation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitation(invitationTimestamp: \(Swift.String(describing: invitationTimestamp)), receiverAccountId: \(Swift.String(describing: receiverAccountId)), resourceShareArn: \(Swift.String(describing: resourceShareArn)), resourceShareAssociations: \(Swift.String(describing: resourceShareAssociations)), resourceShareInvitationArn: \(Swift.String(describing: resourceShareInvitationArn)), resourceShareName: \(Swift.String(describing: resourceShareName)), senderAccountId: \(Swift.String(describing: senderAccountId)), status: \(Swift.String(describing: status)))"}
}

extension RamClientTypes {
    /// <p>Describes an invitation to join a resource share.</p>
    public struct ResourceShareInvitation: Swift.Equatable {
        /// <p>The date and time when the invitation was sent.</p>
        public let invitationTimestamp: ClientRuntime.Date?
        /// <p>The ID of the AWS account that received the invitation.</p>
        public let receiverAccountId: Swift.String?
        /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
        public let resourceShareArn: Swift.String?
        /// <p>To view the resources associated with a pending resource share invitation, use
        ///       	<a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_ListPendingInvitationResources.html">
        ///       		ListPendingInvitationResources</a>.</p>
        @available(*, deprecated, message: "This member has been deprecated. Use ListPendingInvitationResources.")
        public let resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]?
        /// <p>The Amazon Resource Name (ARN) of the invitation.</p>
        public let resourceShareInvitationArn: Swift.String?
        /// <p>The name of the resource share.</p>
        public let resourceShareName: Swift.String?
        /// <p>The ID of the AWS account that sent the invitation.</p>
        public let senderAccountId: Swift.String?
        /// <p>The status of the invitation.</p>
        public let status: RamClientTypes.ResourceShareInvitationStatus?

        public init (
            invitationTimestamp: ClientRuntime.Date? = nil,
            receiverAccountId: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareAssociations: [RamClientTypes.ResourceShareAssociation]? = nil,
            resourceShareInvitationArn: Swift.String? = nil,
            resourceShareName: Swift.String? = nil,
            senderAccountId: Swift.String? = nil,
            status: RamClientTypes.ResourceShareInvitationStatus? = nil
        )
        {
            self.invitationTimestamp = invitationTimestamp
            self.receiverAccountId = receiverAccountId
            self.resourceShareArn = resourceShareArn
            self.resourceShareAssociations = resourceShareAssociations
            self.resourceShareInvitationArn = resourceShareInvitationArn
            self.resourceShareName = resourceShareName
            self.senderAccountId = senderAccountId
            self.status = status
        }
    }

}

extension ResourceShareInvitationAlreadyAcceptedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitationAlreadyAcceptedException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareInvitationAlreadyAcceptedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareInvitationAlreadyAcceptedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The invitation was already accepted.</p>
public struct ResourceShareInvitationAlreadyAcceptedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationAlreadyAcceptedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareInvitationAlreadyAcceptedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationAlreadyRejectedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitationAlreadyRejectedException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareInvitationAlreadyRejectedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareInvitationAlreadyRejectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The invitation was already rejected.</p>
public struct ResourceShareInvitationAlreadyRejectedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationAlreadyRejectedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareInvitationAlreadyRejectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationArnNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitationArnNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareInvitationArnNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareInvitationArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Resource Name (ARN) for an invitation was not found.</p>
public struct ResourceShareInvitationArnNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationArnNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareInvitationArnNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationExpiredException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareInvitationExpiredException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareInvitationExpiredException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareInvitationExpiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The invitation is expired.</p>
public struct ResourceShareInvitationExpiredException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationExpiredExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareInvitationExpiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes {
    public enum ResourceShareInvitationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case expired
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareInvitationStatus] {
            return [
                .accepted,
                .expired,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareInvitationStatus(rawValue: rawValue) ?? ResourceShareInvitationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceShareLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceShareLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension ResourceShareLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceShareLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource share exceeds the limit for your account.</p>
public struct ResourceShareLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceShareLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes.ResourceSharePermissionDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case lastUpdatedTime
        case name
        case permission
        case resourceType
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permission = permission {
            try encodeContainer.encode(permission, forKey: .permission)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permission)
        permission = permissionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension RamClientTypes.ResourceSharePermissionDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceSharePermissionDetail(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), defaultVersion: \(Swift.String(describing: defaultVersion)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), permission: \(Swift.String(describing: permission)), resourceType: \(Swift.String(describing: resourceType)), version: \(Swift.String(describing: version)))"}
}

extension RamClientTypes {
    /// <p>Information about an AWS RAM permission.</p>
    public struct ResourceSharePermissionDetail: Swift.Equatable {
        /// <p>The ARN of the permission.</p>
        public let arn: Swift.String?
        /// <p>The date and time when the permission was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The identifier for the version of the permission that is set as the
        ///     		default version.</p>
        public let defaultVersion: Swift.Bool?
        /// <p>The date and time when the permission was last updated.</p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>The name of the permission.</p>
        public let name: Swift.String?
        /// <p>The permission's effect and actions in JSON format. The <code>effect</code> indicates whether
        /// 			the actions are allowed or denied. The <code>actions</code> list the API actions to
        /// 			which the principal is granted or denied access.</p>
        public let permission: Swift.String?
        /// <p>The resource type to which the permission applies.</p>
        public let resourceType: Swift.String?
        /// <p>The identifier for the version of the permission.</p>
        public let version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultVersion: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            permission: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.permission = permission
            self.resourceType = resourceType
            self.version = version
        }
    }

}

extension RamClientTypes.ResourceSharePermissionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case lastUpdatedTime
        case name
        case resourceType
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let defaultVersion = defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension RamClientTypes.ResourceSharePermissionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceSharePermissionSummary(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), defaultVersion: \(Swift.String(describing: defaultVersion)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), resourceType: \(Swift.String(describing: resourceType)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension RamClientTypes {
    /// <p>Information about a permission that is associated with a resource share.</p>
    public struct ResourceSharePermissionSummary: Swift.Equatable {
        /// <p>The ARN of the permission.</p>
        public let arn: Swift.String?
        /// <p>The date and time when the permission was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The identifier for the version of the permission that is set as the default version.</p>
        public let defaultVersion: Swift.Bool?
        /// <p>The date and time when the permission was last updated.</p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>The name of the permission.</p>
        public let name: Swift.String?
        /// <p>The type of resource to which the permission applies.</p>
        public let resourceType: Swift.String?
        /// <p>The current status of the permission.</p>
        public let status: Swift.String?
        /// <p>The identifier for the version of the permission.</p>
        public let version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultVersion: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.resourceType = resourceType
            self.status = status
            self.version = version
        }
    }

}

extension RamClientTypes {
    public enum ResourceShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareStatus] {
            return [
                .active,
                .deleted,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareStatus(rawValue: rawValue) ?? ResourceShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension RamClientTypes {
    public enum ResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case limitExceeded
        case pending
        case unavailable
        case zonalResourceInaccessible
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .available,
                .limitExceeded,
                .pending,
                .unavailable,
                .zonalResourceInaccessible,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case .pending: return "PENDING"
            case .unavailable: return "UNAVAILABLE"
            case .zonalResourceInaccessible: return "ZONAL_RESOURCE_INACCESSIBLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServerInternalException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerInternalException(message: \(Swift.String(describing: message)))"}
}

extension ServerInternalException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServerInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service could not respond to the request due to an internal problem.</p>
public struct ServerInternalException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServerInternalExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServerInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes.ServiceNameAndResourceType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension RamClientTypes.ServiceNameAndResourceType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNameAndResourceType(resourceType: \(Swift.String(describing: resourceType)), serviceName: \(Swift.String(describing: serviceName)))"}
}

extension RamClientTypes {
    /// <p>Information about the shareable resource types and the AWS services to which they belong.</p>
    public struct ServiceNameAndResourceType: Swift.Equatable {
        /// <p>The shareable resource types.</p>
        public let resourceType: Swift.String?
        /// <p>The name of the AWS services to which the resources belong.</p>
        public let serviceName: Swift.String?

        public init (
            resourceType: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
            self.serviceName = serviceName
        }
    }

}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is not available.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RamClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RamClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension RamClientTypes {
    /// <p>Information about a tag.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The key of the tag.</p>
        public let key: Swift.String?
        /// <p>The value of the tag.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension RamClientTypes.TagFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey
        case tagValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvaluelist0 in tagValues {
                try tagValuesContainer.encode(tagvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension RamClientTypes.TagFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagFilter(tagKey: \(Swift.String(describing: tagKey)), tagValues: \(Swift.String(describing: tagValues)))"}
}

extension RamClientTypes {
    /// <p>Used to filter information based on tags.</p>
    public struct TagFilter: Swift.Equatable {
        /// <p>The tag key.</p>
        public let tagKey: Swift.String?
        /// <p>The tag values.</p>
        public let tagValues: [Swift.String]?

        public init (
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }

}

extension TagLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension TagLimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested tags exceed the limit for your account.</p>
public struct TagLimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyViolationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagPolicyViolationException(message: \(Swift.String(describing: message)))"}
}

extension TagPolicyViolationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagPolicyViolationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified tag is a reserved word and cannot be used.</p>
public struct TagPolicyViolationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyViolationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagPolicyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceShareArn: \(Swift.String(describing: resourceShareArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: Swift.String?
    /// <p>One or more tags.</p>
    public let tags: [RamClientTypes.Tag]?

    public init (
        resourceShareArn: Swift.String? = nil,
        tags: [RamClientTypes.Tag]? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let tags: [RamClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RamClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RamClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RamClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnNotFoundException" : self = .resourceArnNotFoundException(try ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceededException" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolationException" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceArnNotFoundException(ResourceArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UnknownResourceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnknownResourceException(message: \(Swift.String(describing: message)))"}
}

extension UnknownResourceException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnknownResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified resource was not found.</p>
public struct UnknownResourceException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownResourceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnknownResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceShareArn: \(Swift.String(describing: resourceShareArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: Swift.String?
    /// <p>The tag keys of the tags to remove.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceShareArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateResourceShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceShareOutputError>
}

extension UpdateResourceShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceShareInput(allowExternalPrincipals: \(Swift.String(describing: allowExternalPrincipals)), clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), resourceShareArn: \(Swift.String(describing: resourceShareArn)))"}
}

extension UpdateResourceShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceShareArn = resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

public struct UpdateResourceShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceShareOutputError>
}

public struct UpdateResourceShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceShareOutputError>
}

public struct UpdateResourceShareInput: Swift.Equatable {
    /// <p>Indicates whether principals outside your AWS organization can be associated with a resource share.</p>
    public let allowExternalPrincipals: Swift.Bool?
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>The name of the resource share.</p>
    public let name: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the resource share.</p>
    public let resourceShareArn: Swift.String?

    public init (
        allowExternalPrincipals: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.resourceShareArn = resourceShareArn
    }
}

struct UpdateResourceShareInputBody: Swift.Equatable {
    public let resourceShareArn: Swift.String?
    public let name: Swift.String?
    public let allowExternalPrincipals: Swift.Bool?
    public let clientToken: Swift.String?
}

extension UpdateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedArnException" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalException" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownResourceException" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceShareOutputResponse(clientToken: \(Swift.String(describing: clientToken)), resourceShare: \(Swift.String(describing: resourceShare)))"}
}

extension UpdateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct UpdateResourceShareOutputResponse: Swift.Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
    public let clientToken: Swift.String?
    /// <p>Information about the resource share.</p>
    public let resourceShare: RamClientTypes.ResourceShare?

    public init (
        clientToken: Swift.String? = nil,
        resourceShare: RamClientTypes.ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct UpdateResourceShareOutputResponseBody: Swift.Equatable {
    public let resourceShare: RamClientTypes.ResourceShare?
    public let clientToken: Swift.String?
}

extension UpdateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShare
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(RamClientTypes.ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}
