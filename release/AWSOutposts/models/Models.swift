// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have permission to perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting this resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The ID of the resource causing the conflict.
    public var resourceId: Swift.String?
    /// The type of the resource causing the conflict.
    public var resourceType: OutpostsClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: OutpostsClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: OutpostsClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateOrderInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrderOutputError>
}

extension CreateOrderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOrderInput(lineItems: \(Swift.String(describing: lineItems)), outpostIdentifier: \(Swift.String(describing: outpostIdentifier)), paymentOption: \(Swift.String(describing: paymentOption)), paymentTerm: \(Swift.String(describing: paymentTerm)))"}
}

extension CreateOrderInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineItems = "LineItems"
        case outpostIdentifier = "OutpostIdentifier"
        case paymentOption = "PaymentOption"
        case paymentTerm = "PaymentTerm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineItems = lineItems {
            var lineItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineItems)
            for lineitemrequestlistdefinition0 in lineItems {
                try lineItemsContainer.encode(lineitemrequestlistdefinition0)
            }
        }
        if let outpostIdentifier = outpostIdentifier {
            try encodeContainer.encode(outpostIdentifier, forKey: .outpostIdentifier)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let paymentTerm = paymentTerm {
            try encodeContainer.encode(paymentTerm.rawValue, forKey: .paymentTerm)
        }
    }
}

public struct CreateOrderInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrderOutputError>
}

public struct CreateOrderInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOrderInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOrderInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrderOutputError>
}

public struct CreateOrderInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrderInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateOrderInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/orders"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOrderInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrderOutputError>
}

public struct CreateOrderInput: Swift.Equatable {
    /// The line items that make up the order.
    /// This member is required.
    public var lineItems: [OutpostsClientTypes.LineItemRequest]?
    ///
    ///       The ID or the Amazon Resource Name (ARN) of the Outpost.
    ///
    /// This member is required.
    public var outpostIdentifier: Swift.String?
    /// The payment option for the order.
    /// This member is required.
    public var paymentOption: OutpostsClientTypes.PaymentOption?
    /// The payment terms for the order.
    public var paymentTerm: OutpostsClientTypes.PaymentTerm?

    public init (
        lineItems: [OutpostsClientTypes.LineItemRequest]? = nil,
        outpostIdentifier: Swift.String? = nil,
        paymentOption: OutpostsClientTypes.PaymentOption? = nil,
        paymentTerm: OutpostsClientTypes.PaymentTerm? = nil
    )
    {
        self.lineItems = lineItems
        self.outpostIdentifier = outpostIdentifier
        self.paymentOption = paymentOption
        self.paymentTerm = paymentTerm
    }
}

struct CreateOrderInputBody: Swift.Equatable {
    public let outpostIdentifier: Swift.String?
    public let lineItems: [OutpostsClientTypes.LineItemRequest]?
    public let paymentOption: OutpostsClientTypes.PaymentOption?
    public let paymentTerm: OutpostsClientTypes.PaymentTerm?
}

extension CreateOrderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineItems = "LineItems"
        case outpostIdentifier = "OutpostIdentifier"
        case paymentOption = "PaymentOption"
        case paymentTerm = "PaymentTerm"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostIdentifier)
        outpostIdentifier = outpostIdentifierDecoded
        let lineItemsContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.LineItemRequest?].self, forKey: .lineItems)
        var lineItemsDecoded0:[OutpostsClientTypes.LineItemRequest]? = nil
        if let lineItemsContainer = lineItemsContainer {
            lineItemsDecoded0 = [OutpostsClientTypes.LineItemRequest]()
            for structure0 in lineItemsContainer {
                if let structure0 = structure0 {
                    lineItemsDecoded0?.append(structure0)
                }
            }
        }
        lineItems = lineItemsDecoded0
        let paymentOptionDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let paymentTermDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PaymentTerm.self, forKey: .paymentTerm)
        paymentTerm = paymentTermDecoded
    }
}

extension CreateOrderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOrderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOrderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOrderOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOrderOutputResponse(order: \(Swift.String(describing: order)))"}
}

extension CreateOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.order = output.order
        } else {
            self.order = nil
        }
    }
}

public struct CreateOrderOutputResponse: Swift.Equatable {
    /// Information about this order.
    public var order: OutpostsClientTypes.Order?

    public init (
        order: OutpostsClientTypes.Order? = nil
    )
    {
        self.order = order
    }
}

struct CreateOrderOutputResponseBody: Swift.Equatable {
    public let order: OutpostsClientTypes.Order?
}

extension CreateOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case order = "Order"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orderDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Order.self, forKey: .order)
        order = orderDecoded
    }
}

public struct CreateOutpostInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOutpostInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOutpostOutputError>
}

extension CreateOutpostInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOutpostInput(availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateOutpostInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case description = "Description"
        case name = "Name"
        case siteId = "SiteId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateOutpostInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOutpostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOutpostOutputError>
}

public struct CreateOutpostInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOutpostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOutpostOutputError>
}

public struct CreateOutpostInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOutpostInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/outposts"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOutpostOutputError>
}

public struct CreateOutpostInput: Swift.Equatable {
    /// The Availability Zone.
    public var availabilityZone: Swift.String?
    /// The ID of the Availability Zone.
    public var availabilityZoneId: Swift.String?
    /// The description of the Outpost.
    public var description: Swift.String?
    /// The name of the Outpost.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?
    /// The tags to apply to the Outpost.
    public var tags: [Swift.String:Swift.String]?

    public init (
        availabilityZone: Swift.String? = nil,
        availabilityZoneId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.availabilityZoneId = availabilityZoneId
        self.description = description
        self.name = name
        self.siteId = siteId
        self.tags = tags
    }
}

struct CreateOutpostInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let siteId: Swift.String?
    public let availabilityZone: Swift.String?
    public let availabilityZoneId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateOutpostInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case description = "Description"
        case name = "Name"
        case siteId = "SiteId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateOutpostOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOutpostOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOutpostOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOutpostOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOutpostOutputResponse(outpost: \(Swift.String(describing: outpost)))"}
}

extension CreateOutpostOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOutpostOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.outpost = output.outpost
        } else {
            self.outpost = nil
        }
    }
}

public struct CreateOutpostOutputResponse: Swift.Equatable {
    /// Information about an Outpost.
    public var outpost: OutpostsClientTypes.Outpost?

    public init (
        outpost: OutpostsClientTypes.Outpost? = nil
    )
    {
        self.outpost = outpost
    }
}

struct CreateOutpostOutputResponseBody: Swift.Equatable {
    public let outpost: OutpostsClientTypes.Outpost?
}

extension CreateOutpostOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outpost = "Outpost"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Outpost.self, forKey: .outpost)
        outpost = outpostDecoded
    }
}

extension DeleteOutpostInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOutpostInput(outpostId: \(Swift.String(describing: outpostId)))"}
}

extension DeleteOutpostInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteOutpostInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutpostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutpostOutputError>
}

public struct DeleteOutpostInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutpostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutpostOutputError>
}

public struct DeleteOutpostInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOutpostInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let outpostId = input.outpostId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("outpostId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/outposts/\(outpostId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOutpostOutputError>
}

public struct DeleteOutpostInput: Swift.Equatable {
    ///
    ///       The ID of the Outpost.
    ///
    /// This member is required.
    public var outpostId: Swift.String?

    public init (
        outpostId: Swift.String? = nil
    )
    {
        self.outpostId = outpostId
    }
}

struct DeleteOutpostInputBody: Swift.Equatable {
}

extension DeleteOutpostInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOutpostOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOutpostOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOutpostOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOutpostOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOutpostOutputResponse()"}
}

extension DeleteOutpostOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOutpostOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteOutpostOutputResponseBody: Swift.Equatable {
}

extension DeleteOutpostOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSiteInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSiteInput(siteId: \(Swift.String(describing: siteId)))"}
}

extension DeleteSiteInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteSiteInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSiteInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteSiteInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let siteId = input.siteId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("siteId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/sites/\(siteId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSiteInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInput: Swift.Equatable {
    /// The ID of the site.
    /// This member is required.
    public var siteId: Swift.String?

    public init (
        siteId: Swift.String? = nil
    )
    {
        self.siteId = siteId
    }
}

struct DeleteSiteInputBody: Swift.Equatable {
}

extension DeleteSiteInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSiteOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSiteOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSiteOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSiteOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSiteOutputResponse()"}
}

extension DeleteSiteOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSiteOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSiteOutputResponseBody: Swift.Equatable {
}

extension DeleteSiteOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOutpostInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutpostInput(outpostId: \(Swift.String(describing: outpostId)))"}
}

extension GetOutpostInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetOutpostInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostOutputError>
}

public struct GetOutpostInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutpostInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutpostInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostOutputError>
}

public struct GetOutpostInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetOutpostInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let outpostId = input.outpostId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("outpostId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/outposts/\(outpostId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOutpostInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostOutputError>
}

public struct GetOutpostInput: Swift.Equatable {
    ///
    ///       The ID of the Outpost.
    ///
    /// This member is required.
    public var outpostId: Swift.String?

    public init (
        outpostId: Swift.String? = nil
    )
    {
        self.outpostId = outpostId
    }
}

struct GetOutpostInputBody: Swift.Equatable {
}

extension GetOutpostInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOutpostInstanceTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutpostInstanceTypesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), outpostId: \(Swift.String(describing: outpostId)))"}
}

extension GetOutpostInstanceTypesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetOutpostInstanceTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInstanceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutpostInstanceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutpostInstanceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostInstanceTypesOutputError>
}

public struct GetOutpostInstanceTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInstanceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetOutpostInstanceTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetOutpostInstanceTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostInstanceTypesOutputError>
}

public struct GetOutpostInstanceTypesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetOutpostInstanceTypesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetOutpostInstanceTypesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let outpostId = input.outpostId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("outpostId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/outposts/\(outpostId.urlPercentEncoding())/instanceTypes"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetOutpostInstanceTypesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetOutpostInstanceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetOutpostInstanceTypesOutputError>
}

public struct GetOutpostInstanceTypesInput: Swift.Equatable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?
    ///
    ///       The ID of the Outpost.
    ///
    /// This member is required.
    public var outpostId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.outpostId = outpostId
    }
}

struct GetOutpostInstanceTypesInputBody: Swift.Equatable {
}

extension GetOutpostInstanceTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetOutpostInstanceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOutpostInstanceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOutpostInstanceTypesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOutpostInstanceTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutpostInstanceTypesOutputResponse(instanceTypes: \(Swift.String(describing: instanceTypes)), nextToken: \(Swift.String(describing: nextToken)), outpostArn: \(Swift.String(describing: outpostArn)), outpostId: \(Swift.String(describing: outpostId)))"}
}

extension GetOutpostInstanceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOutpostInstanceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceTypes = output.instanceTypes
            self.nextToken = output.nextToken
            self.outpostArn = output.outpostArn
            self.outpostId = output.outpostId
        } else {
            self.instanceTypes = nil
            self.nextToken = nil
            self.outpostArn = nil
            self.outpostId = nil
        }
    }
}

public struct GetOutpostInstanceTypesOutputResponse: Swift.Equatable {
    /// Information about the instance types.
    public var instanceTypes: [OutpostsClientTypes.InstanceTypeItem]?
    /// The pagination token.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Outpost.
    public var outpostArn: Swift.String?
    ///
    ///       The ID of the Outpost.
    ///
    public var outpostId: Swift.String?

    public init (
        instanceTypes: [OutpostsClientTypes.InstanceTypeItem]? = nil,
        nextToken: Swift.String? = nil,
        outpostArn: Swift.String? = nil,
        outpostId: Swift.String? = nil
    )
    {
        self.instanceTypes = instanceTypes
        self.nextToken = nextToken
        self.outpostArn = outpostArn
        self.outpostId = outpostId
    }
}

struct GetOutpostInstanceTypesOutputResponseBody: Swift.Equatable {
    public let instanceTypes: [OutpostsClientTypes.InstanceTypeItem]?
    public let nextToken: Swift.String?
    public let outpostId: Swift.String?
    public let outpostArn: Swift.String?
}

extension GetOutpostInstanceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceTypes = "InstanceTypes"
        case nextToken = "NextToken"
        case outpostArn = "OutpostArn"
        case outpostId = "OutpostId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypesContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.InstanceTypeItem?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[OutpostsClientTypes.InstanceTypeItem]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [OutpostsClientTypes.InstanceTypeItem]()
            for structure0 in instanceTypesContainer {
                if let structure0 = structure0 {
                    instanceTypesDecoded0?.append(structure0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
    }
}

extension GetOutpostOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOutpostOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOutpostOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOutpostOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetOutpostOutputResponse(outpost: \(Swift.String(describing: outpost)))"}
}

extension GetOutpostOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetOutpostOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.outpost = output.outpost
        } else {
            self.outpost = nil
        }
    }
}

public struct GetOutpostOutputResponse: Swift.Equatable {
    /// Information about an Outpost.
    public var outpost: OutpostsClientTypes.Outpost?

    public init (
        outpost: OutpostsClientTypes.Outpost? = nil
    )
    {
        self.outpost = outpost
    }
}

struct GetOutpostOutputResponseBody: Swift.Equatable {
    public let outpost: OutpostsClientTypes.Outpost?
}

extension GetOutpostOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outpost = "Outpost"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.Outpost.self, forKey: .outpost)
        outpost = outpostDecoded
    }
}

extension OutpostsClientTypes.InstanceTypeItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceType = "InstanceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
    }
}

extension OutpostsClientTypes.InstanceTypeItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceTypeItem(instanceType: \(Swift.String(describing: instanceType)))"}
}

extension OutpostsClientTypes {
    /// Information about an instance type.
    public struct InstanceTypeItem: Swift.Equatable {
        /// The instance type.
        public var instanceType: Swift.String?

        public init (
            instanceType: Swift.String? = nil
        )
        {
            self.instanceType = instanceType
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error has occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutpostsClientTypes.LineItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogItemId = "CatalogItemId"
        case lineItemId = "LineItemId"
        case quantity = "Quantity"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogItemId = catalogItemId {
            try encodeContainer.encode(catalogItemId, forKey: .catalogItemId)
        }
        if let lineItemId = lineItemId {
            try encodeContainer.encode(lineItemId, forKey: .lineItemId)
        }
        if quantity != 0 {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogItemId)
        catalogItemId = catalogItemIdDecoded
        let lineItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lineItemId)
        lineItemId = lineItemIdDecoded
        let quantityDecoded = try containerValues.decode(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension OutpostsClientTypes.LineItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LineItem(catalogItemId: \(Swift.String(describing: catalogItemId)), lineItemId: \(Swift.String(describing: lineItemId)), quantity: \(Swift.String(describing: quantity)), status: \(Swift.String(describing: status)))"}
}

extension OutpostsClientTypes {
    /// Information about a line item.
    public struct LineItem: Swift.Equatable {
        ///
        ///       The ID of the catalog item.
        ///
        public var catalogItemId: Swift.String?
        /// The ID of the line item.
        public var lineItemId: Swift.String?
        /// The quantity of the line item.
        public var quantity: Swift.Int
        /// The status of the line item.
        public var status: Swift.String?

        public init (
            catalogItemId: Swift.String? = nil,
            lineItemId: Swift.String? = nil,
            quantity: Swift.Int = 0,
            status: Swift.String? = nil
        )
        {
            self.catalogItemId = catalogItemId
            self.lineItemId = lineItemId
            self.quantity = quantity
            self.status = status
        }
    }

}

extension OutpostsClientTypes.LineItemRequest: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogItemId = "CatalogItemId"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogItemId = catalogItemId {
            try encodeContainer.encode(catalogItemId, forKey: .catalogItemId)
        }
        if quantity != 0 {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalogItemId)
        catalogItemId = catalogItemIdDecoded
        let quantityDecoded = try containerValues.decode(Swift.Int.self, forKey: .quantity)
        quantity = quantityDecoded
    }
}

extension OutpostsClientTypes.LineItemRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LineItemRequest(catalogItemId: \(Swift.String(describing: catalogItemId)), quantity: \(Swift.String(describing: quantity)))"}
}

extension OutpostsClientTypes {
    /// Information about a line item request.
    public struct LineItemRequest: Swift.Equatable {
        /// The ID of the catalog item.
        public var catalogItemId: Swift.String?
        /// The quantity of a line item request.
        public var quantity: Swift.Int

        public init (
            catalogItemId: Swift.String? = nil,
            quantity: Swift.Int = 0
        )
        {
            self.catalogItemId = catalogItemId
            self.quantity = quantity
        }
    }

}

extension ListOutpostsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOutpostsInput(availabilityZoneFilter: \(Swift.String(describing: availabilityZoneFilter)), availabilityZoneIdFilter: \(Swift.String(describing: availabilityZoneIdFilter)), lifeCycleStatusFilter: \(Swift.String(describing: lifeCycleStatusFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOutpostsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListOutpostsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutpostsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOutpostsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutpostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOutpostsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutpostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutpostsOutputError>
}

public struct ListOutpostsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutpostsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOutpostsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutpostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let availabilityZoneIdFilter = input.operationInput.availabilityZoneIdFilter {
            availabilityZoneIdFilter.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "AvailabilityZoneIdFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let lifeCycleStatusFilter = input.operationInput.lifeCycleStatusFilter {
            lifeCycleStatusFilter.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "LifeCycleStatusFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let availabilityZoneFilter = input.operationInput.availabilityZoneFilter {
            availabilityZoneFilter.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "AvailabilityZoneFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOutpostsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutpostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutpostsOutputError>
}

public struct ListOutpostsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOutpostsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListOutpostsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOutpostsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/outposts"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOutpostsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOutpostsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOutpostsOutputError>
}

public struct ListOutpostsInput: Swift.Equatable {
    ///  A filter for the Availibility Zone (us-east-1a) of the Outpost.
    ///
    ///           Filter values are case sensitive. If you specify multiple values for a filter, the values
    ///       are joined with an OR, and the request returns all results that match any of the
    ///       specified values.
    public var availabilityZoneFilter: [Swift.String]?
    ///
    ///       A filter for the AZ IDs (use1-az1) of the Outpost.
    ///
    ///
    ///           Filter values are case sensitive. If you specify multiple values for a filter, the values
    ///       are joined with an OR, and the request returns all results that match any of the
    ///       specified values.
    public var availabilityZoneIdFilter: [Swift.String]?
    ///
    ///       A filter for the lifecycle status of the Outpost.
    ///
    ///           Filter values are case sensitive. If you specify multiple values for a filter, the values
    ///       are joined with an OR, and the request returns all results that match any of the
    ///       specified values.
    public var lifeCycleStatusFilter: [Swift.String]?
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        availabilityZoneFilter: [Swift.String]? = nil,
        availabilityZoneIdFilter: [Swift.String]? = nil,
        lifeCycleStatusFilter: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.availabilityZoneFilter = availabilityZoneFilter
        self.availabilityZoneIdFilter = availabilityZoneIdFilter
        self.lifeCycleStatusFilter = lifeCycleStatusFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOutpostsInputBody: Swift.Equatable {
}

extension ListOutpostsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOutpostsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOutpostsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOutpostsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOutpostsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOutpostsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), outposts: \(Swift.String(describing: outposts)))"}
}

extension ListOutpostsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOutpostsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outposts = output.outposts
        } else {
            self.nextToken = nil
            self.outposts = nil
        }
    }
}

public struct ListOutpostsOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Information about the Outposts.
    public var outposts: [OutpostsClientTypes.Outpost]?

    public init (
        nextToken: Swift.String? = nil,
        outposts: [OutpostsClientTypes.Outpost]? = nil
    )
    {
        self.nextToken = nextToken
        self.outposts = outposts
    }
}

struct ListOutpostsOutputResponseBody: Swift.Equatable {
    public let outposts: [OutpostsClientTypes.Outpost]?
    public let nextToken: Swift.String?
}

extension ListOutpostsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case outposts = "Outposts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostsContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.Outpost?].self, forKey: .outposts)
        var outpostsDecoded0:[OutpostsClientTypes.Outpost]? = nil
        if let outpostsContainer = outpostsContainer {
            outpostsDecoded0 = [OutpostsClientTypes.Outpost]()
            for structure0 in outpostsContainer {
                if let structure0 = structure0 {
                    outpostsDecoded0?.append(structure0)
                }
            }
        }
        outposts = outpostsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSitesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSitesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSitesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListSitesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSitesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSitesOutputError>
}

public struct ListSitesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSitesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSitesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSitesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSitesOutputError>
}

public struct ListSitesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSitesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListSitesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/sites"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSitesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSitesOutputError>
}

public struct ListSitesInput: Swift.Equatable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// The pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSitesInputBody: Swift.Equatable {
}

extension ListSitesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSitesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSitesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSitesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSitesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSitesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sites: \(Swift.String(describing: sites)))"}
}

extension ListSitesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSitesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sites = output.sites
        } else {
            self.nextToken = nil
            self.sites = nil
        }
    }
}

public struct ListSitesOutputResponse: Swift.Equatable {
    /// The pagination token.
    public var nextToken: Swift.String?
    /// Information about the sites.
    public var sites: [OutpostsClientTypes.Site]?

    public init (
        nextToken: Swift.String? = nil,
        sites: [OutpostsClientTypes.Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

struct ListSitesOutputResponseBody: Swift.Equatable {
    public let sites: [OutpostsClientTypes.Site]?
    public let nextToken: Swift.String?
}

extension ListSitesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sites = "Sites"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sitesContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.Site?].self, forKey: .sites)
        var sitesDecoded0:[OutpostsClientTypes.Site]? = nil
        if let sitesContainer = sitesContainer {
            sitesDecoded0 = [OutpostsClientTypes.Site]()
            for structure0 in sitesContainer {
                if let structure0 = structure0 {
                    sitesDecoded0?.append(structure0)
                }
            }
        }
        sites = sitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The resource tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified request is not valid.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutpostsClientTypes.Order: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineItems = "LineItems"
        case orderFulfilledDate = "OrderFulfilledDate"
        case orderId = "OrderId"
        case orderSubmissionDate = "OrderSubmissionDate"
        case outpostId = "OutpostId"
        case paymentOption = "PaymentOption"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineItems = lineItems {
            var lineItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineItems)
            for lineitemlistdefinition0 in lineItems {
                try lineItemsContainer.encode(lineitemlistdefinition0)
            }
        }
        if let orderFulfilledDate = orderFulfilledDate {
            try encodeContainer.encode(orderFulfilledDate.timeIntervalSince1970, forKey: .orderFulfilledDate)
        }
        if let orderId = orderId {
            try encodeContainer.encode(orderId, forKey: .orderId)
        }
        if let orderSubmissionDate = orderSubmissionDate {
            try encodeContainer.encode(orderSubmissionDate.timeIntervalSince1970, forKey: .orderSubmissionDate)
        }
        if let outpostId = outpostId {
            try encodeContainer.encode(outpostId, forKey: .outpostId)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let orderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderId)
        orderId = orderIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.OrderStatus.self, forKey: .status)
        status = statusDecoded
        let lineItemsContainer = try containerValues.decodeIfPresent([OutpostsClientTypes.LineItem?].self, forKey: .lineItems)
        var lineItemsDecoded0:[OutpostsClientTypes.LineItem]? = nil
        if let lineItemsContainer = lineItemsContainer {
            lineItemsDecoded0 = [OutpostsClientTypes.LineItem]()
            for structure0 in lineItemsContainer {
                if let structure0 = structure0 {
                    lineItemsDecoded0?.append(structure0)
                }
            }
        }
        lineItems = lineItemsDecoded0
        let paymentOptionDecoded = try containerValues.decodeIfPresent(OutpostsClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let orderSubmissionDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .orderSubmissionDate)
        orderSubmissionDate = orderSubmissionDateDecoded
        let orderFulfilledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .orderFulfilledDate)
        orderFulfilledDate = orderFulfilledDateDecoded
    }
}

extension OutpostsClientTypes.Order: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Order(lineItems: \(Swift.String(describing: lineItems)), orderFulfilledDate: \(Swift.String(describing: orderFulfilledDate)), orderId: \(Swift.String(describing: orderId)), orderSubmissionDate: \(Swift.String(describing: orderSubmissionDate)), outpostId: \(Swift.String(describing: outpostId)), paymentOption: \(Swift.String(describing: paymentOption)), status: \(Swift.String(describing: status)))"}
}

extension OutpostsClientTypes {
    /// Information about an order.
    public struct Order: Swift.Equatable {
        /// The line items for the order
        public var lineItems: [OutpostsClientTypes.LineItem]?
        /// The fulfillment date of the order.
        public var orderFulfilledDate: ClientRuntime.Date?
        /// The ID of the order.
        public var orderId: Swift.String?
        /// The submission date for the order.
        public var orderSubmissionDate: ClientRuntime.Date?
        ///
        ///       The ID of the Outpost.
        ///
        public var outpostId: Swift.String?
        /// The payment option for the order.
        public var paymentOption: OutpostsClientTypes.PaymentOption?
        /// The status of the order
        public var status: OutpostsClientTypes.OrderStatus?

        public init (
            lineItems: [OutpostsClientTypes.LineItem]? = nil,
            orderFulfilledDate: ClientRuntime.Date? = nil,
            orderId: Swift.String? = nil,
            orderSubmissionDate: ClientRuntime.Date? = nil,
            outpostId: Swift.String? = nil,
            paymentOption: OutpostsClientTypes.PaymentOption? = nil,
            status: OutpostsClientTypes.OrderStatus? = nil
        )
        {
            self.lineItems = lineItems
            self.orderFulfilledDate = orderFulfilledDate
            self.orderId = orderId
            self.orderSubmissionDate = orderSubmissionDate
            self.outpostId = outpostId
            self.paymentOption = paymentOption
            self.status = status
        }
    }

}

extension OutpostsClientTypes {
    public enum OrderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case fulfilled
        case installing
        case pending
        case processing
        case received
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderStatus] {
            return [
                .cancelled,
                .fulfilled,
                .installing,
                .pending,
                .processing,
                .received,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .fulfilled: return "FULFILLED"
            case .installing: return "INSTALLING"
            case .pending: return "PENDING"
            case .processing: return "PROCESSING"
            case .received: return "RECEIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderStatus(rawValue: rawValue) ?? OrderStatus.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes.Outpost: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case description = "Description"
        case lifeCycleStatus = "LifeCycleStatus"
        case name = "Name"
        case outpostArn = "OutpostArn"
        case outpostId = "OutpostId"
        case ownerId = "OwnerId"
        case siteArn = "SiteArn"
        case siteId = "SiteId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lifeCycleStatus = lifeCycleStatus {
            try encodeContainer.encode(lifeCycleStatus, forKey: .lifeCycleStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outpostArn = outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let outpostId = outpostId {
            try encodeContainer.encode(outpostId, forKey: .outpostId)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let siteArn = siteArn {
            try encodeContainer.encode(siteArn, forKey: .siteArn)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outpostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lifeCycleStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifeCycleStatus)
        lifeCycleStatus = lifeCycleStatusDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let siteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteArn)
        siteArn = siteArnDecoded
    }
}

extension OutpostsClientTypes.Outpost: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Outpost(availabilityZone: \(Swift.String(describing: availabilityZone)), availabilityZoneId: \(Swift.String(describing: availabilityZoneId)), description: \(Swift.String(describing: description)), lifeCycleStatus: \(Swift.String(describing: lifeCycleStatus)), name: \(Swift.String(describing: name)), outpostArn: \(Swift.String(describing: outpostArn)), outpostId: \(Swift.String(describing: outpostId)), ownerId: \(Swift.String(describing: ownerId)), siteArn: \(Swift.String(describing: siteArn)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)))"}
}

extension OutpostsClientTypes {
    /// Information about an Outpost.
    public struct Outpost: Swift.Equatable {
        /// The Availability Zone.
        public var availabilityZone: Swift.String?
        /// The ID of the Availability Zone.
        public var availabilityZoneId: Swift.String?
        /// The description of the Outpost.
        public var description: Swift.String?
        /// The life cycle status.
        public var lifeCycleStatus: Swift.String?
        /// The name of the Outpost.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the Outpost.
        public var outpostArn: Swift.String?
        ///
        ///       The ID of the Outpost.
        ///
        public var outpostId: Swift.String?
        /// The AWS account ID of the Outpost owner.
        public var ownerId: Swift.String?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The Outpost tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            description: Swift.String? = nil,
            lifeCycleStatus: Swift.String? = nil,
            name: Swift.String? = nil,
            outpostArn: Swift.String? = nil,
            outpostId: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.description = description
            self.lifeCycleStatus = lifeCycleStatus
            self.name = name
            self.outpostArn = outpostArn
            self.outpostId = outpostId
            self.ownerId = ownerId
            self.siteArn = siteArn
            self.siteId = siteId
            self.tags = tags
        }
    }

}

extension OutpostsClientTypes {
    public enum PaymentOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allUpfront
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentOption] {
            return [
                .allUpfront,
                .noUpfront,
                .partialUpfront,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PaymentOption(rawValue: rawValue) ?? PaymentOption.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum PaymentTerm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case threeYears
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentTerm] {
            return [
                .threeYears,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .threeYears: return "THREE_YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PaymentTerm(rawValue: rawValue) ?? PaymentTerm.sdkUnknown(rawValue)
        }
    }
}

extension OutpostsClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case outpost
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .outpost,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .outpost: return "OUTPOST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded a service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutpostsClientTypes.Site: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case description = "Description"
        case name = "Name"
        case siteArn = "SiteArn"
        case siteId = "SiteId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let siteArn = siteArn {
            try encodeContainer.encode(siteArn, forKey: .siteArn)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let siteArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .siteArn)
        siteArn = siteArnDecoded
    }
}

extension OutpostsClientTypes.Site: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Site(accountId: \(Swift.String(describing: accountId)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), siteArn: \(Swift.String(describing: siteArn)), siteId: \(Swift.String(describing: siteId)), tags: \(Swift.String(describing: tags)))"}
}

extension OutpostsClientTypes {
    /// Information about a site.
    public struct Site: Swift.Equatable {
        /// The ID of the AWS account.
        public var accountId: Swift.String?
        /// The description of the site.
        public var description: Swift.String?
        /// The name of the site.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the site.
        public var siteArn: Swift.String?
        /// The ID of the site.
        public var siteId: Swift.String?
        /// The site tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            siteArn: Swift.String? = nil,
            siteId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.name = name
            self.siteArn = siteArn
            self.siteId = siteId
            self.tags = tags
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case notFoundException(NotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
