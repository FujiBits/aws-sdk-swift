// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddTagsToResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

extension AddTagsToResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagList: \(Swift.String(describing: tagList)))"}
}

extension AddTagsToResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

public struct AddTagsToResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddTagsToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddTagsToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddTagsToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddTagsToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddTagsToResourceOutputError>
}

public struct AddTagsToResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource to tag.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// One or more tags.
    /// This member is required.
    public let tagList: [CloudHsmClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tagList: [CloudHsmClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagList = tagList
    }
}

struct AddTagsToResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagList: [CloudHsmClientTypes.Tag]?
}

extension AddTagsToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagListContainer = try containerValues.decodeIfPresent([CloudHsmClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHsmClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHsmClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension AddTagsToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToResourceOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddTagsToResourceOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension AddTagsToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddTagsToResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct AddTagsToResourceOutputResponse: Swift.Equatable {
    /// The status of the operation.
    /// This member is required.
    public let status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct AddTagsToResourceOutputResponseBody: Swift.Equatable {
    public let status: Swift.String?
}

extension AddTagsToResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudHsmClientTypes {
    public enum ClientVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fiveOne
        case fiveThree
        case sdkUnknown(Swift.String)

        public static var allCases: [ClientVersion] {
            return [
                .fiveOne,
                .fiveThree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fiveOne: return "5.1"
            case .fiveThree: return "5.3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClientVersion(rawValue: rawValue) ?? ClientVersion.sdkUnknown(rawValue)
        }
    }
}

extension CloudHsmInternalException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudHsmInternalException(message: \(Swift.String(describing: message)), retryable: \(Swift.String(describing: retryable)))"}
}

extension CloudHsmInternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudHsmInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.retryable = output.retryable
        } else {
            self.message = nil
            self.retryable = false
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that an internal error occurred.
public struct CloudHsmInternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Additional information about the error.
    public var message: Swift.String?
    /// Indicates if the action can be retried.
    public var retryable: Swift.Bool

    public init (
        message: Swift.String? = nil,
        retryable: Swift.Bool = false
    )
    {
        self.message = message
        self.retryable = retryable
    }
}

struct CloudHsmInternalExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let retryable: Swift.Bool
}

extension CloudHsmInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryable
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .retryable)
        retryable = retryableDecoded
    }
}

extension CloudHsmClientTypes {
    public enum CloudHsmObjectState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degraded
        case ready
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CloudHsmObjectState] {
            return [
                .degraded,
                .ready,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degraded: return "DEGRADED"
            case .ready: return "READY"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CloudHsmObjectState(rawValue: rawValue) ?? CloudHsmObjectState.sdkUnknown(rawValue)
        }
    }
}

extension CloudHsmServiceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudHsmServiceException(message: \(Swift.String(describing: message)), retryable: \(Swift.String(describing: retryable)))"}
}

extension CloudHsmServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloudHsmServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.retryable = output.retryable
        } else {
            self.message = nil
            self.retryable = false
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that an exception occurred in the AWS CloudHSM service.
public struct CloudHsmServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Additional information about the error.
    public var message: Swift.String?
    /// Indicates if the action can be retried.
    public var retryable: Swift.Bool

    public init (
        message: Swift.String? = nil,
        retryable: Swift.Bool = false
    )
    {
        self.message = message
        self.retryable = retryable
    }
}

struct CloudHsmServiceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let retryable: Swift.Bool
}

extension CloudHsmServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryable
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .retryable)
        retryable = retryableDecoded
    }
}

public struct CreateHapgInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHapgInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHapgOutputError>
}

extension CreateHapgInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHapgInput(label: \(Swift.String(describing: label)))"}
}

extension CreateHapgInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
    }
}

public struct CreateHapgInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHapgInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHapgOutputError>
}

public struct CreateHapgInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHapgInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHapgOutputError>
}

/// Contains the inputs for the CreateHapgRequest action.
public struct CreateHapgInput: Swift.Equatable {
    /// The label of the new high-availability partition group.
    /// This member is required.
    public let label: Swift.String?

    public init (
        label: Swift.String? = nil
    )
    {
        self.label = label
    }
}

struct CreateHapgInputBody: Swift.Equatable {
    public let label: Swift.String?
}

extension CreateHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
    }
}

extension CreateHapgOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHapgOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHapgOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHapgOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHapgOutputResponse(hapgArn: \(Swift.String(describing: hapgArn)))"}
}

extension CreateHapgOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHapgOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hapgArn = output.hapgArn
        } else {
            self.hapgArn = nil
        }
    }
}

/// Contains the output of the CreateHAPartitionGroup action.
public struct CreateHapgOutputResponse: Swift.Equatable {
    /// The ARN of the high-availability partition group.
    public let hapgArn: Swift.String?

    public init (
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct CreateHapgOutputResponseBody: Swift.Equatable {
    public let hapgArn: Swift.String?
}

extension CreateHapgOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

public struct CreateHsmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHsmOutputError>
}

extension CreateHsmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHsmInput(clientToken: \(Swift.String(describing: clientToken)), eniIp: \(Swift.String(describing: eniIp)), externalId: \(Swift.String(describing: externalId)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), sshKey: \(Swift.String(describing: sshKey)), subnetId: \(Swift.String(describing: subnetId)), subscriptionType: \(Swift.String(describing: subscriptionType)), syslogIp: \(Swift.String(describing: syslogIp)))"}
}

extension CreateHsmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case iamRoleArn = "IamRoleArn"
        case sshKey = "SshKey"
        case subnetId = "SubnetId"
        case subscriptionType = "SubscriptionType"
        case syslogIp = "SyslogIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let eniIp = eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let sshKey = sshKey {
            try encodeContainer.encode(sshKey, forKey: .sshKey)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let subscriptionType = subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
        if let syslogIp = syslogIp {
            try encodeContainer.encode(syslogIp, forKey: .syslogIp)
        }
    }
}

public struct CreateHsmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHsmOutputError>
}

public struct CreateHsmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateHsmOutputError>
}

/// Contains the inputs for the CreateHsm operation.
public struct CreateHsmInput: Swift.Equatable {
    /// A user-defined token to ensure idempotence. Subsequent calls to this operation with the
    ///       same token will be ignored.
    public let clientToken: Swift.String?
    /// The IP address to assign to the HSM's ENI.
    ///          If an IP address is not specified, an IP address will be randomly chosen from the CIDR
    ///       range of the subnet.
    public let eniIp: Swift.String?
    /// The external ID from IamRoleArn, if present.
    public let externalId: Swift.String?
    /// The ARN of an IAM role to enable the AWS CloudHSM service to allocate an ENI on your
    ///       behalf.
    /// This member is required.
    public let iamRoleArn: Swift.String?
    /// The SSH public key to install on the HSM.
    /// This member is required.
    public let sshKey: Swift.String?
    /// The identifier of the subnet in your VPC in which to place the HSM.
    /// This member is required.
    public let subnetId: Swift.String?
    /// Specifies the type of subscription for the HSM.
    ///
    ///
    ///
    ///                   PRODUCTION - The HSM is being used in a production
    ///           environment.
    ///
    ///
    ///
    ///                   TRIAL - The HSM is being used in a product
    ///           trial.
    ///
    ///
    /// This member is required.
    public let subscriptionType: CloudHsmClientTypes.SubscriptionType?
    /// The IP address for the syslog monitoring server. The AWS CloudHSM service only supports one
    ///       syslog monitoring server.
    public let syslogIp: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        eniIp: Swift.String? = nil,
        externalId: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        sshKey: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        subscriptionType: CloudHsmClientTypes.SubscriptionType? = nil,
        syslogIp: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eniIp = eniIp
        self.externalId = externalId
        self.iamRoleArn = iamRoleArn
        self.sshKey = sshKey
        self.subnetId = subnetId
        self.subscriptionType = subscriptionType
        self.syslogIp = syslogIp
    }
}

struct CreateHsmInputBody: Swift.Equatable {
    public let subnetId: Swift.String?
    public let sshKey: Swift.String?
    public let eniIp: Swift.String?
    public let iamRoleArn: Swift.String?
    public let externalId: Swift.String?
    public let subscriptionType: CloudHsmClientTypes.SubscriptionType?
    public let clientToken: Swift.String?
    public let syslogIp: Swift.String?
}

extension CreateHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case iamRoleArn = "IamRoleArn"
        case sshKey = "SshKey"
        case subnetId = "SubnetId"
        case subscriptionType = "SubscriptionType"
        case syslogIp = "SyslogIp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let sshKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKey)
        sshKey = sshKeyDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(CloudHsmClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let syslogIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syslogIp)
        syslogIp = syslogIpDecoded
    }
}

extension CreateHsmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHsmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHsmOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHsmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateHsmOutputResponse(hsmArn: \(Swift.String(describing: hsmArn)))"}
}

extension CreateHsmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmArn = output.hsmArn
        } else {
            self.hsmArn = nil
        }
    }
}

/// Contains the output of the CreateHsm operation.
public struct CreateHsmOutputResponse: Swift.Equatable {
    /// The ARN of the HSM.
    public let hsmArn: Swift.String?

    public init (
        hsmArn: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct CreateHsmOutputResponseBody: Swift.Equatable {
    public let hsmArn: Swift.String?
}

extension CreateHsmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

public struct CreateLunaClientInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLunaClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLunaClientOutputError>
}

extension CreateLunaClientInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLunaClientInput(certificate: \(Swift.String(describing: certificate)), label: \(Swift.String(describing: label)))"}
}

extension CreateLunaClientInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case label = "Label"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
    }
}

public struct CreateLunaClientInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLunaClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLunaClientOutputError>
}

public struct CreateLunaClientInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLunaClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLunaClientOutputError>
}

/// Contains the inputs for the CreateLunaClient action.
public struct CreateLunaClientInput: Swift.Equatable {
    /// The contents of a Base64-Encoded X.509 v3 certificate to be installed on the HSMs used
    ///       by this client.
    /// This member is required.
    public let certificate: Swift.String?
    /// The label for the client.
    public let label: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        label: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.label = label
    }
}

struct CreateLunaClientInputBody: Swift.Equatable {
    public let label: Swift.String?
    public let certificate: Swift.String?
}

extension CreateLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case label = "Label"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension CreateLunaClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLunaClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLunaClientOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLunaClientOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLunaClientOutputResponse(clientArn: \(Swift.String(describing: clientArn)))"}
}

extension CreateLunaClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientArn = output.clientArn
        } else {
            self.clientArn = nil
        }
    }
}

/// Contains the output of the CreateLunaClient action.
public struct CreateLunaClientOutputResponse: Swift.Equatable {
    /// The ARN of the client.
    public let clientArn: Swift.String?

    public init (
        clientArn: Swift.String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct CreateLunaClientOutputResponseBody: Swift.Equatable {
    public let clientArn: Swift.String?
}

extension CreateLunaClientOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

public struct DeleteHapgInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHapgInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHapgOutputError>
}

extension DeleteHapgInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHapgInput(hapgArn: \(Swift.String(describing: hapgArn)))"}
}

extension DeleteHapgInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
    }
}

public struct DeleteHapgInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHapgInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHapgOutputError>
}

public struct DeleteHapgInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHapgInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHapgOutputError>
}

/// Contains the inputs for the DeleteHapg action.
public struct DeleteHapgInput: Swift.Equatable {
    /// The ARN of the high-availability partition group to delete.
    /// This member is required.
    public let hapgArn: Swift.String?

    public init (
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct DeleteHapgInputBody: Swift.Equatable {
    public let hapgArn: Swift.String?
}

extension DeleteHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension DeleteHapgOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHapgOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHapgOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHapgOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHapgOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension DeleteHapgOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteHapgOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Contains the output of the DeleteHapg action.
public struct DeleteHapgOutputResponse: Swift.Equatable {
    /// The status of the action.
    /// This member is required.
    public let status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteHapgOutputResponseBody: Swift.Equatable {
    public let status: Swift.String?
}

extension DeleteHapgOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteHsmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHsmOutputError>
}

extension DeleteHsmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHsmInput(hsmArn: \(Swift.String(describing: hsmArn)))"}
}

extension DeleteHsmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmArn = hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
    }
}

public struct DeleteHsmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHsmOutputError>
}

public struct DeleteHsmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteHsmOutputError>
}

/// Contains the inputs for the DeleteHsm operation.
public struct DeleteHsmInput: Swift.Equatable {
    /// The ARN of the HSM to delete.
    /// This member is required.
    public let hsmArn: Swift.String?

    public init (
        hsmArn: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct DeleteHsmInputBody: Swift.Equatable {
    public let hsmArn: Swift.String?
}

extension DeleteHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

extension DeleteHsmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHsmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHsmOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHsmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteHsmOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension DeleteHsmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Contains the output of the DeleteHsm operation.
public struct DeleteHsmOutputResponse: Swift.Equatable {
    /// The status of the operation.
    /// This member is required.
    public let status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteHsmOutputResponseBody: Swift.Equatable {
    public let status: Swift.String?
}

extension DeleteHsmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteLunaClientInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLunaClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLunaClientOutputError>
}

extension DeleteLunaClientInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLunaClientInput(clientArn: \(Swift.String(describing: clientArn)))"}
}

extension DeleteLunaClientInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientArn = clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

public struct DeleteLunaClientInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLunaClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLunaClientOutputError>
}

public struct DeleteLunaClientInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLunaClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLunaClientOutputError>
}

public struct DeleteLunaClientInput: Swift.Equatable {
    /// The ARN of the client to delete.
    /// This member is required.
    public let clientArn: Swift.String?

    public init (
        clientArn: Swift.String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct DeleteLunaClientInputBody: Swift.Equatable {
    public let clientArn: Swift.String?
}

extension DeleteLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

extension DeleteLunaClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLunaClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLunaClientOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLunaClientOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLunaClientOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension DeleteLunaClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteLunaClientOutputResponse: Swift.Equatable {
    /// The status of the action.
    /// This member is required.
    public let status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct DeleteLunaClientOutputResponseBody: Swift.Equatable {
    public let status: Swift.String?
}

extension DeleteLunaClientOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DescribeHapgInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHapgInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHapgOutputError>
}

extension DescribeHapgInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHapgInput(hapgArn: \(Swift.String(describing: hapgArn)))"}
}

extension DescribeHapgInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
    }
}

public struct DescribeHapgInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHapgInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHapgOutputError>
}

public struct DescribeHapgInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHapgInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHapgOutputError>
}

/// Contains the inputs for the DescribeHapg action.
public struct DescribeHapgInput: Swift.Equatable {
    /// The ARN of the high-availability partition group to describe.
    /// This member is required.
    public let hapgArn: Swift.String?

    public init (
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct DescribeHapgInputBody: Swift.Equatable {
    public let hapgArn: Swift.String?
}

extension DescribeHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

extension DescribeHapgOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHapgOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHapgOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHapgOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHapgOutputResponse(hapgArn: \(Swift.String(describing: hapgArn)), hapgSerial: \(Swift.String(describing: hapgSerial)), hsmsLastActionFailed: \(Swift.String(describing: hsmsLastActionFailed)), hsmsPendingDeletion: \(Swift.String(describing: hsmsPendingDeletion)), hsmsPendingRegistration: \(Swift.String(describing: hsmsPendingRegistration)), label: \(Swift.String(describing: label)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), partitionSerialList: \(Swift.String(describing: partitionSerialList)), state: \(Swift.String(describing: state)))"}
}

extension DescribeHapgOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHapgOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hapgArn = output.hapgArn
            self.hapgSerial = output.hapgSerial
            self.hsmsLastActionFailed = output.hsmsLastActionFailed
            self.hsmsPendingDeletion = output.hsmsPendingDeletion
            self.hsmsPendingRegistration = output.hsmsPendingRegistration
            self.label = output.label
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
            self.partitionSerialList = output.partitionSerialList
            self.state = output.state
        } else {
            self.hapgArn = nil
            self.hapgSerial = nil
            self.hsmsLastActionFailed = nil
            self.hsmsPendingDeletion = nil
            self.hsmsPendingRegistration = nil
            self.label = nil
            self.lastModifiedTimestamp = nil
            self.partitionSerialList = nil
            self.state = nil
        }
    }
}

/// Contains the output of the DescribeHapg action.
public struct DescribeHapgOutputResponse: Swift.Equatable {
    /// The ARN of the high-availability partition group.
    public let hapgArn: Swift.String?
    /// The serial number of the high-availability partition group.
    public let hapgSerial: Swift.String?
    ///
    public let hsmsLastActionFailed: [Swift.String]?
    ///
    public let hsmsPendingDeletion: [Swift.String]?
    ///
    public let hsmsPendingRegistration: [Swift.String]?
    /// The label for the high-availability partition group.
    public let label: Swift.String?
    /// The date and time the high-availability partition group was last modified.
    public let lastModifiedTimestamp: Swift.String?
    /// The list of partition serial numbers that belong to the high-availability partition
    ///       group.
    public let partitionSerialList: [Swift.String]?
    /// The state of the high-availability partition group.
    public let state: CloudHsmClientTypes.CloudHsmObjectState?

    public init (
        hapgArn: Swift.String? = nil,
        hapgSerial: Swift.String? = nil,
        hsmsLastActionFailed: [Swift.String]? = nil,
        hsmsPendingDeletion: [Swift.String]? = nil,
        hsmsPendingRegistration: [Swift.String]? = nil,
        label: Swift.String? = nil,
        lastModifiedTimestamp: Swift.String? = nil,
        partitionSerialList: [Swift.String]? = nil,
        state: CloudHsmClientTypes.CloudHsmObjectState? = nil
    )
    {
        self.hapgArn = hapgArn
        self.hapgSerial = hapgSerial
        self.hsmsLastActionFailed = hsmsLastActionFailed
        self.hsmsPendingDeletion = hsmsPendingDeletion
        self.hsmsPendingRegistration = hsmsPendingRegistration
        self.label = label
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.partitionSerialList = partitionSerialList
        self.state = state
    }
}

struct DescribeHapgOutputResponseBody: Swift.Equatable {
    public let hapgArn: Swift.String?
    public let hapgSerial: Swift.String?
    public let hsmsLastActionFailed: [Swift.String]?
    public let hsmsPendingDeletion: [Swift.String]?
    public let hsmsPendingRegistration: [Swift.String]?
    public let label: Swift.String?
    public let lastModifiedTimestamp: Swift.String?
    public let partitionSerialList: [Swift.String]?
    public let state: CloudHsmClientTypes.CloudHsmObjectState?
}

extension DescribeHapgOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
        case hapgSerial = "HapgSerial"
        case hsmsLastActionFailed = "HsmsLastActionFailed"
        case hsmsPendingDeletion = "HsmsPendingDeletion"
        case hsmsPendingRegistration = "HsmsPendingRegistration"
        case label = "Label"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
        case partitionSerialList = "PartitionSerialList"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
        let hapgSerialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgSerial)
        hapgSerial = hapgSerialDecoded
        let hsmsLastActionFailedContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmsLastActionFailed)
        var hsmsLastActionFailedDecoded0:[Swift.String]? = nil
        if let hsmsLastActionFailedContainer = hsmsLastActionFailedContainer {
            hsmsLastActionFailedDecoded0 = [Swift.String]()
            for string0 in hsmsLastActionFailedContainer {
                if let string0 = string0 {
                    hsmsLastActionFailedDecoded0?.append(string0)
                }
            }
        }
        hsmsLastActionFailed = hsmsLastActionFailedDecoded0
        let hsmsPendingDeletionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmsPendingDeletion)
        var hsmsPendingDeletionDecoded0:[Swift.String]? = nil
        if let hsmsPendingDeletionContainer = hsmsPendingDeletionContainer {
            hsmsPendingDeletionDecoded0 = [Swift.String]()
            for string0 in hsmsPendingDeletionContainer {
                if let string0 = string0 {
                    hsmsPendingDeletionDecoded0?.append(string0)
                }
            }
        }
        hsmsPendingDeletion = hsmsPendingDeletionDecoded0
        let hsmsPendingRegistrationContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmsPendingRegistration)
        var hsmsPendingRegistrationDecoded0:[Swift.String]? = nil
        if let hsmsPendingRegistrationContainer = hsmsPendingRegistrationContainer {
            hsmsPendingRegistrationDecoded0 = [Swift.String]()
            for string0 in hsmsPendingRegistrationContainer {
                if let string0 = string0 {
                    hsmsPendingRegistrationDecoded0?.append(string0)
                }
            }
        }
        hsmsPendingRegistration = hsmsPendingRegistrationDecoded0
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let partitionSerialListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionSerialList)
        var partitionSerialListDecoded0:[Swift.String]? = nil
        if let partitionSerialListContainer = partitionSerialListContainer {
            partitionSerialListDecoded0 = [Swift.String]()
            for string0 in partitionSerialListContainer {
                if let string0 = string0 {
                    partitionSerialListDecoded0?.append(string0)
                }
            }
        }
        partitionSerialList = partitionSerialListDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(CloudHsmClientTypes.CloudHsmObjectState.self, forKey: .state)
        state = stateDecoded
    }
}

public struct DescribeHsmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHsmOutputError>
}

extension DescribeHsmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHsmInput(hsmArn: \(Swift.String(describing: hsmArn)), hsmSerialNumber: \(Swift.String(describing: hsmSerialNumber)))"}
}

extension DescribeHsmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
        case hsmSerialNumber = "HsmSerialNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmArn = hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
        if let hsmSerialNumber = hsmSerialNumber {
            try encodeContainer.encode(hsmSerialNumber, forKey: .hsmSerialNumber)
        }
    }
}

public struct DescribeHsmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHsmOutputError>
}

public struct DescribeHsmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeHsmOutputError>
}

/// Contains the inputs for the DescribeHsm operation.
public struct DescribeHsmInput: Swift.Equatable {
    /// The ARN of the HSM. Either the HsmArn or the SerialNumber
    ///       parameter must be specified.
    public let hsmArn: Swift.String?
    /// The serial number of the HSM. Either the HsmArn or the
    ///         HsmSerialNumber parameter must be specified.
    public let hsmSerialNumber: Swift.String?

    public init (
        hsmArn: Swift.String? = nil,
        hsmSerialNumber: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
        self.hsmSerialNumber = hsmSerialNumber
    }
}

struct DescribeHsmInputBody: Swift.Equatable {
    public let hsmArn: Swift.String?
    public let hsmSerialNumber: Swift.String?
}

extension DescribeHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
        case hsmSerialNumber = "HsmSerialNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let hsmSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmSerialNumber)
        hsmSerialNumber = hsmSerialNumberDecoded
    }
}

extension DescribeHsmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHsmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHsmOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHsmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeHsmOutputResponse(availabilityZone: \(Swift.String(describing: availabilityZone)), eniId: \(Swift.String(describing: eniId)), eniIp: \(Swift.String(describing: eniIp)), hsmArn: \(Swift.String(describing: hsmArn)), hsmType: \(Swift.String(describing: hsmType)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), partitions: \(Swift.String(describing: partitions)), serialNumber: \(Swift.String(describing: serialNumber)), serverCertLastUpdated: \(Swift.String(describing: serverCertLastUpdated)), serverCertUri: \(Swift.String(describing: serverCertUri)), softwareVersion: \(Swift.String(describing: softwareVersion)), sshKeyLastUpdated: \(Swift.String(describing: sshKeyLastUpdated)), sshPublicKey: \(Swift.String(describing: sshPublicKey)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), subnetId: \(Swift.String(describing: subnetId)), subscriptionEndDate: \(Swift.String(describing: subscriptionEndDate)), subscriptionStartDate: \(Swift.String(describing: subscriptionStartDate)), subscriptionType: \(Swift.String(describing: subscriptionType)), vendorName: \(Swift.String(describing: vendorName)), vpcId: \(Swift.String(describing: vpcId)))"}
}

extension DescribeHsmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZone = output.availabilityZone
            self.eniId = output.eniId
            self.eniIp = output.eniIp
            self.hsmArn = output.hsmArn
            self.hsmType = output.hsmType
            self.iamRoleArn = output.iamRoleArn
            self.partitions = output.partitions
            self.serialNumber = output.serialNumber
            self.serverCertLastUpdated = output.serverCertLastUpdated
            self.serverCertUri = output.serverCertUri
            self.softwareVersion = output.softwareVersion
            self.sshKeyLastUpdated = output.sshKeyLastUpdated
            self.sshPublicKey = output.sshPublicKey
            self.status = output.status
            self.statusDetails = output.statusDetails
            self.subnetId = output.subnetId
            self.subscriptionEndDate = output.subscriptionEndDate
            self.subscriptionStartDate = output.subscriptionStartDate
            self.subscriptionType = output.subscriptionType
            self.vendorName = output.vendorName
            self.vpcId = output.vpcId
        } else {
            self.availabilityZone = nil
            self.eniId = nil
            self.eniIp = nil
            self.hsmArn = nil
            self.hsmType = nil
            self.iamRoleArn = nil
            self.partitions = nil
            self.serialNumber = nil
            self.serverCertLastUpdated = nil
            self.serverCertUri = nil
            self.softwareVersion = nil
            self.sshKeyLastUpdated = nil
            self.sshPublicKey = nil
            self.status = nil
            self.statusDetails = nil
            self.subnetId = nil
            self.subscriptionEndDate = nil
            self.subscriptionStartDate = nil
            self.subscriptionType = nil
            self.vendorName = nil
            self.vpcId = nil
        }
    }
}

/// Contains the output of the DescribeHsm operation.
public struct DescribeHsmOutputResponse: Swift.Equatable {
    /// The Availability Zone that the HSM is in.
    public let availabilityZone: Swift.String?
    /// The identifier of the elastic network interface (ENI) attached to the HSM.
    public let eniId: Swift.String?
    /// The IP address assigned to the HSM's ENI.
    public let eniIp: Swift.String?
    /// The ARN of the HSM.
    public let hsmArn: Swift.String?
    /// The HSM model type.
    public let hsmType: Swift.String?
    /// The ARN of the IAM role assigned to the HSM.
    public let iamRoleArn: Swift.String?
    /// The list of partitions on the HSM.
    public let partitions: [Swift.String]?
    /// The serial number of the HSM.
    public let serialNumber: Swift.String?
    /// The date and time that the server certificate was last updated.
    public let serverCertLastUpdated: Swift.String?
    /// The URI of the certificate server.
    public let serverCertUri: Swift.String?
    /// The HSM software version.
    public let softwareVersion: Swift.String?
    /// The date and time that the SSH key was last updated.
    public let sshKeyLastUpdated: Swift.String?
    /// The public SSH key.
    public let sshPublicKey: Swift.String?
    /// The status of the HSM.
    public let status: CloudHsmClientTypes.HsmStatus?
    /// Contains additional information about the status of the HSM.
    public let statusDetails: Swift.String?
    /// The identifier of the subnet that the HSM is in.
    public let subnetId: Swift.String?
    /// The subscription end date.
    public let subscriptionEndDate: Swift.String?
    /// The subscription start date.
    public let subscriptionStartDate: Swift.String?
    /// Specifies the type of subscription for the HSM.
    ///
    ///
    ///
    ///                   PRODUCTION - The HSM is being used in a production
    ///           environment.
    ///
    ///
    ///
    ///                   TRIAL - The HSM is being used in a product
    ///           trial.
    ///
    ///
    public let subscriptionType: CloudHsmClientTypes.SubscriptionType?
    /// The name of the HSM vendor.
    public let vendorName: Swift.String?
    /// The identifier of the VPC that the HSM is in.
    public let vpcId: Swift.String?

    public init (
        availabilityZone: Swift.String? = nil,
        eniId: Swift.String? = nil,
        eniIp: Swift.String? = nil,
        hsmArn: Swift.String? = nil,
        hsmType: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        partitions: [Swift.String]? = nil,
        serialNumber: Swift.String? = nil,
        serverCertLastUpdated: Swift.String? = nil,
        serverCertUri: Swift.String? = nil,
        softwareVersion: Swift.String? = nil,
        sshKeyLastUpdated: Swift.String? = nil,
        sshPublicKey: Swift.String? = nil,
        status: CloudHsmClientTypes.HsmStatus? = nil,
        statusDetails: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        subscriptionEndDate: Swift.String? = nil,
        subscriptionStartDate: Swift.String? = nil,
        subscriptionType: CloudHsmClientTypes.SubscriptionType? = nil,
        vendorName: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.eniId = eniId
        self.eniIp = eniIp
        self.hsmArn = hsmArn
        self.hsmType = hsmType
        self.iamRoleArn = iamRoleArn
        self.partitions = partitions
        self.serialNumber = serialNumber
        self.serverCertLastUpdated = serverCertLastUpdated
        self.serverCertUri = serverCertUri
        self.softwareVersion = softwareVersion
        self.sshKeyLastUpdated = sshKeyLastUpdated
        self.sshPublicKey = sshPublicKey
        self.status = status
        self.statusDetails = statusDetails
        self.subnetId = subnetId
        self.subscriptionEndDate = subscriptionEndDate
        self.subscriptionStartDate = subscriptionStartDate
        self.subscriptionType = subscriptionType
        self.vendorName = vendorName
        self.vpcId = vpcId
    }
}

struct DescribeHsmOutputResponseBody: Swift.Equatable {
    public let hsmArn: Swift.String?
    public let status: CloudHsmClientTypes.HsmStatus?
    public let statusDetails: Swift.String?
    public let availabilityZone: Swift.String?
    public let eniId: Swift.String?
    public let eniIp: Swift.String?
    public let subscriptionType: CloudHsmClientTypes.SubscriptionType?
    public let subscriptionStartDate: Swift.String?
    public let subscriptionEndDate: Swift.String?
    public let vpcId: Swift.String?
    public let subnetId: Swift.String?
    public let iamRoleArn: Swift.String?
    public let serialNumber: Swift.String?
    public let vendorName: Swift.String?
    public let hsmType: Swift.String?
    public let softwareVersion: Swift.String?
    public let sshPublicKey: Swift.String?
    public let sshKeyLastUpdated: Swift.String?
    public let serverCertUri: Swift.String?
    public let serverCertLastUpdated: Swift.String?
    public let partitions: [Swift.String]?
}

extension DescribeHsmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case eniId = "EniId"
        case eniIp = "EniIp"
        case hsmArn = "HsmArn"
        case hsmType = "HsmType"
        case iamRoleArn = "IamRoleArn"
        case partitions = "Partitions"
        case serialNumber = "SerialNumber"
        case serverCertLastUpdated = "ServerCertLastUpdated"
        case serverCertUri = "ServerCertUri"
        case softwareVersion = "SoftwareVersion"
        case sshKeyLastUpdated = "SshKeyLastUpdated"
        case sshPublicKey = "SshPublicKey"
        case status = "Status"
        case statusDetails = "StatusDetails"
        case subnetId = "SubnetId"
        case subscriptionEndDate = "SubscriptionEndDate"
        case subscriptionStartDate = "SubscriptionStartDate"
        case subscriptionType = "SubscriptionType"
        case vendorName = "VendorName"
        case vpcId = "VpcId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CloudHsmClientTypes.HsmStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetails)
        statusDetails = statusDetailsDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniId)
        eniId = eniIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(CloudHsmClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let subscriptionStartDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionStartDate)
        subscriptionStartDate = subscriptionStartDateDecoded
        let subscriptionEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionEndDate)
        subscriptionEndDate = subscriptionEndDateDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let vendorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorName)
        vendorName = vendorNameDecoded
        let hsmTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmType)
        hsmType = hsmTypeDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let sshPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshPublicKey)
        sshPublicKey = sshPublicKeyDecoded
        let sshKeyLastUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sshKeyLastUpdated)
        sshKeyLastUpdated = sshKeyLastUpdatedDecoded
        let serverCertUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertUri)
        serverCertUri = serverCertUriDecoded
        let serverCertLastUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverCertLastUpdated)
        serverCertLastUpdated = serverCertLastUpdatedDecoded
        let partitionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitions)
        var partitionsDecoded0:[Swift.String]? = nil
        if let partitionsContainer = partitionsContainer {
            partitionsDecoded0 = [Swift.String]()
            for string0 in partitionsContainer {
                if let string0 = string0 {
                    partitionsDecoded0?.append(string0)
                }
            }
        }
        partitions = partitionsDecoded0
    }
}

public struct DescribeLunaClientInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLunaClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLunaClientOutputError>
}

extension DescribeLunaClientInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLunaClientInput(certificateFingerprint: \(Swift.String(describing: certificateFingerprint)), clientArn: \(Swift.String(describing: clientArn)))"}
}

extension DescribeLunaClientInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateFingerprint = certificateFingerprint {
            try encodeContainer.encode(certificateFingerprint, forKey: .certificateFingerprint)
        }
        if let clientArn = clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

public struct DescribeLunaClientInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLunaClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLunaClientOutputError>
}

public struct DescribeLunaClientInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLunaClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLunaClientOutputError>
}

public struct DescribeLunaClientInput: Swift.Equatable {
    /// The certificate fingerprint.
    public let certificateFingerprint: Swift.String?
    /// The ARN of the client.
    public let clientArn: Swift.String?

    public init (
        certificateFingerprint: Swift.String? = nil,
        clientArn: Swift.String? = nil
    )
    {
        self.certificateFingerprint = certificateFingerprint
        self.clientArn = clientArn
    }
}

struct DescribeLunaClientInputBody: Swift.Equatable {
    public let clientArn: Swift.String?
    public let certificateFingerprint: Swift.String?
}

extension DescribeLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateFingerprint)
        certificateFingerprint = certificateFingerprintDecoded
    }
}

extension DescribeLunaClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLunaClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLunaClientOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLunaClientOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLunaClientOutputResponse(certificate: \(Swift.String(describing: certificate)), certificateFingerprint: \(Swift.String(describing: certificateFingerprint)), clientArn: \(Swift.String(describing: clientArn)), label: \(Swift.String(describing: label)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)))"}
}

extension DescribeLunaClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificate = output.certificate
            self.certificateFingerprint = output.certificateFingerprint
            self.clientArn = output.clientArn
            self.label = output.label
            self.lastModifiedTimestamp = output.lastModifiedTimestamp
        } else {
            self.certificate = nil
            self.certificateFingerprint = nil
            self.clientArn = nil
            self.label = nil
            self.lastModifiedTimestamp = nil
        }
    }
}

public struct DescribeLunaClientOutputResponse: Swift.Equatable {
    /// The certificate installed on the HSMs used by this client.
    public let certificate: Swift.String?
    /// The certificate fingerprint.
    public let certificateFingerprint: Swift.String?
    /// The ARN of the client.
    public let clientArn: Swift.String?
    /// The label of the client.
    public let label: Swift.String?
    /// The date and time the client was last modified.
    public let lastModifiedTimestamp: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        certificateFingerprint: Swift.String? = nil,
        clientArn: Swift.String? = nil,
        label: Swift.String? = nil,
        lastModifiedTimestamp: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.certificateFingerprint = certificateFingerprint
        self.clientArn = clientArn
        self.label = label
        self.lastModifiedTimestamp = lastModifiedTimestamp
    }
}

struct DescribeLunaClientOutputResponseBody: Swift.Equatable {
    public let clientArn: Swift.String?
    public let certificate: Swift.String?
    public let certificateFingerprint: Swift.String?
    public let lastModifiedTimestamp: Swift.String?
    public let label: Swift.String?
}

extension DescribeLunaClientOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case certificateFingerprint = "CertificateFingerprint"
        case clientArn = "ClientArn"
        case label = "Label"
        case lastModifiedTimestamp = "LastModifiedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateFingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateFingerprint)
        certificateFingerprint = certificateFingerprintDecoded
        let lastModifiedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTimestamp)
        lastModifiedTimestamp = lastModifiedTimestampDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
    }
}

public struct GetConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigOutputError>
}

extension GetConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigInput(clientArn: \(Swift.String(describing: clientArn)), clientVersion: \(Swift.String(describing: clientVersion)), hapgList: \(Swift.String(describing: hapgList)))"}
}

extension GetConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
        case clientVersion = "ClientVersion"
        case hapgList = "HapgList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientArn = clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
        if let clientVersion = clientVersion {
            try encodeContainer.encode(clientVersion.rawValue, forKey: .clientVersion)
        }
        if let hapgList = hapgList {
            var hapgListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hapgList)
            for hapglist0 in hapgList {
                try hapgListContainer.encode(hapglist0)
            }
        }
    }
}

public struct GetConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigOutputError>
}

public struct GetConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetConfigOutputError>
}

public struct GetConfigInput: Swift.Equatable {
    /// The ARN of the client.
    /// This member is required.
    public let clientArn: Swift.String?
    /// The client version.
    /// This member is required.
    public let clientVersion: CloudHsmClientTypes.ClientVersion?
    /// A list of ARNs that identify the high-availability partition groups that are associated
    ///       with the client.
    /// This member is required.
    public let hapgList: [Swift.String]?

    public init (
        clientArn: Swift.String? = nil,
        clientVersion: CloudHsmClientTypes.ClientVersion? = nil,
        hapgList: [Swift.String]? = nil
    )
    {
        self.clientArn = clientArn
        self.clientVersion = clientVersion
        self.hapgList = hapgList
    }
}

struct GetConfigInputBody: Swift.Equatable {
    public let clientArn: Swift.String?
    public let clientVersion: CloudHsmClientTypes.ClientVersion?
    public let hapgList: [Swift.String]?
}

extension GetConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
        case clientVersion = "ClientVersion"
        case hapgList = "HapgList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let clientVersionDecoded = try containerValues.decodeIfPresent(CloudHsmClientTypes.ClientVersion.self, forKey: .clientVersion)
        clientVersion = clientVersionDecoded
        let hapgListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hapgList)
        var hapgListDecoded0:[Swift.String]? = nil
        if let hapgListContainer = hapgListContainer {
            hapgListDecoded0 = [Swift.String]()
            for string0 in hapgListContainer {
                if let string0 = string0 {
                    hapgListDecoded0?.append(string0)
                }
            }
        }
        hapgList = hapgListDecoded0
    }
}

extension GetConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConfigOutputResponse(configCred: \(Swift.String(describing: configCred)), configFile: \(Swift.String(describing: configFile)), configType: \(Swift.String(describing: configType)))"}
}

extension GetConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configCred = output.configCred
            self.configFile = output.configFile
            self.configType = output.configType
        } else {
            self.configCred = nil
            self.configFile = nil
            self.configType = nil
        }
    }
}

public struct GetConfigOutputResponse: Swift.Equatable {
    /// The certificate file containing the server.pem files of the HSMs.
    public let configCred: Swift.String?
    /// The chrystoki.conf configuration file.
    public let configFile: Swift.String?
    /// The type of credentials.
    public let configType: Swift.String?

    public init (
        configCred: Swift.String? = nil,
        configFile: Swift.String? = nil,
        configType: Swift.String? = nil
    )
    {
        self.configCred = configCred
        self.configFile = configFile
        self.configType = configType
    }
}

struct GetConfigOutputResponseBody: Swift.Equatable {
    public let configType: Swift.String?
    public let configFile: Swift.String?
    public let configCred: Swift.String?
}

extension GetConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configCred = "ConfigCred"
        case configFile = "ConfigFile"
        case configType = "ConfigType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configType)
        configType = configTypeDecoded
        let configFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configFile)
        configFile = configFileDecoded
        let configCredDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configCred)
        configCred = configCredDecoded
    }
}

extension CloudHsmClientTypes {
    public enum HsmStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case degraded
        case pending
        case running
        case suspended
        case terminated
        case terminating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [HsmStatus] {
            return [
                .degraded,
                .pending,
                .running,
                .suspended,
                .terminated,
                .terminating,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .degraded: return "DEGRADED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .suspended: return "SUSPENDED"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HsmStatus(rawValue: rawValue) ?? HsmStatus.sdkUnknown(rawValue)
        }
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)), retryable: \(Swift.String(describing: retryable)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.retryable = output.retryable
        } else {
            self.message = nil
            self.retryable = false
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates that one or more of the request parameters are not valid.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Additional information about the error.
    public var message: Swift.String?
    /// Indicates if the action can be retried.
    public var retryable: Swift.Bool

    public init (
        message: Swift.String? = nil,
        retryable: Swift.Bool = false
    )
    {
        self.message = message
        self.retryable = retryable
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let retryable: Swift.Bool
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case retryable
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let retryableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .retryable)
        retryable = retryableDecoded
    }
}

extension ListAvailableZonesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAvailableZonesInput()"}
}

extension ListAvailableZonesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAvailableZonesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAvailableZonesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAvailableZonesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAvailableZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAvailableZonesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAvailableZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAvailableZonesOutputError>
}

public struct ListAvailableZonesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAvailableZonesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAvailableZonesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAvailableZonesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAvailableZonesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAvailableZonesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAvailableZonesOutputError>
}

/// Contains the inputs for the ListAvailableZones action.
public struct ListAvailableZonesInput: Swift.Equatable {

    public init() {}
}

struct ListAvailableZonesInputBody: Swift.Equatable {
}

extension ListAvailableZonesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAvailableZonesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableZonesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAvailableZonesOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableZonesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAvailableZonesOutputResponse(aZList: \(Swift.String(describing: aZList)))"}
}

extension ListAvailableZonesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAvailableZonesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aZList = output.aZList
        } else {
            self.aZList = nil
        }
    }
}

public struct ListAvailableZonesOutputResponse: Swift.Equatable {
    /// The list of Availability Zones that have available AWS CloudHSM capacity.
    public let aZList: [Swift.String]?

    public init (
        aZList: [Swift.String]? = nil
    )
    {
        self.aZList = aZList
    }
}

struct ListAvailableZonesOutputResponseBody: Swift.Equatable {
    public let aZList: [Swift.String]?
}

extension ListAvailableZonesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aZList = "AZList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aZListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aZList)
        var aZListDecoded0:[Swift.String]? = nil
        if let aZListContainer = aZListContainer {
            aZListDecoded0 = [Swift.String]()
            for string0 in aZListContainer {
                if let string0 = string0 {
                    aZListDecoded0?.append(string0)
                }
            }
        }
        aZList = aZListDecoded0
    }
}

public struct ListHapgsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHapgsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHapgsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHapgsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHapgsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHapgsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHapgsOutputError>
}

extension ListHapgsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHapgsInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHapgsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListHapgsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHapgsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHapgsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHapgsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHapgsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHapgsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHapgsOutputError>
}

public struct ListHapgsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHapgsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHapgsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHapgsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHapgsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHapgsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHapgsOutputError>
}

public struct ListHapgsInput: Swift.Equatable {
    /// The NextToken value from a previous call to ListHapgs. Pass
    ///       null if this is the first call.
    public let nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListHapgsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
}

extension ListHapgsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHapgsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHapgsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHapgsOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHapgsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHapgsOutputResponse(hapgList: \(Swift.String(describing: hapgList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHapgsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHapgsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hapgList = output.hapgList
            self.nextToken = output.nextToken
        } else {
            self.hapgList = nil
            self.nextToken = nil
        }
    }
}

public struct ListHapgsOutputResponse: Swift.Equatable {
    /// The list of high-availability partition groups.
    /// This member is required.
    public let hapgList: [Swift.String]?
    /// If not null, more results are available. Pass this value to ListHapgs to
    ///       retrieve the next set of items.
    public let nextToken: Swift.String?

    public init (
        hapgList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hapgList = hapgList
        self.nextToken = nextToken
    }
}

struct ListHapgsOutputResponseBody: Swift.Equatable {
    public let hapgList: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListHapgsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgList = "HapgList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hapgList)
        var hapgListDecoded0:[Swift.String]? = nil
        if let hapgListContainer = hapgListContainer {
            hapgListDecoded0 = [Swift.String]()
            for string0 in hapgListContainer {
                if let string0 = string0 {
                    hapgListDecoded0?.append(string0)
                }
            }
        }
        hapgList = hapgListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListHsmsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHsmsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHsmsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHsmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHsmsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHsmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHsmsOutputError>
}

extension ListHsmsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHsmsInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHsmsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListHsmsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHsmsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHsmsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHsmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHsmsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHsmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHsmsOutputError>
}

public struct ListHsmsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListHsmsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListHsmsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListHsmsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListHsmsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListHsmsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListHsmsOutputError>
}

public struct ListHsmsInput: Swift.Equatable {
    /// The NextToken value from a previous call to ListHsms. Pass
    ///       null if this is the first call.
    public let nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListHsmsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
}

extension ListHsmsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHsmsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHsmsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHsmsOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHsmsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListHsmsOutputResponse(hsmList: \(Swift.String(describing: hsmList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListHsmsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHsmsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmList = output.hsmList
            self.nextToken = output.nextToken
        } else {
            self.hsmList = nil
            self.nextToken = nil
        }
    }
}

/// Contains the output of the ListHsms operation.
public struct ListHsmsOutputResponse: Swift.Equatable {
    /// The list of ARNs that identify the HSMs.
    public let hsmList: [Swift.String]?
    /// If not null, more results are available. Pass this value to ListHsms to
    ///       retrieve the next set of items.
    public let nextToken: Swift.String?

    public init (
        hsmList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hsmList = hsmList
        self.nextToken = nextToken
    }
}

struct ListHsmsOutputResponseBody: Swift.Equatable {
    public let hsmList: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListHsmsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmList = "HsmList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .hsmList)
        var hsmListDecoded0:[Swift.String]? = nil
        if let hsmListContainer = hsmListContainer {
            hsmListDecoded0 = [Swift.String]()
            for string0 in hsmListContainer {
                if let string0 = string0 {
                    hsmListDecoded0?.append(string0)
                }
            }
        }
        hsmList = hsmListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLunaClientsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLunaClientsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLunaClientsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLunaClientsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLunaClientsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLunaClientsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLunaClientsOutputError>
}

extension ListLunaClientsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLunaClientsInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLunaClientsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLunaClientsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLunaClientsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLunaClientsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLunaClientsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLunaClientsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLunaClientsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLunaClientsOutputError>
}

public struct ListLunaClientsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLunaClientsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLunaClientsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLunaClientsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLunaClientsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLunaClientsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLunaClientsOutputError>
}

public struct ListLunaClientsInput: Swift.Equatable {
    /// The NextToken value from a previous call to ListLunaClients.
    ///       Pass null if this is the first call.
    public let nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListLunaClientsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
}

extension ListLunaClientsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLunaClientsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLunaClientsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLunaClientsOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLunaClientsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLunaClientsOutputResponse(clientList: \(Swift.String(describing: clientList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLunaClientsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLunaClientsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientList = output.clientList
            self.nextToken = output.nextToken
        } else {
            self.clientList = nil
            self.nextToken = nil
        }
    }
}

public struct ListLunaClientsOutputResponse: Swift.Equatable {
    /// The list of clients.
    /// This member is required.
    public let clientList: [Swift.String]?
    /// If not null, more results are available. Pass this to ListLunaClients to
    ///       retrieve the next set of items.
    public let nextToken: Swift.String?

    public init (
        clientList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clientList = clientList
        self.nextToken = nextToken
    }
}

struct ListLunaClientsOutputResponseBody: Swift.Equatable {
    public let clientList: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListLunaClientsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientList = "ClientList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .clientList)
        var clientListDecoded0:[Swift.String]? = nil
        if let clientListContainer = clientListContainer {
            clientListDecoded0 = [Swift.String]()
            for string0 in clientListContainer {
                if let string0 = string0 {
                    clientListDecoded0?.append(string0)
                }
            }
        }
        clientList = clientListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource.
    /// This member is required.
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tagList: \(Swift.String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// One or more tags.
    /// This member is required.
    public let tagList: [CloudHsmClientTypes.Tag]?

    public init (
        tagList: [CloudHsmClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tagList: [CloudHsmClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([CloudHsmClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[CloudHsmClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [CloudHsmClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

public struct ModifyHapgInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyHapgInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyHapgOutputError>
}

extension ModifyHapgInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyHapgInput(hapgArn: \(Swift.String(describing: hapgArn)), label: \(Swift.String(describing: label)), partitionSerialList: \(Swift.String(describing: partitionSerialList)))"}
}

extension ModifyHapgInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
        case label = "Label"
        case partitionSerialList = "PartitionSerialList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hapgArn = hapgArn {
            try encodeContainer.encode(hapgArn, forKey: .hapgArn)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let partitionSerialList = partitionSerialList {
            var partitionSerialListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionSerialList)
            for partitionseriallist0 in partitionSerialList {
                try partitionSerialListContainer.encode(partitionseriallist0)
            }
        }
    }
}

public struct ModifyHapgInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyHapgInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyHapgOutputError>
}

public struct ModifyHapgInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyHapgInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyHapgInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyHapgOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyHapgInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyHapgOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyHapgOutputError>
}

public struct ModifyHapgInput: Swift.Equatable {
    /// The ARN of the high-availability partition group to modify.
    /// This member is required.
    public let hapgArn: Swift.String?
    /// The new label for the high-availability partition group.
    public let label: Swift.String?
    /// The list of partition serial numbers to make members of the high-availability partition
    ///       group.
    public let partitionSerialList: [Swift.String]?

    public init (
        hapgArn: Swift.String? = nil,
        label: Swift.String? = nil,
        partitionSerialList: [Swift.String]? = nil
    )
    {
        self.hapgArn = hapgArn
        self.label = label
        self.partitionSerialList = partitionSerialList
    }
}

struct ModifyHapgInputBody: Swift.Equatable {
    public let hapgArn: Swift.String?
    public let label: Swift.String?
    public let partitionSerialList: [Swift.String]?
}

extension ModifyHapgInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
        case label = "Label"
        case partitionSerialList = "PartitionSerialList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let partitionSerialListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionSerialList)
        var partitionSerialListDecoded0:[Swift.String]? = nil
        if let partitionSerialListContainer = partitionSerialListContainer {
            partitionSerialListDecoded0 = [Swift.String]()
            for string0 in partitionSerialListContainer {
                if let string0 = string0 {
                    partitionSerialListDecoded0?.append(string0)
                }
            }
        }
        partitionSerialList = partitionSerialListDecoded0
    }
}

extension ModifyHapgOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyHapgOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyHapgOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyHapgOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyHapgOutputResponse(hapgArn: \(Swift.String(describing: hapgArn)))"}
}

extension ModifyHapgOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyHapgOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hapgArn = output.hapgArn
        } else {
            self.hapgArn = nil
        }
    }
}

public struct ModifyHapgOutputResponse: Swift.Equatable {
    /// The ARN of the high-availability partition group.
    public let hapgArn: Swift.String?

    public init (
        hapgArn: Swift.String? = nil
    )
    {
        self.hapgArn = hapgArn
    }
}

struct ModifyHapgOutputResponseBody: Swift.Equatable {
    public let hapgArn: Swift.String?
}

extension ModifyHapgOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hapgArn = "HapgArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hapgArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hapgArn)
        hapgArn = hapgArnDecoded
    }
}

public struct ModifyHsmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyHsmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyHsmOutputError>
}

extension ModifyHsmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyHsmInput(eniIp: \(Swift.String(describing: eniIp)), externalId: \(Swift.String(describing: externalId)), hsmArn: \(Swift.String(describing: hsmArn)), iamRoleArn: \(Swift.String(describing: iamRoleArn)), subnetId: \(Swift.String(describing: subnetId)), syslogIp: \(Swift.String(describing: syslogIp)))"}
}

extension ModifyHsmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case hsmArn = "HsmArn"
        case iamRoleArn = "IamRoleArn"
        case subnetId = "SubnetId"
        case syslogIp = "SyslogIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eniIp = eniIp {
            try encodeContainer.encode(eniIp, forKey: .eniIp)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let hsmArn = hsmArn {
            try encodeContainer.encode(hsmArn, forKey: .hsmArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let syslogIp = syslogIp {
            try encodeContainer.encode(syslogIp, forKey: .syslogIp)
        }
    }
}

public struct ModifyHsmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyHsmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyHsmOutputError>
}

public struct ModifyHsmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyHsmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyHsmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyHsmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyHsmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyHsmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyHsmOutputError>
}

/// Contains the inputs for the ModifyHsm operation.
public struct ModifyHsmInput: Swift.Equatable {
    /// The new IP address for the elastic network interface (ENI) attached to the
    ///       HSM.
    ///          If the HSM is moved to a different subnet, and an IP address is not specified, an IP
    ///       address will be randomly chosen from the CIDR range of the new subnet.
    public let eniIp: Swift.String?
    /// The new external ID.
    public let externalId: Swift.String?
    /// The ARN of the HSM to modify.
    /// This member is required.
    public let hsmArn: Swift.String?
    /// The new IAM role ARN.
    public let iamRoleArn: Swift.String?
    /// The new identifier of the subnet that the HSM is in. The new subnet must be in the same
    ///       Availability Zone as the current subnet.
    public let subnetId: Swift.String?
    /// The new IP address for the syslog monitoring server. The AWS CloudHSM service only supports
    ///       one syslog monitoring server.
    public let syslogIp: Swift.String?

    public init (
        eniIp: Swift.String? = nil,
        externalId: Swift.String? = nil,
        hsmArn: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        syslogIp: Swift.String? = nil
    )
    {
        self.eniIp = eniIp
        self.externalId = externalId
        self.hsmArn = hsmArn
        self.iamRoleArn = iamRoleArn
        self.subnetId = subnetId
        self.syslogIp = syslogIp
    }
}

struct ModifyHsmInputBody: Swift.Equatable {
    public let hsmArn: Swift.String?
    public let subnetId: Swift.String?
    public let eniIp: Swift.String?
    public let iamRoleArn: Swift.String?
    public let externalId: Swift.String?
    public let syslogIp: Swift.String?
}

extension ModifyHsmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eniIp = "EniIp"
        case externalId = "ExternalId"
        case hsmArn = "HsmArn"
        case iamRoleArn = "IamRoleArn"
        case subnetId = "SubnetId"
        case syslogIp = "SyslogIp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let eniIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniIp)
        eniIp = eniIpDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let syslogIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .syslogIp)
        syslogIp = syslogIpDecoded
    }
}

extension ModifyHsmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyHsmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyHsmOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyHsmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyHsmOutputResponse(hsmArn: \(Swift.String(describing: hsmArn)))"}
}

extension ModifyHsmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyHsmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.hsmArn = output.hsmArn
        } else {
            self.hsmArn = nil
        }
    }
}

/// Contains the output of the ModifyHsm operation.
public struct ModifyHsmOutputResponse: Swift.Equatable {
    /// The ARN of the HSM.
    public let hsmArn: Swift.String?

    public init (
        hsmArn: Swift.String? = nil
    )
    {
        self.hsmArn = hsmArn
    }
}

struct ModifyHsmOutputResponseBody: Swift.Equatable {
    public let hsmArn: Swift.String?
}

extension ModifyHsmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmArn = "HsmArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmArn)
        hsmArn = hsmArnDecoded
    }
}

public struct ModifyLunaClientInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyLunaClientInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyLunaClientOutputError>
}

extension ModifyLunaClientInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyLunaClientInput(certificate: \(Swift.String(describing: certificate)), clientArn: \(Swift.String(describing: clientArn)))"}
}

extension ModifyLunaClientInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case clientArn = "ClientArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let clientArn = clientArn {
            try encodeContainer.encode(clientArn, forKey: .clientArn)
        }
    }
}

public struct ModifyLunaClientInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyLunaClientInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyLunaClientOutputError>
}

public struct ModifyLunaClientInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ModifyLunaClientInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ModifyLunaClientInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ModifyLunaClientOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ModifyLunaClientInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ModifyLunaClientOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ModifyLunaClientOutputError>
}

public struct ModifyLunaClientInput: Swift.Equatable {
    /// The new certificate for the client.
    /// This member is required.
    public let certificate: Swift.String?
    /// The ARN of the client.
    /// This member is required.
    public let clientArn: Swift.String?

    public init (
        certificate: Swift.String? = nil,
        clientArn: Swift.String? = nil
    )
    {
        self.certificate = certificate
        self.clientArn = clientArn
    }
}

struct ModifyLunaClientInputBody: Swift.Equatable {
    public let clientArn: Swift.String?
    public let certificate: Swift.String?
}

extension ModifyLunaClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension ModifyLunaClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ModifyLunaClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyLunaClientOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmServiceException(CloudHsmServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyLunaClientOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ModifyLunaClientOutputResponse(clientArn: \(Swift.String(describing: clientArn)))"}
}

extension ModifyLunaClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ModifyLunaClientOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientArn = output.clientArn
        } else {
            self.clientArn = nil
        }
    }
}

public struct ModifyLunaClientOutputResponse: Swift.Equatable {
    /// The ARN of the client.
    public let clientArn: Swift.String?

    public init (
        clientArn: Swift.String? = nil
    )
    {
        self.clientArn = clientArn
    }
}

struct ModifyLunaClientOutputResponseBody: Swift.Equatable {
    public let clientArn: Swift.String?
}

extension ModifyLunaClientOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientArn = "ClientArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientArn)
        clientArn = clientArnDecoded
    }
}

public struct RemoveTagsFromResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

extension RemoveTagsFromResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeyList: \(Swift.String(describing: tagKeyList)))"}
}

extension RemoveTagsFromResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkeylist0 in tagKeyList {
                try tagKeyListContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct RemoveTagsFromResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveTagsFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveTagsFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveTagsFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveTagsFromResourceOutputError>
}

public struct RemoveTagsFromResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the AWS CloudHSM resource.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// The tag key or keys to remove.
    ///          Specify only the tag key to remove (not the value). To overwrite the value for an
    ///       existing tag, use AddTagsToResource.
    /// This member is required.
    public let tagKeyList: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeyList = tagKeyList
    }
}

struct RemoveTagsFromResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeyList: [Swift.String]?
}

extension RemoveTagsFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension RemoveTagsFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CloudHsmInternalException" : self = .cloudHsmInternalException(try CloudHsmInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudHsmServiceException" : self = .cloudHsmServiceException(try CloudHsmServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromResourceOutputError: Swift.Error, Swift.Equatable {
    case cloudHsmInternalException(CloudHsmInternalException)
    case cloudHsmServiceException(CloudHsmServiceException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveTagsFromResourceOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension RemoveTagsFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveTagsFromResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct RemoveTagsFromResourceOutputResponse: Swift.Equatable {
    /// The status of the operation.
    /// This member is required.
    public let status: Swift.String?

    public init (
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct RemoveTagsFromResourceOutputResponseBody: Swift.Equatable {
    public let status: Swift.String?
}

extension RemoveTagsFromResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudHsmClientTypes {
    /// Specifies the type of subscription for the HSM.
    ///
    ///
    ///
    ///                   PRODUCTION - The HSM is being used in a production
    ///           environment.
    ///
    ///
    ///
    ///                   TRIAL - The HSM is being used in a product
    ///           trial.
    ///
    ///
    public enum SubscriptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case production
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .production,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .production: return "PRODUCTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
        }
    }
}

extension CloudHsmClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudHsmClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CloudHsmClientTypes {
    /// A key-value pair that identifies or specifies metadata about an AWS CloudHSM
    ///       resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public let key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}
