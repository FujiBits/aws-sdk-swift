// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class ApiGatewayClient {
    let client: ClientRuntime.SdkHttpClient
    let config: AWSClientRuntime.AWSClientConfiguration
    let serviceName = "API Gateway"
    let encoder: ClientRuntime.RequestEncoder
    let decoder: ClientRuntime.ResponseDecoder

    public init(config: AWSClientRuntime.AWSClientConfiguration) {
        client = ClientRuntime.SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public convenience init(region: Swift.String? = nil) throws {
        let config = try ApiGatewayClientConfiguration(region: region)
        self.init(config: config)
    }

    deinit {
        client.close()
    }

    public class ApiGatewayClientConfiguration: AWSClientRuntime.AWSClientConfiguration {

        public var clientLogMode: ClientRuntime.ClientLogMode
        public var decoder: ClientRuntime.ResponseDecoder?
        public var encoder: ClientRuntime.RequestEncoder?
        public var httpClientConfiguration: ClientRuntime.HttpClientConfiguration
        public var httpClientEngine: ClientRuntime.HttpClientEngine
        public var idempotencyTokenGenerator: ClientRuntime.IdempotencyTokenGenerator
        public var logger: ClientRuntime.LogAgent
        public var retryer: ClientRuntime.SDKRetryer

        public var credentialsProvider: AWSClientRuntime.CredentialsProvider
        public var endpointResolver: AWSClientRuntime.EndpointResolver
        public var region: Swift.String?
        public var regionResolver: AWSClientRuntime.RegionResolver
        public var signingRegion: Swift.String?

        public init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil,
            runtimeConfig: ClientRuntime.SDKRuntimeConfiguration
        ) throws {
            self.regionResolver = regionResolver ?? DefaultRegionResolver()
            let defaultRegion = self.regionResolver.resolveRegion()
            self.region = region ?? defaultRegion
            self.signingRegion = signingRegion ?? defaultRegion
            self.endpointResolver = endpointResolver ?? DefaultEndpointResolver()
            if let credProvider = credentialsProvider {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromCustom(credProvider)
            } else {
                self.credentialsProvider = try AWSClientRuntime.AWSCredentialsProvider.fromChain()
            }
            self.clientLogMode = runtimeConfig.clientLogMode
            self.decoder = runtimeConfig.decoder
            self.encoder = runtimeConfig.encoder
            self.httpClientConfiguration = runtimeConfig.httpClientConfiguration
            self.httpClientEngine = runtimeConfig.httpClientEngine
            self.idempotencyTokenGenerator = runtimeConfig.idempotencyTokenGenerator
            self.logger = runtimeConfig.logger
            self.retryer = runtimeConfig.retryer
        }

        public convenience init(
            credentialsProvider: AWSClientRuntime.CredentialsProvider? = nil,
            endpointResolver: AWSClientRuntime.EndpointResolver? = nil,
            region: Swift.String? = nil,
            regionResolver: AWSClientRuntime.RegionResolver? = nil,
            signingRegion: Swift.String? = nil
        ) throws {
            let defaultRuntimeConfig = try ClientRuntime.DefaultSDKRuntimeConfiguration("ApiGatewayClient")
            try self.init(credentialsProvider: credentialsProvider, endpointResolver: endpointResolver, region: region, regionResolver: regionResolver, signingRegion: signingRegion, runtimeConfig: defaultRuntimeConfig)
        }
    }
}

public struct ApiGatewayClientLogHandlerFactory: ClientRuntime.SDKLogHandlerFactory {
    public var label = "ApiGatewayClient"
    let logLevel: ClientRuntime.SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: ClientRuntime.SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension ApiGatewayClient: ApiGatewayClientProtocol {
    /// Create an ApiKey resource.
    ///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/create-api-key.html">AWS CLI</div>
    public func createApiKey(input: CreateApiKeyInput, completion: @escaping (ClientRuntime.SdkResult<CreateApiKeyOutputResponse, CreateApiKeyOutputError>) -> Void)
    {
        let urlPath = "/apikeys"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createApiKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateApiKeyInput, CreateApiKeyOutputResponse, CreateApiKeyOutputError>(id: "createApiKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateApiKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateApiKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateApiKeyInput, CreateApiKeyOutputResponse, CreateApiKeyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateApiKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Adds a new Authorizer resource to an existing RestApi resource.
    ///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/create-authorizer.html">AWS CLI</div>
    public func createAuthorizer(input: CreateAuthorizerInput, completion: @escaping (ClientRuntime.SdkResult<CreateAuthorizerOutputResponse, CreateAuthorizerOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/authorizers"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateAuthorizerInput, CreateAuthorizerOutputResponse, CreateAuthorizerOutputError>(id: "createAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateAuthorizerInput, CreateAuthorizerOutputResponse, CreateAuthorizerOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateAuthorizerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a new BasePathMapping resource.
    public func createBasePathMapping(input: CreateBasePathMappingInput, completion: @escaping (ClientRuntime.SdkResult<CreateBasePathMappingOutputResponse, CreateBasePathMappingOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domainnames/\(domainName)/basepathmappings"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createBasePathMapping")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateBasePathMappingInput, CreateBasePathMappingOutputResponse, CreateBasePathMappingOutputError>(id: "createBasePathMapping")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateBasePathMappingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateBasePathMappingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateBasePathMappingInput, CreateBasePathMappingOutputResponse, CreateBasePathMappingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateBasePathMappingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a Deployment resource, which makes a specified RestApi callable over the internet.
    public func createDeployment(input: CreateDeploymentInput, completion: @escaping (ClientRuntime.SdkResult<CreateDeploymentOutputResponse, CreateDeploymentOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/deployments"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDeploymentInput, CreateDeploymentOutputResponse, CreateDeploymentOutputError>(id: "createDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateDeploymentInput, CreateDeploymentOutputResponse, CreateDeploymentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDeploymentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func createDocumentationPart(input: CreateDocumentationPartInput, completion: @escaping (ClientRuntime.SdkResult<CreateDocumentationPartOutputResponse, CreateDocumentationPartOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/parts"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDocumentationPart")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDocumentationPartInput, CreateDocumentationPartOutputResponse, CreateDocumentationPartOutputError>(id: "createDocumentationPart")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDocumentationPartInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDocumentationPartInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateDocumentationPartInput, CreateDocumentationPartOutputResponse, CreateDocumentationPartOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDocumentationPartInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func createDocumentationVersion(input: CreateDocumentationVersionInput, completion: @escaping (ClientRuntime.SdkResult<CreateDocumentationVersionOutputResponse, CreateDocumentationVersionOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/versions"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDocumentationVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDocumentationVersionInput, CreateDocumentationVersionOutputResponse, CreateDocumentationVersionOutputError>(id: "createDocumentationVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDocumentationVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDocumentationVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateDocumentationVersionInput, CreateDocumentationVersionOutputResponse, CreateDocumentationVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDocumentationVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a new domain name.
    public func createDomainName(input: CreateDomainNameInput, completion: @escaping (ClientRuntime.SdkResult<CreateDomainNameOutputResponse, CreateDomainNameOutputError>) -> Void)
    {
        let urlPath = "/domainnames"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDomainName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDomainNameInput, CreateDomainNameOutputResponse, CreateDomainNameOutputError>(id: "createDomainName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateDomainNameInput, CreateDomainNameOutputResponse, CreateDomainNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDomainNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Adds a new Model resource to an existing RestApi resource.
    public func createModel(input: CreateModelInput, completion: @escaping (ClientRuntime.SdkResult<CreateModelOutputResponse, CreateModelOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/models"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createModel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateModelInput, CreateModelOutputResponse, CreateModelOutputError>(id: "createModel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateModelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateModelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateModelInput, CreateModelOutputResponse, CreateModelOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateModelInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a ReqeustValidator of a given RestApi.
    public func createRequestValidator(input: CreateRequestValidatorInput, completion: @escaping (ClientRuntime.SdkResult<CreateRequestValidatorOutputResponse, CreateRequestValidatorOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/requestvalidators"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createRequestValidator")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateRequestValidatorInput, CreateRequestValidatorOutputResponse, CreateRequestValidatorOutputError>(id: "createRequestValidator")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateRequestValidatorInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateRequestValidatorInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateRequestValidatorInput, CreateRequestValidatorOutputResponse, CreateRequestValidatorOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateRequestValidatorInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a Resource resource.
    public func createResource(input: CreateResourceInput, completion: @escaping (ClientRuntime.SdkResult<CreateResourceOutputResponse, CreateResourceOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let parentId = input.parentId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component parentId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(parentId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateResourceInput, CreateResourceOutputResponse, CreateResourceOutputError>(id: "createResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateResourceInput, CreateResourceOutputResponse, CreateResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a new RestApi resource.
    public func createRestApi(input: CreateRestApiInput, completion: @escaping (ClientRuntime.SdkResult<CreateRestApiOutputResponse, CreateRestApiOutputError>) -> Void)
    {
        let urlPath = "/restapis"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createRestApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateRestApiInput, CreateRestApiOutputResponse, CreateRestApiOutputError>(id: "createRestApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateRestApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateRestApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateRestApiInput, CreateRestApiOutputResponse, CreateRestApiOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateRestApiInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a new Stage resource that references a pre-existing Deployment for the API.
    ///         <!--   Creates a Stage resource.  -->
    public func createStage(input: CreateStageInput, completion: @escaping (ClientRuntime.SdkResult<CreateStageOutputResponse, CreateStageOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/stages"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createStage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateStageInput, CreateStageOutputResponse, CreateStageOutputError>(id: "createStage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateStageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateStageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateStageInput, CreateStageOutputResponse, CreateStageOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateStageInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a usage plan with the throttle and quota limits, as well as the associated API stages, specified in the payload.
    public func createUsagePlan(input: CreateUsagePlanInput, completion: @escaping (ClientRuntime.SdkResult<CreateUsagePlanOutputResponse, CreateUsagePlanOutputError>) -> Void)
    {
        let urlPath = "/usageplans"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUsagePlan")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUsagePlanInput, CreateUsagePlanOutputResponse, CreateUsagePlanOutputError>(id: "createUsagePlan")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUsagePlanInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUsagePlanInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateUsagePlanInput, CreateUsagePlanOutputResponse, CreateUsagePlanOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUsagePlanInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a usage plan key for adding an existing API key to a usage plan.
    public func createUsagePlanKey(input: CreateUsagePlanKeyInput, completion: @escaping (ClientRuntime.SdkResult<CreateUsagePlanKeyOutputResponse, CreateUsagePlanKeyOutputError>) -> Void)
    {
        guard let usagePlanId = input.usagePlanId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component usagePlanId unexpectedly nil"))))
            return
        }
        let urlPath = "/usageplans/\(usagePlanId)/keys"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createUsagePlanKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateUsagePlanKeyInput, CreateUsagePlanKeyOutputResponse, CreateUsagePlanKeyOutputError>(id: "createUsagePlanKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateUsagePlanKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateUsagePlanKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateUsagePlanKeyInput, CreateUsagePlanKeyOutputResponse, CreateUsagePlanKeyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateUsagePlanKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.
    public func createVpcLink(input: CreateVpcLinkInput, completion: @escaping (ClientRuntime.SdkResult<CreateVpcLinkOutputResponse, CreateVpcLinkOutputError>) -> Void)
    {
        let urlPath = "/vpclinks"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVpcLink")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVpcLinkInput, CreateVpcLinkOutputResponse, CreateVpcLinkOutputError>(id: "createVpcLink")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateVpcLinkInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVpcLinkInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<CreateVpcLinkInput, CreateVpcLinkOutputResponse, CreateVpcLinkOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVpcLinkInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes the ApiKey resource.
    public func deleteApiKey(input: DeleteApiKeyInput, completion: @escaping (ClientRuntime.SdkResult<DeleteApiKeyOutputResponse, DeleteApiKeyOutputError>) -> Void)
    {
        guard let apiKey = input.apiKey else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component apiKey unexpectedly nil"))))
            return
        }
        let urlPath = "/apikeys/\(apiKey)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteApiKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteApiKeyInput, DeleteApiKeyOutputResponse, DeleteApiKeyOutputError>(id: "deleteApiKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteApiKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteApiKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteApiKeyInput, DeleteApiKeyOutputResponse, DeleteApiKeyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing Authorizer resource.
    ///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/delete-authorizer.html">AWS CLI</div>
    public func deleteAuthorizer(input: DeleteAuthorizerInput, completion: @escaping (ClientRuntime.SdkResult<DeleteAuthorizerOutputResponse, DeleteAuthorizerOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let authorizerId = input.authorizerId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component authorizerId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/authorizers/\(authorizerId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAuthorizerInput, DeleteAuthorizerOutputResponse, DeleteAuthorizerOutputError>(id: "deleteAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteAuthorizerInput, DeleteAuthorizerOutputResponse, DeleteAuthorizerOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes the BasePathMapping resource.
    public func deleteBasePathMapping(input: DeleteBasePathMappingInput, completion: @escaping (ClientRuntime.SdkResult<DeleteBasePathMappingOutputResponse, DeleteBasePathMappingOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        guard let basePath = input.basePath else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component basePath unexpectedly nil"))))
            return
        }
        let urlPath = "/domainnames/\(domainName)/basepathmappings/\(basePath)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBasePathMapping")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBasePathMappingInput, DeleteBasePathMappingOutputResponse, DeleteBasePathMappingOutputError>(id: "deleteBasePathMapping")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBasePathMappingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBasePathMappingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteBasePathMappingInput, DeleteBasePathMappingOutputResponse, DeleteBasePathMappingOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes the ClientCertificate resource.
    public func deleteClientCertificate(input: DeleteClientCertificateInput, completion: @escaping (ClientRuntime.SdkResult<DeleteClientCertificateOutputResponse, DeleteClientCertificateOutputError>) -> Void)
    {
        guard let clientCertificateId = input.clientCertificateId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component clientCertificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/clientcertificates/\(clientCertificateId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteClientCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteClientCertificateInput, DeleteClientCertificateOutputResponse, DeleteClientCertificateOutputError>(id: "deleteClientCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteClientCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteClientCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteClientCertificateInput, DeleteClientCertificateOutputResponse, DeleteClientCertificateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a Deployment resource. Deleting a deployment will only succeed if there are no Stage resources associated with it.
    public func deleteDeployment(input: DeleteDeploymentInput, completion: @escaping (ClientRuntime.SdkResult<DeleteDeploymentOutputResponse, DeleteDeploymentOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let deploymentId = input.deploymentId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component deploymentId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/deployments/\(deploymentId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDeploymentInput, DeleteDeploymentOutputResponse, DeleteDeploymentOutputError>(id: "deleteDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteDeploymentInput, DeleteDeploymentOutputResponse, DeleteDeploymentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func deleteDocumentationPart(input: DeleteDocumentationPartInput, completion: @escaping (ClientRuntime.SdkResult<DeleteDocumentationPartOutputResponse, DeleteDocumentationPartOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let documentationPartId = input.documentationPartId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component documentationPartId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/parts/\(documentationPartId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDocumentationPart")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDocumentationPartInput, DeleteDocumentationPartOutputResponse, DeleteDocumentationPartOutputError>(id: "deleteDocumentationPart")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDocumentationPartInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDocumentationPartInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteDocumentationPartInput, DeleteDocumentationPartOutputResponse, DeleteDocumentationPartOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func deleteDocumentationVersion(input: DeleteDocumentationVersionInput, completion: @escaping (ClientRuntime.SdkResult<DeleteDocumentationVersionOutputResponse, DeleteDocumentationVersionOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let documentationVersion = input.documentationVersion else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component documentationVersion unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/versions/\(documentationVersion)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDocumentationVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDocumentationVersionInput, DeleteDocumentationVersionOutputResponse, DeleteDocumentationVersionOutputError>(id: "deleteDocumentationVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDocumentationVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDocumentationVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteDocumentationVersionInput, DeleteDocumentationVersionOutputResponse, DeleteDocumentationVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes the DomainName resource.
    public func deleteDomainName(input: DeleteDomainNameInput, completion: @escaping (ClientRuntime.SdkResult<DeleteDomainNameOutputResponse, DeleteDomainNameOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domainnames/\(domainName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDomainName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDomainNameInput, DeleteDomainNameOutputResponse, DeleteDomainNameOutputError>(id: "deleteDomainName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDomainNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteDomainNameInput, DeleteDomainNameOutputResponse, DeleteDomainNameOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Clears any customization of a GatewayResponse of a specified response type on the given RestApi and resets it with the default settings.
    public func deleteGatewayResponse(input: DeleteGatewayResponseInput, completion: @escaping (ClientRuntime.SdkResult<DeleteGatewayResponseOutputResponse, DeleteGatewayResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let responseType = input.responseType else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component responseType unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/gatewayresponses/\(responseType.rawValue)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteGatewayResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteGatewayResponseInput, DeleteGatewayResponseOutputResponse, DeleteGatewayResponseOutputError>(id: "deleteGatewayResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteGatewayResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteGatewayResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteGatewayResponseInput, DeleteGatewayResponseOutputResponse, DeleteGatewayResponseOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Represents a delete integration.
    public func deleteIntegration(input: DeleteIntegrationInput, completion: @escaping (ClientRuntime.SdkResult<DeleteIntegrationOutputResponse, DeleteIntegrationOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/integration"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteIntegration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteIntegrationInput, DeleteIntegrationOutputResponse, DeleteIntegrationOutputError>(id: "deleteIntegration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteIntegrationInput, DeleteIntegrationOutputResponse, DeleteIntegrationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Represents a delete integration response.
    public func deleteIntegrationResponse(input: DeleteIntegrationResponseInput, completion: @escaping (ClientRuntime.SdkResult<DeleteIntegrationResponseOutputResponse, DeleteIntegrationResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        guard let statusCode = input.statusCode else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component statusCode unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/integration/responses/\(statusCode)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteIntegrationResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteIntegrationResponseInput, DeleteIntegrationResponseOutputResponse, DeleteIntegrationResponseOutputError>(id: "deleteIntegrationResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntegrationResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteIntegrationResponseInput, DeleteIntegrationResponseOutputResponse, DeleteIntegrationResponseOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing Method resource.
    public func deleteMethod(input: DeleteMethodInput, completion: @escaping (ClientRuntime.SdkResult<DeleteMethodOutputResponse, DeleteMethodOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteMethod")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteMethodInput, DeleteMethodOutputResponse, DeleteMethodOutputError>(id: "deleteMethod")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteMethodInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteMethodInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteMethodInput, DeleteMethodOutputResponse, DeleteMethodOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing MethodResponse resource.
    public func deleteMethodResponse(input: DeleteMethodResponseInput, completion: @escaping (ClientRuntime.SdkResult<DeleteMethodResponseOutputResponse, DeleteMethodResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        guard let statusCode = input.statusCode else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component statusCode unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/responses/\(statusCode)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteMethodResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteMethodResponseInput, DeleteMethodResponseOutputResponse, DeleteMethodResponseOutputError>(id: "deleteMethodResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteMethodResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteMethodResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteMethodResponseInput, DeleteMethodResponseOutputResponse, DeleteMethodResponseOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a model.
    public func deleteModel(input: DeleteModelInput, completion: @escaping (ClientRuntime.SdkResult<DeleteModelOutputResponse, DeleteModelOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let modelName = input.modelName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component modelName unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/models/\(modelName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteModel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteModelInput, DeleteModelOutputResponse, DeleteModelOutputError>(id: "deleteModel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteModelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteModelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteModelInput, DeleteModelOutputResponse, DeleteModelOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a RequestValidator of a given RestApi.
    public func deleteRequestValidator(input: DeleteRequestValidatorInput, completion: @escaping (ClientRuntime.SdkResult<DeleteRequestValidatorOutputResponse, DeleteRequestValidatorOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let requestValidatorId = input.requestValidatorId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component requestValidatorId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/requestvalidators/\(requestValidatorId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRequestValidator")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRequestValidatorInput, DeleteRequestValidatorOutputResponse, DeleteRequestValidatorOutputError>(id: "deleteRequestValidator")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRequestValidatorInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRequestValidatorInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteRequestValidatorInput, DeleteRequestValidatorOutputResponse, DeleteRequestValidatorOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a Resource resource.
    public func deleteResource(input: DeleteResourceInput, completion: @escaping (ClientRuntime.SdkResult<DeleteResourceOutputResponse, DeleteResourceOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteResourceInput, DeleteResourceOutputResponse, DeleteResourceOutputError>(id: "deleteResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteResourceInput, DeleteResourceOutputResponse, DeleteResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes the specified API.
    public func deleteRestApi(input: DeleteRestApiInput, completion: @escaping (ClientRuntime.SdkResult<DeleteRestApiOutputResponse, DeleteRestApiOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRestApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRestApiInput, DeleteRestApiOutputResponse, DeleteRestApiOutputError>(id: "deleteRestApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRestApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRestApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteRestApiInput, DeleteRestApiOutputResponse, DeleteRestApiOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a Stage resource.
    public func deleteStage(input: DeleteStageInput, completion: @escaping (ClientRuntime.SdkResult<DeleteStageOutputResponse, DeleteStageOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let stageName = input.stageName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component stageName unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/stages/\(stageName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteStage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteStageInput, DeleteStageOutputResponse, DeleteStageOutputError>(id: "deleteStage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteStageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteStageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteStageInput, DeleteStageOutputResponse, DeleteStageOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a usage plan of a given plan Id.
    public func deleteUsagePlan(input: DeleteUsagePlanInput, completion: @escaping (ClientRuntime.SdkResult<DeleteUsagePlanOutputResponse, DeleteUsagePlanOutputError>) -> Void)
    {
        guard let usagePlanId = input.usagePlanId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component usagePlanId unexpectedly nil"))))
            return
        }
        let urlPath = "/usageplans/\(usagePlanId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUsagePlan")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUsagePlanInput, DeleteUsagePlanOutputResponse, DeleteUsagePlanOutputError>(id: "deleteUsagePlan")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUsagePlanInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUsagePlanInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteUsagePlanInput, DeleteUsagePlanOutputResponse, DeleteUsagePlanOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes a usage plan key  and remove the underlying API key from the associated usage plan.
    public func deleteUsagePlanKey(input: DeleteUsagePlanKeyInput, completion: @escaping (ClientRuntime.SdkResult<DeleteUsagePlanKeyOutputResponse, DeleteUsagePlanKeyOutputError>) -> Void)
    {
        guard let usagePlanId = input.usagePlanId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component usagePlanId unexpectedly nil"))))
            return
        }
        guard let keyId = input.keyId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component keyId unexpectedly nil"))))
            return
        }
        let urlPath = "/usageplans/\(usagePlanId)/keys/\(keyId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUsagePlanKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUsagePlanKeyInput, DeleteUsagePlanKeyOutputResponse, DeleteUsagePlanKeyOutputError>(id: "deleteUsagePlanKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUsagePlanKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUsagePlanKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteUsagePlanKeyInput, DeleteUsagePlanKeyOutputResponse, DeleteUsagePlanKeyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Deletes an existing VpcLink of a specified identifier.
    public func deleteVpcLink(input: DeleteVpcLinkInput, completion: @escaping (ClientRuntime.SdkResult<DeleteVpcLinkOutputResponse, DeleteVpcLinkOutputError>) -> Void)
    {
        guard let vpcLinkId = input.vpcLinkId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component vpcLinkId unexpectedly nil"))))
            return
        }
        let urlPath = "/vpclinks/\(vpcLinkId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVpcLink")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVpcLinkInput, DeleteVpcLinkOutputResponse, DeleteVpcLinkOutputError>(id: "deleteVpcLink")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVpcLinkInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVpcLinkInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DeleteVpcLinkInput, DeleteVpcLinkOutputResponse, DeleteVpcLinkOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Flushes all authorizer cache entries on a stage.
    public func flushStageAuthorizersCache(input: FlushStageAuthorizersCacheInput, completion: @escaping (ClientRuntime.SdkResult<FlushStageAuthorizersCacheOutputResponse, FlushStageAuthorizersCacheOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let stageName = input.stageName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component stageName unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/stages/\(stageName)/cache/authorizers"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "flushStageAuthorizersCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<FlushStageAuthorizersCacheInput, FlushStageAuthorizersCacheOutputResponse, FlushStageAuthorizersCacheOutputError>(id: "flushStageAuthorizersCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: FlushStageAuthorizersCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: FlushStageAuthorizersCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<FlushStageAuthorizersCacheInput, FlushStageAuthorizersCacheOutputResponse, FlushStageAuthorizersCacheOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Flushes a stage's cache.
    public func flushStageCache(input: FlushStageCacheInput, completion: @escaping (ClientRuntime.SdkResult<FlushStageCacheOutputResponse, FlushStageCacheOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let stageName = input.stageName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component stageName unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/stages/\(stageName)/cache/data"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "flushStageCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<FlushStageCacheInput, FlushStageCacheOutputResponse, FlushStageCacheOutputError>(id: "flushStageCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: FlushStageCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: FlushStageCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<FlushStageCacheInput, FlushStageCacheOutputResponse, FlushStageCacheOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Generates a ClientCertificate resource.
    public func generateClientCertificate(input: GenerateClientCertificateInput, completion: @escaping (ClientRuntime.SdkResult<GenerateClientCertificateOutputResponse, GenerateClientCertificateOutputError>) -> Void)
    {
        let urlPath = "/clientcertificates"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "generateClientCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GenerateClientCertificateInput, GenerateClientCertificateOutputResponse, GenerateClientCertificateOutputError>(id: "generateClientCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GenerateClientCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GenerateClientCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GenerateClientCertificateInput, GenerateClientCertificateOutputResponse, GenerateClientCertificateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: GenerateClientCertificateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about the current Account resource.
    public func getAccount(input: GetAccountInput, completion: @escaping (ClientRuntime.SdkResult<GetAccountOutputResponse, GetAccountOutputError>) -> Void)
    {
        let urlPath = "/account"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAccount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAccountInput, GetAccountOutputResponse, GetAccountOutputError>(id: "getAccount")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAccountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAccountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetAccountInput, GetAccountOutputResponse, GetAccountOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about the current ApiKey resource.
    public func getApiKey(input: GetApiKeyInput, completion: @escaping (ClientRuntime.SdkResult<GetApiKeyOutputResponse, GetApiKeyOutputError>) -> Void)
    {
        guard let apiKey = input.apiKey else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component apiKey unexpectedly nil"))))
            return
        }
        let urlPath = "/apikeys/\(apiKey)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getApiKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetApiKeyInput, GetApiKeyOutputResponse, GetApiKeyOutputError>(id: "getApiKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetApiKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetApiKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetApiKeyInput, GetApiKeyOutputResponse, GetApiKeyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about the current ApiKeys resource.
    public func getApiKeys(input: GetApiKeysInput, completion: @escaping (ClientRuntime.SdkResult<GetApiKeysOutputResponse, GetApiKeysOutputError>) -> Void)
    {
        let urlPath = "/apikeys"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getApiKeys")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetApiKeysInput, GetApiKeysOutputResponse, GetApiKeysOutputError>(id: "getApiKeys")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetApiKeysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetApiKeysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetApiKeysInput, GetApiKeysOutputResponse, GetApiKeysOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describe an existing Authorizer resource.
    ///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-authorizer.html">AWS CLI</div>
    public func getAuthorizer(input: GetAuthorizerInput, completion: @escaping (ClientRuntime.SdkResult<GetAuthorizerOutputResponse, GetAuthorizerOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let authorizerId = input.authorizerId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component authorizerId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/authorizers/\(authorizerId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAuthorizerInput, GetAuthorizerOutputResponse, GetAuthorizerOutputError>(id: "getAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetAuthorizerInput, GetAuthorizerOutputResponse, GetAuthorizerOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describe an existing Authorizers resource.
    ///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-authorizers.html">AWS CLI</div>
    public func getAuthorizers(input: GetAuthorizersInput, completion: @escaping (ClientRuntime.SdkResult<GetAuthorizersOutputResponse, GetAuthorizersOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/authorizers"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAuthorizers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAuthorizersInput, GetAuthorizersOutputResponse, GetAuthorizersOutputError>(id: "getAuthorizers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAuthorizersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAuthorizersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetAuthorizersInput, GetAuthorizersOutputResponse, GetAuthorizersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describe a BasePathMapping resource.
    public func getBasePathMapping(input: GetBasePathMappingInput, completion: @escaping (ClientRuntime.SdkResult<GetBasePathMappingOutputResponse, GetBasePathMappingOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        guard let basePath = input.basePath else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component basePath unexpectedly nil"))))
            return
        }
        let urlPath = "/domainnames/\(domainName)/basepathmappings/\(basePath)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBasePathMapping")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBasePathMappingInput, GetBasePathMappingOutputResponse, GetBasePathMappingOutputError>(id: "getBasePathMapping")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBasePathMappingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBasePathMappingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetBasePathMappingInput, GetBasePathMappingOutputResponse, GetBasePathMappingOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Represents a collection of BasePathMapping resources.
    public func getBasePathMappings(input: GetBasePathMappingsInput, completion: @escaping (ClientRuntime.SdkResult<GetBasePathMappingsOutputResponse, GetBasePathMappingsOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domainnames/\(domainName)/basepathmappings"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBasePathMappings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBasePathMappingsInput, GetBasePathMappingsOutputResponse, GetBasePathMappingsOutputError>(id: "getBasePathMappings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBasePathMappingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBasePathMappingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetBasePathMappingsInput, GetBasePathMappingsOutputResponse, GetBasePathMappingsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about the current ClientCertificate resource.
    public func getClientCertificate(input: GetClientCertificateInput, completion: @escaping (ClientRuntime.SdkResult<GetClientCertificateOutputResponse, GetClientCertificateOutputError>) -> Void)
    {
        guard let clientCertificateId = input.clientCertificateId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component clientCertificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/clientcertificates/\(clientCertificateId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getClientCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetClientCertificateInput, GetClientCertificateOutputResponse, GetClientCertificateOutputError>(id: "getClientCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetClientCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetClientCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetClientCertificateInput, GetClientCertificateOutputResponse, GetClientCertificateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets a collection of ClientCertificate resources.
    public func getClientCertificates(input: GetClientCertificatesInput, completion: @escaping (ClientRuntime.SdkResult<GetClientCertificatesOutputResponse, GetClientCertificatesOutputError>) -> Void)
    {
        let urlPath = "/clientcertificates"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getClientCertificates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetClientCertificatesInput, GetClientCertificatesOutputResponse, GetClientCertificatesOutputError>(id: "getClientCertificates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetClientCertificatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetClientCertificatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetClientCertificatesInput, GetClientCertificatesOutputResponse, GetClientCertificatesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about a Deployment resource.
    public func getDeployment(input: GetDeploymentInput, completion: @escaping (ClientRuntime.SdkResult<GetDeploymentOutputResponse, GetDeploymentOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let deploymentId = input.deploymentId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component deploymentId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/deployments/\(deploymentId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDeploymentInput, GetDeploymentOutputResponse, GetDeploymentOutputError>(id: "getDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDeploymentInput, GetDeploymentOutputResponse, GetDeploymentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about a Deployments collection.
    public func getDeployments(input: GetDeploymentsInput, completion: @escaping (ClientRuntime.SdkResult<GetDeploymentsOutputResponse, GetDeploymentsOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/deployments"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDeployments")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDeploymentsInput, GetDeploymentsOutputResponse, GetDeploymentsOutputError>(id: "getDeployments")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDeploymentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDeploymentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDeploymentsInput, GetDeploymentsOutputResponse, GetDeploymentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func getDocumentationPart(input: GetDocumentationPartInput, completion: @escaping (ClientRuntime.SdkResult<GetDocumentationPartOutputResponse, GetDocumentationPartOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let documentationPartId = input.documentationPartId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component documentationPartId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/parts/\(documentationPartId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDocumentationPart")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDocumentationPartInput, GetDocumentationPartOutputResponse, GetDocumentationPartOutputError>(id: "getDocumentationPart")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentationPartInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentationPartInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDocumentationPartInput, GetDocumentationPartOutputResponse, GetDocumentationPartOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func getDocumentationParts(input: GetDocumentationPartsInput, completion: @escaping (ClientRuntime.SdkResult<GetDocumentationPartsOutputResponse, GetDocumentationPartsOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/parts"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDocumentationParts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDocumentationPartsInput, GetDocumentationPartsOutputResponse, GetDocumentationPartsOutputError>(id: "getDocumentationParts")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentationPartsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentationPartsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDocumentationPartsInput, GetDocumentationPartsOutputResponse, GetDocumentationPartsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func getDocumentationVersion(input: GetDocumentationVersionInput, completion: @escaping (ClientRuntime.SdkResult<GetDocumentationVersionOutputResponse, GetDocumentationVersionOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let documentationVersion = input.documentationVersion else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component documentationVersion unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/versions/\(documentationVersion)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDocumentationVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDocumentationVersionInput, GetDocumentationVersionOutputResponse, GetDocumentationVersionOutputError>(id: "getDocumentationVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentationVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentationVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDocumentationVersionInput, GetDocumentationVersionOutputResponse, GetDocumentationVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func getDocumentationVersions(input: GetDocumentationVersionsInput, completion: @escaping (ClientRuntime.SdkResult<GetDocumentationVersionsOutputResponse, GetDocumentationVersionsOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/versions"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDocumentationVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDocumentationVersionsInput, GetDocumentationVersionsOutputResponse, GetDocumentationVersionsOutputError>(id: "getDocumentationVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentationVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDocumentationVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDocumentationVersionsInput, GetDocumentationVersionsOutputResponse, GetDocumentationVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Represents a domain name that is contained in a simpler, more intuitive URL that can be called.
    public func getDomainName(input: GetDomainNameInput, completion: @escaping (ClientRuntime.SdkResult<GetDomainNameOutputResponse, GetDomainNameOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domainnames/\(domainName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDomainName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDomainNameInput, GetDomainNameOutputResponse, GetDomainNameOutputError>(id: "getDomainName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDomainNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDomainNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDomainNameInput, GetDomainNameOutputResponse, GetDomainNameOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Represents a collection of DomainName resources.
    public func getDomainNames(input: GetDomainNamesInput, completion: @escaping (ClientRuntime.SdkResult<GetDomainNamesOutputResponse, GetDomainNamesOutputError>) -> Void)
    {
        let urlPath = "/domainnames"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDomainNames")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDomainNamesInput, GetDomainNamesOutputResponse, GetDomainNamesOutputError>(id: "getDomainNames")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDomainNamesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDomainNamesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetDomainNamesInput, GetDomainNamesOutputResponse, GetDomainNamesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Exports a deployed version of a RestApi in a specified format.
    public func getExport(input: GetExportInput, completion: @escaping (ClientRuntime.SdkResult<GetExportOutputResponse, GetExportOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let stageName = input.stageName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component stageName unexpectedly nil"))))
            return
        }
        guard let exportType = input.exportType else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component exportType unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/stages/\(stageName)/exports/\(exportType)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getExport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetExportInput, GetExportOutputResponse, GetExportOutputError>(id: "getExport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetExportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetExportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetExportInput, GetExportOutputResponse, GetExportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets a GatewayResponse of a specified response type on the given RestApi.
    public func getGatewayResponse(input: GetGatewayResponseInput, completion: @escaping (ClientRuntime.SdkResult<GetGatewayResponseOutputResponse, GetGatewayResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let responseType = input.responseType else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component responseType unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/gatewayresponses/\(responseType.rawValue)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGatewayResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetGatewayResponseInput, GetGatewayResponseOutputResponse, GetGatewayResponseOutputError>(id: "getGatewayResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetGatewayResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetGatewayResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetGatewayResponseInput, GetGatewayResponseOutputResponse, GetGatewayResponseOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the GatewayResponses collection on the given RestApi. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default GatewayResponses collection for the supported response types.
    public func getGatewayResponses(input: GetGatewayResponsesInput, completion: @escaping (ClientRuntime.SdkResult<GetGatewayResponsesOutputResponse, GetGatewayResponsesOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/gatewayresponses"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGatewayResponses")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetGatewayResponsesInput, GetGatewayResponsesOutputResponse, GetGatewayResponsesOutputError>(id: "getGatewayResponses")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetGatewayResponsesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetGatewayResponsesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetGatewayResponsesInput, GetGatewayResponsesOutputResponse, GetGatewayResponsesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Get the integration settings.
    public func getIntegration(input: GetIntegrationInput, completion: @escaping (ClientRuntime.SdkResult<GetIntegrationOutputResponse, GetIntegrationOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/integration"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getIntegration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetIntegrationInput, GetIntegrationOutputResponse, GetIntegrationOutputError>(id: "getIntegration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetIntegrationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetIntegrationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetIntegrationInput, GetIntegrationOutputResponse, GetIntegrationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Represents a get integration response.
    public func getIntegrationResponse(input: GetIntegrationResponseInput, completion: @escaping (ClientRuntime.SdkResult<GetIntegrationResponseOutputResponse, GetIntegrationResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        guard let statusCode = input.statusCode else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component statusCode unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/integration/responses/\(statusCode)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getIntegrationResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetIntegrationResponseInput, GetIntegrationResponseOutputResponse, GetIntegrationResponseOutputError>(id: "getIntegrationResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetIntegrationResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetIntegrationResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetIntegrationResponseInput, GetIntegrationResponseOutputResponse, GetIntegrationResponseOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describe an existing Method resource.
    public func getMethod(input: GetMethodInput, completion: @escaping (ClientRuntime.SdkResult<GetMethodOutputResponse, GetMethodOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getMethod")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetMethodInput, GetMethodOutputResponse, GetMethodOutputError>(id: "getMethod")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetMethodInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetMethodInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetMethodInput, GetMethodOutputResponse, GetMethodOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes a MethodResponse resource.
    public func getMethodResponse(input: GetMethodResponseInput, completion: @escaping (ClientRuntime.SdkResult<GetMethodResponseOutputResponse, GetMethodResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        guard let statusCode = input.statusCode else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component statusCode unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/responses/\(statusCode)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getMethodResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetMethodResponseInput, GetMethodResponseOutputResponse, GetMethodResponseOutputError>(id: "getMethodResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetMethodResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetMethodResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetMethodResponseInput, GetMethodResponseOutputResponse, GetMethodResponseOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes an existing model defined for a RestApi resource.
    public func getModel(input: GetModelInput, completion: @escaping (ClientRuntime.SdkResult<GetModelOutputResponse, GetModelOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let modelName = input.modelName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component modelName unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/models/\(modelName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getModel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetModelInput, GetModelOutputResponse, GetModelOutputError>(id: "getModel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetModelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetModelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetModelInput, GetModelOutputResponse, GetModelOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Generates a sample mapping template that can be used to transform a payload into the structure of a model.
    public func getModelTemplate(input: GetModelTemplateInput, completion: @escaping (ClientRuntime.SdkResult<GetModelTemplateOutputResponse, GetModelTemplateOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let modelName = input.modelName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component modelName unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/models/\(modelName)/default_template"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getModelTemplate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetModelTemplateInput, GetModelTemplateOutputResponse, GetModelTemplateOutputError>(id: "getModelTemplate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetModelTemplateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetModelTemplateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetModelTemplateInput, GetModelTemplateOutputResponse, GetModelTemplateOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Describes existing Models defined for a RestApi resource.
    public func getModels(input: GetModelsInput, completion: @escaping (ClientRuntime.SdkResult<GetModelsOutputResponse, GetModelsOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/models"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getModels")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetModelsInput, GetModelsOutputResponse, GetModelsOutputError>(id: "getModels")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetModelsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetModelsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetModelsInput, GetModelsOutputResponse, GetModelsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets a RequestValidator of a given RestApi.
    public func getRequestValidator(input: GetRequestValidatorInput, completion: @escaping (ClientRuntime.SdkResult<GetRequestValidatorOutputResponse, GetRequestValidatorOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let requestValidatorId = input.requestValidatorId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component requestValidatorId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/requestvalidators/\(requestValidatorId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getRequestValidator")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetRequestValidatorInput, GetRequestValidatorOutputResponse, GetRequestValidatorOutputError>(id: "getRequestValidator")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetRequestValidatorInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetRequestValidatorInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetRequestValidatorInput, GetRequestValidatorOutputResponse, GetRequestValidatorOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the RequestValidators collection of a given RestApi.
    public func getRequestValidators(input: GetRequestValidatorsInput, completion: @escaping (ClientRuntime.SdkResult<GetRequestValidatorsOutputResponse, GetRequestValidatorsOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/requestvalidators"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getRequestValidators")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetRequestValidatorsInput, GetRequestValidatorsOutputResponse, GetRequestValidatorsOutputError>(id: "getRequestValidators")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetRequestValidatorsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetRequestValidatorsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetRequestValidatorsInput, GetRequestValidatorsOutputResponse, GetRequestValidatorsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists information about a resource.
    public func getResource(input: GetResourceInput, completion: @escaping (ClientRuntime.SdkResult<GetResourceOutputResponse, GetResourceOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetResourceInput, GetResourceOutputResponse, GetResourceOutputError>(id: "getResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetResourceInput, GetResourceOutputResponse, GetResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists information about a collection of Resource resources.
    public func getResources(input: GetResourcesInput, completion: @escaping (ClientRuntime.SdkResult<GetResourcesOutputResponse, GetResourcesOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getResources")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetResourcesInput, GetResourcesOutputResponse, GetResourcesOutputError>(id: "getResources")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetResourcesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetResourcesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetResourcesInput, GetResourcesOutputResponse, GetResourcesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the RestApi resource in the collection.
    public func getRestApi(input: GetRestApiInput, completion: @escaping (ClientRuntime.SdkResult<GetRestApiOutputResponse, GetRestApiOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getRestApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetRestApiInput, GetRestApiOutputResponse, GetRestApiOutputError>(id: "getRestApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetRestApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetRestApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetRestApiInput, GetRestApiOutputResponse, GetRestApiOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Lists the RestApis resources for your collection.
    public func getRestApis(input: GetRestApisInput, completion: @escaping (ClientRuntime.SdkResult<GetRestApisOutputResponse, GetRestApisOutputError>) -> Void)
    {
        let urlPath = "/restapis"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getRestApis")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetRestApisInput, GetRestApisOutputResponse, GetRestApisOutputError>(id: "getRestApis")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetRestApisInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetRestApisInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetRestApisInput, GetRestApisOutputResponse, GetRestApisOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Generates a client SDK for a RestApi and Stage.
    public func getSdk(input: GetSdkInput, completion: @escaping (ClientRuntime.SdkResult<GetSdkOutputResponse, GetSdkOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let stageName = input.stageName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component stageName unexpectedly nil"))))
            return
        }
        guard let sdkType = input.sdkType else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component sdkType unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/stages/\(stageName)/sdks/\(sdkType)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSdk")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSdkInput, GetSdkOutputResponse, GetSdkOutputError>(id: "getSdk")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSdkInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSdkInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetSdkInput, GetSdkOutputResponse, GetSdkOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func getSdkType(input: GetSdkTypeInput, completion: @escaping (ClientRuntime.SdkResult<GetSdkTypeOutputResponse, GetSdkTypeOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/sdktypes/\(id)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSdkType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSdkTypeInput, GetSdkTypeOutputResponse, GetSdkTypeOutputError>(id: "getSdkType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSdkTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSdkTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetSdkTypeInput, GetSdkTypeOutputResponse, GetSdkTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func getSdkTypes(input: GetSdkTypesInput, completion: @escaping (ClientRuntime.SdkResult<GetSdkTypesOutputResponse, GetSdkTypesOutputError>) -> Void)
    {
        let urlPath = "/sdktypes"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSdkTypes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSdkTypesInput, GetSdkTypesOutputResponse, GetSdkTypesOutputError>(id: "getSdkTypes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSdkTypesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSdkTypesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetSdkTypesInput, GetSdkTypesOutputResponse, GetSdkTypesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about a Stage resource.
    public func getStage(input: GetStageInput, completion: @escaping (ClientRuntime.SdkResult<GetStageOutputResponse, GetStageOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let stageName = input.stageName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component stageName unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/stages/\(stageName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getStage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetStageInput, GetStageOutputResponse, GetStageOutputError>(id: "getStage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetStageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetStageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetStageInput, GetStageOutputResponse, GetStageOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets information about one or more Stage resources.
    public func getStages(input: GetStagesInput, completion: @escaping (ClientRuntime.SdkResult<GetStagesOutputResponse, GetStagesOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/stages"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getStages")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetStagesInput, GetStagesOutputResponse, GetStagesOutputError>(id: "getStages")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetStagesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetStagesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetStagesInput, GetStagesOutputResponse, GetStagesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the Tags collection for a given resource.
    public func getTags(input: GetTagsInput, completion: @escaping (ClientRuntime.SdkResult<GetTagsOutputResponse, GetTagsOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetTagsInput, GetTagsOutputResponse, GetTagsOutputError>(id: "getTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetTagsInput, GetTagsOutputResponse, GetTagsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the usage data of a usage plan in a specified time interval.
    public func getUsage(input: GetUsageInput, completion: @escaping (ClientRuntime.SdkResult<GetUsageOutputResponse, GetUsageOutputError>) -> Void)
    {
        guard let usagePlanId = input.usagePlanId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component usagePlanId unexpectedly nil"))))
            return
        }
        let urlPath = "/usageplans/\(usagePlanId)/usage"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getUsage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetUsageInput, GetUsageOutputResponse, GetUsageOutputError>(id: "getUsage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetUsageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetUsageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetUsageInput, GetUsageOutputResponse, GetUsageOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets a usage plan of a given plan identifier.
    public func getUsagePlan(input: GetUsagePlanInput, completion: @escaping (ClientRuntime.SdkResult<GetUsagePlanOutputResponse, GetUsagePlanOutputError>) -> Void)
    {
        guard let usagePlanId = input.usagePlanId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component usagePlanId unexpectedly nil"))))
            return
        }
        let urlPath = "/usageplans/\(usagePlanId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getUsagePlan")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetUsagePlanInput, GetUsagePlanOutputResponse, GetUsagePlanOutputError>(id: "getUsagePlan")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetUsagePlanInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetUsagePlanInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetUsagePlanInput, GetUsagePlanOutputResponse, GetUsagePlanOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets a usage plan key of a given key identifier.
    public func getUsagePlanKey(input: GetUsagePlanKeyInput, completion: @escaping (ClientRuntime.SdkResult<GetUsagePlanKeyOutputResponse, GetUsagePlanKeyOutputError>) -> Void)
    {
        guard let usagePlanId = input.usagePlanId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component usagePlanId unexpectedly nil"))))
            return
        }
        guard let keyId = input.keyId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component keyId unexpectedly nil"))))
            return
        }
        let urlPath = "/usageplans/\(usagePlanId)/keys/\(keyId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getUsagePlanKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetUsagePlanKeyInput, GetUsagePlanKeyOutputResponse, GetUsagePlanKeyOutputError>(id: "getUsagePlanKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetUsagePlanKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetUsagePlanKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetUsagePlanKeyInput, GetUsagePlanKeyOutputResponse, GetUsagePlanKeyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets all the usage plan keys representing the API keys added to a specified usage plan.
    public func getUsagePlanKeys(input: GetUsagePlanKeysInput, completion: @escaping (ClientRuntime.SdkResult<GetUsagePlanKeysOutputResponse, GetUsagePlanKeysOutputError>) -> Void)
    {
        guard let usagePlanId = input.usagePlanId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component usagePlanId unexpectedly nil"))))
            return
        }
        let urlPath = "/usageplans/\(usagePlanId)/keys"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getUsagePlanKeys")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetUsagePlanKeysInput, GetUsagePlanKeysOutputResponse, GetUsagePlanKeysOutputError>(id: "getUsagePlanKeys")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetUsagePlanKeysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetUsagePlanKeysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetUsagePlanKeysInput, GetUsagePlanKeysOutputResponse, GetUsagePlanKeysOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets all the usage plans of the caller's account.
    public func getUsagePlans(input: GetUsagePlansInput, completion: @escaping (ClientRuntime.SdkResult<GetUsagePlansOutputResponse, GetUsagePlansOutputError>) -> Void)
    {
        let urlPath = "/usageplans"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getUsagePlans")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetUsagePlansInput, GetUsagePlansOutputResponse, GetUsagePlansOutputError>(id: "getUsagePlans")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetUsagePlansInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetUsagePlansInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetUsagePlansInput, GetUsagePlansOutputResponse, GetUsagePlansOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets a specified VPC link under the caller's account in a region.
    public func getVpcLink(input: GetVpcLinkInput, completion: @escaping (ClientRuntime.SdkResult<GetVpcLinkOutputResponse, GetVpcLinkOutputError>) -> Void)
    {
        guard let vpcLinkId = input.vpcLinkId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component vpcLinkId unexpectedly nil"))))
            return
        }
        let urlPath = "/vpclinks/\(vpcLinkId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getVpcLink")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetVpcLinkInput, GetVpcLinkOutputResponse, GetVpcLinkOutputError>(id: "getVpcLink")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetVpcLinkInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetVpcLinkInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetVpcLinkInput, GetVpcLinkOutputResponse, GetVpcLinkOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Gets the VpcLinks collection under the caller's account in a selected region.
    public func getVpcLinks(input: GetVpcLinksInput, completion: @escaping (ClientRuntime.SdkResult<GetVpcLinksOutputResponse, GetVpcLinksOutputError>) -> Void)
    {
        let urlPath = "/vpclinks"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getVpcLinks")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetVpcLinksInput, GetVpcLinksOutputResponse, GetVpcLinksOutputError>(id: "getVpcLinks")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetVpcLinksInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetVpcLinksInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<GetVpcLinksInput, GetVpcLinksOutputResponse, GetVpcLinksOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Import API keys from an external source, such as a CSV-formatted file.
    public func importApiKeys(input: ImportApiKeysInput, completion: @escaping (ClientRuntime.SdkResult<ImportApiKeysOutputResponse, ImportApiKeysOutputError>) -> Void)
    {
        let urlPath = "/apikeys"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "importApiKeys")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ImportApiKeysInput, ImportApiKeysOutputResponse, ImportApiKeysOutputError>(id: "importApiKeys")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ImportApiKeysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ImportApiKeysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ImportApiKeysInput, ImportApiKeysOutputResponse, ImportApiKeysOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ImportApiKeysInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func importDocumentationParts(input: ImportDocumentationPartsInput, completion: @escaping (ClientRuntime.SdkResult<ImportDocumentationPartsOutputResponse, ImportDocumentationPartsOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/parts"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "importDocumentationParts")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ImportDocumentationPartsInput, ImportDocumentationPartsOutputResponse, ImportDocumentationPartsOutputError>(id: "importDocumentationParts")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ImportDocumentationPartsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ImportDocumentationPartsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ImportDocumentationPartsInput, ImportDocumentationPartsOutputResponse, ImportDocumentationPartsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ImportDocumentationPartsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// A feature of the API Gateway control service for creating a new API from an external API definition file.
    public func importRestApi(input: ImportRestApiInput, completion: @escaping (ClientRuntime.SdkResult<ImportRestApiOutputResponse, ImportRestApiOutputError>) -> Void)
    {
        let urlPath = "/restapis"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "importRestApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ImportRestApiInput, ImportRestApiOutputResponse, ImportRestApiOutputError>(id: "importRestApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ImportRestApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ImportRestApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<ImportRestApiInput, ImportRestApiOutputResponse, ImportRestApiOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ImportRestApiInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Creates a customization of a GatewayResponse of a specified response type and status code on the given RestApi.
    public func putGatewayResponse(input: PutGatewayResponseInput, completion: @escaping (ClientRuntime.SdkResult<PutGatewayResponseOutputResponse, PutGatewayResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let responseType = input.responseType else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component responseType unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/gatewayresponses/\(responseType.rawValue)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putGatewayResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutGatewayResponseInput, PutGatewayResponseOutputResponse, PutGatewayResponseOutputError>(id: "putGatewayResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutGatewayResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutGatewayResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<PutGatewayResponseInput, PutGatewayResponseOutputResponse, PutGatewayResponseOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutGatewayResponseInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Sets up a method's integration.
    public func putIntegration(input: PutIntegrationInput, completion: @escaping (ClientRuntime.SdkResult<PutIntegrationOutputResponse, PutIntegrationOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/integration"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putIntegration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutIntegrationInput, PutIntegrationOutputResponse, PutIntegrationOutputError>(id: "putIntegration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutIntegrationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutIntegrationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<PutIntegrationInput, PutIntegrationOutputResponse, PutIntegrationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutIntegrationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Represents a put integration.
    public func putIntegrationResponse(input: PutIntegrationResponseInput, completion: @escaping (ClientRuntime.SdkResult<PutIntegrationResponseOutputResponse, PutIntegrationResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        guard let statusCode = input.statusCode else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component statusCode unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/integration/responses/\(statusCode)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putIntegrationResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutIntegrationResponseInput, PutIntegrationResponseOutputResponse, PutIntegrationResponseOutputError>(id: "putIntegrationResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutIntegrationResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutIntegrationResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<PutIntegrationResponseInput, PutIntegrationResponseOutputResponse, PutIntegrationResponseOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutIntegrationResponseInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Add a method to an existing Resource resource.
    public func putMethod(input: PutMethodInput, completion: @escaping (ClientRuntime.SdkResult<PutMethodOutputResponse, PutMethodOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putMethod")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutMethodInput, PutMethodOutputResponse, PutMethodOutputError>(id: "putMethod")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutMethodInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutMethodInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<PutMethodInput, PutMethodOutputResponse, PutMethodOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutMethodInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Adds a MethodResponse to an existing Method resource.
    public func putMethodResponse(input: PutMethodResponseInput, completion: @escaping (ClientRuntime.SdkResult<PutMethodResponseOutputResponse, PutMethodResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        guard let statusCode = input.statusCode else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component statusCode unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/responses/\(statusCode)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putMethodResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutMethodResponseInput, PutMethodResponseOutputResponse, PutMethodResponseOutputError>(id: "putMethodResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutMethodResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutMethodResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<PutMethodResponseInput, PutMethodResponseOutputResponse, PutMethodResponseOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutMethodResponseInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// A feature of the API Gateway control service for updating an existing API with an input of external API definitions.
    ///             The update can take the form of merging the supplied definition into the existing API or overwriting the existing API.
    public func putRestApi(input: PutRestApiInput, completion: @escaping (ClientRuntime.SdkResult<PutRestApiOutputResponse, PutRestApiOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putRestApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutRestApiInput, PutRestApiOutputResponse, PutRestApiOutputError>(id: "putRestApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutRestApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutRestApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<PutRestApiInput, PutRestApiOutputResponse, PutRestApiOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutRestApiInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Adds or updates a tag on a given resource.
    public func tagResource(input: TagResourceInput, completion: @escaping (ClientRuntime.SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Simulate the execution of an Authorizer in your RestApi with headers, parameters, and an incoming request body.
    ///       <div class="seeAlso">
    ///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html">Use Lambda Function as Authorizer
    ///         <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html">Use Cognito User Pool as Authorizer
    ///       </div>
    public func testInvokeAuthorizer(input: TestInvokeAuthorizerInput, completion: @escaping (ClientRuntime.SdkResult<TestInvokeAuthorizerOutputResponse, TestInvokeAuthorizerOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let authorizerId = input.authorizerId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component authorizerId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/authorizers/\(authorizerId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "testInvokeAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TestInvokeAuthorizerInput, TestInvokeAuthorizerOutputResponse, TestInvokeAuthorizerOutputError>(id: "testInvokeAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TestInvokeAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TestInvokeAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<TestInvokeAuthorizerInput, TestInvokeAuthorizerOutputResponse, TestInvokeAuthorizerOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TestInvokeAuthorizerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Simulate the execution of a Method in your RestApi with headers, parameters, and an incoming request body.
    public func testInvokeMethod(input: TestInvokeMethodInput, completion: @escaping (ClientRuntime.SdkResult<TestInvokeMethodOutputResponse, TestInvokeMethodOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "testInvokeMethod")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TestInvokeMethodInput, TestInvokeMethodOutputResponse, TestInvokeMethodOutputError>(id: "testInvokeMethod")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TestInvokeMethodInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TestInvokeMethodInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<TestInvokeMethodInput, TestInvokeMethodOutputResponse, TestInvokeMethodOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TestInvokeMethodInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Removes a tag from a given resource.
    public func untagResource(input: UntagResourceInput, completion: @escaping (ClientRuntime.SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about the current Account resource.
    public func updateAccount(input: UpdateAccountInput, completion: @escaping (ClientRuntime.SdkResult<UpdateAccountOutputResponse, UpdateAccountOutputError>) -> Void)
    {
        let urlPath = "/account"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateAccount")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateAccountInput, UpdateAccountOutputResponse, UpdateAccountOutputError>(id: "updateAccount")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateAccountInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateAccountInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateAccountInput, UpdateAccountOutputResponse, UpdateAccountOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateAccountInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about an ApiKey resource.
    public func updateApiKey(input: UpdateApiKeyInput, completion: @escaping (ClientRuntime.SdkResult<UpdateApiKeyOutputResponse, UpdateApiKeyOutputError>) -> Void)
    {
        guard let apiKey = input.apiKey else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component apiKey unexpectedly nil"))))
            return
        }
        let urlPath = "/apikeys/\(apiKey)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateApiKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateApiKeyInput, UpdateApiKeyOutputResponse, UpdateApiKeyOutputError>(id: "updateApiKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateApiKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateApiKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateApiKeyInput, UpdateApiKeyOutputResponse, UpdateApiKeyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateApiKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing Authorizer resource.
    ///         <div class="seeAlso"><a href="https://docs.aws.amazon.com/cli/latest/reference/apigateway/update-authorizer.html">AWS CLI</div>
    public func updateAuthorizer(input: UpdateAuthorizerInput, completion: @escaping (ClientRuntime.SdkResult<UpdateAuthorizerOutputResponse, UpdateAuthorizerOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let authorizerId = input.authorizerId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component authorizerId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/authorizers/\(authorizerId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateAuthorizer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateAuthorizerInput, UpdateAuthorizerOutputResponse, UpdateAuthorizerOutputError>(id: "updateAuthorizer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateAuthorizerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateAuthorizerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateAuthorizerInput, UpdateAuthorizerOutputResponse, UpdateAuthorizerOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateAuthorizerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about the BasePathMapping resource.
    public func updateBasePathMapping(input: UpdateBasePathMappingInput, completion: @escaping (ClientRuntime.SdkResult<UpdateBasePathMappingOutputResponse, UpdateBasePathMappingOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        guard let basePath = input.basePath else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component basePath unexpectedly nil"))))
            return
        }
        let urlPath = "/domainnames/\(domainName)/basepathmappings/\(basePath)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateBasePathMapping")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateBasePathMappingInput, UpdateBasePathMappingOutputResponse, UpdateBasePathMappingOutputError>(id: "updateBasePathMapping")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateBasePathMappingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateBasePathMappingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateBasePathMappingInput, UpdateBasePathMappingOutputResponse, UpdateBasePathMappingOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateBasePathMappingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about an ClientCertificate resource.
    public func updateClientCertificate(input: UpdateClientCertificateInput, completion: @escaping (ClientRuntime.SdkResult<UpdateClientCertificateOutputResponse, UpdateClientCertificateOutputError>) -> Void)
    {
        guard let clientCertificateId = input.clientCertificateId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component clientCertificateId unexpectedly nil"))))
            return
        }
        let urlPath = "/clientcertificates/\(clientCertificateId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateClientCertificate")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateClientCertificateInput, UpdateClientCertificateOutputResponse, UpdateClientCertificateOutputError>(id: "updateClientCertificate")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateClientCertificateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateClientCertificateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateClientCertificateInput, UpdateClientCertificateOutputResponse, UpdateClientCertificateOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateClientCertificateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about a Deployment resource.
    public func updateDeployment(input: UpdateDeploymentInput, completion: @escaping (ClientRuntime.SdkResult<UpdateDeploymentOutputResponse, UpdateDeploymentOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let deploymentId = input.deploymentId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component deploymentId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/deployments/\(deploymentId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDeployment")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDeploymentInput, UpdateDeploymentOutputResponse, UpdateDeploymentOutputError>(id: "updateDeployment")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDeploymentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDeploymentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateDeploymentInput, UpdateDeploymentOutputResponse, UpdateDeploymentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDeploymentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func updateDocumentationPart(input: UpdateDocumentationPartInput, completion: @escaping (ClientRuntime.SdkResult<UpdateDocumentationPartOutputResponse, UpdateDocumentationPartOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let documentationPartId = input.documentationPartId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component documentationPartId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/parts/\(documentationPartId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDocumentationPart")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDocumentationPartInput, UpdateDocumentationPartOutputResponse, UpdateDocumentationPartOutputError>(id: "updateDocumentationPart")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentationPartInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentationPartInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateDocumentationPartInput, UpdateDocumentationPartOutputResponse, UpdateDocumentationPartOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentationPartInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    public func updateDocumentationVersion(input: UpdateDocumentationVersionInput, completion: @escaping (ClientRuntime.SdkResult<UpdateDocumentationVersionOutputResponse, UpdateDocumentationVersionOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let documentationVersion = input.documentationVersion else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component documentationVersion unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/documentation/versions/\(documentationVersion)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDocumentationVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDocumentationVersionInput, UpdateDocumentationVersionOutputResponse, UpdateDocumentationVersionOutputError>(id: "updateDocumentationVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentationVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentationVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateDocumentationVersionInput, UpdateDocumentationVersionOutputResponse, UpdateDocumentationVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDocumentationVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about the DomainName resource.
    public func updateDomainName(input: UpdateDomainNameInput, completion: @escaping (ClientRuntime.SdkResult<UpdateDomainNameOutputResponse, UpdateDomainNameOutputError>) -> Void)
    {
        guard let domainName = input.domainName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component domainName unexpectedly nil"))))
            return
        }
        let urlPath = "/domainnames/\(domainName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDomainName")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDomainNameInput, UpdateDomainNameOutputResponse, UpdateDomainNameOutputError>(id: "updateDomainName")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDomainNameInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDomainNameInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateDomainNameInput, UpdateDomainNameOutputResponse, UpdateDomainNameOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDomainNameInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a GatewayResponse of a specified response type on the given RestApi.
    public func updateGatewayResponse(input: UpdateGatewayResponseInput, completion: @escaping (ClientRuntime.SdkResult<UpdateGatewayResponseOutputResponse, UpdateGatewayResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let responseType = input.responseType else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component responseType unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/gatewayresponses/\(responseType.rawValue)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateGatewayResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateGatewayResponseInput, UpdateGatewayResponseOutputResponse, UpdateGatewayResponseOutputError>(id: "updateGatewayResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateGatewayResponseInput, UpdateGatewayResponseOutputResponse, UpdateGatewayResponseOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayResponseInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Represents an update integration.
    public func updateIntegration(input: UpdateIntegrationInput, completion: @escaping (ClientRuntime.SdkResult<UpdateIntegrationOutputResponse, UpdateIntegrationOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/integration"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateIntegration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateIntegrationInput, UpdateIntegrationOutputResponse, UpdateIntegrationOutputError>(id: "updateIntegration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateIntegrationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateIntegrationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateIntegrationInput, UpdateIntegrationOutputResponse, UpdateIntegrationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateIntegrationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Represents an update integration response.
    public func updateIntegrationResponse(input: UpdateIntegrationResponseInput, completion: @escaping (ClientRuntime.SdkResult<UpdateIntegrationResponseOutputResponse, UpdateIntegrationResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        guard let statusCode = input.statusCode else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component statusCode unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/integration/responses/\(statusCode)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateIntegrationResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateIntegrationResponseInput, UpdateIntegrationResponseOutputResponse, UpdateIntegrationResponseOutputError>(id: "updateIntegrationResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateIntegrationResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateIntegrationResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateIntegrationResponseInput, UpdateIntegrationResponseOutputResponse, UpdateIntegrationResponseOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateIntegrationResponseInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing Method resource.
    public func updateMethod(input: UpdateMethodInput, completion: @escaping (ClientRuntime.SdkResult<UpdateMethodOutputResponse, UpdateMethodOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateMethod")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateMethodInput, UpdateMethodOutputResponse, UpdateMethodOutputError>(id: "updateMethod")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateMethodInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateMethodInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateMethodInput, UpdateMethodOutputResponse, UpdateMethodOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateMethodInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing MethodResponse resource.
    public func updateMethodResponse(input: UpdateMethodResponseInput, completion: @escaping (ClientRuntime.SdkResult<UpdateMethodResponseOutputResponse, UpdateMethodResponseOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        guard let httpMethod = input.httpMethod else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component httpMethod unexpectedly nil"))))
            return
        }
        guard let statusCode = input.statusCode else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component statusCode unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)/methods/\(httpMethod)/responses/\(statusCode)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateMethodResponse")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateMethodResponseInput, UpdateMethodResponseOutputResponse, UpdateMethodResponseOutputError>(id: "updateMethodResponse")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateMethodResponseInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateMethodResponseInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateMethodResponseInput, UpdateMethodResponseOutputResponse, UpdateMethodResponseOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateMethodResponseInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about a model.
    public func updateModel(input: UpdateModelInput, completion: @escaping (ClientRuntime.SdkResult<UpdateModelOutputResponse, UpdateModelOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let modelName = input.modelName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component modelName unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/models/\(modelName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateModel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateModelInput, UpdateModelOutputResponse, UpdateModelOutputError>(id: "updateModel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateModelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateModelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateModelInput, UpdateModelOutputResponse, UpdateModelOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateModelInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a RequestValidator of a given RestApi.
    public func updateRequestValidator(input: UpdateRequestValidatorInput, completion: @escaping (ClientRuntime.SdkResult<UpdateRequestValidatorOutputResponse, UpdateRequestValidatorOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let requestValidatorId = input.requestValidatorId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component requestValidatorId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/requestvalidators/\(requestValidatorId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRequestValidator")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRequestValidatorInput, UpdateRequestValidatorOutputResponse, UpdateRequestValidatorOutputError>(id: "updateRequestValidator")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRequestValidatorInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRequestValidatorInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateRequestValidatorInput, UpdateRequestValidatorOutputResponse, UpdateRequestValidatorOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRequestValidatorInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about a Resource resource.
    public func updateResource(input: UpdateResourceInput, completion: @escaping (ClientRuntime.SdkResult<UpdateResourceOutputResponse, UpdateResourceOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let resourceId = input.resourceId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component resourceId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/resources/\(resourceId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateResourceInput, UpdateResourceOutputResponse, UpdateResourceOutputError>(id: "updateResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateResourceInput, UpdateResourceOutputResponse, UpdateResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about the specified API.
    public func updateRestApi(input: UpdateRestApiInput, completion: @escaping (ClientRuntime.SdkResult<UpdateRestApiOutputResponse, UpdateRestApiOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRestApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRestApiInput, UpdateRestApiOutputResponse, UpdateRestApiOutputError>(id: "updateRestApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRestApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRestApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateRestApiInput, UpdateRestApiOutputResponse, UpdateRestApiOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRestApiInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Changes information about a Stage resource.
    public func updateStage(input: UpdateStageInput, completion: @escaping (ClientRuntime.SdkResult<UpdateStageOutputResponse, UpdateStageOutputError>) -> Void)
    {
        guard let restApiId = input.restApiId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component restApiId unexpectedly nil"))))
            return
        }
        guard let stageName = input.stageName else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component stageName unexpectedly nil"))))
            return
        }
        let urlPath = "/restapis/\(restApiId)/stages/\(stageName)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateStage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateStageInput, UpdateStageOutputResponse, UpdateStageOutputError>(id: "updateStage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateStageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateStageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateStageInput, UpdateStageOutputResponse, UpdateStageOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateStageInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Grants a temporary extension to the remaining quota of a usage plan associated with a specified API key.
    public func updateUsage(input: UpdateUsageInput, completion: @escaping (ClientRuntime.SdkResult<UpdateUsageOutputResponse, UpdateUsageOutputError>) -> Void)
    {
        guard let usagePlanId = input.usagePlanId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component usagePlanId unexpectedly nil"))))
            return
        }
        guard let keyId = input.keyId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component keyId unexpectedly nil"))))
            return
        }
        let urlPath = "/usageplans/\(usagePlanId)/keys/\(keyId)/usage"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUsage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUsageInput, UpdateUsageOutputResponse, UpdateUsageOutputError>(id: "updateUsage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUsageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUsageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateUsageInput, UpdateUsageOutputResponse, UpdateUsageOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUsageInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates a usage plan of a given plan Id.
    public func updateUsagePlan(input: UpdateUsagePlanInput, completion: @escaping (ClientRuntime.SdkResult<UpdateUsagePlanOutputResponse, UpdateUsagePlanOutputError>) -> Void)
    {
        guard let usagePlanId = input.usagePlanId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component usagePlanId unexpectedly nil"))))
            return
        }
        let urlPath = "/usageplans/\(usagePlanId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateUsagePlan")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateUsagePlanInput, UpdateUsagePlanOutputResponse, UpdateUsagePlanOutputError>(id: "updateUsagePlan")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateUsagePlanInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateUsagePlanInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateUsagePlanInput, UpdateUsagePlanOutputResponse, UpdateUsagePlanOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateUsagePlanInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// Updates an existing VpcLink of a specified identifier.
    public func updateVpcLink(input: UpdateVpcLinkInput, completion: @escaping (ClientRuntime.SdkResult<UpdateVpcLinkOutputResponse, UpdateVpcLinkOutputError>) -> Void)
    {
        guard let vpcLinkId = input.vpcLinkId else {
            completion(.failure(.client(ClientRuntime.ClientError.serializationFailed("uri component vpcLinkId unexpectedly nil"))))
            return
        }
        let urlPath = "/vpclinks/\(vpcLinkId)"
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .patch)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVpcLink")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "apigateway")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVpcLinkInput, UpdateVpcLinkOutputResponse, UpdateVpcLinkOutputError>(id: "updateVpcLink")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateVpcLinkInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVpcLinkInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<UpdateVpcLinkInput, UpdateVpcLinkOutputResponse, UpdateVpcLinkOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVpcLinkInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: ClientRuntime.LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: AWSClientRuntime.RetryerMiddleware(retryer: config.retryer))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: AWSClientRuntime.SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromEnv(apiMetadata: AWSClientRuntime.APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.buildStep.intercept(position: .after, middleware: ClientRuntime.MutateHeadersMiddleware(additional: ["Accept": "application/json"]))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
