// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension FSxClientTypes.ActiveDirectoryBackupAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryId = "ActiveDirectoryId"
        case domainName = "DomainName"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryId = activeDirectoryId {
            try encodeContainer.encode(activeDirectoryId, forKey: .activeDirectoryId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeDirectoryId)
        activeDirectoryId = activeDirectoryIdDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension FSxClientTypes.ActiveDirectoryBackupAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveDirectoryBackupAttributes(activeDirectoryId: \(Swift.String(describing: activeDirectoryId)), domainName: \(Swift.String(describing: domainName)), resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension FSxClientTypes {
    /// <p>The Microsoft AD attributes of the Amazon FSx for Windows File Server file system.</p>
    public struct ActiveDirectoryBackupAttributes: Swift.Equatable {
        /// <p>The ID of the AWS Managed Microsoft Active Directory instance to which the file system is joined.</p>
        public let activeDirectoryId: Swift.String?
        /// <p>The fully qualified domain name of the self-managed AD directory.</p>
        public let domainName: Swift.String?
        /// <p>The Amazon Resource Name (ARN) for a given resource. ARNs uniquely identify AWS
        ///             resources. We require an ARN when you need to specify a resource unambiguously across
        ///             all of AWS. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)
        ///                 and AWS Service Namespaces</a> in the <i>AWS General
        ///             Reference</i>.</p>
        public let resourceARN: Swift.String?

        public init (
            activeDirectoryId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            resourceARN: Swift.String? = nil
        )
        {
            self.activeDirectoryId = activeDirectoryId
            self.domainName = domainName
            self.resourceARN = resourceARN
        }
    }

}

extension ActiveDirectoryError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveDirectoryError(activeDirectoryId: \(Swift.String(describing: activeDirectoryId)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension ActiveDirectoryError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActiveDirectoryErrorBody = try responseDecoder.decode(responseBody: data)
            self.activeDirectoryId = output.activeDirectoryId
            self.message = output.message
            self.type = output.type
        } else {
            self.activeDirectoryId = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An Active Directory error.</p>
public struct ActiveDirectoryError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The directory ID of the directory that an error pertains to.</p>
    public var activeDirectoryId: Swift.String?
    /// <p>A detailed error message.</p>
    public var message: Swift.String?
    /// <p>The type of Active Directory error.</p>
    public var type: FSxClientTypes.ActiveDirectoryErrorType?

    public init (
        activeDirectoryId: Swift.String? = nil,
        message: Swift.String? = nil,
        type: FSxClientTypes.ActiveDirectoryErrorType? = nil
    )
    {
        self.activeDirectoryId = activeDirectoryId
        self.message = message
        self.type = type
    }
}

struct ActiveDirectoryErrorBody: Swift.Equatable {
    public let activeDirectoryId: Swift.String?
    public let type: FSxClientTypes.ActiveDirectoryErrorType?
    public let message: Swift.String?
}

extension ActiveDirectoryErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryId = "ActiveDirectoryId"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeDirectoryId)
        activeDirectoryId = activeDirectoryIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.ActiveDirectoryErrorType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes {
    /// <p>The type of error relating to Microsoft Active Directory. NOT_FOUND means that no
    ///             directory was found by specifying the given directory. INCOMPATIBLE_MODE means that the
    ///             directory specified is not a Microsoft AD directory. WRONG_VPC means that the specified
    ///             directory isn't accessible from the specified VPC. WRONG_STAGE means that the
    ///             specified directory isn't currently in the ACTIVE state.</p>
    public enum ActiveDirectoryErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainNotFound
        case incompatibleDomainMode
        case invalidDomainStage
        case wrongVpc
        case sdkUnknown(Swift.String)

        public static var allCases: [ActiveDirectoryErrorType] {
            return [
                .domainNotFound,
                .incompatibleDomainMode,
                .invalidDomainStage,
                .wrongVpc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainNotFound: return "DOMAIN_NOT_FOUND"
            case .incompatibleDomainMode: return "INCOMPATIBLE_DOMAIN_MODE"
            case .invalidDomainStage: return "INVALID_DOMAIN_STAGE"
            case .wrongVpc: return "WRONG_VPC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActiveDirectoryErrorType(rawValue: rawValue) ?? ActiveDirectoryErrorType.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.AdministrativeAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administrativeActionType = "AdministrativeActionType"
        case failureDetails = "FailureDetails"
        case progressPercent = "ProgressPercent"
        case requestTime = "RequestTime"
        case status = "Status"
        case targetFileSystemValues = "TargetFileSystemValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administrativeActionType = administrativeActionType {
            try encodeContainer.encode(administrativeActionType.rawValue, forKey: .administrativeActionType)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let progressPercent = progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let requestTime = requestTime {
            try encodeContainer.encode(requestTime.timeIntervalSince1970, forKey: .requestTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetFileSystemValues = targetFileSystemValues {
            try encodeContainer.encode(targetFileSystemValues, forKey: .targetFileSystemValues)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administrativeActionTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.AdministrativeActionType.self, forKey: .administrativeActionType)
        administrativeActionType = administrativeActionTypeDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let requestTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .requestTime)
        requestTime = requestTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FSxClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let targetFileSystemValuesDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystem.self, forKey: .targetFileSystemValues)
        targetFileSystemValues = targetFileSystemValuesDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(FSxClientTypes.AdministrativeActionFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
    }
}

extension FSxClientTypes.AdministrativeAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdministrativeAction(administrativeActionType: \(Swift.String(describing: administrativeActionType)), failureDetails: \(Swift.String(describing: failureDetails)), progressPercent: \(Swift.String(describing: progressPercent)), requestTime: \(Swift.String(describing: requestTime)), status: \(Swift.String(describing: status)), targetFileSystemValues: \(Swift.String(describing: targetFileSystemValues)))"}
}

extension FSxClientTypes {
    /// <p>Describes a specific Amazon FSx administrative action for the current Windows or
    ///             Lustre file system.</p>
    public struct AdministrativeAction: Swift.Equatable {
        /// <p>Describes the type of administrative action, as follows:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                   <code>FILE_SYSTEM_UPDATE</code> - A file system update administrative action initiated by the user from the
        ///                     Amazon FSx console, API (UpdateFileSystem), or CLI (update-file-system).</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>STORAGE_OPTIMIZATION</code> - Once the <code>FILE_SYSTEM_UPDATE</code>
        ///                     task to increase a file system's storage capacity completes successfully, a
        ///                     <code>STORAGE_OPTIMIZATION</code> task starts.
        ///                     </p>
        ///                 <ul>
        ///                   <li>
        ///                      <p>For Windows, storage optimization is the process of migrating the file system data
        ///                         to the new, larger disks.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>For Lustre, storage optimization consists of rebalancing the data across the existing and
        ///                             newly added file servers.</p>
        ///                   </li>
        ///                </ul>
        ///                 <p>You can track the storage optimization progress using the
        ///                         <code>ProgressPercent</code> property. When
        ///                         <code>STORAGE_OPTIMIZATION</code> completes successfully, the parent
        ///                         <code>FILE_SYSTEM_UPDATE</code> action status changes to
        ///                         <code>COMPLETED</code>. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
        ///                         storage capacity</a> in the <i>Amazon FSx for Windows File Server
        ///                         User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
        ///                         and throughput capacity</a> in the <i>Amazon FSx for Lustre User
        ///                         Guide</i>. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>FILE_SYSTEM_ALIAS_ASSOCIATION</code> - A file system update to associate a new DNS alias with the file system.
        ///                 For more information, see
        ///                 .</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>FILE_SYSTEM_ALIAS_DISASSOCIATION</code> - A file system update to disassociate a DNS alias from the file system.
        ///                 For more information, see .</p>
        ///             </li>
        ///          </ul>
        public let administrativeActionType: FSxClientTypes.AdministrativeActionType?
        /// <p>Provides information about a failed administrative action.</p>
        public let failureDetails: FSxClientTypes.AdministrativeActionFailureDetails?
        /// <p>Provides the percent complete of a <code>STORAGE_OPTIMIZATION</code> administrative action.
        ///             Does not apply to any other administrative action type.</p>
        public let progressPercent: Swift.Int?
        /// <p>Time that the administrative action request was received.</p>
        public let requestTime: ClientRuntime.Date?
        /// <p>Describes the status of the administrative action, as follows:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>FAILED</code> - Amazon FSx failed to process the administrative action successfully.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>IN_PROGRESS</code> - Amazon FSx is processing the administrative action.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>PENDING</code> - Amazon FSx is waiting to process the administrative action.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>COMPLETED</code> - Amazon FSx has finished processing the administrative task.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>UPDATED_OPTIMIZING</code> - For a storage capacity increase update, Amazon FSx has
        ///                     updated the file system with the new storage capacity, and is now performing the
        ///                     storage optimization process. For more information, see
        ///                         <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
        ///                         storage capacity</a> in the <i>Amazon FSx for Windows File Server
        ///                         User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
        ///                         and throughput capacity</a> in the <i>Amazon FSx for Lustre User
        ///                         Guide</i>.</p>
        ///             </li>
        ///          </ul>
        public let status: FSxClientTypes.Status?
        /// <p>Describes the target value for the administration action,
        ///             provided in the <code>UpdateFileSystem</code> operation.
        ///            Returned for <code>FILE_SYSTEM_UPDATE</code> administrative actions.
        ///          </p>
        public let targetFileSystemValues: FSxClientTypes.FileSystem?

        public init (
            administrativeActionType: FSxClientTypes.AdministrativeActionType? = nil,
            failureDetails: FSxClientTypes.AdministrativeActionFailureDetails? = nil,
            progressPercent: Swift.Int? = nil,
            requestTime: ClientRuntime.Date? = nil,
            status: FSxClientTypes.Status? = nil,
            targetFileSystemValues: FSxClientTypes.FileSystem? = nil
        )
        {
            self.administrativeActionType = administrativeActionType
            self.failureDetails = failureDetails
            self.progressPercent = progressPercent
            self.requestTime = requestTime
            self.status = status
            self.targetFileSystemValues = targetFileSystemValues
        }
    }

}

extension FSxClientTypes.AdministrativeActionFailureDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes.AdministrativeActionFailureDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdministrativeActionFailureDetails(message: \(Swift.String(describing: message)))"}
}

extension FSxClientTypes {
    /// <p>Provides information about a failed administrative action.</p>
    public struct AdministrativeActionFailureDetails: Swift.Equatable {
        /// <p>Error message providing details about the failed administrative action.</p>
        public let message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension FSxClientTypes {
    /// <p>Describes the type of administrative action, as follows:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>FILE_SYSTEM_UPDATE</code> - A file system update administrative action initiated by the user from the
    ///                     Amazon FSx console, API (UpdateFileSystem), or CLI (update-file-system).</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>STORAGE_OPTIMIZATION</code> - Once the <code>FILE_SYSTEM_UPDATE</code>
    ///                     task to increase a file system's storage capacity completes successfully, a
    ///                     <code>STORAGE_OPTIMIZATION</code> task starts.
    ///                     </p>
    ///                 <ul>
    ///                   <li>
    ///                      <p>For Windows, storage optimization is the process of migrating the file system data
    ///                         to the new, larger disks.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>For Lustre, storage optimization consists of rebalancing the data across the existing and
    ///                             newly added file servers.</p>
    ///                   </li>
    ///                </ul>
    ///                 <p>You can track the storage optimization progress using the
    ///                         <code>ProgressPercent</code> property. When
    ///                         <code>STORAGE_OPTIMIZATION</code> completes successfully, the parent
    ///                         <code>FILE_SYSTEM_UPDATE</code> action status changes to
    ///                         <code>COMPLETED</code>. For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing
    ///                         storage capacity</a> in the <i>Amazon FSx for Windows File Server
    ///                         User Guide</i> and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage
    ///                         and throughput capacity</a> in the <i>Amazon FSx for Lustre User
    ///                         Guide</i>. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FILE_SYSTEM_ALIAS_ASSOCIATION</code> - A file system update to associate a new DNS alias with the file system.
    ///                 For more information, see
    ///                 .</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FILE_SYSTEM_ALIAS_DISASSOCIATION</code> - A file system update to disassociate a DNS alias from the file system.
    ///                 For more information, see .</p>
    ///             </li>
    ///          </ul>
    public enum AdministrativeActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fileSystemAliasAssociation
        case fileSystemAliasDisassociation
        case fileSystemUpdate
        case storageOptimization
        case sdkUnknown(Swift.String)

        public static var allCases: [AdministrativeActionType] {
            return [
                .fileSystemAliasAssociation,
                .fileSystemAliasDisassociation,
                .fileSystemUpdate,
                .storageOptimization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fileSystemAliasAssociation: return "FILE_SYSTEM_ALIAS_ASSOCIATION"
            case .fileSystemAliasDisassociation: return "FILE_SYSTEM_ALIAS_DISASSOCIATION"
            case .fileSystemUpdate: return "FILE_SYSTEM_UPDATE"
            case .storageOptimization: return "STORAGE_OPTIMIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdministrativeActionType(rawValue: rawValue) ?? AdministrativeActionType.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.Alias: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(FSxClientTypes.AliasLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension FSxClientTypes.Alias: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Alias(lifecycle: \(Swift.String(describing: lifecycle)), name: \(Swift.String(describing: name)))"}
}

extension FSxClientTypes {
    /// <p>A DNS alias that is associated with the file system. You can use a DNS alias to access a file system using
    ///             user-defined DNS names, in addition to the default DNS name
    ///             that Amazon FSx assigns to the file system. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">DNS aliases</a>
    ///             in the <i>FSx for Windows File Server User Guide</i>.</p>
    public struct Alias: Swift.Equatable {
        /// <p>Describes the state of the DNS alias.</p>
        ///         <ul>
        ///             <li>
        ///                <p>AVAILABLE - The DNS alias is associated with an Amazon FSx file system.</p>
        ///             </li>
        ///             <li>
        ///                <p>CREATING - Amazon FSx is creating the DNS alias and associating it with the file system.</p>
        ///             </li>
        ///             <li>
        ///                <p>CREATE_FAILED - Amazon FSx was unable to associate the DNS alias with the file system.</p>
        ///             </li>
        ///             <li>
        ///                <p>DELETING - Amazon FSx is disassociating the DNS alias from the file system and deleting it.</p>
        ///             </li>
        ///             <li>
        ///                <p>DELETE_FAILED - Amazon FSx was unable to disassocate the DNS alias from the file system.</p>
        ///             </li>
        ///          </ul>
        public let lifecycle: FSxClientTypes.AliasLifecycle?
        /// <p>The name of the DNS alias. The alias name has to meet the following requirements:</p>
        ///         <ul>
        ///             <li>
        ///                <p>Formatted as a fully-qualified domain name (FQDN), <code>hostname.domain</code>, for example, <code>accounting.example.com</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>Can contain alphanumeric characters, the underscore (_), and the hyphen (-).</p>
        ///             </li>
        ///             <li>
        ///                <p>Cannot start or end with a hyphen.</p>
        ///             </li>
        ///             <li>
        ///                <p>Can start with a numeric.</p>
        ///             </li>
        ///          </ul>
        ///         <p>For DNS names, Amazon FSx stores alphabetic characters as lowercase letters (a-z), regardless of how you specify them:
        ///             as uppercase letters, lowercase letters, or the corresponding letters in escape codes.</p>
        public let name: Swift.String?

        public init (
            lifecycle: FSxClientTypes.AliasLifecycle? = nil,
            name: Swift.String? = nil
        )
        {
            self.lifecycle = lifecycle
            self.name = name
        }
    }

}

extension FSxClientTypes {
    public enum AliasLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [AliasLifecycle] {
            return [
                .available,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AliasLifecycle(rawValue: rawValue) ?? AliasLifecycle.sdkUnknown(rawValue)
        }
    }
}

public struct AssociateFileSystemAliasesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFileSystemAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateFileSystemAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFileSystemAliasesOutputError>
}

extension AssociateFileSystemAliasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFileSystemAliasesInput(aliases: \(Swift.String(describing: aliases)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), fileSystemId: \(Swift.String(describing: fileSystemId)))"}
}

extension AssociateFileSystemAliasesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for alternatednsnames0 in aliases {
                try aliasesContainer.encode(alternatednsnames0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
    }
}

public struct AssociateFileSystemAliasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFileSystemAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateFileSystemAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFileSystemAliasesOutputError>
}

public struct AssociateFileSystemAliasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateFileSystemAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateFileSystemAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateFileSystemAliasesOutputError>
}

/// <p>The request object specifying one or more DNS alias names to associate with an Amazon FSx for Windows File Server file system.</p>
public struct AssociateFileSystemAliasesInput: Swift.Equatable {
    /// <p>An array of one or more DNS alias names to associate with the file system.
    ///             The alias name has to comply with the following formatting requirements:</p>
    ///             <ul>
    ///             <li>
    ///                <p>Formatted as a fully-qualified domain name (FQDN), <i>
    ///                      <code>hostname.domain</code>
    ///                   </i>,
    ///                     for example, <code>accounting.corp.example.com</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can contain alphanumeric characters and the hyphen (-).</p>
    ///             </li>
    ///             <li>
    ///                <p>Cannot start or end with a hyphen.</p>
    ///             </li>
    ///             <li>
    ///                <p>Can start with a numeric.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For DNS alias names, Amazon FSx stores alphabetic characters as lowercase letters (a-z), regardless of how you specify them:
    ///             as uppercase letters, lowercase letters, or the corresponding letters in escape codes.</p>
    public let aliases: [Swift.String]?
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>Specifies the file system with which you want to associate one or more DNS aliases.</p>
    public let fileSystemId: Swift.String?

    public init (
        aliases: [Swift.String]? = nil,
        clientRequestToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
    }
}

struct AssociateFileSystemAliasesInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let fileSystemId: Swift.String?
    public let aliases: [Swift.String]?
}

extension AssociateFileSystemAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aliases)
        var aliasesDecoded0:[Swift.String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Swift.String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension AssociateFileSystemAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFileSystemAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFileSystemAliasesOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFileSystemAliasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFileSystemAliasesOutputResponse(aliases: \(Swift.String(describing: aliases)))"}
}

extension AssociateFileSystemAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateFileSystemAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliases = output.aliases
        } else {
            self.aliases = nil
        }
    }
}

/// <p>The system generated response showing the DNS aliases that
///             Amazon FSx is attempting to associate with the file system.
///             Use the  API
///             operation to monitor the status of the aliases Amazon FSx is
///             associating with the file system. It can take up to 2.5 minutes for
///         the alias status to change from <code>CREATING</code> to <code>AVAILABLE</code>. </p>
public struct AssociateFileSystemAliasesOutputResponse: Swift.Equatable {
    /// <p>An array of the DNS aliases that Amazon FSx is associating with the file system.</p>
    public let aliases: [FSxClientTypes.Alias]?

    public init (
        aliases: [FSxClientTypes.Alias]? = nil
    )
    {
        self.aliases = aliases
    }
}

struct AssociateFileSystemAliasesOutputResponseBody: Swift.Equatable {
    public let aliases: [FSxClientTypes.Alias]?
}

extension AssociateFileSystemAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([FSxClientTypes.Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[FSxClientTypes.Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [FSxClientTypes.Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension FSxClientTypes {
    public enum AutoImportPolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case new
        case newChanged
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoImportPolicyType] {
            return [
                .new,
                .newChanged,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .new: return "NEW"
            case .newChanged: return "NEW_CHANGED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoImportPolicyType(rawValue: rawValue) ?? AutoImportPolicyType.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.Backup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case creationTime = "CreationTime"
        case directoryInformation = "DirectoryInformation"
        case failureDetails = "FailureDetails"
        case fileSystem = "FileSystem"
        case kmsKeyId = "KmsKeyId"
        case lifecycle = "Lifecycle"
        case ownerId = "OwnerId"
        case progressPercent = "ProgressPercent"
        case resourceARN = "ResourceARN"
        case sourceBackupId = "SourceBackupId"
        case sourceBackupRegion = "SourceBackupRegion"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let directoryInformation = directoryInformation {
            try encodeContainer.encode(directoryInformation, forKey: .directoryInformation)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let fileSystem = fileSystem {
            try encodeContainer.encode(fileSystem, forKey: .fileSystem)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let progressPercent = progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let sourceBackupId = sourceBackupId {
            try encodeContainer.encode(sourceBackupId, forKey: .sourceBackupId)
        }
        if let sourceBackupRegion = sourceBackupRegion {
            try encodeContainer.encode(sourceBackupRegion, forKey: .sourceBackupRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(FSxClientTypes.BackupLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(FSxClientTypes.BackupFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.BackupType.self, forKey: .type)
        type = typeDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileSystemDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystem.self, forKey: .fileSystem)
        fileSystem = fileSystemDecoded
        let directoryInformationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.ActiveDirectoryBackupAttributes.self, forKey: .directoryInformation)
        directoryInformation = directoryInformationDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let sourceBackupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupId)
        sourceBackupId = sourceBackupIdDecoded
        let sourceBackupRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupRegion)
        sourceBackupRegion = sourceBackupRegionDecoded
    }
}

extension FSxClientTypes.Backup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Backup(backupId: \(Swift.String(describing: backupId)), creationTime: \(Swift.String(describing: creationTime)), directoryInformation: \(Swift.String(describing: directoryInformation)), failureDetails: \(Swift.String(describing: failureDetails)), fileSystem: \(Swift.String(describing: fileSystem)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lifecycle: \(Swift.String(describing: lifecycle)), ownerId: \(Swift.String(describing: ownerId)), progressPercent: \(Swift.String(describing: progressPercent)), resourceARN: \(Swift.String(describing: resourceARN)), sourceBackupId: \(Swift.String(describing: sourceBackupId)), sourceBackupRegion: \(Swift.String(describing: sourceBackupRegion)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension FSxClientTypes {
    /// <p>A backup of an Amazon FSx file system.</p>
    public struct Backup: Swift.Equatable {
        /// <p>The ID of the backup.</p>
        public let backupId: Swift.String?
        /// <p>The time when a particular backup was created.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The configuration of the self-managed Microsoft Active Directory (AD) to which the Windows File Server instance is joined.</p>
        public let directoryInformation: FSxClientTypes.ActiveDirectoryBackupAttributes?
        /// <p>Details explaining any failures that occur when creating a backup.</p>
        public let failureDetails: FSxClientTypes.BackupFailureDetails?
        /// <p>Metadata of the file system associated with the backup. This metadata is persisted
        ///             even if the file system is deleted.</p>
        public let fileSystem: FSxClientTypes.FileSystem?
        /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the
        ///               backup of the Amazon FSx file system's data at rest.
        ///               </p>
        public let kmsKeyId: Swift.String?
        /// <p>The lifecycle status of the backup.</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>AVAILABLE</code> - The backup is fully available.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>PENDING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx has not started creating the backup.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>CREATING</code> - Amazon FSx is creating the backup.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>TRANSFERRING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx is transferring the backup to S3.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>COPYING</code> - Amazon FSx is copying the backup.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>DELETED</code> - Amazon FSx deleted the backup and it is no longer available.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>FAILED</code> - Amazon FSx could not complete the backup.</p>
        ///             </li>
        ///          </ul>
        public let lifecycle: FSxClientTypes.BackupLifecycle?
        /// <p>An AWS account ID. This ID is a 12-digit number that you use to construct Amazon
        ///             Resource Names (ARNs) for resources.</p>
        public let ownerId: Swift.String?
        /// <p>The current percent of progress of an asynchronous task.</p>
        public let progressPercent: Swift.Int?
        /// <p>The Amazon Resource Name (ARN) for the backup resource.</p>
        public let resourceARN: Swift.String?
        /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
        public let sourceBackupId: Swift.String?
        /// <p>The source Region of the backup. Specifies the Region from where this backup
        ///             is copied.</p>
        public let sourceBackupRegion: Swift.String?
        /// <p>Tags associated with a particular file system.</p>
        public let tags: [FSxClientTypes.Tag]?
        /// <p>The type of the file system backup.</p>
        public let type: FSxClientTypes.BackupType?

        public init (
            backupId: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            directoryInformation: FSxClientTypes.ActiveDirectoryBackupAttributes? = nil,
            failureDetails: FSxClientTypes.BackupFailureDetails? = nil,
            fileSystem: FSxClientTypes.FileSystem? = nil,
            kmsKeyId: Swift.String? = nil,
            lifecycle: FSxClientTypes.BackupLifecycle? = nil,
            ownerId: Swift.String? = nil,
            progressPercent: Swift.Int? = nil,
            resourceARN: Swift.String? = nil,
            sourceBackupId: Swift.String? = nil,
            sourceBackupRegion: Swift.String? = nil,
            tags: [FSxClientTypes.Tag]? = nil,
            type: FSxClientTypes.BackupType? = nil
        )
        {
            self.backupId = backupId
            self.creationTime = creationTime
            self.directoryInformation = directoryInformation
            self.failureDetails = failureDetails
            self.fileSystem = fileSystem
            self.kmsKeyId = kmsKeyId
            self.lifecycle = lifecycle
            self.ownerId = ownerId
            self.progressPercent = progressPercent
            self.resourceARN = resourceARN
            self.sourceBackupId = sourceBackupId
            self.sourceBackupRegion = sourceBackupRegion
            self.tags = tags
            self.type = type
        }
    }

}

extension BackupBeingCopied: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupBeingCopied(backupId: \(Swift.String(describing: backupId)), message: \(Swift.String(describing: message)))"}
}

extension BackupBeingCopied: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BackupBeingCopiedBody = try responseDecoder.decode(responseBody: data)
            self.backupId = output.backupId
            self.message = output.message
        } else {
            self.backupId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't delete a backup while it's being copied.</p>
public struct BackupBeingCopied: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    public var backupId: Swift.String?
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        backupId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.message = message
    }
}

struct BackupBeingCopiedBody: Swift.Equatable {
    public let message: Swift.String?
    public let backupId: Swift.String?
}

extension BackupBeingCopiedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension FSxClientTypes.BackupFailureDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes.BackupFailureDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupFailureDetails(message: \(Swift.String(describing: message)))"}
}

extension FSxClientTypes {
    /// <p>If backup creation fails, this structure contains the details of that
    ///             failure.</p>
    public struct BackupFailureDetails: Swift.Equatable {
        /// <p>A message describing the backup creation failure.</p>
        public let message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension BackupInProgress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupInProgress(message: \(Swift.String(describing: message)))"}
}

extension BackupInProgress: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BackupInProgressBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another backup is already under way. Wait for completion before initiating
///             additional backups of this file system.</p>
public struct BackupInProgress: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BackupInProgressBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BackupInProgressBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes {
    /// <p>The lifecycle status of the backup.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AVAILABLE</code> - The backup is fully available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx has not started creating the backup.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATING</code> - Amazon FSx is creating the new user-intiated backup</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TRANSFERRING</code> - For user-initiated backups on Lustre file systems only; Amazon FSx is backing up the file system.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COPYING</code> - Amazon FSx is copying the backup.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETED</code> - Amazon FSx deleted the backup and it is no longer available.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> - Amazon FSx could not complete the backup.</p>
    ///             </li>
    ///          </ul>
    public enum BackupLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case copying
        case creating
        case deleted
        case failed
        case pending
        case transferring
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupLifecycle] {
            return [
                .available,
                .copying,
                .creating,
                .deleted,
                .failed,
                .pending,
                .transferring,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .copying: return "COPYING"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .transferring: return "TRANSFERRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupLifecycle(rawValue: rawValue) ?? BackupLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension BackupNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupNotFound(message: \(Swift.String(describing: message)))"}
}

extension BackupNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BackupNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No Amazon FSx backups were found based upon the supplied parameters.</p>
public struct BackupNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BackupNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BackupNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BackupRestoring: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackupRestoring(fileSystemId: \(Swift.String(describing: fileSystemId)), message: \(Swift.String(describing: message)))"}
}

extension BackupRestoring: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BackupRestoringBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemId = output.fileSystemId
            self.message = output.message
        } else {
            self.fileSystemId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't delete a backup while it's being used to restore a file
///             system.</p>
public struct BackupRestoring: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The ID of a file system being restored from the backup.</p>
    public var fileSystemId: Swift.String?
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        fileSystemId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.message = message
    }
}

struct BackupRestoringBody: Swift.Equatable {
    public let message: Swift.String?
    public let fileSystemId: Swift.String?
}

extension BackupRestoringBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
    }
}

extension FSxClientTypes {
    /// <p>The type of the backup.</p>
    public enum BackupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automatic
        case awsBackup
        case userInitiated
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupType] {
            return [
                .automatic,
                .awsBackup,
                .userInitiated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .awsBackup: return "AWS_BACKUP"
            case .userInitiated: return "USER_INITIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupType(rawValue: rawValue) ?? BackupType.sdkUnknown(rawValue)
        }
    }
}

extension BadRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequest(message: \(Swift.String(describing: message)))"}
}

extension BadRequest: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A generic error indicating a failure with a client request.</p>
public struct BadRequest: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadRequestBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelDataRepositoryTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDataRepositoryTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelDataRepositoryTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDataRepositoryTaskOutputError>
}

extension CancelDataRepositoryTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelDataRepositoryTaskInput(taskId: \(Swift.String(describing: taskId)))"}
}

extension CancelDataRepositoryTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }
}

public struct CancelDataRepositoryTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDataRepositoryTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelDataRepositoryTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDataRepositoryTaskOutputError>
}

public struct CancelDataRepositoryTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelDataRepositoryTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelDataRepositoryTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelDataRepositoryTaskOutputError>
}

/// <p>Cancels a data repository task.</p>
public struct CancelDataRepositoryTaskInput: Swift.Equatable {
    /// <p>Specifies the data repository task to cancel.</p>
    public let taskId: Swift.String?

    public init (
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelDataRepositoryTaskInputBody: Swift.Equatable {
    public let taskId: Swift.String?
}

extension CancelDataRepositoryTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId = "TaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension CancelDataRepositoryTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelDataRepositoryTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataRepositoryTaskEnded" : self = .dataRepositoryTaskEnded(try DataRepositoryTaskEnded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataRepositoryTaskNotFound" : self = .dataRepositoryTaskNotFound(try DataRepositoryTaskNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelDataRepositoryTaskOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case dataRepositoryTaskEnded(DataRepositoryTaskEnded)
    case dataRepositoryTaskNotFound(DataRepositoryTaskNotFound)
    case internalServerError(InternalServerError)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelDataRepositoryTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelDataRepositoryTaskOutputResponse(lifecycle: \(Swift.String(describing: lifecycle)), taskId: \(Swift.String(describing: taskId)))"}
}

extension CancelDataRepositoryTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelDataRepositoryTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lifecycle = output.lifecycle
            self.taskId = output.taskId
        } else {
            self.lifecycle = nil
            self.taskId = nil
        }
    }
}

public struct CancelDataRepositoryTaskOutputResponse: Swift.Equatable {
    /// <p>The lifecycle status of the data repository task, as follows:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PENDING</code> - Amazon FSx has not started the task.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EXECUTING</code> - Amazon FSx is processing the task.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code> -  Amazon FSx was not able to complete the task. For example, there may be files the task failed to process.
    ///                 The <a>DataRepositoryTaskFailureDetails</a> property provides more information about task failures.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCEEDED</code> - FSx completed the task successfully.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CANCELED</code> - Amazon FSx canceled the task and it did not complete.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CANCELING</code> - FSx is in process of canceling the task.</p>
    ///             </li>
    ///          </ul>
    public let lifecycle: FSxClientTypes.DataRepositoryTaskLifecycle?
    /// <p>The ID of the task being canceled.</p>
    public let taskId: Swift.String?

    public init (
        lifecycle: FSxClientTypes.DataRepositoryTaskLifecycle? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.lifecycle = lifecycle
        self.taskId = taskId
    }
}

struct CancelDataRepositoryTaskOutputResponseBody: Swift.Equatable {
    public let lifecycle: FSxClientTypes.DataRepositoryTaskLifecycle?
    public let taskId: Swift.String?
}

extension CancelDataRepositoryTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycle = "Lifecycle"
        case taskId = "TaskId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryTaskLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension FSxClientTypes.CompletionReport: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case format = "Format"
        case path = "Path"
        case scope = "Scope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let scope = scope {
            try encodeContainer.encode(scope.rawValue, forKey: .scope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let formatDecoded = try containerValues.decodeIfPresent(FSxClientTypes.ReportFormat.self, forKey: .format)
        format = formatDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.ReportScope.self, forKey: .scope)
        scope = scopeDecoded
    }
}

extension FSxClientTypes.CompletionReport: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompletionReport(enabled: \(Swift.String(describing: enabled)), format: \(Swift.String(describing: format)), path: \(Swift.String(describing: path)), scope: \(Swift.String(describing: scope)))"}
}

extension FSxClientTypes {
    /// <p>Provides a report detailing the data repository task results of the files processed that match the criteria specified in the report <code>Scope</code> parameter.
    ///             FSx delivers the report to the file system's linked data repository in Amazon S3,
    ///             using the path specified in the report <code>Path</code> parameter.
    ///             You can specify whether or not a report gets generated for a task using the <code>Enabled</code> parameter.</p>
    public struct CompletionReport: Swift.Equatable {
        /// <p>Set <code>Enabled</code> to <code>True</code> to generate a <code>CompletionReport</code> when the task completes.
        ///             If set to <code>true</code>, then you need to provide a report <code>Scope</code>, <code>Path</code>, and <code>Format</code>.
        ///             Set <code>Enabled</code> to <code>False</code> if you do not want a <code>CompletionReport</code> generated when the task completes.</p>
        public let enabled: Swift.Bool?
        /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the format of the <code>CompletionReport</code>. <code>REPORT_CSV_20191124</code> is the only format currently supported.
        ///             When <code>Format</code> is set to <code>REPORT_CSV_20191124</code>, the <code>CompletionReport</code> is provided in CSV format, and is delivered to
        ///             <code>{path}/task-{id}/failures.csv</code>.
        ///         </p>
        public let format: FSxClientTypes.ReportFormat?
        /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the location of the report on the file system's linked S3 data repository. An absolute path that defines where the completion report will be stored in the destination location.
        ///             The <code>Path</code> you provide must be located within the file system’s ExportPath.
        ///             An example <code>Path</code> value is "s3://myBucket/myExportPath/optionalPrefix". The report provides the following information for each file in the report:
        ///             FilePath, FileStatus, and ErrorCode. To learn more about a file system's <code>ExportPath</code>, see .
        ///             </p>
        public let path: Swift.String?
        /// <p>Required if <code>Enabled</code> is set to <code>true</code>. Specifies the scope of the <code>CompletionReport</code>; <code>FAILED_FILES_ONLY</code> is the only scope currently supported.
        ///             When <code>Scope</code> is set to <code>FAILED_FILES_ONLY</code>, the <code>CompletionReport</code> only contains information about files that the data repository task failed to process.</p>
        public let scope: FSxClientTypes.ReportScope?

        public init (
            enabled: Swift.Bool? = nil,
            format: FSxClientTypes.ReportFormat? = nil,
            path: Swift.String? = nil,
            scope: FSxClientTypes.ReportScope? = nil
        )
        {
            self.enabled = enabled
            self.format = format
            self.path = path
            self.scope = scope
        }
    }

}

public struct CopyBackupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyBackupOutputError>
}

extension CopyBackupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyBackupInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), copyTags: \(Swift.String(describing: copyTags)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), sourceBackupId: \(Swift.String(describing: sourceBackupId)), sourceRegion: \(Swift.String(describing: sourceRegion)), tags: \(Swift.String(describing: tags)))"}
}

extension CopyBackupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case copyTags = "CopyTags"
        case kmsKeyId = "KmsKeyId"
        case sourceBackupId = "SourceBackupId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let copyTags = copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let sourceBackupId = sourceBackupId {
            try encodeContainer.encode(sourceBackupId, forKey: .sourceBackupId)
        }
        if let sourceRegion = sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CopyBackupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyBackupOutputError>
}

public struct CopyBackupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyBackupOutputError>
}

public struct CopyBackupInput: Swift.Equatable {
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>A boolean flag indicating whether tags from the source backup
    ///          should be copied to the backup copy. This value defaults to false.</p>
    ///          <p>If you set <code>CopyTags</code> to true and the source backup has
    ///          existing tags, you can use the <code>Tags</code> parameter to create new
    ///          tags, provided that the sum of the source backup tags and the new tags
    ///          doesn't exceed 50. Both sets of tags are merged. If there are tag
    ///          conflicts (for example, two tags with the same key but different values),
    ///          the tags created with the <code>Tags</code> parameter take precedence.</p>
    public let copyTags: Swift.Bool?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
    ///             for Amazon FSx for Windows File Server file systems and Amazon FSx for Lustre <code>PERSISTENT_1</code> file
    ///             systems at rest. In either case, if not specified, the Amazon FSx managed key
    ///             is used. The Amazon FSx for Lustre <code>SCRATCH_1</code> and <code>SCRATCH_2</code> file systems are always encrypted at rest using
    ///             Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
    ///             in the <i>AWS Key Management Service API Reference</i>.</p>
    public let kmsKeyId: Swift.String?
    /// <p>The ID of the source backup. Specifies the ID of the backup that is
    ///          being copied.</p>
    public let sourceBackupId: Swift.String?
    /// <p>The source AWS Region of the backup. Specifies the AWS Region from which
    ///          the backup is being copied. The source and destination Regions must be in
    ///          the same AWS partition. If you don't specify a Region, it defaults to
    ///          the Region where the request is sent from (in-Region copy).</p>
    public let sourceRegion: Swift.String?
    /// <p>A list of <code>Tag</code> values, with a maximum of 50 elements.</p>
    public let tags: [FSxClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        copyTags: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        sourceBackupId: Swift.String? = nil,
        sourceRegion: Swift.String? = nil,
        tags: [FSxClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.copyTags = copyTags
        self.kmsKeyId = kmsKeyId
        self.sourceBackupId = sourceBackupId
        self.sourceRegion = sourceRegion
        self.tags = tags
    }
}

struct CopyBackupInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let sourceBackupId: Swift.String?
    public let sourceRegion: Swift.String?
    public let kmsKeyId: Swift.String?
    public let copyTags: Swift.Bool?
    public let tags: [FSxClientTypes.Tag]?
}

extension CopyBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case copyTags = "CopyTags"
        case kmsKeyId = "KmsKeyId"
        case sourceBackupId = "SourceBackupId"
        case sourceRegion = "SourceRegion"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let sourceBackupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupId)
        sourceBackupId = sourceBackupIdDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CopyBackupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyBackupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BackupNotFound" : self = .backupNotFound(try BackupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleRegionForMultiAZ" : self = .incompatibleRegionForMultiAZ(try IncompatibleRegionForMultiAZ(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDestinationKmsKey" : self = .invalidDestinationKmsKey(try InvalidDestinationKmsKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRegion" : self = .invalidRegion(try InvalidRegion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSourceKmsKey" : self = .invalidSourceKmsKey(try InvalidSourceKmsKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceBackupUnavailable" : self = .sourceBackupUnavailable(try SourceBackupUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyBackupOutputError: Swift.Error, Swift.Equatable {
    case backupNotFound(BackupNotFound)
    case badRequest(BadRequest)
    case incompatibleParameterError(IncompatibleParameterError)
    case incompatibleRegionForMultiAZ(IncompatibleRegionForMultiAZ)
    case internalServerError(InternalServerError)
    case invalidDestinationKmsKey(InvalidDestinationKmsKey)
    case invalidRegion(InvalidRegion)
    case invalidSourceKmsKey(InvalidSourceKmsKey)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case sourceBackupUnavailable(SourceBackupUnavailable)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyBackupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyBackupOutputResponse(backup: \(Swift.String(describing: backup)))"}
}

extension CopyBackupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyBackupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct CopyBackupOutputResponse: Swift.Equatable {
    /// <p>A backup of an Amazon FSx file system.</p>
    public let backup: FSxClientTypes.Backup?

    public init (
        backup: FSxClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct CopyBackupOutputResponseBody: Swift.Equatable {
    public let backup: FSxClientTypes.Backup?
}

extension CopyBackupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backup = "Backup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(FSxClientTypes.Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

public struct CreateBackupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupOutputError>
}

extension CreateBackupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), fileSystemId: \(Swift.String(describing: fileSystemId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateBackupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateBackupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupOutputError>
}

public struct CreateBackupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupOutputError>
}

/// <p>The request object for the <code>CreateBackup</code> operation.</p>
public struct CreateBackupInput: Swift.Equatable {
    /// <p>(Optional) A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent creation. This string is automatically filled on your behalf when you use the
    ///             AWS Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>The ID of the file system to back up.</p>
    public let fileSystemId: Swift.String?
    /// <p>(Optional) The tags to apply to the backup at backup creation. The key value of the
    ///             <code>Name</code> tag appears in the console as the backup name. If you have set <code>CopyTagsToBackups</code> to true, and
    ///             you specify one or more tags using the <code>CreateBackup</code> action, no existing file system tags are copied from the file system to the backup.</p>
    public let tags: [FSxClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        tags: [FSxClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.tags = tags
    }
}

struct CreateBackupInputBody: Swift.Equatable {
    public let fileSystemId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let tags: [FSxClientTypes.Tag]?
}

extension CreateBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBackupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BackupInProgress" : self = .backupInProgress(try BackupInProgress(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupOutputError: Swift.Error, Swift.Equatable {
    case backupInProgress(BackupInProgress)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupOutputResponse(backup: \(Swift.String(describing: backup)))"}
}

extension CreateBackupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBackupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

/// <p>The response object for the <code>CreateBackup</code> operation.</p>
public struct CreateBackupOutputResponse: Swift.Equatable {
    /// <p>A description of the backup.</p>
    public let backup: FSxClientTypes.Backup?

    public init (
        backup: FSxClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct CreateBackupOutputResponseBody: Swift.Equatable {
    public let backup: FSxClientTypes.Backup?
}

extension CreateBackupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backup = "Backup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(FSxClientTypes.Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

public struct CreateDataRepositoryTaskInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataRepositoryTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataRepositoryTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataRepositoryTaskOutputError>
}

extension CreateDataRepositoryTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataRepositoryTaskInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), fileSystemId: \(Swift.String(describing: fileSystemId)), paths: \(Swift.String(describing: paths)), report: \(Swift.String(describing: report)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateDataRepositoryTaskInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case paths = "Paths"
        case report = "Report"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let paths = paths {
            var pathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .paths)
            for datarepositorytaskpaths0 in paths {
                try pathsContainer.encode(datarepositorytaskpaths0)
            }
        }
        if let report = report {
            try encodeContainer.encode(report, forKey: .report)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateDataRepositoryTaskInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataRepositoryTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataRepositoryTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataRepositoryTaskOutputError>
}

public struct CreateDataRepositoryTaskInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDataRepositoryTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDataRepositoryTaskInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDataRepositoryTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDataRepositoryTaskInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDataRepositoryTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDataRepositoryTaskOutputError>
}

public struct CreateDataRepositoryTaskInput: Swift.Equatable {
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>The globally unique ID of the file system, assigned by Amazon FSx.</p>
    public let fileSystemId: Swift.String?
    /// <p>(Optional) The path or paths on the Amazon FSx file system to use when the data repository task is processed.
    ///             The default path is the file system root directory. The paths you provide need to be relative to the mount point of the file system.
    ///             If the mount point is <code>/mnt/fsx</code> and <code>/mnt/fsx/path1</code> is a directory or
    ///             file on the file system you want to export, then the path to provide is <code>path1</code>.
    ///             If a path that you provide isn't valid, the task fails.</p>
    public let paths: [Swift.String]?
    /// <p>Defines whether or not Amazon FSx provides a CompletionReport once the task has completed.
    ///             A CompletionReport provides a detailed  report on the files that Amazon FSx processed that meet the criteria specified by the
    ///             <code>Scope</code> parameter. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/task-completion-report.html">Working with Task Completion Reports</a>.</p>
    public let report: FSxClientTypes.CompletionReport?
    /// <p>A list of <code>Tag</code> values, with a maximum of 50 elements.</p>
    public let tags: [FSxClientTypes.Tag]?
    /// <p>Specifies the type of data repository task to create.</p>
    public let type: FSxClientTypes.DataRepositoryTaskType?

    public init (
        clientRequestToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        paths: [Swift.String]? = nil,
        report: FSxClientTypes.CompletionReport? = nil,
        tags: [FSxClientTypes.Tag]? = nil,
        type: FSxClientTypes.DataRepositoryTaskType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.paths = paths
        self.report = report
        self.tags = tags
        self.type = type
    }
}

struct CreateDataRepositoryTaskInputBody: Swift.Equatable {
    public let type: FSxClientTypes.DataRepositoryTaskType?
    public let paths: [Swift.String]?
    public let fileSystemId: Swift.String?
    public let report: FSxClientTypes.CompletionReport?
    public let clientRequestToken: Swift.String?
    public let tags: [FSxClientTypes.Tag]?
}

extension CreateDataRepositoryTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case paths = "Paths"
        case report = "Report"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryTaskType.self, forKey: .type)
        type = typeDecoded
        let pathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .paths)
        var pathsDecoded0:[Swift.String]? = nil
        if let pathsContainer = pathsContainer {
            pathsDecoded0 = [Swift.String]()
            for string0 in pathsContainer {
                if let string0 = string0 {
                    pathsDecoded0?.append(string0)
                }
            }
        }
        paths = pathsDecoded0
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let reportDecoded = try containerValues.decodeIfPresent(FSxClientTypes.CompletionReport.self, forKey: .report)
        report = reportDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataRepositoryTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataRepositoryTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataRepositoryTaskExecuting" : self = .dataRepositoryTaskExecuting(try DataRepositoryTaskExecuting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataRepositoryTaskOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case dataRepositoryTaskExecuting(DataRepositoryTaskExecuting)
    case fileSystemNotFound(FileSystemNotFound)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataRepositoryTaskOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataRepositoryTaskOutputResponse(dataRepositoryTask: \(Swift.String(describing: dataRepositoryTask)))"}
}

extension CreateDataRepositoryTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDataRepositoryTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataRepositoryTask = output.dataRepositoryTask
        } else {
            self.dataRepositoryTask = nil
        }
    }
}

public struct CreateDataRepositoryTaskOutputResponse: Swift.Equatable {
    /// <p>The description of the data repository task that you just created.</p>
    public let dataRepositoryTask: FSxClientTypes.DataRepositoryTask?

    public init (
        dataRepositoryTask: FSxClientTypes.DataRepositoryTask? = nil
    )
    {
        self.dataRepositoryTask = dataRepositoryTask
    }
}

struct CreateDataRepositoryTaskOutputResponseBody: Swift.Equatable {
    public let dataRepositoryTask: FSxClientTypes.DataRepositoryTask?
}

extension CreateDataRepositoryTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRepositoryTask = "DataRepositoryTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRepositoryTaskDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryTask.self, forKey: .dataRepositoryTask)
        dataRepositoryTask = dataRepositoryTaskDecoded
    }
}

public struct CreateFileSystemFromBackupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFileSystemFromBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFileSystemFromBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFileSystemFromBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFileSystemFromBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFileSystemFromBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFileSystemFromBackupOutputError>
}

extension CreateFileSystemFromBackupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFileSystemFromBackupInput(backupId: \(Swift.String(describing: backupId)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lustreConfiguration: \(Swift.String(describing: lustreConfiguration)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), storageType: \(Swift.String(describing: storageType)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), windowsConfiguration: \(Swift.String(describing: windowsConfiguration)))"}
}

extension CreateFileSystemFromBackupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case clientRequestToken = "ClientRequestToken"
        case kmsKeyId = "KmsKeyId"
        case lustreConfiguration = "LustreConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }
}

public struct CreateFileSystemFromBackupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFileSystemFromBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFileSystemFromBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFileSystemFromBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFileSystemFromBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFileSystemFromBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFileSystemFromBackupOutputError>
}

public struct CreateFileSystemFromBackupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFileSystemFromBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFileSystemFromBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFileSystemFromBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFileSystemFromBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFileSystemFromBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFileSystemFromBackupOutputError>
}

/// <p>The request object for the <code>CreateFileSystemFromBackup</code>
///             operation.</p>
public struct CreateFileSystemFromBackupInput: Swift.Equatable {
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    public let backupId: Swift.String?
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent creation. This string is automatically filled on your behalf when you use the
    ///             AWS Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
    ///             for Amazon FSx for Windows File Server file systems and Amazon FSx for Lustre <code>PERSISTENT_1</code> file
    ///             systems at rest. In either case, if not specified, the Amazon FSx managed key
    ///             is used. The Amazon FSx for Lustre <code>SCRATCH_1</code> and <code>SCRATCH_2</code> file systems are always encrypted at rest using
    ///             Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
    ///             in the <i>AWS Key Management Service API Reference</i>.</p>
    public let kmsKeyId: Swift.String?
    /// <p>The Lustre configuration for the file system being created.
    ///             </p>
    public let lustreConfiguration: FSxClientTypes.CreateFileSystemLustreConfiguration?
    /// <p>A list of IDs for the security groups that apply to the specified network
    ///             interfaces created for file system access. These security groups apply to all network
    ///             interfaces. This value isn't returned in later DescribeFileSystem requests.</p>
    public let securityGroupIds: [Swift.String]?
    /// <p>Sets the storage type for the Windows file system you're creating from a backup.
    ///             Valid values are <code>SSD</code> and <code>HDD</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>Set to <code>SSD</code> to use solid state drive storage.
    ///                 Supported on all Windows deployment types.</p>
    ///             </li>
    ///             <li>
    ///                <p>Set to <code>HDD</code> to use hard disk drive storage.
    ///                 Supported on <code>SINGLE_AZ_2</code> and <code>MULTI_AZ_1</code> Windows file system deployment types.
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             Default value is <code>SSD</code>.
    ///         </p>
    ///         <note>
    ///             <p>HDD and SSD storage types have different minimum storage capacity requirements.
    ///             A restored file system's storage capacity is tied to the file system that was backed up.
    ///             You can create a file system that uses HDD storage from a backup of a file system that
    ///             used SSD storage only if the original SSD file system had a storage capacity of at least 2000 GiB.
    ///         </p>
    ///          </note>
    public let storageType: FSxClientTypes.StorageType?
    /// <p>Specifies the IDs of the subnets that the file system will be accessible from. For Windows <code>MULTI_AZ_1</code>
    ///             file system deployment types, provide exactly two subnet IDs, one for the preferred file server
    ///             and one for the standby file server. You specify one of these subnets as the preferred subnet
    ///             using the <code>WindowsConfiguration > PreferredSubnetID</code> property.</p>
    ///         <p>For Windows <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment
    ///             types and Lustre file systems, provide exactly one subnet ID.
    ///             The file server is launched in that subnet's Availability Zone.</p>
    public let subnetIds: [Swift.String]?
    /// <p>The tags to be applied to the file system at file system creation. The key value of
    ///             the <code>Name</code> tag appears in the console as the file system
    ///             name.</p>
    public let tags: [FSxClientTypes.Tag]?
    /// <p>The configuration for this Microsoft Windows file system.</p>
    public let windowsConfiguration: FSxClientTypes.CreateFileSystemWindowsConfiguration?

    public init (
        backupId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lustreConfiguration: FSxClientTypes.CreateFileSystemLustreConfiguration? = nil,
        securityGroupIds: [Swift.String]? = nil,
        storageType: FSxClientTypes.StorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [FSxClientTypes.Tag]? = nil,
        windowsConfiguration: FSxClientTypes.CreateFileSystemWindowsConfiguration? = nil
    )
    {
        self.backupId = backupId
        self.clientRequestToken = clientRequestToken
        self.kmsKeyId = kmsKeyId
        self.lustreConfiguration = lustreConfiguration
        self.securityGroupIds = securityGroupIds
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.windowsConfiguration = windowsConfiguration
    }
}

struct CreateFileSystemFromBackupInputBody: Swift.Equatable {
    public let backupId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let subnetIds: [Swift.String]?
    public let securityGroupIds: [Swift.String]?
    public let tags: [FSxClientTypes.Tag]?
    public let windowsConfiguration: FSxClientTypes.CreateFileSystemWindowsConfiguration?
    public let lustreConfiguration: FSxClientTypes.CreateFileSystemLustreConfiguration?
    public let storageType: FSxClientTypes.StorageType?
    public let kmsKeyId: Swift.String?
}

extension CreateFileSystemFromBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case clientRequestToken = "ClientRequestToken"
        case kmsKeyId = "KmsKeyId"
        case lustreConfiguration = "LustreConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.CreateFileSystemWindowsConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.CreateFileSystemLustreConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateFileSystemFromBackupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFileSystemFromBackupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActiveDirectoryError" : self = .activeDirectoryError(try ActiveDirectoryError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupNotFound" : self = .backupNotFound(try BackupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNetworkSettings" : self = .invalidNetworkSettings(try InvalidNetworkSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPerUnitStorageThroughput" : self = .invalidPerUnitStorageThroughput(try InvalidPerUnitStorageThroughput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingFileSystemConfiguration" : self = .missingFileSystemConfiguration(try MissingFileSystemConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFileSystemFromBackupOutputError: Swift.Error, Swift.Equatable {
    case activeDirectoryError(ActiveDirectoryError)
    case backupNotFound(BackupNotFound)
    case badRequest(BadRequest)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case invalidNetworkSettings(InvalidNetworkSettings)
    case invalidPerUnitStorageThroughput(InvalidPerUnitStorageThroughput)
    case missingFileSystemConfiguration(MissingFileSystemConfiguration)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFileSystemFromBackupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFileSystemFromBackupOutputResponse(fileSystem: \(Swift.String(describing: fileSystem)))"}
}

extension CreateFileSystemFromBackupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFileSystemFromBackupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystem = output.fileSystem
        } else {
            self.fileSystem = nil
        }
    }
}

/// <p>The response object for the <code>CreateFileSystemFromBackup</code>
///             operation.</p>
public struct CreateFileSystemFromBackupOutputResponse: Swift.Equatable {
    /// <p>A description of the file system.</p>
    public let fileSystem: FSxClientTypes.FileSystem?

    public init (
        fileSystem: FSxClientTypes.FileSystem? = nil
    )
    {
        self.fileSystem = fileSystem
    }
}

struct CreateFileSystemFromBackupOutputResponseBody: Swift.Equatable {
    public let fileSystem: FSxClientTypes.FileSystem?
}

extension CreateFileSystemFromBackupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystem = "FileSystem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystem.self, forKey: .fileSystem)
        fileSystem = fileSystemDecoded
    }
}

public struct CreateFileSystemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFileSystemOutputError>
}

extension CreateFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFileSystemInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), fileSystemType: \(Swift.String(describing: fileSystemType)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lustreConfiguration: \(Swift.String(describing: lustreConfiguration)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), storageCapacity: \(Swift.String(describing: storageCapacity)), storageType: \(Swift.String(describing: storageType)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), windowsConfiguration: \(Swift.String(describing: windowsConfiguration)))"}
}

extension CreateFileSystemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemType = "FileSystemType"
        case kmsKeyId = "KmsKeyId"
        case lustreConfiguration = "LustreConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case storageCapacity = "StorageCapacity"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemType = fileSystemType {
            try encodeContainer.encode(fileSystemType.rawValue, forKey: .fileSystemType)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let storageCapacity = storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }
}

public struct CreateFileSystemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFileSystemOutputError>
}

public struct CreateFileSystemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFileSystemOutputError>
}

/// <p>The request object used to create a new Amazon FSx file system.</p>
public struct CreateFileSystemInput: Swift.Equatable {
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent creation. This string is automatically filled on your behalf when you use the
    ///             AWS Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>The type of Amazon FSx file system to create, either <code>WINDOWS</code> or <code>LUSTRE</code>.</p>
    public let fileSystemType: FSxClientTypes.FileSystemType?
    /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
    ///             for Amazon FSx for Windows File Server file systems and Amazon FSx for Lustre <code>PERSISTENT_1</code> file
    ///             systems at rest. In either case, if not specified, the Amazon FSx managed key
    ///             is used. The Amazon FSx for Lustre <code>SCRATCH_1</code> and <code>SCRATCH_2</code> file systems are always encrypted at rest using
    ///             Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
    ///             in the <i>AWS Key Management Service API Reference</i>.</p>
    public let kmsKeyId: Swift.String?
    /// <p>The Lustre configuration for the file system being created.
    ///             </p>
    public let lustreConfiguration: FSxClientTypes.CreateFileSystemLustreConfiguration?
    /// <p>A list of IDs specifying the security groups to apply to all network interfaces
    ///             created for file system access. This list isn't returned in later requests to
    ///             describe the file system.</p>
    public let securityGroupIds: [Swift.String]?
    /// <p>Sets the storage capacity of the file system that you're creating.</p>
    ///         <p>For Lustre file systems:</p>
    ///         <ul>
    ///             <li>
    ///                <p>For <code>SCRATCH_2</code> and <code>PERSISTENT_1 SSD</code> deployment types, valid values are
    ///                 1200 GiB, 2400 GiB, and increments of 2400 GiB.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>PERSISTENT HDD</code> file systems, valid values are increments of 6000 GiB for
    ///                 12 MB/s/TiB file systems and increments of 1800 GiB for 40 MB/s/TiB file systems.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>SCRATCH_1</code> deployment type, valid values are
    ///                 1200 GiB, 2400 GiB, and increments of 3600 GiB.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For Windows file systems:</p>
    ///         <ul>
    ///             <li>
    ///                <p>If <code>StorageType=SSD</code>, valid values are 32 GiB - 65,536 GiB (64 TiB).</p>
    ///             </li>
    ///             <li>
    ///                <p>If <code>StorageType=HDD</code>, valid values are 2000 GiB - 65,536 GiB (64 TiB).</p>
    ///             </li>
    ///          </ul>
    public let storageCapacity: Swift.Int?
    /// <p>Sets the storage type for the file system you're creating.
    ///             Valid values are <code>SSD</code> and <code>HDD</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>Set to <code>SSD</code> to use solid state drive storage.
    ///                 SSD is supported on all Windows and Lustre deployment types.</p>
    ///             </li>
    ///             <li>
    ///                <p>Set to <code>HDD</code> to use hard disk drive storage.
    ///                 HDD is supported on <code>SINGLE_AZ_2</code> and <code>MULTI_AZ_1</code> Windows file system deployment types,
    ///                 and on <code>PERSISTENT</code> Lustre file system deployment types.
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             Default value is <code>SSD</code>. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/optimize-fsx-costs.html#storage-type-options">
    ///             Storage Type Options</a> in the <i>Amazon FSx for Windows User Guide</i> and
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/what-is.html#storage-options">Multiple Storage Options</a>
    ///             in the <i>Amazon FSx for Lustre User Guide</i>.
    ///         </p>
    public let storageType: FSxClientTypes.StorageType?
    /// <p>Specifies the IDs of the subnets that the file system will be accessible from. For Windows <code>MULTI_AZ_1</code>
    ///             file system deployment types, provide exactly two subnet IDs, one for the preferred file server
    ///             and one for the standby file server. You specify one of these subnets as the preferred subnet
    ///             using the <code>WindowsConfiguration > PreferredSubnetID</code> property. For more information,
    ///             see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">
    ///                 Availability and durability: Single-AZ and Multi-AZ file systems</a>.</p>
    ///         <p>For Windows <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> file system deployment types and Lustre file systems, provide exactly one subnet ID.
    ///            The file server is launched in that subnet's Availability Zone.</p>
    public let subnetIds: [Swift.String]?
    /// <p>The tags to apply to the file system being created. The key value of
    ///             the <code>Name</code> tag appears in the console as the file system name.</p>
    public let tags: [FSxClientTypes.Tag]?
    /// <p>The Microsoft Windows configuration for the file system being created.
    ///             </p>
    public let windowsConfiguration: FSxClientTypes.CreateFileSystemWindowsConfiguration?

    public init (
        clientRequestToken: Swift.String? = nil,
        fileSystemType: FSxClientTypes.FileSystemType? = nil,
        kmsKeyId: Swift.String? = nil,
        lustreConfiguration: FSxClientTypes.CreateFileSystemLustreConfiguration? = nil,
        securityGroupIds: [Swift.String]? = nil,
        storageCapacity: Swift.Int? = nil,
        storageType: FSxClientTypes.StorageType? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [FSxClientTypes.Tag]? = nil,
        windowsConfiguration: FSxClientTypes.CreateFileSystemWindowsConfiguration? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemType = fileSystemType
        self.kmsKeyId = kmsKeyId
        self.lustreConfiguration = lustreConfiguration
        self.securityGroupIds = securityGroupIds
        self.storageCapacity = storageCapacity
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.windowsConfiguration = windowsConfiguration
    }
}

struct CreateFileSystemInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let fileSystemType: FSxClientTypes.FileSystemType?
    public let storageCapacity: Swift.Int?
    public let storageType: FSxClientTypes.StorageType?
    public let subnetIds: [Swift.String]?
    public let securityGroupIds: [Swift.String]?
    public let tags: [FSxClientTypes.Tag]?
    public let kmsKeyId: Swift.String?
    public let windowsConfiguration: FSxClientTypes.CreateFileSystemWindowsConfiguration?
    public let lustreConfiguration: FSxClientTypes.CreateFileSystemLustreConfiguration?
}

extension CreateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemType = "FileSystemType"
        case kmsKeyId = "KmsKeyId"
        case lustreConfiguration = "LustreConfiguration"
        case securityGroupIds = "SecurityGroupIds"
        case storageCapacity = "StorageCapacity"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fileSystemTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystemType.self, forKey: .fileSystemType)
        fileSystemType = fileSystemTypeDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.CreateFileSystemWindowsConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.CreateFileSystemLustreConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
    }
}

extension FSxClientTypes.CreateFileSystemLustreConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoImportPolicy = "AutoImportPolicy"
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case copyTagsToBackups = "CopyTagsToBackups"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case dataCompressionType = "DataCompressionType"
        case deploymentType = "DeploymentType"
        case driveCacheType = "DriveCacheType"
        case exportPath = "ExportPath"
        case importPath = "ImportPath"
        case importedFileChunkSize = "ImportedFileChunkSize"
        case perUnitStorageThroughput = "PerUnitStorageThroughput"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoImportPolicy = autoImportPolicy {
            try encodeContainer.encode(autoImportPolicy.rawValue, forKey: .autoImportPolicy)
        }
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let copyTagsToBackups = copyTagsToBackups {
            try encodeContainer.encode(copyTagsToBackups, forKey: .copyTagsToBackups)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let dataCompressionType = dataCompressionType {
            try encodeContainer.encode(dataCompressionType.rawValue, forKey: .dataCompressionType)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let driveCacheType = driveCacheType {
            try encodeContainer.encode(driveCacheType.rawValue, forKey: .driveCacheType)
        }
        if let exportPath = exportPath {
            try encodeContainer.encode(exportPath, forKey: .exportPath)
        }
        if let importPath = importPath {
            try encodeContainer.encode(importPath, forKey: .importPath)
        }
        if let importedFileChunkSize = importedFileChunkSize {
            try encodeContainer.encode(importedFileChunkSize, forKey: .importedFileChunkSize)
        }
        if let perUnitStorageThroughput = perUnitStorageThroughput {
            try encodeContainer.encode(perUnitStorageThroughput, forKey: .perUnitStorageThroughput)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let importPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importPath)
        importPath = importPathDecoded
        let exportPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportPath)
        exportPath = exportPathDecoded
        let importedFileChunkSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .importedFileChunkSize)
        importedFileChunkSize = importedFileChunkSizeDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.LustreDeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let autoImportPolicyDecoded = try containerValues.decodeIfPresent(FSxClientTypes.AutoImportPolicyType.self, forKey: .autoImportPolicy)
        autoImportPolicy = autoImportPolicyDecoded
        let perUnitStorageThroughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .perUnitStorageThroughput)
        perUnitStorageThroughput = perUnitStorageThroughputDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let copyTagsToBackupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToBackups)
        copyTagsToBackups = copyTagsToBackupsDecoded
        let driveCacheTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DriveCacheType.self, forKey: .driveCacheType)
        driveCacheType = driveCacheTypeDecoded
        let dataCompressionTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataCompressionType.self, forKey: .dataCompressionType)
        dataCompressionType = dataCompressionTypeDecoded
    }
}

extension FSxClientTypes.CreateFileSystemLustreConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFileSystemLustreConfiguration(autoImportPolicy: \(Swift.String(describing: autoImportPolicy)), automaticBackupRetentionDays: \(Swift.String(describing: automaticBackupRetentionDays)), copyTagsToBackups: \(Swift.String(describing: copyTagsToBackups)), dailyAutomaticBackupStartTime: \(Swift.String(describing: dailyAutomaticBackupStartTime)), dataCompressionType: \(Swift.String(describing: dataCompressionType)), deploymentType: \(Swift.String(describing: deploymentType)), driveCacheType: \(Swift.String(describing: driveCacheType)), exportPath: \(Swift.String(describing: exportPath)), importPath: \(Swift.String(describing: importPath)), importedFileChunkSize: \(Swift.String(describing: importedFileChunkSize)), perUnitStorageThroughput: \(Swift.String(describing: perUnitStorageThroughput)), weeklyMaintenanceStartTime: \(Swift.String(describing: weeklyMaintenanceStartTime)))"}
}

extension FSxClientTypes {
    /// <p>The Lustre configuration for the file system being created.
    ///             </p>
    public struct CreateFileSystemLustreConfiguration: Swift.Equatable {
        /// <p> (Optional) When you create your file system, your existing S3 objects appear as file and directory listings.
        ///             Use this property to choose how Amazon FSx keeps your file and directory listings up to date
        ///             as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can
        ///             have the following values:</p>
        ///
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
        ///                 file and directory listings from the linked S3 bucket
        ///                 when the file system is created. FSx does not update file and directory
        ///                 listings for any new or changed objects after choosing this option.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
        ///                 directory listings of any new objects added to the linked S3 bucket that
        ///                 do not currently exist in the FSx file system. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
        ///                 file and directory listings of any new objects added to the S3 bucket and any
        ///                 existing objects that are changed in the S3 bucket after you choose this option.
        ///             </p>
        ///             </li>
        ///          </ul>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
        public let autoImportPolicy: FSxClientTypes.AutoImportPolicyType?
        /// <p>The number of days to retain automatic backups. Setting this to 0 disables
        ///             automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
        public let automaticBackupRetentionDays: Swift.Int?
        /// <p>(Optional) Not available to use with file systems that are linked to a data repository.
        ///             A boolean flag indicating whether tags for the file system should be copied to
        ///             backups. The default value is false. If it's set to true, all file system
        ///             tags are copied to all automatic and user-initiated backups when the user
        ///             doesn't specify any backup-specific tags. If this value is true, and you specify one or more backup tags, only
        ///             the specified tags are copied to backups. If you specify one or more tags when creating a
        ///             user-initiated backup, no tags are copied from the file system, regardless of this value.</p>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/using-backups-fsx.html">Working with backups</a>.</p>
        public let copyTagsToBackups: Swift.Bool?
        /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
        ///             zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
        ///             hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
        public let dailyAutomaticBackupStartTime: Swift.String?
        /// <p>Sets the data compression configuration for the file system. <code>DataCompressionType</code>
        ///             can have the following values:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>NONE</code> - (Default) Data compression is turned off when
        ///                 the file system is created.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>LZ4</code> - Data compression is turned on with the LZ4
        ///                 algorithm.</p>
        ///             </li>
        ///          </ul>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
        public let dataCompressionType: FSxClientTypes.DataCompressionType?
        /// <p>
        ///             Choose <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment
        ///             types when you need temporary storage and shorter-term processing of data.
        ///             The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst
        ///             throughput capacity than <code>SCRATCH_1</code>.</p>
        ///
        ///             <p>Choose <code>PERSISTENT_1</code> deployment type for longer-term storage
        ///                 and workloads and encryption of data in transit. To learn more about deployment types, see
        ///                 <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html">
        ///                     FSx for Lustre Deployment Options</a>.</p>
        ///             <p>Encryption of data in-transit is automatically
        ///             enabled when you access a <code>SCRATCH_2</code> or <code>PERSISTENT_1</code>
        ///             file system from Amazon EC2 instances that <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/data-                 protection.html">support this feature</a>.
        ///             (Default = <code>SCRATCH_1</code>)
        ///         </p>
        ///             <p>Encryption of data in-transit for <code>SCRATCH_2</code> and <code>PERSISTENT_1</code>
        ///                 deployment types is supported when accessed from supported instance types in supported AWS Regions. To learn more,
        ///                 <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/encryption-in-transit-fsxl.html">Encrypting Data in Transit</a>.</p>
        public let deploymentType: FSxClientTypes.LustreDeploymentType?
        /// <p>The type of drive cache used by PERSISTENT_1 file systems that are provisioned with
        ///             HDD storage devices. This parameter is required when storage type is HDD. Set to
        ///             <code>READ</code>, improve the performance for frequently accessed files and allows 20%
        ///             of the total storage capacity of the file system to be cached. </p>
        ///         <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
        public let driveCacheType: FSxClientTypes.DriveCacheType?
        /// <p>(Optional) The path in Amazon S3 where the root of your Amazon FSx file system is exported.
        ///             The path must use the same Amazon S3 bucket as specified in ImportPath. You can provide an optional prefix to which
        ///             new and changed data is to be exported from your Amazon FSx for Lustre file system. If
        ///             an <code>ExportPath</code> value is not provided, Amazon FSx sets a default export path,
        ///             <code>s3://import-bucket/FSxLustre[creation-timestamp]</code>. The timestamp is in
        ///             UTC format, for example
        ///             <code>s3://import-bucket/FSxLustre20181105T222312Z</code>.</p>
        ///
        ///         <p>The Amazon S3 export bucket must be the same as the import bucket specified by
        ///             <code>ImportPath</code>. If you only specify a bucket name, such as
        ///             <code>s3://import-bucket</code>, you get a 1:1 mapping of file system objects to S3
        ///             bucket objects. This mapping means that the input data in S3 is overwritten on export.
        ///             If you provide a custom prefix in the export path, such as
        ///             <code>s3://import-bucket/[custom-optional-prefix]</code>, Amazon FSx exports the contents of your file
        ///             system to that export prefix in the Amazon S3 bucket.</p>
        public let exportPath: Swift.String?
        /// <p>(Optional) The path to the Amazon S3 bucket (including the optional prefix) that
        ///             you're using as the data repository for your Amazon FSx for Lustre file system.
        ///             The root of your FSx for Lustre file system will
        ///             be mapped to the root of the Amazon S3 bucket you select. An
        ///             example is <code>s3://import-bucket/optional-prefix</code>. If you specify a prefix
        ///             after the Amazon S3 bucket name, only object keys with that prefix are loaded into the
        ///             file system.</p>
        public let importPath: Swift.String?
        /// <p>(Optional) For files imported from a data repository, this value determines the stripe
        ///             count and maximum amount of data per file (in MiB) stored on a single physical disk. The
        ///             maximum number of disks that a single file can be striped across is limited by the total
        ///             number of disks that make up the file system.</p>
        ///
        ///         <p>The default chunk size is 1,024 MiB (1 GiB) and can go as high as 512,000 MiB (500
        ///             GiB). Amazon S3 objects have a maximum size of 5 TB.</p>
        public let importedFileChunkSize: Swift.Int?
        /// <p>
        ///             Required for the <code>PERSISTENT_1</code> deployment type, describes the amount of read and write
        ///             throughput for each 1 tebibyte of storage, in MB/s/TiB.
        ///             File system throughput capacity is calculated by multiplying ﬁle system storage capacity (TiB) by the PerUnitStorageThroughput
        ///             (MB/s/TiB). For a 2.4 TiB ﬁle system, provisioning 50 MB/s/TiB of PerUnitStorageThroughput
        ///             yields 120 MB/s of ﬁle system throughput. You pay for the amount of throughput that you
        ///             provision.
        ///         </p>
        ///         <p>Valid values for  SSD storage: 50, 100, 200. Valid values for  HDD storage: 12, 40.</p>
        public let perUnitStorageThroughput: Swift.Int?
        /// <p>(Optional) The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        ///             time zone, where d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        public let weeklyMaintenanceStartTime: Swift.String?

        public init (
            autoImportPolicy: FSxClientTypes.AutoImportPolicyType? = nil,
            automaticBackupRetentionDays: Swift.Int? = nil,
            copyTagsToBackups: Swift.Bool? = nil,
            dailyAutomaticBackupStartTime: Swift.String? = nil,
            dataCompressionType: FSxClientTypes.DataCompressionType? = nil,
            deploymentType: FSxClientTypes.LustreDeploymentType? = nil,
            driveCacheType: FSxClientTypes.DriveCacheType? = nil,
            exportPath: Swift.String? = nil,
            importPath: Swift.String? = nil,
            importedFileChunkSize: Swift.Int? = nil,
            perUnitStorageThroughput: Swift.Int? = nil,
            weeklyMaintenanceStartTime: Swift.String? = nil
        )
        {
            self.autoImportPolicy = autoImportPolicy
            self.automaticBackupRetentionDays = automaticBackupRetentionDays
            self.copyTagsToBackups = copyTagsToBackups
            self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
            self.dataCompressionType = dataCompressionType
            self.deploymentType = deploymentType
            self.driveCacheType = driveCacheType
            self.exportPath = exportPath
            self.importPath = importPath
            self.importedFileChunkSize = importedFileChunkSize
            self.perUnitStorageThroughput = perUnitStorageThroughput
            self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
        }
    }

}

extension CreateFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActiveDirectoryError" : self = .activeDirectoryError(try ActiveDirectoryError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidExportPath" : self = .invalidExportPath(try InvalidExportPath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidImportPath" : self = .invalidImportPath(try InvalidImportPath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNetworkSettings" : self = .invalidNetworkSettings(try InvalidNetworkSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPerUnitStorageThroughput" : self = .invalidPerUnitStorageThroughput(try InvalidPerUnitStorageThroughput(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingFileSystemConfiguration" : self = .missingFileSystemConfiguration(try MissingFileSystemConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFileSystemOutputError: Swift.Error, Swift.Equatable {
    case activeDirectoryError(ActiveDirectoryError)
    case badRequest(BadRequest)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case invalidExportPath(InvalidExportPath)
    case invalidImportPath(InvalidImportPath)
    case invalidNetworkSettings(InvalidNetworkSettings)
    case invalidPerUnitStorageThroughput(InvalidPerUnitStorageThroughput)
    case missingFileSystemConfiguration(MissingFileSystemConfiguration)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFileSystemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFileSystemOutputResponse(fileSystem: \(Swift.String(describing: fileSystem)))"}
}

extension CreateFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystem = output.fileSystem
        } else {
            self.fileSystem = nil
        }
    }
}

/// <p>The response object returned after the file system is created.</p>
public struct CreateFileSystemOutputResponse: Swift.Equatable {
    /// <p>The configuration of the file system that was created.</p>
    public let fileSystem: FSxClientTypes.FileSystem?

    public init (
        fileSystem: FSxClientTypes.FileSystem? = nil
    )
    {
        self.fileSystem = fileSystem
    }
}

struct CreateFileSystemOutputResponseBody: Swift.Equatable {
    public let fileSystem: FSxClientTypes.FileSystem?
}

extension CreateFileSystemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystem = "FileSystem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystem.self, forKey: .fileSystem)
        fileSystem = fileSystemDecoded
    }
}

extension FSxClientTypes.CreateFileSystemWindowsConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryId = "ActiveDirectoryId"
        case aliases = "Aliases"
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case copyTagsToBackups = "CopyTagsToBackups"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case deploymentType = "DeploymentType"
        case preferredSubnetId = "PreferredSubnetId"
        case selfManagedActiveDirectoryConfiguration = "SelfManagedActiveDirectoryConfiguration"
        case throughputCapacity = "ThroughputCapacity"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryId = activeDirectoryId {
            try encodeContainer.encode(activeDirectoryId, forKey: .activeDirectoryId)
        }
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for alternatednsnames0 in aliases {
                try aliasesContainer.encode(alternatednsnames0)
            }
        }
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let copyTagsToBackups = copyTagsToBackups {
            try encodeContainer.encode(copyTagsToBackups, forKey: .copyTagsToBackups)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let preferredSubnetId = preferredSubnetId {
            try encodeContainer.encode(preferredSubnetId, forKey: .preferredSubnetId)
        }
        if let selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration {
            try encodeContainer.encode(selfManagedActiveDirectoryConfiguration, forKey: .selfManagedActiveDirectoryConfiguration)
        }
        if let throughputCapacity = throughputCapacity {
            try encodeContainer.encode(throughputCapacity, forKey: .throughputCapacity)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeDirectoryId)
        activeDirectoryId = activeDirectoryIdDecoded
        let selfManagedActiveDirectoryConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.SelfManagedActiveDirectoryConfiguration.self, forKey: .selfManagedActiveDirectoryConfiguration)
        selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfigurationDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.WindowsDeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let preferredSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredSubnetId)
        preferredSubnetId = preferredSubnetIdDecoded
        let throughputCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughputCapacity)
        throughputCapacity = throughputCapacityDecoded
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let copyTagsToBackupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToBackups)
        copyTagsToBackups = copyTagsToBackupsDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aliases)
        var aliasesDecoded0:[Swift.String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Swift.String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension FSxClientTypes.CreateFileSystemWindowsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFileSystemWindowsConfiguration(activeDirectoryId: \(Swift.String(describing: activeDirectoryId)), aliases: \(Swift.String(describing: aliases)), automaticBackupRetentionDays: \(Swift.String(describing: automaticBackupRetentionDays)), copyTagsToBackups: \(Swift.String(describing: copyTagsToBackups)), dailyAutomaticBackupStartTime: \(Swift.String(describing: dailyAutomaticBackupStartTime)), deploymentType: \(Swift.String(describing: deploymentType)), preferredSubnetId: \(Swift.String(describing: preferredSubnetId)), selfManagedActiveDirectoryConfiguration: \(Swift.String(describing: selfManagedActiveDirectoryConfiguration)), throughputCapacity: \(Swift.String(describing: throughputCapacity)), weeklyMaintenanceStartTime: \(Swift.String(describing: weeklyMaintenanceStartTime)))"}
}

extension FSxClientTypes {
    /// <p>The configuration object for the Microsoft Windows file system used in
    ///                 <code>CreateFileSystem</code> and <code>CreateFileSystemFromBackup</code>
    ///             operations.</p>
    public struct CreateFileSystemWindowsConfiguration: Swift.Equatable {
        /// <p>The ID for an existing AWS Managed Microsoft Active Directory (AD) instance that the
        ///             file system should join when it's created.</p>
        public let activeDirectoryId: Swift.String?
        /// <p>An array of one or more DNS alias names that you want to associate with the Amazon FSx file system.
        ///             Aliases allow you to use existing DNS names to access the data in your Amazon FSx file system.
        ///             You can associate up to 50 aliases with a file system at any time.
        ///             You can associate additional DNS aliases after you create the file system using the AssociateFileSystemAliases operation.
        ///             You can remove DNS aliases from the file system after it is created using the DisassociateFileSystemAliases operation.
        ///             You only need to specify the alias name in the request payload.</p>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">Working with DNS Aliases</a> and
        ///         <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/walkthrough05-file-system-custom-CNAME.html">Walkthrough 5: Using DNS aliases to access your file system</a>, including
        ///         additional steps you must take to be able to access your file system using a DNS alias.</p>
        ///          <p>An alias name has to meet the following requirements:</p>
        ///             <ul>
        ///             <li>
        ///                <p>Formatted as a fully-qualified domain name (FQDN), <code>hostname.domain</code>, for example, <code>accounting.example.com</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>Can contain alphanumeric characters, the underscore (_), and the hyphen (-).</p>
        ///             </li>
        ///             <li>
        ///                <p>Cannot start or end with a hyphen.</p>
        ///             </li>
        ///             <li>
        ///                <p>Can start with a numeric.</p>
        ///             </li>
        ///          </ul>
        ///         <p>For DNS alias names, Amazon FSx stores alphabetic characters as lowercase letters (a-z), regardless of how you specify them:
        ///             as uppercase letters, lowercase letters, or the corresponding letters in escape codes.</p>
        public let aliases: [Swift.String]?
        /// <p>The number of days to retain automatic backups. The default is to retain backups for 7
        ///             days. Setting this value to 0 disables the creation of automatic backups. The maximum
        ///             retention period for backups is 90 days.</p>
        public let automaticBackupRetentionDays: Swift.Int?
        /// <p>A boolean flag indicating whether tags for the file system should be copied to
        ///             backups. This value defaults to false. If it's set to true, all tags for the file
        ///             system are copied to all automatic and user-initiated backups where the user
        ///             doesn't specify tags. If this value is true, and you specify one or more tags, only
        ///             the specified tags are copied to backups. If you specify one or more tags when creating a
        ///             user-initiated backup, no tags are copied from the file system, regardless of this value.</p>
        public let copyTagsToBackups: Swift.Bool?
        /// <p>The preferred time to take daily automatic backups, formatted HH:MM in the UTC time
        ///             zone.</p>
        public let dailyAutomaticBackupStartTime: Swift.String?
        /// <p>Specifies the file system deployment type, valid values are the following:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                   <code>MULTI_AZ_1</code> - Deploys a high availability file system that is configured
        ///                     for Multi-AZ redundancy to tolerate temporary Availability Zone (AZ) unavailability. You
        ///                     can only deploy a Multi-AZ file system in AWS Regions that have a minimum of three Availability Zones. Also
        ///                 supports HDD storage type</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>SINGLE_AZ_1</code> - (Default) Choose to deploy a file system that is configured for single AZ redundancy.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>SINGLE_AZ_2</code> - The latest generation Single AZ file system.
        ///                     Specifies a file system that is configured for single AZ redundancy and supports HDD storage type.</p>
        ///             </li>
        ///          </ul>
        ///         <p>For more information, see
        ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">
        ///                 Availability and Durability: Single-AZ and Multi-AZ File Systems</a>.</p>
        public let deploymentType: FSxClientTypes.WindowsDeploymentType?
        /// <p>Required when <code>DeploymentType</code> is set to <code>MULTI_AZ_1</code>. This specifies the subnet
        ///             in which you want the preferred file server to be located. For in-AWS applications, we recommend that you launch
        ///             your clients in the same Availability Zone (AZ) as your preferred file server to reduce cross-AZ
        ///             data transfer costs and minimize latency. </p>
        public let preferredSubnetId: Swift.String?
        /// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to
        ///             your self-managed (including on-premises) Microsoft Active Directory (AD)
        ///             directory. For more information, see
        ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/self-managed-AD.html">
        ///                 Using Amazon FSx with your self-managed Microsoft Active Directory</a>.</p>
        public let selfManagedActiveDirectoryConfiguration: FSxClientTypes.SelfManagedActiveDirectoryConfiguration?
        /// <p>The throughput of an Amazon FSx file system, measured in megabytes per second, in 2 to
        ///             the <i>n</i>th increments, between 2^3 (8) and 2^11 (2048).</p>
        public let throughputCapacity: Swift.Int?
        /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        ///             time zone, where d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        public let weeklyMaintenanceStartTime: Swift.String?

        public init (
            activeDirectoryId: Swift.String? = nil,
            aliases: [Swift.String]? = nil,
            automaticBackupRetentionDays: Swift.Int? = nil,
            copyTagsToBackups: Swift.Bool? = nil,
            dailyAutomaticBackupStartTime: Swift.String? = nil,
            deploymentType: FSxClientTypes.WindowsDeploymentType? = nil,
            preferredSubnetId: Swift.String? = nil,
            selfManagedActiveDirectoryConfiguration: FSxClientTypes.SelfManagedActiveDirectoryConfiguration? = nil,
            throughputCapacity: Swift.Int? = nil,
            weeklyMaintenanceStartTime: Swift.String? = nil
        )
        {
            self.activeDirectoryId = activeDirectoryId
            self.aliases = aliases
            self.automaticBackupRetentionDays = automaticBackupRetentionDays
            self.copyTagsToBackups = copyTagsToBackups
            self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
            self.deploymentType = deploymentType
            self.preferredSubnetId = preferredSubnetId
            self.selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration
            self.throughputCapacity = throughputCapacity
            self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
        }
    }

}

extension FSxClientTypes {
    public enum DataCompressionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lz4
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [DataCompressionType] {
            return [
                .lz4,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lz4: return "LZ4"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataCompressionType(rawValue: rawValue) ?? DataCompressionType.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.DataRepositoryConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoImportPolicy = "AutoImportPolicy"
        case exportPath = "ExportPath"
        case failureDetails = "FailureDetails"
        case importPath = "ImportPath"
        case importedFileChunkSize = "ImportedFileChunkSize"
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoImportPolicy = autoImportPolicy {
            try encodeContainer.encode(autoImportPolicy.rawValue, forKey: .autoImportPolicy)
        }
        if let exportPath = exportPath {
            try encodeContainer.encode(exportPath, forKey: .exportPath)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let importPath = importPath {
            try encodeContainer.encode(importPath, forKey: .importPath)
        }
        if let importedFileChunkSize = importedFileChunkSize {
            try encodeContainer.encode(importedFileChunkSize, forKey: .importedFileChunkSize)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let importPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importPath)
        importPath = importPathDecoded
        let exportPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportPath)
        exportPath = exportPathDecoded
        let importedFileChunkSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .importedFileChunkSize)
        importedFileChunkSize = importedFileChunkSizeDecoded
        let autoImportPolicyDecoded = try containerValues.decodeIfPresent(FSxClientTypes.AutoImportPolicyType.self, forKey: .autoImportPolicy)
        autoImportPolicy = autoImportPolicyDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
    }
}

extension FSxClientTypes.DataRepositoryConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRepositoryConfiguration(autoImportPolicy: \(Swift.String(describing: autoImportPolicy)), exportPath: \(Swift.String(describing: exportPath)), failureDetails: \(Swift.String(describing: failureDetails)), importPath: \(Swift.String(describing: importPath)), importedFileChunkSize: \(Swift.String(describing: importedFileChunkSize)), lifecycle: \(Swift.String(describing: lifecycle)))"}
}

extension FSxClientTypes {
    /// <p>The data repository configuration object for Lustre file systems returned in the response of
    ///             the <code>CreateFileSystem</code> operation.</p>
    public struct DataRepositoryConfiguration: Swift.Equatable {
        /// <p>Describes the file system's linked S3 data repository's <code>AutoImportPolicy</code>.
        ///             The AutoImportPolicy configures how Amazon FSx keeps your file and directory listings up to date
        ///             as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can have the following values:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
        ///                 file and directory listings from the linked S3 bucket
        ///                 when the file system is created. FSx does not update file and directory
        ///                 listings for any new or changed objects after choosing this option.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
        ///                 directory listings of any new objects added to the linked S3 bucket that
        ///                 do not currently exist in the FSx file system. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
        ///                 file and directory listings of any new objects added to the S3 bucket and any
        ///                 existing objects that are changed in the S3 bucket after you choose this option.
        ///             </p>
        ///             </li>
        ///          </ul>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
        public let autoImportPolicy: FSxClientTypes.AutoImportPolicyType?
        /// <p>The export path to the Amazon S3 bucket (and prefix) that you are using to store new and
        ///             changed Lustre file system files in S3.</p>
        public let exportPath: Swift.String?
        /// <p>Provides detailed information about the data respository if its <code>Lifecycle</code> is
        ///             set to <code>MISCONFIGURED</code>.</p>
        public let failureDetails: FSxClientTypes.DataRepositoryFailureDetails?
        /// <p>The import path to the Amazon S3 bucket (and optional prefix) that you're using
        ///             as the data repository for your FSx for Lustre file system, for example
        ///                 <code>s3://import-bucket/optional-prefix</code>. If a prefix is specified after the
        ///             Amazon S3 bucket name, only object keys with that prefix are loaded into the file
        ///             system.</p>
        public let importPath: Swift.String?
        /// <p>For files imported from a data repository, this value determines the stripe count and
        ///             maximum amount of data per file (in MiB) stored on a single physical disk. The maximum
        ///             number of disks that a single file can be striped across is limited by the total number
        ///             of disks that make up the file system.</p>
        ///
        ///         <p>The default chunk size is 1,024 MiB (1 GiB) and can go as high as 512,000 MiB (500
        ///             GiB). Amazon S3 objects have a maximum size of 5 TB.</p>
        public let importedFileChunkSize: Swift.Int?
        /// <p>Describes the state of the file system's S3 durable data repository, if it is configured with an S3 repository.
        ///         The lifecycle can have the following values:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>CREATING</code> - The data repository configuration between
        ///                 the FSx file system and the linked S3 data repository is being created.
        ///                 The data repository is unavailable.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>AVAILABLE</code> - The data repository is available for use.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>MISCONFIGURED</code> - Amazon FSx cannot automatically import updates from the S3 bucket
        ///                 until the data repository configuration is corrected. For more information, see
        ///                 <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/troubleshooting.html#troubleshooting-misconfigured-data-repository">Troubleshooting a Misconfigured linked S3 bucket</a>.
        ///                 </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>UPDATING</code> - The data repository is undergoing a customer initiated update and availability may be impacted.</p>
        ///             </li>
        ///          </ul>
        public let lifecycle: FSxClientTypes.DataRepositoryLifecycle?

        public init (
            autoImportPolicy: FSxClientTypes.AutoImportPolicyType? = nil,
            exportPath: Swift.String? = nil,
            failureDetails: FSxClientTypes.DataRepositoryFailureDetails? = nil,
            importPath: Swift.String? = nil,
            importedFileChunkSize: Swift.Int? = nil,
            lifecycle: FSxClientTypes.DataRepositoryLifecycle? = nil
        )
        {
            self.autoImportPolicy = autoImportPolicy
            self.exportPath = exportPath
            self.failureDetails = failureDetails
            self.importPath = importPath
            self.importedFileChunkSize = importedFileChunkSize
            self.lifecycle = lifecycle
        }
    }

}

extension FSxClientTypes.DataRepositoryFailureDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes.DataRepositoryFailureDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRepositoryFailureDetails(message: \(Swift.String(describing: message)))"}
}

extension FSxClientTypes {
    /// <p>Provides detailed information about the data respository if its <code>Lifecycle</code> is
    ///             set to <code>MISCONFIGURED</code>.</p>
    public struct DataRepositoryFailureDetails: Swift.Equatable {
        /// <p>A detailed error message.</p>
        public let message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension FSxClientTypes {
    public enum DataRepositoryLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case misconfigured
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DataRepositoryLifecycle] {
            return [
                .available,
                .creating,
                .deleting,
                .misconfigured,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .misconfigured: return "MISCONFIGURED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataRepositoryLifecycle(rawValue: rawValue) ?? DataRepositoryLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.DataRepositoryTask: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case endTime = "EndTime"
        case failureDetails = "FailureDetails"
        case fileSystemId = "FileSystemId"
        case lifecycle = "Lifecycle"
        case paths = "Paths"
        case report = "Report"
        case resourceARN = "ResourceARN"
        case startTime = "StartTime"
        case status = "Status"
        case tags = "Tags"
        case taskId = "TaskId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let paths = paths {
            var pathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .paths)
            for datarepositorytaskpaths0 in paths {
                try pathsContainer.encode(datarepositorytaskpaths0)
            }
        }
        if let report = report {
            try encodeContainer.encode(report, forKey: .report)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let taskId = taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryTaskLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryTaskType.self, forKey: .type)
        type = typeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let pathsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .paths)
        var pathsDecoded0:[Swift.String]? = nil
        if let pathsContainer = pathsContainer {
            pathsDecoded0 = [Swift.String]()
            for string0 in pathsContainer {
                if let string0 = string0 {
                    pathsDecoded0?.append(string0)
                }
            }
        }
        paths = pathsDecoded0
        let failureDetailsDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryTaskFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryTaskStatus.self, forKey: .status)
        status = statusDecoded
        let reportDecoded = try containerValues.decodeIfPresent(FSxClientTypes.CompletionReport.self, forKey: .report)
        report = reportDecoded
    }
}

extension FSxClientTypes.DataRepositoryTask: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRepositoryTask(creationTime: \(Swift.String(describing: creationTime)), endTime: \(Swift.String(describing: endTime)), failureDetails: \(Swift.String(describing: failureDetails)), fileSystemId: \(Swift.String(describing: fileSystemId)), lifecycle: \(Swift.String(describing: lifecycle)), paths: \(Swift.String(describing: paths)), report: \(Swift.String(describing: report)), resourceARN: \(Swift.String(describing: resourceARN)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), taskId: \(Swift.String(describing: taskId)), type: \(Swift.String(describing: type)))"}
}

extension FSxClientTypes {
    /// <p>A description of the data repository task. You use data repository tasks
    ///             to perform bulk transfer operations between your Amazon FSx file system and its linked data
    ///             repository.</p>
    public struct DataRepositoryTask: Swift.Equatable {
        /// <p>The time that the resource was created, in seconds (since 1970-01-01T00:00:00Z),
        ///             also known as Unix time.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The time that Amazon FSx completed processing the task, populated after the task is complete.</p>
        public let endTime: ClientRuntime.Date?
        /// <p>Failure message describing why the task failed, it is populated only when <code>Lifecycle</code> is set to <code>FAILED</code>.</p>
        public let failureDetails: FSxClientTypes.DataRepositoryTaskFailureDetails?
        /// <p>The globally unique ID of the file system, assigned by Amazon FSx.</p>
        public let fileSystemId: Swift.String?
        /// <p>The lifecycle status of the data repository task, as follows:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>PENDING</code> - Amazon FSx has not started the task.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>EXECUTING</code> - Amazon FSx is processing the task.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>FAILED</code> -  Amazon FSx was not able to complete the task. For example, there may be files the task failed to process.
        ///                 The <a>DataRepositoryTaskFailureDetails</a> property provides more information about task failures.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>SUCCEEDED</code> - FSx completed the task successfully.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>CANCELED</code> - Amazon FSx canceled the task and it did not complete.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>CANCELING</code> - FSx is in process of canceling the task.</p>
        ///             </li>
        ///          </ul>
        ///         <note>
        ///             <p>You cannot delete an FSx for Lustre file system if there are data
        ///                 repository tasks for the file system in the <code>PENDING</code> or <code>EXECUTING</code> states.
        ///                 Please retry when the data repository task is finished (with a status of <code>CANCELED</code>, <code>SUCCEEDED</code>, or <code>FAILED</code>).
        ///                 You can use the DescribeDataRepositoryTask action to monitor the task status. Contact the FSx team if you need to delete your file system immediately.</p>
        ///         </note>
        public let lifecycle: FSxClientTypes.DataRepositoryTaskLifecycle?
        /// <p>An array of paths on the Amazon FSx for Lustre file system that specify the data for the data repository task to process.
        ///             For example, in an EXPORT_TO_REPOSITORY task, the paths specify which data to export to the linked data repository.</p>
        ///             <p>(Default) If <code>Paths</code> is not specified, Amazon FSx uses the file system root directory.</p>
        public let paths: [Swift.String]?
        /// <p>Provides a report detailing the data repository task results of the files processed that match the criteria specified in the report <code>Scope</code> parameter.
        ///             FSx delivers the report to the file system's linked data repository in Amazon S3,
        ///             using the path specified in the report <code>Path</code> parameter.
        ///             You can specify whether or not a report gets generated for a task using the <code>Enabled</code> parameter.</p>
        public let report: FSxClientTypes.CompletionReport?
        /// <p>The Amazon Resource Name (ARN) for a given resource. ARNs uniquely identify AWS
        ///             resources. We require an ARN when you need to specify a resource unambiguously across
        ///             all of AWS. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs)
        ///                 and AWS Service Namespaces</a> in the <i>AWS General
        ///             Reference</i>.</p>
        public let resourceARN: Swift.String?
        /// <p>The time that Amazon FSx began processing the task.</p>
        public let startTime: ClientRuntime.Date?
        /// <p>Provides the status of the number of files that the task has processed successfully and failed to process.</p>
        public let status: FSxClientTypes.DataRepositoryTaskStatus?
        /// <p>A list of <code>Tag</code> values, with a maximum of 50 elements.</p>
        public let tags: [FSxClientTypes.Tag]?
        /// <p>The system-generated, unique 17-digit ID of the data repository task.</p>
        public let taskId: Swift.String?
        /// <p>The type of data repository task; EXPORT_TO_REPOSITORY is the only type currently supported.</p>
        public let type: FSxClientTypes.DataRepositoryTaskType?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            failureDetails: FSxClientTypes.DataRepositoryTaskFailureDetails? = nil,
            fileSystemId: Swift.String? = nil,
            lifecycle: FSxClientTypes.DataRepositoryTaskLifecycle? = nil,
            paths: [Swift.String]? = nil,
            report: FSxClientTypes.CompletionReport? = nil,
            resourceARN: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: FSxClientTypes.DataRepositoryTaskStatus? = nil,
            tags: [FSxClientTypes.Tag]? = nil,
            taskId: Swift.String? = nil,
            type: FSxClientTypes.DataRepositoryTaskType? = nil
        )
        {
            self.creationTime = creationTime
            self.endTime = endTime
            self.failureDetails = failureDetails
            self.fileSystemId = fileSystemId
            self.lifecycle = lifecycle
            self.paths = paths
            self.report = report
            self.resourceARN = resourceARN
            self.startTime = startTime
            self.status = status
            self.tags = tags
            self.taskId = taskId
            self.type = type
        }
    }

}

extension DataRepositoryTaskEnded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRepositoryTaskEnded(message: \(Swift.String(describing: message)))"}
}

extension DataRepositoryTaskEnded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DataRepositoryTaskEndedBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The data repository task could not be canceled because the task has already ended.</p>
public struct DataRepositoryTaskEnded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DataRepositoryTaskEndedBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DataRepositoryTaskEndedBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DataRepositoryTaskExecuting: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRepositoryTaskExecuting(message: \(Swift.String(describing: message)))"}
}

extension DataRepositoryTaskExecuting: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DataRepositoryTaskExecutingBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An existing data repository task is currently executing on the file system.
///         Wait until the existing task has completed, then create the new task.</p>
public struct DataRepositoryTaskExecuting: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DataRepositoryTaskExecutingBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DataRepositoryTaskExecutingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes.DataRepositoryTaskFailureDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes.DataRepositoryTaskFailureDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRepositoryTaskFailureDetails(message: \(Swift.String(describing: message)))"}
}

extension FSxClientTypes {
    /// <p>Provides information about why a data repository task failed. Only populated when the task <code>Lifecycle</code> is set to <code>FAILED</code>.</p>
    public struct DataRepositoryTaskFailureDetails: Swift.Equatable {
        /// <p>A detailed error message.</p>
        public let message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension FSxClientTypes.DataRepositoryTaskFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for datarepositorytaskfiltervalues0 in values {
                try valuesContainer.encode(datarepositorytaskfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryTaskFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FSxClientTypes.DataRepositoryTaskFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRepositoryTaskFilter(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension FSxClientTypes {
    /// <p>(Optional) An array of filter objects you can use to filter the response of data repository tasks you will see in the the response.
    ///             You can filter the tasks returned in the response by one or more file system IDs, task lifecycles, and by task type.
    ///             A filter object consists of a filter <code>Name</code>, and one or more <code>Values</code> for the filter.</p>
    public struct DataRepositoryTaskFilter: Swift.Equatable {
        /// <p>Name of the task property to use in filtering the tasks returned in the response.</p>
        ///         <ul>
        ///             <li>
        ///                <p>Use <code>file-system-id</code> to retrieve data repository tasks for specific file systems.</p>
        ///             </li>
        ///             <li>
        ///                <p>Use <code>task-lifecycle</code> to retrieve data repository tasks with one or more specific lifecycle states,
        ///                 as follows: CANCELED, EXECUTING, FAILED, PENDING, and SUCCEEDED.</p>
        ///             </li>
        ///          </ul>
        public let name: FSxClientTypes.DataRepositoryTaskFilterName?
        /// <p>Use Values to include the specific file system IDs and task
        ///             lifecycle states for the filters you are using.</p>
        public let values: [Swift.String]?

        public init (
            name: FSxClientTypes.DataRepositoryTaskFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension FSxClientTypes {
    public enum DataRepositoryTaskFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fileSystemId
        case taskLifecycle
        case sdkUnknown(Swift.String)

        public static var allCases: [DataRepositoryTaskFilterName] {
            return [
                .fileSystemId,
                .taskLifecycle,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fileSystemId: return "file-system-id"
            case .taskLifecycle: return "task-lifecycle"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataRepositoryTaskFilterName(rawValue: rawValue) ?? DataRepositoryTaskFilterName.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes {
    public enum DataRepositoryTaskLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case executing
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataRepositoryTaskLifecycle] {
            return [
                .canceled,
                .canceling,
                .executing,
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .executing: return "EXECUTING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataRepositoryTaskLifecycle(rawValue: rawValue) ?? DataRepositoryTaskLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension DataRepositoryTaskNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRepositoryTaskNotFound(message: \(Swift.String(describing: message)))"}
}

extension DataRepositoryTaskNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DataRepositoryTaskNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The data repository task or tasks you specified could not be found.</p>
public struct DataRepositoryTaskNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DataRepositoryTaskNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DataRepositoryTaskNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes.DataRepositoryTaskStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedCount = "FailedCount"
        case lastUpdatedTime = "LastUpdatedTime"
        case succeededCount = "SucceededCount"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failedCount = failedCount {
            try encodeContainer.encode(failedCount, forKey: .failedCount)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let succeededCount = succeededCount {
            try encodeContainer.encode(succeededCount, forKey: .succeededCount)
        }
        if let totalCount = totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let succeededCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .succeededCount)
        succeededCount = succeededCountDecoded
        let failedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedCount)
        failedCount = failedCountDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension FSxClientTypes.DataRepositoryTaskStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataRepositoryTaskStatus(failedCount: \(Swift.String(describing: failedCount)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), succeededCount: \(Swift.String(describing: succeededCount)), totalCount: \(Swift.String(describing: totalCount)))"}
}

extension FSxClientTypes {
    /// <p>Provides the task status showing a running total of the total number of files to be processed,
    ///             the number successfully processed, and the number of files the task failed to process.</p>
    public struct DataRepositoryTaskStatus: Swift.Equatable {
        /// <p>A running total of the number of files that the task failed to process.</p>
        public let failedCount: Swift.Int?
        /// <p>The time at which the task status was last updated.</p>
        public let lastUpdatedTime: ClientRuntime.Date?
        /// <p>A running total of the number of files that the task has successfully processed.</p>
        public let succeededCount: Swift.Int?
        /// <p>The total number of files that the task will process. While a task is executing, the sum of
        ///             <code>SucceededCount</code> plus <code>FailedCount</code> may not equal <code>TotalCount</code>. When the task is complete,
        ///             <code>TotalCount</code> equals the sum of <code>SucceededCount</code> plus <code>FailedCount</code>.</p>
        public let totalCount: Swift.Int?

        public init (
            failedCount: Swift.Int? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            succeededCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.failedCount = failedCount
            self.lastUpdatedTime = lastUpdatedTime
            self.succeededCount = succeededCount
            self.totalCount = totalCount
        }
    }

}

extension FSxClientTypes {
    public enum DataRepositoryTaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case export
        case sdkUnknown(Swift.String)

        public static var allCases: [DataRepositoryTaskType] {
            return [
                .export,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .export: return "EXPORT_TO_REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataRepositoryTaskType(rawValue: rawValue) ?? DataRepositoryTaskType.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteBackupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupOutputError>
}

extension DeleteBackupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupInput(backupId: \(Swift.String(describing: backupId)), clientRequestToken: \(Swift.String(describing: clientRequestToken)))"}
}

extension DeleteBackupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case clientRequestToken = "ClientRequestToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
    }
}

public struct DeleteBackupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupOutputError>
}

public struct DeleteBackupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupOutputError>
}

/// <p>The request object for <code>DeleteBackup</code> operation.</p>
public struct DeleteBackupInput: Swift.Equatable {
    /// <p>The ID of the backup you want to delete.</p>
    public let backupId: Swift.String?
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent deletion. This is automatically filled on your behalf when using the AWS CLI
    ///             or SDK.</p>
    public var clientRequestToken: Swift.String?

    public init (
        backupId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.clientRequestToken = clientRequestToken
    }
}

struct DeleteBackupInputBody: Swift.Equatable {
    public let backupId: Swift.String?
    public let clientRequestToken: Swift.String?
}

extension DeleteBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case clientRequestToken = "ClientRequestToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension DeleteBackupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BackupBeingCopied" : self = .backupBeingCopied(try BackupBeingCopied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupInProgress" : self = .backupInProgress(try BackupInProgress(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupNotFound" : self = .backupNotFound(try BackupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BackupRestoring" : self = .backupRestoring(try BackupRestoring(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupOutputError: Swift.Error, Swift.Equatable {
    case backupBeingCopied(BackupBeingCopied)
    case backupInProgress(BackupInProgress)
    case backupNotFound(BackupNotFound)
    case backupRestoring(BackupRestoring)
    case badRequest(BadRequest)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupOutputResponse(backupId: \(Swift.String(describing: backupId)), lifecycle: \(Swift.String(describing: lifecycle)))"}
}

extension DeleteBackupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBackupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backupId = output.backupId
            self.lifecycle = output.lifecycle
        } else {
            self.backupId = nil
            self.lifecycle = nil
        }
    }
}

/// <p>The response object for <code>DeleteBackup</code> operation.</p>
public struct DeleteBackupOutputResponse: Swift.Equatable {
    /// <p>The ID of the backup deleted.</p>
    public let backupId: Swift.String?
    /// <p>The lifecycle of the backup. Should be <code>DELETED</code>.</p>
    public let lifecycle: FSxClientTypes.BackupLifecycle?

    public init (
        backupId: Swift.String? = nil,
        lifecycle: FSxClientTypes.BackupLifecycle? = nil
    )
    {
        self.backupId = backupId
        self.lifecycle = lifecycle
    }
}

struct DeleteBackupOutputResponseBody: Swift.Equatable {
    public let backupId: Swift.String?
    public let lifecycle: FSxClientTypes.BackupLifecycle?
}

extension DeleteBackupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case lifecycle = "Lifecycle"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(FSxClientTypes.BackupLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

public struct DeleteFileSystemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileSystemOutputError>
}

extension DeleteFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), fileSystemId: \(Swift.String(describing: fileSystemId)), lustreConfiguration: \(Swift.String(describing: lustreConfiguration)), windowsConfiguration: \(Swift.String(describing: windowsConfiguration)))"}
}

extension DeleteFileSystemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case lustreConfiguration = "LustreConfiguration"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }
}

public struct DeleteFileSystemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileSystemOutputError>
}

public struct DeleteFileSystemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFileSystemOutputError>
}

/// <p>The request object for <code>DeleteFileSystem</code> operation.</p>
public struct DeleteFileSystemInput: Swift.Equatable {
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///             idempotent deletion. This is automatically filled on your behalf when using the AWS CLI
    ///             or SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>The ID of the file system you want to delete.</p>
    public let fileSystemId: Swift.String?
    /// <p>The configuration object for the Amazon FSx for Lustre file system being deleted in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public let lustreConfiguration: FSxClientTypes.DeleteFileSystemLustreConfiguration?
    /// <p>The configuration object for the Microsoft Windows file system used in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public let windowsConfiguration: FSxClientTypes.DeleteFileSystemWindowsConfiguration?

    public init (
        clientRequestToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        lustreConfiguration: FSxClientTypes.DeleteFileSystemLustreConfiguration? = nil,
        windowsConfiguration: FSxClientTypes.DeleteFileSystemWindowsConfiguration? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.lustreConfiguration = lustreConfiguration
        self.windowsConfiguration = windowsConfiguration
    }
}

struct DeleteFileSystemInputBody: Swift.Equatable {
    public let fileSystemId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let windowsConfiguration: FSxClientTypes.DeleteFileSystemWindowsConfiguration?
    public let lustreConfiguration: FSxClientTypes.DeleteFileSystemLustreConfiguration?
}

extension DeleteFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case lustreConfiguration = "LustreConfiguration"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DeleteFileSystemWindowsConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DeleteFileSystemLustreConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
    }
}

extension FSxClientTypes.DeleteFileSystemLustreConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalBackupTags = "FinalBackupTags"
        case skipFinalBackup = "SkipFinalBackup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalBackupTags = finalBackupTags {
            var finalBackupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .finalBackupTags)
            for tags0 in finalBackupTags {
                try finalBackupTagsContainer.encode(tags0)
            }
        }
        if let skipFinalBackup = skipFinalBackup {
            try encodeContainer.encode(skipFinalBackup, forKey: .skipFinalBackup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skipFinalBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipFinalBackup)
        skipFinalBackup = skipFinalBackupDecoded
        let finalBackupTagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .finalBackupTags)
        var finalBackupTagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let finalBackupTagsContainer = finalBackupTagsContainer {
            finalBackupTagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in finalBackupTagsContainer {
                if let structure0 = structure0 {
                    finalBackupTagsDecoded0?.append(structure0)
                }
            }
        }
        finalBackupTags = finalBackupTagsDecoded0
    }
}

extension FSxClientTypes.DeleteFileSystemLustreConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemLustreConfiguration(finalBackupTags: \(Swift.String(describing: finalBackupTags)), skipFinalBackup: \(Swift.String(describing: skipFinalBackup)))"}
}

extension FSxClientTypes {
    /// <p>The configuration object for the Amazon FSx for Lustre file system being deleted in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public struct DeleteFileSystemLustreConfiguration: Swift.Equatable {
        /// <p>Use if <code>SkipFinalBackup</code> is set to <code>false</code>,
        ///             and you want to apply an array of tags to the final backup. If you have set the file system property
        ///             <code>CopyTagsToBackups</code> to true, and
        ///             you specify one or more <code>FinalBackupTags</code> when deleting a file system, Amazon FSx will not copy any existing file system tags to the backup.</p>
        public let finalBackupTags: [FSxClientTypes.Tag]?
        /// <p>Set <code>SkipFinalBackup</code> to false if you want to take a final backup of the file
        ///             system you are deleting. By default, Amazon FSx will not take a final backup on your behalf when the
        ///                 <code>DeleteFileSystem</code> operation is invoked. (Default = true)</p>
        public let skipFinalBackup: Swift.Bool?

        public init (
            finalBackupTags: [FSxClientTypes.Tag]? = nil,
            skipFinalBackup: Swift.Bool? = nil
        )
        {
            self.finalBackupTags = finalBackupTags
            self.skipFinalBackup = skipFinalBackup
        }
    }

}

extension FSxClientTypes.DeleteFileSystemLustreResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalBackupId = "FinalBackupId"
        case finalBackupTags = "FinalBackupTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalBackupId = finalBackupId {
            try encodeContainer.encode(finalBackupId, forKey: .finalBackupId)
        }
        if let finalBackupTags = finalBackupTags {
            var finalBackupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .finalBackupTags)
            for tags0 in finalBackupTags {
                try finalBackupTagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let finalBackupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .finalBackupId)
        finalBackupId = finalBackupIdDecoded
        let finalBackupTagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .finalBackupTags)
        var finalBackupTagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let finalBackupTagsContainer = finalBackupTagsContainer {
            finalBackupTagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in finalBackupTagsContainer {
                if let structure0 = structure0 {
                    finalBackupTagsDecoded0?.append(structure0)
                }
            }
        }
        finalBackupTags = finalBackupTagsDecoded0
    }
}

extension FSxClientTypes.DeleteFileSystemLustreResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemLustreResponse(finalBackupId: \(Swift.String(describing: finalBackupId)), finalBackupTags: \(Swift.String(describing: finalBackupTags)))"}
}

extension FSxClientTypes {
    /// <p>The response object for the Amazon FSx for Lustre file system being deleted in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public struct DeleteFileSystemLustreResponse: Swift.Equatable {
        /// <p>The ID of the final backup for this file system.</p>
        public let finalBackupId: Swift.String?
        /// <p>The set of tags applied to the final backup.</p>
        public let finalBackupTags: [FSxClientTypes.Tag]?

        public init (
            finalBackupId: Swift.String? = nil,
            finalBackupTags: [FSxClientTypes.Tag]? = nil
        )
        {
            self.finalBackupId = finalBackupId
            self.finalBackupTags = finalBackupTags
        }
    }

}

extension DeleteFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFileSystemOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileSystemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemOutputResponse(fileSystemId: \(Swift.String(describing: fileSystemId)), lifecycle: \(Swift.String(describing: lifecycle)), lustreResponse: \(Swift.String(describing: lustreResponse)), windowsResponse: \(Swift.String(describing: windowsResponse)))"}
}

extension DeleteFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemId = output.fileSystemId
            self.lifecycle = output.lifecycle
            self.lustreResponse = output.lustreResponse
            self.windowsResponse = output.windowsResponse
        } else {
            self.fileSystemId = nil
            self.lifecycle = nil
            self.lustreResponse = nil
            self.windowsResponse = nil
        }
    }
}

/// <p>The response object for the <code>DeleteFileSystem</code> operation.</p>
public struct DeleteFileSystemOutputResponse: Swift.Equatable {
    /// <p>The ID of the file system being deleted.</p>
    public let fileSystemId: Swift.String?
    /// <p>The file system lifecycle for the deletion request. Should be
    ///             <code>DELETING</code>.</p>
    public let lifecycle: FSxClientTypes.FileSystemLifecycle?
    /// <p>The response object for the Amazon FSx for Lustre file system being deleted in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public let lustreResponse: FSxClientTypes.DeleteFileSystemLustreResponse?
    /// <p>The response object for the Microsoft Windows file system used in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public let windowsResponse: FSxClientTypes.DeleteFileSystemWindowsResponse?

    public init (
        fileSystemId: Swift.String? = nil,
        lifecycle: FSxClientTypes.FileSystemLifecycle? = nil,
        lustreResponse: FSxClientTypes.DeleteFileSystemLustreResponse? = nil,
        windowsResponse: FSxClientTypes.DeleteFileSystemWindowsResponse? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.lifecycle = lifecycle
        self.lustreResponse = lustreResponse
        self.windowsResponse = windowsResponse
    }
}

struct DeleteFileSystemOutputResponseBody: Swift.Equatable {
    public let fileSystemId: Swift.String?
    public let lifecycle: FSxClientTypes.FileSystemLifecycle?
    public let windowsResponse: FSxClientTypes.DeleteFileSystemWindowsResponse?
    public let lustreResponse: FSxClientTypes.DeleteFileSystemLustreResponse?
}

extension DeleteFileSystemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case lifecycle = "Lifecycle"
        case lustreResponse = "LustreResponse"
        case windowsResponse = "WindowsResponse"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystemLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let windowsResponseDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DeleteFileSystemWindowsResponse.self, forKey: .windowsResponse)
        windowsResponse = windowsResponseDecoded
        let lustreResponseDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DeleteFileSystemLustreResponse.self, forKey: .lustreResponse)
        lustreResponse = lustreResponseDecoded
    }
}

extension FSxClientTypes.DeleteFileSystemWindowsConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalBackupTags = "FinalBackupTags"
        case skipFinalBackup = "SkipFinalBackup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalBackupTags = finalBackupTags {
            var finalBackupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .finalBackupTags)
            for tags0 in finalBackupTags {
                try finalBackupTagsContainer.encode(tags0)
            }
        }
        if let skipFinalBackup = skipFinalBackup {
            try encodeContainer.encode(skipFinalBackup, forKey: .skipFinalBackup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skipFinalBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .skipFinalBackup)
        skipFinalBackup = skipFinalBackupDecoded
        let finalBackupTagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .finalBackupTags)
        var finalBackupTagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let finalBackupTagsContainer = finalBackupTagsContainer {
            finalBackupTagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in finalBackupTagsContainer {
                if let structure0 = structure0 {
                    finalBackupTagsDecoded0?.append(structure0)
                }
            }
        }
        finalBackupTags = finalBackupTagsDecoded0
    }
}

extension FSxClientTypes.DeleteFileSystemWindowsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemWindowsConfiguration(finalBackupTags: \(Swift.String(describing: finalBackupTags)), skipFinalBackup: \(Swift.String(describing: skipFinalBackup)))"}
}

extension FSxClientTypes {
    /// <p>The configuration object for the Microsoft Windows file system used in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public struct DeleteFileSystemWindowsConfiguration: Swift.Equatable {
        /// <p>A set of tags for your final backup.</p>
        public let finalBackupTags: [FSxClientTypes.Tag]?
        /// <p>By default, Amazon FSx for Windows takes a final backup on your behalf when the
        ///                 <code>DeleteFileSystem</code> operation is invoked. Doing this helps protect you
        ///             from data loss, and we highly recommend taking the final backup. If you want to skip
        ///             this backup, use this flag to do so.</p>
        public let skipFinalBackup: Swift.Bool?

        public init (
            finalBackupTags: [FSxClientTypes.Tag]? = nil,
            skipFinalBackup: Swift.Bool? = nil
        )
        {
            self.finalBackupTags = finalBackupTags
            self.skipFinalBackup = skipFinalBackup
        }
    }

}

extension FSxClientTypes.DeleteFileSystemWindowsResponse: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalBackupId = "FinalBackupId"
        case finalBackupTags = "FinalBackupTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalBackupId = finalBackupId {
            try encodeContainer.encode(finalBackupId, forKey: .finalBackupId)
        }
        if let finalBackupTags = finalBackupTags {
            var finalBackupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .finalBackupTags)
            for tags0 in finalBackupTags {
                try finalBackupTagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let finalBackupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .finalBackupId)
        finalBackupId = finalBackupIdDecoded
        let finalBackupTagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .finalBackupTags)
        var finalBackupTagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let finalBackupTagsContainer = finalBackupTagsContainer {
            finalBackupTagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in finalBackupTagsContainer {
                if let structure0 = structure0 {
                    finalBackupTagsDecoded0?.append(structure0)
                }
            }
        }
        finalBackupTags = finalBackupTagsDecoded0
    }
}

extension FSxClientTypes.DeleteFileSystemWindowsResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFileSystemWindowsResponse(finalBackupId: \(Swift.String(describing: finalBackupId)), finalBackupTags: \(Swift.String(describing: finalBackupTags)))"}
}

extension FSxClientTypes {
    /// <p>The response object for the Microsoft Windows file system used in the
    ///                 <code>DeleteFileSystem</code> operation.</p>
    public struct DeleteFileSystemWindowsResponse: Swift.Equatable {
        /// <p>The ID of the final backup for this file system.</p>
        public let finalBackupId: Swift.String?
        /// <p>The set of tags applied to the final backup.</p>
        public let finalBackupTags: [FSxClientTypes.Tag]?

        public init (
            finalBackupId: Swift.String? = nil,
            finalBackupTags: [FSxClientTypes.Tag]? = nil
        )
        {
            self.finalBackupId = finalBackupId
            self.finalBackupTags = finalBackupTags
        }
    }

}

public struct DescribeBackupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupsOutputError>
}

extension DescribeBackupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupsInput(backupIds: \(Swift.String(describing: backupIds)), filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBackupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupIds = "BackupIds"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupIds = backupIds {
            var backupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backupIds)
            for backupids0 in backupIds {
                try backupIdsContainer.encode(backupids0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeBackupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupsOutputError>
}

public struct DescribeBackupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupsOutputError>
}

/// <p>The request object for <code>DescribeBackups</code> operation.</p>
public struct DescribeBackupsInput: Swift.Equatable {
    /// <p>IDs of the backups you want to retrieve (String). This overrides any
    ///             filters. If any IDs are not found, BackupNotFound will be thrown.</p>
    public let backupIds: [Swift.String]?
    /// <p>Filters structure. Supported names are file-system-id and
    ///             backup-type.</p>
    public let filters: [FSxClientTypes.Filter]?
    /// <p>Maximum number of backups to return in the response (integer). This
    ///             parameter value must be greater than 0. The number of items that Amazon FSx returns is
    ///             the minimum of the <code>MaxResults</code> parameter specified in the request and the
    ///             service's internal maximum number of items per page.</p>
    public let maxResults: Swift.Int?
    /// <p>Opaque pagination token returned from a previous
    ///                 <code>DescribeBackups</code> operation (String). If a token present, the action
    ///             continues the list from where the returning call left off.</p>
    public let nextToken: Swift.String?

    public init (
        backupIds: [Swift.String]? = nil,
        filters: [FSxClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backupIds = backupIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBackupsInputBody: Swift.Equatable {
    public let backupIds: [Swift.String]?
    public let filters: [FSxClientTypes.Filter]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeBackupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupIds = "BackupIds"
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .backupIds)
        var backupIdsDecoded0:[Swift.String]? = nil
        if let backupIdsContainer = backupIdsContainer {
            backupIdsDecoded0 = [Swift.String]()
            for string0 in backupIdsContainer {
                if let string0 = string0 {
                    backupIdsDecoded0?.append(string0)
                }
            }
        }
        backupIds = backupIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FSxClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[FSxClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FSxClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBackupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BackupNotFound" : self = .backupNotFound(try BackupNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupsOutputError: Swift.Error, Swift.Equatable {
    case backupNotFound(BackupNotFound)
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupsOutputResponse(backups: \(Swift.String(describing: backups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBackupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBackupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backups = output.backups
            self.nextToken = output.nextToken
        } else {
            self.backups = nil
            self.nextToken = nil
        }
    }
}

/// <p>Response object for <code>DescribeBackups</code> operation.</p>
public struct DescribeBackupsOutputResponse: Swift.Equatable {
    /// <p>An array of backups.</p>
    public let backups: [FSxClientTypes.Backup]?
    /// <p>This is present if there are more backups than returned in the response (String).
    ///             You can use the <code>NextToken</code> value in the later request to fetch the backups.
    ///         </p>
    public let nextToken: Swift.String?

    public init (
        backups: [FSxClientTypes.Backup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backups = backups
        self.nextToken = nextToken
    }
}

struct DescribeBackupsOutputResponseBody: Swift.Equatable {
    public let backups: [FSxClientTypes.Backup]?
    public let nextToken: Swift.String?
}

extension DescribeBackupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backups = "Backups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Backup?].self, forKey: .backups)
        var backupsDecoded0:[FSxClientTypes.Backup]? = nil
        if let backupsContainer = backupsContainer {
            backupsDecoded0 = [FSxClientTypes.Backup]()
            for structure0 in backupsContainer {
                if let structure0 = structure0 {
                    backupsDecoded0?.append(structure0)
                }
            }
        }
        backups = backupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeDataRepositoryTasksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDataRepositoryTasksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDataRepositoryTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDataRepositoryTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDataRepositoryTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDataRepositoryTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDataRepositoryTasksOutputError>
}

extension DescribeDataRepositoryTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDataRepositoryTasksInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), taskIds: \(Swift.String(describing: taskIds)))"}
}

extension DescribeDataRepositoryTasksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskIds = "TaskIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for datarepositorytaskfilters0 in filters {
                try filtersContainer.encode(datarepositorytaskfilters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let taskIds = taskIds {
            var taskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .taskIds)
            for taskids0 in taskIds {
                try taskIdsContainer.encode(taskids0)
            }
        }
    }
}

public struct DescribeDataRepositoryTasksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDataRepositoryTasksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDataRepositoryTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDataRepositoryTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDataRepositoryTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDataRepositoryTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDataRepositoryTasksOutputError>
}

public struct DescribeDataRepositoryTasksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDataRepositoryTasksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDataRepositoryTasksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDataRepositoryTasksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDataRepositoryTasksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDataRepositoryTasksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDataRepositoryTasksOutputError>
}

public struct DescribeDataRepositoryTasksInput: Swift.Equatable {
    /// <p>(Optional) You can use filters to narrow the <code>DescribeDataRepositoryTasks</code> response to
    ///             include just tasks for specific file systems, or tasks in a specific lifecycle state.</p>
    public let filters: [FSxClientTypes.DataRepositoryTaskFilter]?
    /// <p>The maximum number of resources to return in the response. This value must be an
    ///             integer greater than zero.</p>
    public let maxResults: Swift.Int?
    /// <p>(Optional) Opaque pagination token returned from a previous operation (String). If
    ///             present, this token indicates from what point you can continue processing the request, where
    ///             the previous <code>NextToken</code> value left off.</p>
    public let nextToken: Swift.String?
    /// <p>(Optional) IDs of the tasks whose descriptions you want to retrieve
    ///             (String).</p>
    public let taskIds: [Swift.String]?

    public init (
        filters: [FSxClientTypes.DataRepositoryTaskFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        taskIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskIds = taskIds
    }
}

struct DescribeDataRepositoryTasksInputBody: Swift.Equatable {
    public let taskIds: [Swift.String]?
    public let filters: [FSxClientTypes.DataRepositoryTaskFilter]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeDataRepositoryTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case taskIds = "TaskIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .taskIds)
        var taskIdsDecoded0:[Swift.String]? = nil
        if let taskIdsContainer = taskIdsContainer {
            taskIdsDecoded0 = [Swift.String]()
            for string0 in taskIdsContainer {
                if let string0 = string0 {
                    taskIdsDecoded0?.append(string0)
                }
            }
        }
        taskIds = taskIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FSxClientTypes.DataRepositoryTaskFilter?].self, forKey: .filters)
        var filtersDecoded0:[FSxClientTypes.DataRepositoryTaskFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FSxClientTypes.DataRepositoryTaskFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDataRepositoryTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataRepositoryTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataRepositoryTaskNotFound" : self = .dataRepositoryTaskNotFound(try DataRepositoryTaskNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataRepositoryTasksOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case dataRepositoryTaskNotFound(DataRepositoryTaskNotFound)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataRepositoryTasksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDataRepositoryTasksOutputResponse(dataRepositoryTasks: \(Swift.String(describing: dataRepositoryTasks)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeDataRepositoryTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDataRepositoryTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataRepositoryTasks = output.dataRepositoryTasks
            self.nextToken = output.nextToken
        } else {
            self.dataRepositoryTasks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDataRepositoryTasksOutputResponse: Swift.Equatable {
    /// <p>The collection of data repository task descriptions returned.</p>
    public let dataRepositoryTasks: [FSxClientTypes.DataRepositoryTask]?
    /// <p>(Optional) Opaque pagination token returned from a previous operation (String). If
    ///             present, this token indicates from what point you can continue processing the request, where
    ///             the previous <code>NextToken</code> value left off.</p>
    public let nextToken: Swift.String?

    public init (
        dataRepositoryTasks: [FSxClientTypes.DataRepositoryTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataRepositoryTasks = dataRepositoryTasks
        self.nextToken = nextToken
    }
}

struct DescribeDataRepositoryTasksOutputResponseBody: Swift.Equatable {
    public let dataRepositoryTasks: [FSxClientTypes.DataRepositoryTask]?
    public let nextToken: Swift.String?
}

extension DescribeDataRepositoryTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRepositoryTasks = "DataRepositoryTasks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRepositoryTasksContainer = try containerValues.decodeIfPresent([FSxClientTypes.DataRepositoryTask?].self, forKey: .dataRepositoryTasks)
        var dataRepositoryTasksDecoded0:[FSxClientTypes.DataRepositoryTask]? = nil
        if let dataRepositoryTasksContainer = dataRepositoryTasksContainer {
            dataRepositoryTasksDecoded0 = [FSxClientTypes.DataRepositoryTask]()
            for structure0 in dataRepositoryTasksContainer {
                if let structure0 = structure0 {
                    dataRepositoryTasksDecoded0?.append(structure0)
                }
            }
        }
        dataRepositoryTasks = dataRepositoryTasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFileSystemAliasesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemAliasesOutputError>
}

extension DescribeFileSystemAliasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemAliasesInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), fileSystemId: \(Swift.String(describing: fileSystemId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeFileSystemAliasesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeFileSystemAliasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemAliasesOutputError>
}

public struct DescribeFileSystemAliasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemAliasesOutputError>
}

/// <p>The request object for <code>DescribeFileSystemAliases</code> operation.</p>
public struct DescribeFileSystemAliasesInput: Swift.Equatable {
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>The ID of the file system to return the associated DNS aliases for
    ///             (String).</p>
    public let fileSystemId: Swift.String?
    /// <p>Maximum number of DNS aliases to return in the response (integer). This
    ///             parameter value must be greater than 0. The number of items that Amazon FSx returns is
    ///             the minimum of the <code>MaxResults</code> parameter specified in the request and the
    ///             service's internal maximum number of items per page.</p>
    public let maxResults: Swift.Int?
    /// <p>Opaque pagination token returned from a previous
    ///                 <code>DescribeFileSystemAliases</code> operation (String). If a token is included in the request, the action
    ///             continues the list from where the previous returning call left off.</p>
    public let nextToken: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeFileSystemAliasesInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let fileSystemId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeFileSystemAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFileSystemAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemAliasesOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemAliasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemAliasesOutputResponse(aliases: \(Swift.String(describing: aliases)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeFileSystemAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFileSystemAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliases = output.aliases
            self.nextToken = output.nextToken
        } else {
            self.aliases = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response object for <code>DescribeFileSystemAliases</code> operation.</p>
public struct DescribeFileSystemAliasesOutputResponse: Swift.Equatable {
    /// <p>An array of one or more DNS aliases currently associated with the specified file system.</p>
    public let aliases: [FSxClientTypes.Alias]?
    /// <p>Present if there are more DNS aliases than returned in the response (String). You
    ///             can use the <code>NextToken</code> value in a later request to fetch additional
    ///             descriptions. </p>
    public let nextToken: Swift.String?

    public init (
        aliases: [FSxClientTypes.Alias]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.nextToken = nextToken
    }
}

struct DescribeFileSystemAliasesOutputResponseBody: Swift.Equatable {
    public let aliases: [FSxClientTypes.Alias]?
    public let nextToken: Swift.String?
}

extension DescribeFileSystemAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([FSxClientTypes.Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[FSxClientTypes.Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [FSxClientTypes.Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeFileSystemsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemsOutputError>
}

extension DescribeFileSystemsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemsInput(fileSystemIds: \(Swift.String(describing: fileSystemIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeFileSystemsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemIds = "FileSystemIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemIds = fileSystemIds {
            var fileSystemIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemIds)
            for filesystemids0 in fileSystemIds {
                try fileSystemIdsContainer.encode(filesystemids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeFileSystemsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemsOutputError>
}

public struct DescribeFileSystemsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFileSystemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFileSystemsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFileSystemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFileSystemsOutputError>
}

/// <p>The request object for <code>DescribeFileSystems</code> operation.</p>
public struct DescribeFileSystemsInput: Swift.Equatable {
    /// <p>IDs of the file systems whose descriptions you want to retrieve
    ///             (String).</p>
    public let fileSystemIds: [Swift.String]?
    /// <p>Maximum number of file systems to return in the response (integer). This
    ///             parameter value must be greater than 0. The number of items that Amazon FSx returns is
    ///             the minimum of the <code>MaxResults</code> parameter specified in the request and the
    ///             service's internal maximum number of items per page.</p>
    public let maxResults: Swift.Int?
    /// <p>Opaque pagination token returned from a previous
    ///                 <code>DescribeFileSystems</code> operation (String). If a token present, the action
    ///             continues the list from where the returning call left off.</p>
    public let nextToken: Swift.String?

    public init (
        fileSystemIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fileSystemIds = fileSystemIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeFileSystemsInputBody: Swift.Equatable {
    public let fileSystemIds: [Swift.String]?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension DescribeFileSystemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemIds = "FileSystemIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fileSystemIds)
        var fileSystemIdsDecoded0:[Swift.String]? = nil
        if let fileSystemIdsContainer = fileSystemIdsContainer {
            fileSystemIdsDecoded0 = [Swift.String]()
            for string0 in fileSystemIdsContainer {
                if let string0 = string0 {
                    fileSystemIdsDecoded0?.append(string0)
                }
            }
        }
        fileSystemIds = fileSystemIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFileSystemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFileSystemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFileSystemsOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFileSystemsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFileSystemsOutputResponse(fileSystems: \(Swift.String(describing: fileSystems)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeFileSystemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFileSystemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystems = output.fileSystems
            self.nextToken = output.nextToken
        } else {
            self.fileSystems = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response object for <code>DescribeFileSystems</code> operation.</p>
public struct DescribeFileSystemsOutputResponse: Swift.Equatable {
    /// <p>An array of file system descriptions.</p>
    public let fileSystems: [FSxClientTypes.FileSystem]?
    /// <p>Present if there are more file systems than returned in the response (String). You
    ///             can use the <code>NextToken</code> value in the later request to fetch the
    ///             descriptions. </p>
    public let nextToken: Swift.String?

    public init (
        fileSystems: [FSxClientTypes.FileSystem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fileSystems = fileSystems
        self.nextToken = nextToken
    }
}

struct DescribeFileSystemsOutputResponseBody: Swift.Equatable {
    public let fileSystems: [FSxClientTypes.FileSystem]?
    public let nextToken: Swift.String?
}

extension DescribeFileSystemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystems = "FileSystems"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemsContainer = try containerValues.decodeIfPresent([FSxClientTypes.FileSystem?].self, forKey: .fileSystems)
        var fileSystemsDecoded0:[FSxClientTypes.FileSystem]? = nil
        if let fileSystemsContainer = fileSystemsContainer {
            fileSystemsDecoded0 = [FSxClientTypes.FileSystem]()
            for structure0 in fileSystemsContainer {
                if let structure0 = structure0 {
                    fileSystemsDecoded0?.append(structure0)
                }
            }
        }
        fileSystems = fileSystemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DisassociateFileSystemAliasesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFileSystemAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateFileSystemAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFileSystemAliasesOutputError>
}

extension DisassociateFileSystemAliasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateFileSystemAliasesInput(aliases: \(Swift.String(describing: aliases)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), fileSystemId: \(Swift.String(describing: fileSystemId)))"}
}

extension DisassociateFileSystemAliasesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for alternatednsnames0 in aliases {
                try aliasesContainer.encode(alternatednsnames0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
    }
}

public struct DisassociateFileSystemAliasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFileSystemAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateFileSystemAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFileSystemAliasesOutputError>
}

public struct DisassociateFileSystemAliasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateFileSystemAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateFileSystemAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateFileSystemAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateFileSystemAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateFileSystemAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateFileSystemAliasesOutputError>
}

/// <p>The request object of DNS aliases to disassociate from an Amazon FSx for Windows File Server file system.</p>
public struct DisassociateFileSystemAliasesInput: Swift.Equatable {
    /// <p>An array of one or more DNS alias names to disassociate, or remove, from the file system.</p>
    public let aliases: [Swift.String]?
    /// <p>(Optional) An idempotency token for resource creation, in a string of up to 64
    ///             ASCII characters. This token is automatically filled on your behalf when you use the AWS
    ///             Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>Specifies the file system from which to disassociate the DNS aliases.</p>
    public let fileSystemId: Swift.String?

    public init (
        aliases: [Swift.String]? = nil,
        clientRequestToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
    }
}

struct DisassociateFileSystemAliasesInputBody: Swift.Equatable {
    public let clientRequestToken: Swift.String?
    public let fileSystemId: Swift.String?
    public let aliases: [Swift.String]?
}

extension DisassociateFileSystemAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aliases)
        var aliasesDecoded0:[Swift.String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Swift.String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension DisassociateFileSystemAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFileSystemAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFileSystemAliasesOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case internalServerError(InternalServerError)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFileSystemAliasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateFileSystemAliasesOutputResponse(aliases: \(Swift.String(describing: aliases)))"}
}

extension DisassociateFileSystemAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateFileSystemAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliases = output.aliases
        } else {
            self.aliases = nil
        }
    }
}

/// <p>The system generated response showing the DNS aliases that Amazon FSx is attempting to disassociate from the file system.
///         Use the  API operation to monitor the status of the aliases Amazon FSx is removing from the file system.</p>
public struct DisassociateFileSystemAliasesOutputResponse: Swift.Equatable {
    /// <p>An array of one or more DNS aliases that Amazon FSx is attempting to disassociate from the file system.</p>
    public let aliases: [FSxClientTypes.Alias]?

    public init (
        aliases: [FSxClientTypes.Alias]? = nil
    )
    {
        self.aliases = aliases
    }
}

struct DisassociateFileSystemAliasesOutputResponseBody: Swift.Equatable {
    public let aliases: [FSxClientTypes.Alias]?
}

extension DisassociateFileSystemAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([FSxClientTypes.Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[FSxClientTypes.Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [FSxClientTypes.Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension FSxClientTypes {
    public enum DriveCacheType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case read
        case sdkUnknown(Swift.String)

        public static var allCases: [DriveCacheType] {
            return [
                .none,
                .read,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .read: return "READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DriveCacheType(rawValue: rawValue) ?? DriveCacheType.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.FileSystem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administrativeActions = "AdministrativeActions"
        case creationTime = "CreationTime"
        case dNSName = "DNSName"
        case failureDetails = "FailureDetails"
        case fileSystemId = "FileSystemId"
        case fileSystemType = "FileSystemType"
        case kmsKeyId = "KmsKeyId"
        case lifecycle = "Lifecycle"
        case lustreConfiguration = "LustreConfiguration"
        case networkInterfaceIds = "NetworkInterfaceIds"
        case ownerId = "OwnerId"
        case resourceARN = "ResourceARN"
        case storageCapacity = "StorageCapacity"
        case storageType = "StorageType"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
        case vpcId = "VpcId"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administrativeActions = administrativeActions {
            var administrativeActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .administrativeActions)
            for administrativeactions0 in administrativeActions {
                try administrativeActionsContainer.encode(administrativeactions0)
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dNSName = dNSName {
            try encodeContainer.encode(dNSName, forKey: .dNSName)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let fileSystemType = fileSystemType {
            try encodeContainer.encode(fileSystemType.rawValue, forKey: .fileSystemType)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lifecycle = lifecycle {
            try encodeContainer.encode(lifecycle.rawValue, forKey: .lifecycle)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let networkInterfaceIds = networkInterfaceIds {
            var networkInterfaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaceIds)
            for networkinterfaceids0 in networkInterfaceIds {
                try networkInterfaceIdsContainer.encode(networkinterfaceids0)
            }
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let storageCapacity = storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystemType.self, forKey: .fileSystemType)
        fileSystemType = fileSystemTypeDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystemLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystemFailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let networkInterfaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .networkInterfaceIds)
        var networkInterfaceIdsDecoded0:[Swift.String]? = nil
        if let networkInterfaceIdsContainer = networkInterfaceIdsContainer {
            networkInterfaceIdsDecoded0 = [Swift.String]()
            for string0 in networkInterfaceIdsContainer {
                if let string0 = string0 {
                    networkInterfaceIdsDecoded0?.append(string0)
                }
            }
        }
        networkInterfaceIds = networkInterfaceIdsDecoded0
        let dNSNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dNSName)
        dNSName = dNSNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.WindowsFileSystemConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.LustreFileSystemConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
        let administrativeActionsContainer = try containerValues.decodeIfPresent([FSxClientTypes.AdministrativeAction?].self, forKey: .administrativeActions)
        var administrativeActionsDecoded0:[FSxClientTypes.AdministrativeAction]? = nil
        if let administrativeActionsContainer = administrativeActionsContainer {
            administrativeActionsDecoded0 = [FSxClientTypes.AdministrativeAction]()
            for structure0 in administrativeActionsContainer {
                if let structure0 = structure0 {
                    administrativeActionsDecoded0?.append(structure0)
                }
            }
        }
        administrativeActions = administrativeActionsDecoded0
    }
}

extension FSxClientTypes.FileSystem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystem(administrativeActions: \(Swift.String(describing: administrativeActions)), creationTime: \(Swift.String(describing: creationTime)), dNSName: \(Swift.String(describing: dNSName)), failureDetails: \(Swift.String(describing: failureDetails)), fileSystemId: \(Swift.String(describing: fileSystemId)), fileSystemType: \(Swift.String(describing: fileSystemType)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lifecycle: \(Swift.String(describing: lifecycle)), lustreConfiguration: \(Swift.String(describing: lustreConfiguration)), networkInterfaceIds: \(Swift.String(describing: networkInterfaceIds)), ownerId: \(Swift.String(describing: ownerId)), resourceARN: \(Swift.String(describing: resourceARN)), storageCapacity: \(Swift.String(describing: storageCapacity)), storageType: \(Swift.String(describing: storageType)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)), vpcId: \(Swift.String(describing: vpcId)), windowsConfiguration: \(Swift.String(describing: windowsConfiguration)))"}
}

extension FSxClientTypes {
    /// <p>A description of a specific Amazon FSx file system.</p>
    public struct FileSystem: Swift.Equatable {
        /// <p>A list of administrative actions for the file system that are in process or waiting to be processed.
        ///             Administrative actions describe changes to the Windows file system that you have initiated using the <code>UpdateFileSystem</code> action.
        ///         </p>
        public let administrativeActions: [FSxClientTypes.AdministrativeAction]?
        /// <p>The time that the file system was created, in seconds (since 1970-01-01T00:00:00Z),
        ///             also known as Unix time.</p>
        public let creationTime: ClientRuntime.Date?
        /// <p>The DNS name for the file system.</p>
        public let dNSName: Swift.String?
        /// <p>A structure providing details of any failures that occur when creating the file system
        ///             has failed.</p>
        public let failureDetails: FSxClientTypes.FileSystemFailureDetails?
        /// <p>The system-generated, unique 17-digit ID of the file system.</p>
        public let fileSystemId: Swift.String?
        /// <p>The type of Amazon FSx file system, either <code>LUSTRE</code> or <code>WINDOWS</code>.</p>
        public let fileSystemType: FSxClientTypes.FileSystemType?
        /// <p>The ID of the AWS Key Management Service (AWS KMS) key used to encrypt the file system's data
        ///             for Amazon FSx for Windows File Server file systems and persistent Amazon FSx for Lustre file
        ///             systems at rest. In either case, if not specified, the Amazon FSx managed key
        ///             is used. The scratch Amazon FSx for Lustre file systems are always encrypted at rest using
        ///             Amazon FSx managed keys. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html">Encrypt</a>
        ///             in the <i>AWS Key Management Service API Reference</i>.</p>
        public let kmsKeyId: Swift.String?
        /// <p>The lifecycle status of the file system, following are the possible values and what they mean:</p>
        ///             <ul>
        ///             <li>
        ///                <p>
        ///                   <code>AVAILABLE</code> - The file system is in a healthy state, and is reachable and available for use.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>CREATING</code> - Amazon FSx is creating the new file system.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>DELETING</code> - Amazon FSx is deleting an existing file system.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>FAILED</code> - An existing file system has experienced an unrecoverable failure.
        ///                     When creating a new file system, Amazon FSx was unable to create the file system.</p>
        ///             </li>
        ///             <li>
        ///                     <p>
        ///                   <code>MISCONFIGURED</code> indicates that the file system is in a failed but recoverable state.</p>
        ///                 </li>
        ///             <li>
        ///                     <p>
        ///                   <code>UPDATING</code> indicates that the file system is undergoing a customer initiated update.</p>
        ///                 </li>
        ///          </ul>
        public let lifecycle: FSxClientTypes.FileSystemLifecycle?
        /// <p>The configuration for the Amazon FSx for Lustre file system.</p>
        public let lustreConfiguration: FSxClientTypes.LustreFileSystemConfiguration?
        /// <p>The IDs of the elastic network interface from which a specific file system is
        ///             accessible. The elastic network interface is automatically created in the same VPC that
        ///             the Amazon FSx file system was created in. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html">Elastic Network
        ///                 Interfaces</a> in the <i>Amazon EC2 User Guide.</i>
        ///          </p>
        ///
        ///         <p>For an Amazon FSx for Windows File Server file system, you can have one network
        ///             interface ID. For an Amazon FSx for Lustre file system, you can have more than
        ///             one.</p>
        public let networkInterfaceIds: [Swift.String]?
        /// <p>The AWS account that created the file system. If the file system was created by an AWS
        ///             Identity and Access Management (IAM) user, the AWS account to which the IAM user belongs
        ///             is the owner.</p>
        public let ownerId: Swift.String?
        /// <p>The Amazon Resource Name (ARN) for the file system resource.</p>
        public let resourceARN: Swift.String?
        /// <p>The storage capacity of the file system in gibibytes (GiB).</p>
        public let storageCapacity: Swift.Int?
        /// <p>The storage type of the file system.
        ///             Valid values are <code>SSD</code> and <code>HDD</code>.
        ///             If set to <code>SSD</code>, the file system uses solid state drive storage.
        ///             If set to <code>HDD</code>, the file system uses hard disk drive storage.
        ///         </p>
        public let storageType: FSxClientTypes.StorageType?
        /// <p>Specifies the IDs of the subnets that the file system is accessible from. For Windows <code>MULTI_AZ_1</code>
        ///             file system deployment type, there are two subnet IDs, one for the preferred file server
        ///             and one for the standby file server. The preferred file server subnet identified in the
        ///             <code>PreferredSubnetID</code> property. All other file systems have only one subnet ID.</p>
        ///         <p>For Lustre file systems, and Single-AZ Windows file systems, this is the ID of
        ///             the subnet that contains the endpoint for the file system. For <code>MULTI_AZ_1</code> Windows file systems,
        ///             the endpoint for the file system is available in the <code>PreferredSubnetID</code>.</p>
        public let subnetIds: [Swift.String]?
        /// <p>The tags to associate with the file system. For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html">Tagging Your
        ///                 Amazon EC2 Resources</a> in the <i>Amazon EC2 User
        ///             Guide</i>.</p>
        public let tags: [FSxClientTypes.Tag]?
        /// <p>The ID of the primary VPC for the file system.</p>
        public let vpcId: Swift.String?
        /// <p>The configuration for this Microsoft Windows file system.</p>
        public let windowsConfiguration: FSxClientTypes.WindowsFileSystemConfiguration?

        public init (
            administrativeActions: [FSxClientTypes.AdministrativeAction]? = nil,
            creationTime: ClientRuntime.Date? = nil,
            dNSName: Swift.String? = nil,
            failureDetails: FSxClientTypes.FileSystemFailureDetails? = nil,
            fileSystemId: Swift.String? = nil,
            fileSystemType: FSxClientTypes.FileSystemType? = nil,
            kmsKeyId: Swift.String? = nil,
            lifecycle: FSxClientTypes.FileSystemLifecycle? = nil,
            lustreConfiguration: FSxClientTypes.LustreFileSystemConfiguration? = nil,
            networkInterfaceIds: [Swift.String]? = nil,
            ownerId: Swift.String? = nil,
            resourceARN: Swift.String? = nil,
            storageCapacity: Swift.Int? = nil,
            storageType: FSxClientTypes.StorageType? = nil,
            subnetIds: [Swift.String]? = nil,
            tags: [FSxClientTypes.Tag]? = nil,
            vpcId: Swift.String? = nil,
            windowsConfiguration: FSxClientTypes.WindowsFileSystemConfiguration? = nil
        )
        {
            self.administrativeActions = administrativeActions
            self.creationTime = creationTime
            self.dNSName = dNSName
            self.failureDetails = failureDetails
            self.fileSystemId = fileSystemId
            self.fileSystemType = fileSystemType
            self.kmsKeyId = kmsKeyId
            self.lifecycle = lifecycle
            self.lustreConfiguration = lustreConfiguration
            self.networkInterfaceIds = networkInterfaceIds
            self.ownerId = ownerId
            self.resourceARN = resourceARN
            self.storageCapacity = storageCapacity
            self.storageType = storageType
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcId = vpcId
            self.windowsConfiguration = windowsConfiguration
        }
    }

}

extension FSxClientTypes.FileSystemFailureDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes.FileSystemFailureDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemFailureDetails(message: \(Swift.String(describing: message)))"}
}

extension FSxClientTypes {
    /// <p>A structure providing details of any failures that occur when creating the file system
    ///             has failed.</p>
    public struct FileSystemFailureDetails: Swift.Equatable {
        /// <p>A message describing any failures that occurred during file system creation.</p>
        public let message: Swift.String?

        public init (
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }

}

extension FSxClientTypes {
    /// <p>The lifecycle status of the file system.</p>
    public enum FileSystemLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case misconfigured
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [FileSystemLifecycle] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .misconfigured,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .misconfigured: return "MISCONFIGURED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileSystemLifecycle(rawValue: rawValue) ?? FileSystemLifecycle.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes {
    /// <p>An enumeration specifying the currently ongoing maintenance operation.</p>
    public enum FileSystemMaintenanceOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backingUp
        case patching
        case sdkUnknown(Swift.String)

        public static var allCases: [FileSystemMaintenanceOperation] {
            return [
                .backingUp,
                .patching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backingUp: return "BACKING_UP"
            case .patching: return "PATCHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileSystemMaintenanceOperation(rawValue: rawValue) ?? FileSystemMaintenanceOperation.sdkUnknown(rawValue)
        }
    }
}

extension FileSystemNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FileSystemNotFound(message: \(Swift.String(describing: message)))"}
}

extension FileSystemNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FileSystemNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No Amazon FSx file systems were found based upon supplied parameters.</p>
public struct FileSystemNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FileSystemNotFoundBody: Swift.Equatable {
    public let message: Swift.String?
}

extension FileSystemNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes {
    /// <p>The type of file system.</p>
    public enum FileSystemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lustre
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [FileSystemType] {
            return [
                .lustre,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lustre: return "LUSTRE"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileSystemType(rawValue: rawValue) ?? FileSystemType.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FSxClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension FSxClientTypes {
    /// <p>A filter used to restrict the results of describe calls. You can use multiple
    ///             filters to return results that meet all applied filter requirements.</p>
    public struct Filter: Swift.Equatable {
        /// <p>The name for this filter.</p>
        public let name: FSxClientTypes.FilterName?
        /// <p>The values of the filter. These are all the values for any of the applied
        ///             filters.</p>
        public let values: [Swift.String]?

        public init (
            name: FSxClientTypes.FilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension FSxClientTypes {
    /// <p>The name for a filter.</p>
    public enum FilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backupType
        case fileSystemId
        case fileSystemType
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterName] {
            return [
                .backupType,
                .fileSystemId,
                .fileSystemType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backupType: return "backup-type"
            case .fileSystemId: return "file-system-id"
            case .fileSystemType: return "file-system-type"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterName(rawValue: rawValue) ?? FilterName.sdkUnknown(rawValue)
        }
    }
}

extension IncompatibleParameterError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncompatibleParameterError(message: \(Swift.String(describing: message)), parameter: \(Swift.String(describing: parameter)))"}
}

extension IncompatibleParameterError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncompatibleParameterErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.parameter = output.parameter
        } else {
            self.message = nil
            self.parameter = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The error returned when a second request is received with the same client request
///             token but different parameters settings. A client request token should always uniquely
///             identify a single request.</p>
public struct IncompatibleParameterError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?
    /// <p>A parameter that is incompatible with the earlier request.</p>
    public var parameter: Swift.String?

    public init (
        message: Swift.String? = nil,
        parameter: Swift.String? = nil
    )
    {
        self.message = message
        self.parameter = parameter
    }
}

struct IncompatibleParameterErrorBody: Swift.Equatable {
    public let parameter: Swift.String?
    public let message: Swift.String?
}

extension IncompatibleParameterErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case parameter = "Parameter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameter)
        parameter = parameterDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncompatibleRegionForMultiAZ: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncompatibleRegionForMultiAZ(message: \(Swift.String(describing: message)))"}
}

extension IncompatibleRegionForMultiAZ: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncompatibleRegionForMultiAZBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon FSx doesn't support Multi-AZ Windows File Server
///          copy backup in the destination Region, so the copied backup
///          can't be restored.</p>
public struct IncompatibleRegionForMultiAZ: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleRegionForMultiAZBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IncompatibleRegionForMultiAZBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerError(message: \(Swift.String(describing: message)))"}
}

extension InternalServerError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A generic error indicating a server-side failure.</p>
public struct InternalServerError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDestinationKmsKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidDestinationKmsKey(message: \(Swift.String(describing: message)))"}
}

extension InvalidDestinationKmsKey: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDestinationKmsKeyBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS Key Management Service (AWS KMS) key of the destination
///          backup is invalid.</p>
public struct InvalidDestinationKmsKey: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDestinationKmsKeyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidDestinationKmsKeyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidExportPath: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidExportPath(message: \(Swift.String(describing: message)))"}
}

extension InvalidExportPath: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidExportPathBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The path provided for data repository export isn't valid.</p>
public struct InvalidExportPath: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidExportPathBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidExportPathBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidImportPath: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidImportPath(message: \(Swift.String(describing: message)))"}
}

extension InvalidImportPath: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidImportPathBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The path provided for data repository import isn't valid.</p>
public struct InvalidImportPath: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidImportPathBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidImportPathBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNetworkSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNetworkSettings(invalidSecurityGroupId: \(Swift.String(describing: invalidSecurityGroupId)), invalidSubnetId: \(Swift.String(describing: invalidSubnetId)), message: \(Swift.String(describing: message)))"}
}

extension InvalidNetworkSettings: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNetworkSettingsBody = try responseDecoder.decode(responseBody: data)
            self.invalidSecurityGroupId = output.invalidSecurityGroupId
            self.invalidSubnetId = output.invalidSubnetId
            self.message = output.message
        } else {
            self.invalidSecurityGroupId = nil
            self.invalidSubnetId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more network settings specified in the request are invalid.
///                 <code>InvalidVpcId</code> means that the ID passed for the virtual private cloud
///             (VPC) is invalid. <code>InvalidSubnetIds</code> returns the list of IDs for subnets that
///             are either invalid or not part of the VPC specified.
///                 <code>InvalidSecurityGroupIds</code> returns the list of IDs for security groups
///             that are either invalid or not part of the VPC specified.</p>
public struct InvalidNetworkSettings: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The ID of your Amazon EC2 security group. This ID is used to control network access
    ///             to the endpoint that Amazon FSx creates on your behalf in each subnet. For more
    ///             information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html">Amazon EC2 Security
    ///                 Groups for Linux Instances</a> in the <i>Amazon EC2 User
    ///             Guide</i>.</p>
    public var invalidSecurityGroupId: Swift.String?
    /// <p>The ID for a subnet. A <i>subnet</i> is a range of IP addresses in
    ///             your virtual private cloud (VPC). For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html">VPC and Subnets</a> in the
    ///                 <i>Amazon VPC User Guide.</i>
    ///          </p>
    public var invalidSubnetId: Swift.String?
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        invalidSecurityGroupId: Swift.String? = nil,
        invalidSubnetId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidSecurityGroupId = invalidSecurityGroupId
        self.invalidSubnetId = invalidSubnetId
        self.message = message
    }
}

struct InvalidNetworkSettingsBody: Swift.Equatable {
    public let message: Swift.String?
    public let invalidSubnetId: Swift.String?
    public let invalidSecurityGroupId: Swift.String?
}

extension InvalidNetworkSettingsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidSecurityGroupId = "InvalidSecurityGroupId"
        case invalidSubnetId = "InvalidSubnetId"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let invalidSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidSubnetId)
        invalidSubnetId = invalidSubnetIdDecoded
        let invalidSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invalidSecurityGroupId)
        invalidSecurityGroupId = invalidSecurityGroupIdDecoded
    }
}

extension InvalidPerUnitStorageThroughput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPerUnitStorageThroughput(message: \(Swift.String(describing: message)))"}
}

extension InvalidPerUnitStorageThroughput: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPerUnitStorageThroughputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid value for <code>PerUnitStorageThroughput</code> was provided. Please create your file system again, using a valid value.</p>
public struct InvalidPerUnitStorageThroughput: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPerUnitStorageThroughputBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidPerUnitStorageThroughputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRegion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRegion(message: \(Swift.String(describing: message)))"}
}

extension InvalidRegion: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRegionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Region provided for <code>Source Region</code> is invalid or
///          is in a different AWS partition.</p>
public struct InvalidRegion: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRegionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRegionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSourceKmsKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidSourceKmsKey(message: \(Swift.String(describing: message)))"}
}

extension InvalidSourceKmsKey: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSourceKmsKeyBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS Key Management Service (AWS KMS) key of the source backup
///          is invalid.</p>
public struct InvalidSourceKmsKey: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSourceKmsKeyBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidSourceKmsKeyBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

/// <p>The request object for <code>ListTagsForResource</code> operation.</p>
public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>Maximum number of tags to return in the response (integer). This
    ///             parameter value must be greater than 0. The number of items that Amazon FSx returns is
    ///             the minimum of the <code>MaxResults</code> parameter specified in the request and the
    ///             service's internal maximum number of items per page.</p>
    public let maxResults: Swift.Int?
    /// <p>Opaque pagination token returned from a previous
    ///                 <code>ListTagsForResource</code> operation (String). If a token present, the action
    ///             continues the list from where the returning call left off.</p>
    public let nextToken: Swift.String?
    /// <p>The ARN of the Amazon FSx resource that will have its tags listed.</p>
    public let resourceARN: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotServiceResourceError" : self = .notServiceResourceError(try NotServiceResourceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDoesNotSupportTagging" : self = .resourceDoesNotSupportTagging(try ResourceDoesNotSupportTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case internalServerError(InternalServerError)
    case notServiceResourceError(NotServiceResourceError)
    case resourceDoesNotSupportTagging(ResourceDoesNotSupportTagging)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

/// <p>The response object for <code>ListTagsForResource</code> operation.</p>
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>This is present if there are more tags than returned in the response (String). You
    ///             can use the <code>NextToken</code> value in the later request to fetch the tags.
    ///         </p>
    public let nextToken: Swift.String?
    /// <p>A list of tags on the resource.</p>
    public let tags: [FSxClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [FSxClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [FSxClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension FSxClientTypes {
    public enum LustreDeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case persistent1
        case scratch1
        case scratch2
        case sdkUnknown(Swift.String)

        public static var allCases: [LustreDeploymentType] {
            return [
                .persistent1,
                .scratch1,
                .scratch2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .persistent1: return "PERSISTENT_1"
            case .scratch1: return "SCRATCH_1"
            case .scratch2: return "SCRATCH_2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LustreDeploymentType(rawValue: rawValue) ?? LustreDeploymentType.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.LustreFileSystemConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case copyTagsToBackups = "CopyTagsToBackups"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case dataCompressionType = "DataCompressionType"
        case dataRepositoryConfiguration = "DataRepositoryConfiguration"
        case deploymentType = "DeploymentType"
        case driveCacheType = "DriveCacheType"
        case mountName = "MountName"
        case perUnitStorageThroughput = "PerUnitStorageThroughput"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let copyTagsToBackups = copyTagsToBackups {
            try encodeContainer.encode(copyTagsToBackups, forKey: .copyTagsToBackups)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let dataCompressionType = dataCompressionType {
            try encodeContainer.encode(dataCompressionType.rawValue, forKey: .dataCompressionType)
        }
        if let dataRepositoryConfiguration = dataRepositoryConfiguration {
            try encodeContainer.encode(dataRepositoryConfiguration, forKey: .dataRepositoryConfiguration)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let driveCacheType = driveCacheType {
            try encodeContainer.encode(driveCacheType.rawValue, forKey: .driveCacheType)
        }
        if let mountName = mountName {
            try encodeContainer.encode(mountName, forKey: .mountName)
        }
        if let perUnitStorageThroughput = perUnitStorageThroughput {
            try encodeContainer.encode(perUnitStorageThroughput, forKey: .perUnitStorageThroughput)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dataRepositoryConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataRepositoryConfiguration.self, forKey: .dataRepositoryConfiguration)
        dataRepositoryConfiguration = dataRepositoryConfigurationDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.LustreDeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let perUnitStorageThroughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .perUnitStorageThroughput)
        perUnitStorageThroughput = perUnitStorageThroughputDecoded
        let mountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountName)
        mountName = mountNameDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let copyTagsToBackupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToBackups)
        copyTagsToBackups = copyTagsToBackupsDecoded
        let driveCacheTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DriveCacheType.self, forKey: .driveCacheType)
        driveCacheType = driveCacheTypeDecoded
        let dataCompressionTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataCompressionType.self, forKey: .dataCompressionType)
        dataCompressionType = dataCompressionTypeDecoded
    }
}

extension FSxClientTypes.LustreFileSystemConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LustreFileSystemConfiguration(automaticBackupRetentionDays: \(Swift.String(describing: automaticBackupRetentionDays)), copyTagsToBackups: \(Swift.String(describing: copyTagsToBackups)), dailyAutomaticBackupStartTime: \(Swift.String(describing: dailyAutomaticBackupStartTime)), dataCompressionType: \(Swift.String(describing: dataCompressionType)), dataRepositoryConfiguration: \(Swift.String(describing: dataRepositoryConfiguration)), deploymentType: \(Swift.String(describing: deploymentType)), driveCacheType: \(Swift.String(describing: driveCacheType)), mountName: \(Swift.String(describing: mountName)), perUnitStorageThroughput: \(Swift.String(describing: perUnitStorageThroughput)), weeklyMaintenanceStartTime: \(Swift.String(describing: weeklyMaintenanceStartTime)))"}
}

extension FSxClientTypes {
    /// <p>The configuration for the Amazon FSx for Lustre file system.</p>
    public struct LustreFileSystemConfiguration: Swift.Equatable {
        /// <p>The number of days to retain automatic backups. Setting this to 0 disables
        ///             automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
        public let automaticBackupRetentionDays: Swift.Int?
        /// <p>A boolean flag indicating whether tags on the file system should be copied to backups.
        ///             If it's set to true, all tags on the file system are
        ///             copied to all automatic backups and any user-initiated backups where the user
        ///             doesn't specify any tags. If this value is true, and you specify one or more tags,
        ///             only the specified tags are copied to backups. If you specify one or more tags when
        ///             creating a user-initiated backup, no tags are copied from the file system,
        ///             regardless of this value. (Default = false)</p>
        public let copyTagsToBackups: Swift.Bool?
        /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
        ///             zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
        ///             hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
        public let dailyAutomaticBackupStartTime: Swift.String?
        /// <p>The data compression configuration for the file system. <code>DataCompressionType</code>
        ///             can have the following values:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>NONE</code> - Data compression is turned off for
        ///                 the file system.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>LZ4</code> - Data compression is turned on with the LZ4
        ///                 algorithm.</p>
        ///             </li>
        ///          </ul>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
        public let dataCompressionType: FSxClientTypes.DataCompressionType?
        /// <p>The data repository configuration object for Lustre file systems returned in the response of
        ///             the <code>CreateFileSystem</code> operation.</p>
        public let dataRepositoryConfiguration: FSxClientTypes.DataRepositoryConfiguration?
        /// <p>The deployment type of the FSX for Lustre file system. <i>Scratch deployment type</i> is designed for temporary storage
        ///             and shorter-term processing of data.</p>
        ///         <p>
        ///             <code>SCRATCH_1</code> and <code>SCRATCH_2</code> deployment
        ///         types are best suited for when you need temporary storage and shorter-term processing of data.
        ///         The <code>SCRATCH_2</code> deployment type provides in-transit encryption of data and higher burst
        ///         throughput capacity than <code>SCRATCH_1</code>.</p>
        ///         <p>The <code>PERSISTENT_1</code> deployment type is used for longer-term storage
        ///             and workloads and encryption of data in transit. To learn more about deployment types, see
        ///             <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/lustre-deployment-types.html">
        ///                 FSx for Lustre Deployment Options</a>. (Default = <code>SCRATCH_1</code>)</p>
        public let deploymentType: FSxClientTypes.LustreDeploymentType?
        /// <p>The type of drive cache used by PERSISTENT_1 file systems that are provisioned with
        ///             HDD storage devices. This parameter is required when storage type is HDD. Set to
        ///             <code>READ</code>, improve the performance for frequently accessed files and allows 20%
        ///             of the total storage capacity of the file system to be cached.  </p>
        ///         <p>This parameter is required when <code>StorageType</code> is set to HDD.</p>
        public let driveCacheType: FSxClientTypes.DriveCacheType?
        /// <p>You use the <code>MountName</code> value when mounting the file system.</p>
        ///         <p>For the <code>SCRATCH_1</code> deployment type, this value is always "<code>fsx</code>".
        ///             For <code>SCRATCH_2</code> and <code>PERSISTENT_1</code> deployment types, this
        ///             value is a string that is unique within an AWS Region.
        ///
        ///         </p>
        public let mountName: Swift.String?
        /// <p> Per unit storage throughput represents the megabytes per second of read or write
        ///             throughput per 1 tebibyte of storage provisioned. File system throughput capacity is
        ///             equal to Storage capacity (TiB) * PerUnitStorageThroughput (MB/s/TiB). This option is
        ///             only valid for <code>PERSISTENT_1</code> deployment types. </p>
        ///         <p>Valid values for SSD storage: 50, 100, 200. Valid values for HDD storage: 12, 40. </p>
        public let perUnitStorageThroughput: Swift.Int?
        /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        ///             time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        public let weeklyMaintenanceStartTime: Swift.String?

        public init (
            automaticBackupRetentionDays: Swift.Int? = nil,
            copyTagsToBackups: Swift.Bool? = nil,
            dailyAutomaticBackupStartTime: Swift.String? = nil,
            dataCompressionType: FSxClientTypes.DataCompressionType? = nil,
            dataRepositoryConfiguration: FSxClientTypes.DataRepositoryConfiguration? = nil,
            deploymentType: FSxClientTypes.LustreDeploymentType? = nil,
            driveCacheType: FSxClientTypes.DriveCacheType? = nil,
            mountName: Swift.String? = nil,
            perUnitStorageThroughput: Swift.Int? = nil,
            weeklyMaintenanceStartTime: Swift.String? = nil
        )
        {
            self.automaticBackupRetentionDays = automaticBackupRetentionDays
            self.copyTagsToBackups = copyTagsToBackups
            self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
            self.dataCompressionType = dataCompressionType
            self.dataRepositoryConfiguration = dataRepositoryConfiguration
            self.deploymentType = deploymentType
            self.driveCacheType = driveCacheType
            self.mountName = mountName
            self.perUnitStorageThroughput = perUnitStorageThroughput
            self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
        }
    }

}

extension MissingFileSystemConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MissingFileSystemConfiguration(message: \(Swift.String(describing: message)))"}
}

extension MissingFileSystemConfiguration: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MissingFileSystemConfigurationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A file system configuration is required for this operation.</p>
public struct MissingFileSystemConfiguration: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MissingFileSystemConfigurationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MissingFileSystemConfigurationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotServiceResourceError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotServiceResourceError(message: \(Swift.String(describing: message)), resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension NotServiceResourceError: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotServiceResourceErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceARN = output.resourceARN
        } else {
            self.message = nil
            self.resourceARN = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified for the tagging operation is not a resource type owned by
///             Amazon FSx. Use the API of the relevant service to perform the operation. </p>
public struct NotServiceResourceError: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the non-Amazon FSx resource.</p>
    public var resourceARN: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceARN = resourceARN
    }
}

struct NotServiceResourceErrorBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let message: Swift.String?
}

extension NotServiceResourceErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes {
    public enum ReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case reportCsv20191124
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormat] {
            return [
                .reportCsv20191124,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .reportCsv20191124: return "REPORT_CSV_20191124"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFormat(rawValue: rawValue) ?? ReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes {
    public enum ReportScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failedFilesOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportScope] {
            return [
                .failedFilesOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failedFilesOnly: return "FAILED_FILES_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportScope(rawValue: rawValue) ?? ReportScope.sdkUnknown(rawValue)
        }
    }
}

extension ResourceDoesNotSupportTagging: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDoesNotSupportTagging(message: \(Swift.String(describing: message)), resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ResourceDoesNotSupportTagging: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDoesNotSupportTaggingBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceARN = output.resourceARN
        } else {
            self.message = nil
            self.resourceARN = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified does not support tagging. </p>
public struct ResourceDoesNotSupportTagging: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the resource that doesn't support
    ///             tagging.</p>
    public var resourceARN: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceARN = resourceARN
    }
}

struct ResourceDoesNotSupportTaggingBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let message: Swift.String?
}

extension ResourceDoesNotSupportTaggingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFound: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFound(message: \(Swift.String(describing: message)), resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ResourceNotFound: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceARN = output.resourceARN
        } else {
            self.message = nil
            self.resourceARN = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified by the Amazon Resource Name (ARN) can't be found.</p>
public struct ResourceNotFound: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?
    /// <p>The resource ARN of the resource that can't be found.</p>
    public var resourceARN: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceARN = resourceARN
    }
}

struct ResourceNotFoundBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let message: Swift.String?
}

extension ResourceNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FSxClientTypes.SelfManagedActiveDirectoryAttributes: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsIps = "DnsIps"
        case domainName = "DomainName"
        case fileSystemAdministratorsGroup = "FileSystemAdministratorsGroup"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsIps = dnsIps {
            var dnsIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIps)
            for dnsips0 in dnsIps {
                try dnsIpsContainer.encode(dnsips0)
            }
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fileSystemAdministratorsGroup = fileSystemAdministratorsGroup {
            try encodeContainer.encode(fileSystemAdministratorsGroup, forKey: .fileSystemAdministratorsGroup)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let fileSystemAdministratorsGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAdministratorsGroup)
        fileSystemAdministratorsGroup = fileSystemAdministratorsGroupDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let dnsIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIps)
        var dnsIpsDecoded0:[Swift.String]? = nil
        if let dnsIpsContainer = dnsIpsContainer {
            dnsIpsDecoded0 = [Swift.String]()
            for string0 in dnsIpsContainer {
                if let string0 = string0 {
                    dnsIpsDecoded0?.append(string0)
                }
            }
        }
        dnsIps = dnsIpsDecoded0
    }
}

extension FSxClientTypes.SelfManagedActiveDirectoryAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelfManagedActiveDirectoryAttributes(dnsIps: \(Swift.String(describing: dnsIps)), domainName: \(Swift.String(describing: domainName)), fileSystemAdministratorsGroup: \(Swift.String(describing: fileSystemAdministratorsGroup)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)), userName: \(Swift.String(describing: userName)))"}
}

extension FSxClientTypes {
    /// <p>The configuration of the self-managed Microsoft Active Directory (AD) directory to
    ///             which the Windows File Server instance is joined.</p>
    public struct SelfManagedActiveDirectoryAttributes: Swift.Equatable {
        /// <p>A list of up to two IP addresses of DNS servers or domain controllers in the
        ///             self-managed AD directory.</p>
        public let dnsIps: [Swift.String]?
        /// <p>The fully qualified domain name of the self-managed AD directory.</p>
        public let domainName: Swift.String?
        /// <p>The name of the domain group whose members have administrative privileges for the FSx
        ///             file system.</p>
        public let fileSystemAdministratorsGroup: Swift.String?
        /// <p>The fully qualified distinguished name of the organizational unit within the
        ///             self-managed AD directory to which the Windows File Server instance is joined.</p>
        public let organizationalUnitDistinguishedName: Swift.String?
        /// <p>The user name for the service account on your self-managed AD domain that FSx uses to
        ///             join to your AD domain.</p>
        public let userName: Swift.String?

        public init (
            dnsIps: [Swift.String]? = nil,
            domainName: Swift.String? = nil,
            fileSystemAdministratorsGroup: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.dnsIps = dnsIps
            self.domainName = domainName
            self.fileSystemAdministratorsGroup = fileSystemAdministratorsGroup
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.userName = userName
        }
    }

}

extension FSxClientTypes.SelfManagedActiveDirectoryConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsIps = "DnsIps"
        case domainName = "DomainName"
        case fileSystemAdministratorsGroup = "FileSystemAdministratorsGroup"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsIps = dnsIps {
            var dnsIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIps)
            for dnsips0 in dnsIps {
                try dnsIpsContainer.encode(dnsips0)
            }
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fileSystemAdministratorsGroup = fileSystemAdministratorsGroup {
            try encodeContainer.encode(fileSystemAdministratorsGroup, forKey: .fileSystemAdministratorsGroup)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let fileSystemAdministratorsGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemAdministratorsGroup)
        fileSystemAdministratorsGroup = fileSystemAdministratorsGroupDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let dnsIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIps)
        var dnsIpsDecoded0:[Swift.String]? = nil
        if let dnsIpsContainer = dnsIpsContainer {
            dnsIpsDecoded0 = [Swift.String]()
            for string0 in dnsIpsContainer {
                if let string0 = string0 {
                    dnsIpsDecoded0?.append(string0)
                }
            }
        }
        dnsIps = dnsIpsDecoded0
    }
}

extension FSxClientTypes.SelfManagedActiveDirectoryConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelfManagedActiveDirectoryConfiguration(dnsIps: \(Swift.String(describing: dnsIps)), domainName: \(Swift.String(describing: domainName)), fileSystemAdministratorsGroup: \(Swift.String(describing: fileSystemAdministratorsGroup)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)), password: \(Swift.String(describing: password)), userName: \(Swift.String(describing: userName)))"}
}

extension FSxClientTypes {
    /// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to
    ///             your self-managed (including on-premises) Microsoft Active Directory (AD)
    ///             directory. For more information, see
    ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/self-managed-AD.html">
    ///                 Using Amazon FSx with your self-managed Microsoft Active Directory</a>.</p>
    public struct SelfManagedActiveDirectoryConfiguration: Swift.Equatable {
        /// <p>A list of up to two IP addresses of DNS servers or domain controllers in the
        ///             self-managed AD directory. </p>
        public let dnsIps: [Swift.String]?
        /// <p>The fully qualified domain name of the self-managed AD directory, such as
        ///                 <code>corp.example.com</code>.</p>
        public let domainName: Swift.String?
        /// <p>(Optional) The name of the domain group whose members are granted administrative
        ///             privileges for the file system. Administrative privileges include taking ownership of
        ///             files and folders, setting audit controls (audit ACLs) on files and folders, and
        ///                 administering the file system remotely by using the FSx Remote PowerShell.
        ///             The group that you specify must already exist in your domain. If you don't provide one,
        ///             your AD domain's Domain Admins group is used.</p>
        public let fileSystemAdministratorsGroup: Swift.String?
        /// <p>(Optional) The fully qualified distinguished name of the organizational unit within
        ///             your self-managed AD directory that the Windows File Server instance will join. Amazon
        ///             FSx only accepts OU as the direct parent of the file system. An example is
        ///                 <code>OU=FSx,DC=yourdomain,DC=corp,DC=com</code>. To learn more, see <a href="https://tools.ietf.org/html/rfc2253">RFC 2253</a>. If none is provided, the
        ///             FSx file system is created in the default location of your self-managed AD directory. </p>
        ///         <important>
        ///             <p>Only Organizational Unit (OU) objects can be the direct parent of the file system
        ///                 that you're creating.</p>
        ///         </important>
        public let organizationalUnitDistinguishedName: Swift.String?
        /// <p>The password for the service account on your self-managed AD domain that Amazon FSx
        ///             will use to join to your AD domain.</p>
        public let password: Swift.String?
        /// <p>The user name for the service account on your self-managed AD domain that Amazon FSx
        ///             will use to join to your AD domain. This account must have the permission to join
        ///             computers to the domain in the organizational unit provided in
        ///                 <code>OrganizationalUnitDistinguishedName</code>, or in the default location of your
        ///             AD domain.</p>
        public let userName: Swift.String?

        public init (
            dnsIps: [Swift.String]? = nil,
            domainName: Swift.String? = nil,
            fileSystemAdministratorsGroup: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil,
            password: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.dnsIps = dnsIps
            self.domainName = domainName
            self.fileSystemAdministratorsGroup = fileSystemAdministratorsGroup
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.password = password
            self.userName = userName
        }
    }

}

extension FSxClientTypes.SelfManagedActiveDirectoryConfigurationUpdates: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnsIps = "DnsIps"
        case password = "Password"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnsIps = dnsIps {
            var dnsIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIps)
            for dnsips0 in dnsIps {
                try dnsIpsContainer.encode(dnsips0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let dnsIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIps)
        var dnsIpsDecoded0:[Swift.String]? = nil
        if let dnsIpsContainer = dnsIpsContainer {
            dnsIpsDecoded0 = [Swift.String]()
            for string0 in dnsIpsContainer {
                if let string0 = string0 {
                    dnsIpsDecoded0?.append(string0)
                }
            }
        }
        dnsIps = dnsIpsDecoded0
    }
}

extension FSxClientTypes.SelfManagedActiveDirectoryConfigurationUpdates: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelfManagedActiveDirectoryConfigurationUpdates(dnsIps: \(Swift.String(describing: dnsIps)), password: \(Swift.String(describing: password)), userName: \(Swift.String(describing: userName)))"}
}

extension FSxClientTypes {
    /// <p>The configuration that Amazon FSx uses to join the Windows File Server instance to a
    ///             self-managed Microsoft Active Directory (AD) directory.</p>
    public struct SelfManagedActiveDirectoryConfigurationUpdates: Swift.Equatable {
        /// <p>A list of up to two IP addresses of DNS servers or domain controllers in the
        ///             self-managed AD directory.</p>
        public let dnsIps: [Swift.String]?
        /// <p>The password for the service account on your self-managed AD domain that Amazon FSx will use to join to
        ///             your AD domain.</p>
        public let password: Swift.String?
        /// <p>The user name for the service account on your self-managed AD domain that Amazon FSx will use to join to
        ///             your AD domain. This account must have the permission to join
        ///             computers to the domain in the organizational unit provided in
        ///             <code>OrganizationalUnitDistinguishedName</code>.</p>
        public let userName: Swift.String?

        public init (
            dnsIps: [Swift.String]? = nil,
            password: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.dnsIps = dnsIps
            self.password = password
            self.userName = userName
        }
    }

}

extension FSxClientTypes {
    /// <p>The types of limits on your service utilization. Limits include file system count,
    ///             total throughput capacity, total storage, and total user-initiated backups. These limits
    ///             apply for a specific account in a specific AWS Region. You can increase some of them by
    ///             contacting AWS Support. </p>
    public enum ServiceLimit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fileSystemCount
        case totalInProgressCopyBackups
        case totalStorage
        case totalThroughputCapacity
        case totalUserInitiatedBackups
        case totalUserTags
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceLimit] {
            return [
                .fileSystemCount,
                .totalInProgressCopyBackups,
                .totalStorage,
                .totalThroughputCapacity,
                .totalUserInitiatedBackups,
                .totalUserTags,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fileSystemCount: return "FILE_SYSTEM_COUNT"
            case .totalInProgressCopyBackups: return "TOTAL_IN_PROGRESS_COPY_BACKUPS"
            case .totalStorage: return "TOTAL_STORAGE"
            case .totalThroughputCapacity: return "TOTAL_THROUGHPUT_CAPACITY"
            case .totalUserInitiatedBackups: return "TOTAL_USER_INITIATED_BACKUPS"
            case .totalUserTags: return "TOTAL_USER_TAGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceLimit(rawValue: rawValue) ?? ServiceLimit.sdkUnknown(rawValue)
        }
    }
}

extension ServiceLimitExceeded: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceLimitExceeded(limit: \(Swift.String(describing: limit)), message: \(Swift.String(describing: message)))"}
}

extension ServiceLimitExceeded: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.message = output.message
        } else {
            self.limit = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error indicating that a particular service limit was exceeded. You can increase
///             some service limits by contacting AWS Support.
///             </p>
public struct ServiceLimitExceeded: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Enumeration of the service limit that was exceeded. </p>
    public var limit: FSxClientTypes.ServiceLimit?
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        limit: FSxClientTypes.ServiceLimit? = nil,
        message: Swift.String? = nil
    )
    {
        self.limit = limit
        self.message = message
    }
}

struct ServiceLimitExceededBody: Swift.Equatable {
    public let limit: FSxClientTypes.ServiceLimit?
    public let message: Swift.String?
}

extension ServiceLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decodeIfPresent(FSxClientTypes.ServiceLimit.self, forKey: .limit)
        limit = limitDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceBackupUnavailable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceBackupUnavailable(backupId: \(Swift.String(describing: backupId)), message: \(Swift.String(describing: message)))"}
}

extension SourceBackupUnavailable: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SourceBackupUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.backupId = output.backupId
            self.message = output.message
        } else {
            self.backupId = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the lifecycle status of the
///          source backup is not <code>AVAILABLE</code>.</p>
public struct SourceBackupUnavailable: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The ID of the source backup. Specifies the backup you are copying.</p>
    public var backupId: Swift.String?
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        backupId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.message = message
    }
}

struct SourceBackupUnavailableBody: Swift.Equatable {
    public let message: Swift.String?
    public let backupId: Swift.String?
}

extension SourceBackupUnavailableBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension FSxClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case updatedOptimizing
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending,
                .updatedOptimizing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .updatedOptimizing: return "UPDATED_OPTIMIZING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes {
    /// <p>The storage type for your Amazon FSx file system.</p>
    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hdd
        case ssd
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .hdd,
                .ssd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hdd: return "HDD"
            case .ssd: return "SSD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FSxClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension FSxClientTypes {
    /// <p>Specifies a key-value pair for a resource tag.</p>
    public struct Tag: Swift.Equatable {
        /// <p>A value that specifies the <code>TagKey</code>, the name of the tag. Tag keys must
        ///             be unique for the resource to which they are attached.</p>
        public let key: Swift.String?
        /// <p>A value that specifies the <code>TagValue</code>, the value assigned to the
        ///             corresponding tag key. Tag values can be null and don't have to be unique in a tag set.
        ///             For example, you can have a key-value pair in a tag set of <code>finances : April</code>
        ///             and also of <code>payroll : April</code>.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

/// <p>The request object for the <code>TagResource</code> operation.</p>
public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon FSx resource that you want to
    ///             tag.</p>
    public let resourceARN: Swift.String?
    /// <p>A list of tags for the resource. If a tag with a given key already exists, the
    ///             value is replaced by the one specified in this parameter.</p>
    public let tags: [FSxClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [FSxClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [FSxClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FSxClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FSxClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FSxClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotServiceResourceError" : self = .notServiceResourceError(try NotServiceResourceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDoesNotSupportTagging" : self = .resourceDoesNotSupportTagging(try ResourceDoesNotSupportTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case internalServerError(InternalServerError)
    case notServiceResourceError(NotServiceResourceError)
    case resourceDoesNotSupportTagging(ResourceDoesNotSupportTagging)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The response object for the <code>TagResource</code> operation.</p>
public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UnsupportedOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedOperation(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedOperation: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedOperationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation is not supported for this resource or API.</p>
public struct UnsupportedOperation: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>A detailed error message.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

/// <p>The request object for <code>UntagResource</code> action.</p>
public struct UntagResourceInput: Swift.Equatable {
    /// <p>The ARN of the Amazon FSx resource to untag.</p>
    public let resourceARN: Swift.String?
    /// <p>A list of keys of tags on the resource to untag. In case the tag key doesn't exist,
    ///             the call will still succeed to be idempotent.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotServiceResourceError" : self = .notServiceResourceError(try NotServiceResourceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDoesNotSupportTagging" : self = .resourceDoesNotSupportTagging(try ResourceDoesNotSupportTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFound" : self = .resourceNotFound(try ResourceNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case internalServerError(InternalServerError)
    case notServiceResourceError(NotServiceResourceError)
    case resourceDoesNotSupportTagging(ResourceDoesNotSupportTagging)
    case resourceNotFound(ResourceNotFound)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The response object for <code>UntagResource</code> action.</p>
public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateFileSystemInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemOutputError>
}

extension UpdateFileSystemInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), fileSystemId: \(Swift.String(describing: fileSystemId)), lustreConfiguration: \(Swift.String(describing: lustreConfiguration)), storageCapacity: \(Swift.String(describing: storageCapacity)), windowsConfiguration: \(Swift.String(describing: windowsConfiguration)))"}
}

extension UpdateFileSystemInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case lustreConfiguration = "LustreConfiguration"
        case storageCapacity = "StorageCapacity"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lustreConfiguration = lustreConfiguration {
            try encodeContainer.encode(lustreConfiguration, forKey: .lustreConfiguration)
        }
        if let storageCapacity = storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let windowsConfiguration = windowsConfiguration {
            try encodeContainer.encode(windowsConfiguration, forKey: .windowsConfiguration)
        }
    }
}

public struct UpdateFileSystemInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemOutputError>
}

public struct UpdateFileSystemInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFileSystemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFileSystemInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFileSystemInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFileSystemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateFileSystemOutputError>
}

/// <p>The request object for the <code>UpdateFileSystem</code> operation.</p>
public struct UpdateFileSystemInput: Swift.Equatable {
    /// <p>A string of up to 64 ASCII characters that Amazon FSx uses to ensure
    ///           idempotent updates. This string is automatically filled on your behalf when you use the AWS
    ///           Command Line Interface (AWS CLI) or an AWS SDK.</p>
    public var clientRequestToken: Swift.String?
    /// <p>Identifies the file system that you are updating.</p>
    public let fileSystemId: Swift.String?
    /// <p>The configuration object for Amazon FSx for Lustre file systems used in the
    ///                 <code>UpdateFileSystem</code> operation.</p>
    public let lustreConfiguration: FSxClientTypes.UpdateFileSystemLustreConfiguration?
    /// <p>Use this parameter to increase the storage capacity of an Amazon FSx file system.
    ///       Specifies the storage capacity target value, GiB, to increase the storage capacity for the
    ///       file system that you're updating. You cannot make a storage capacity increase request if
    ///       there is an existing storage capacity increase request in progress.</p>
    ///          <p>For Windows file systems, the storage capacity target value must be at least 10 percent
    ///       (%) greater than the current storage capacity value. In order to increase storage capacity,
    ///       the file system must have at least 16 MB/s of throughput capacity.</p>
    ///          <p>For Lustre file systems, the storage capacity target value can be the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>For <code>SCRATCH_2</code> and <code>PERSISTENT_1 SSD</code> deployment types, valid values
    ///           are in multiples of 2400 GiB. The value must be greater than the current storage capacity.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>PERSISTENT HDD</code> file systems, valid values are multiples of 6000 GiB for
    ///           12 MB/s/TiB file systems and multiples of 1800 GiB for 40 MB/s/TiB file systems. The values must be greater
    ///           than the current storage capacity.</p>
    ///             </li>
    ///             <li>
    ///                <p>For <code>SCRATCH_1</code> file systems, you cannot increase the storage capacity.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-storage-capacity.html">Managing storage
    ///         capacity</a> in the <i>Amazon FSx for Windows File Server User Guide</i>
    ///       and <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/managing-storage-capacity.html">Managing storage and throughput capacity</a> in the <i>Amazon FSx for Lustre
    ///         User Guide</i>.</p>
    public let storageCapacity: Swift.Int?
    /// <p>The configuration updates for an Amazon FSx for Windows File Server file system.</p>
    public let windowsConfiguration: FSxClientTypes.UpdateFileSystemWindowsConfiguration?

    public init (
        clientRequestToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        lustreConfiguration: FSxClientTypes.UpdateFileSystemLustreConfiguration? = nil,
        storageCapacity: Swift.Int? = nil,
        windowsConfiguration: FSxClientTypes.UpdateFileSystemWindowsConfiguration? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.fileSystemId = fileSystemId
        self.lustreConfiguration = lustreConfiguration
        self.storageCapacity = storageCapacity
        self.windowsConfiguration = windowsConfiguration
    }
}

struct UpdateFileSystemInputBody: Swift.Equatable {
    public let fileSystemId: Swift.String?
    public let clientRequestToken: Swift.String?
    public let storageCapacity: Swift.Int?
    public let windowsConfiguration: FSxClientTypes.UpdateFileSystemWindowsConfiguration?
    public let lustreConfiguration: FSxClientTypes.UpdateFileSystemLustreConfiguration?
}

extension UpdateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case fileSystemId = "FileSystemId"
        case lustreConfiguration = "LustreConfiguration"
        case storageCapacity = "StorageCapacity"
        case windowsConfiguration = "WindowsConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let windowsConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.UpdateFileSystemWindowsConfiguration.self, forKey: .windowsConfiguration)
        windowsConfiguration = windowsConfigurationDecoded
        let lustreConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.UpdateFileSystemLustreConfiguration.self, forKey: .lustreConfiguration)
        lustreConfiguration = lustreConfigurationDecoded
    }
}

extension FSxClientTypes.UpdateFileSystemLustreConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoImportPolicy = "AutoImportPolicy"
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case dataCompressionType = "DataCompressionType"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoImportPolicy = autoImportPolicy {
            try encodeContainer.encode(autoImportPolicy.rawValue, forKey: .autoImportPolicy)
        }
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let dataCompressionType = dataCompressionType {
            try encodeContainer.encode(dataCompressionType.rawValue, forKey: .dataCompressionType)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let autoImportPolicyDecoded = try containerValues.decodeIfPresent(FSxClientTypes.AutoImportPolicyType.self, forKey: .autoImportPolicy)
        autoImportPolicy = autoImportPolicyDecoded
        let dataCompressionTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.DataCompressionType.self, forKey: .dataCompressionType)
        dataCompressionType = dataCompressionTypeDecoded
    }
}

extension FSxClientTypes.UpdateFileSystemLustreConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemLustreConfiguration(autoImportPolicy: \(Swift.String(describing: autoImportPolicy)), automaticBackupRetentionDays: \(Swift.String(describing: automaticBackupRetentionDays)), dailyAutomaticBackupStartTime: \(Swift.String(describing: dailyAutomaticBackupStartTime)), dataCompressionType: \(Swift.String(describing: dataCompressionType)), weeklyMaintenanceStartTime: \(Swift.String(describing: weeklyMaintenanceStartTime)))"}
}

extension FSxClientTypes {
    /// <p>The configuration object for Amazon FSx for Lustre file systems used in the
    ///                 <code>UpdateFileSystem</code> operation.</p>
    public struct UpdateFileSystemLustreConfiguration: Swift.Equatable {
        /// <p> (Optional) When you create your file system, your existing S3 objects appear as file and directory listings.
        ///             Use this property to choose how Amazon FSx keeps your file and directory listing up to date
        ///             as you add or modify objects in your linked S3 bucket. <code>AutoImportPolicy</code> can
        ///             have the following values:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>NONE</code> - (Default) AutoImport is off. Amazon FSx only updates
        ///                 file and directory listings from the linked S3 bucket
        ///                 when the file system is created. FSx does not update the file and directory
        ///                 listing for any new or changed objects after choosing this option.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>NEW</code> - AutoImport is on. Amazon FSx automatically imports
        ///                 directory listings of any new objects added to the linked S3 bucket that
        ///                 do not currently exist in the FSx file system. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>NEW_CHANGED</code> - AutoImport is on. Amazon FSx automatically imports
        ///                 file and directory listings of any new objects added to the S3 bucket and any
        ///                 existing objects that are changed in the S3 bucket after you choose this option.
        ///             </p>
        ///             </li>
        ///          </ul>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/autoimport-data-repo.html">Automatically import updates from your S3 bucket</a>.</p>
        public let autoImportPolicy: FSxClientTypes.AutoImportPolicyType?
        /// <p>The number of days to retain automatic backups. Setting this to 0 disables
        ///             automatic backups. You can retain automatic backups for a maximum of 90 days. The default is 0.</p>
        public let automaticBackupRetentionDays: Swift.Int?
        /// <p>A recurring daily time, in the format <code>HH:MM</code>. <code>HH</code> is the
        ///             zero-padded hour of the day (0-23), and <code>MM</code> is the zero-padded minute of the
        ///             hour. For example, <code>05:00</code> specifies 5 AM daily. </p>
        public let dailyAutomaticBackupStartTime: Swift.String?
        /// <p>Sets the data compression configuration for the file system. <code>DataCompressionType</code>
        ///             can have the following values:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>NONE</code> - Data compression is turned off for
        ///                 the file system.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>LZ4</code> - Data compression is turned on with the LZ4
        ///                 algorithm.</p>
        ///             </li>
        ///          </ul>
        ///         <p>If you don't use <code>DataCompressionType</code>, the file system retains
        ///             its current data compression configuration.</p>
        ///         <p>For more information, see <a href="https://docs.aws.amazon.com/fsx/latest/LustreGuide/data-compression.html">Lustre data compression</a>.</p>
        public let dataCompressionType: FSxClientTypes.DataCompressionType?
        /// <p>(Optional) The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        ///             time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        public let weeklyMaintenanceStartTime: Swift.String?

        public init (
            autoImportPolicy: FSxClientTypes.AutoImportPolicyType? = nil,
            automaticBackupRetentionDays: Swift.Int? = nil,
            dailyAutomaticBackupStartTime: Swift.String? = nil,
            dataCompressionType: FSxClientTypes.DataCompressionType? = nil,
            weeklyMaintenanceStartTime: Swift.String? = nil
        )
        {
            self.autoImportPolicy = autoImportPolicy
            self.automaticBackupRetentionDays = automaticBackupRetentionDays
            self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
            self.dataCompressionType = dataCompressionType
            self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
        }
    }

}

extension UpdateFileSystemOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFileSystemOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequest" : self = .badRequest(try BadRequest(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileSystemNotFound" : self = .fileSystemNotFound(try FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleParameterError" : self = .incompatibleParameterError(try IncompatibleParameterError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingFileSystemConfiguration" : self = .missingFileSystemConfiguration(try MissingFileSystemConfiguration(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLimitExceeded" : self = .serviceLimitExceeded(try ServiceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFileSystemOutputError: Swift.Error, Swift.Equatable {
    case badRequest(BadRequest)
    case fileSystemNotFound(FileSystemNotFound)
    case incompatibleParameterError(IncompatibleParameterError)
    case internalServerError(InternalServerError)
    case missingFileSystemConfiguration(MissingFileSystemConfiguration)
    case serviceLimitExceeded(ServiceLimitExceeded)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFileSystemOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemOutputResponse(fileSystem: \(Swift.String(describing: fileSystem)))"}
}

extension UpdateFileSystemOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFileSystemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fileSystem = output.fileSystem
        } else {
            self.fileSystem = nil
        }
    }
}

/// <p>The response object for the <code>UpdateFileSystem</code> operation.</p>
public struct UpdateFileSystemOutputResponse: Swift.Equatable {
    /// <p>A description of the file system that was updated.</p>
    public let fileSystem: FSxClientTypes.FileSystem?

    public init (
        fileSystem: FSxClientTypes.FileSystem? = nil
    )
    {
        self.fileSystem = fileSystem
    }
}

struct UpdateFileSystemOutputResponseBody: Swift.Equatable {
    public let fileSystem: FSxClientTypes.FileSystem?
}

extension UpdateFileSystemOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystem = "FileSystem"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemDecoded = try containerValues.decodeIfPresent(FSxClientTypes.FileSystem.self, forKey: .fileSystem)
        fileSystem = fileSystemDecoded
    }
}

extension FSxClientTypes.UpdateFileSystemWindowsConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case selfManagedActiveDirectoryConfiguration = "SelfManagedActiveDirectoryConfiguration"
        case throughputCapacity = "ThroughputCapacity"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration {
            try encodeContainer.encode(selfManagedActiveDirectoryConfiguration, forKey: .selfManagedActiveDirectoryConfiguration)
        }
        if let throughputCapacity = throughputCapacity {
            try encodeContainer.encode(throughputCapacity, forKey: .throughputCapacity)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let throughputCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughputCapacity)
        throughputCapacity = throughputCapacityDecoded
        let selfManagedActiveDirectoryConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.SelfManagedActiveDirectoryConfigurationUpdates.self, forKey: .selfManagedActiveDirectoryConfiguration)
        selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfigurationDecoded
    }
}

extension FSxClientTypes.UpdateFileSystemWindowsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFileSystemWindowsConfiguration(automaticBackupRetentionDays: \(Swift.String(describing: automaticBackupRetentionDays)), dailyAutomaticBackupStartTime: \(Swift.String(describing: dailyAutomaticBackupStartTime)), selfManagedActiveDirectoryConfiguration: \(Swift.String(describing: selfManagedActiveDirectoryConfiguration)), throughputCapacity: \(Swift.String(describing: throughputCapacity)), weeklyMaintenanceStartTime: \(Swift.String(describing: weeklyMaintenanceStartTime)))"}
}

extension FSxClientTypes {
    /// <p>Updates the configuration for an existing Amazon FSx for Windows
    ///             File Server file system. Amazon FSx only overwrites existing properties with non-null values
    ///             provided in the request.</p>
    public struct UpdateFileSystemWindowsConfiguration: Swift.Equatable {
        /// <p>The number of days to retain automatic daily backups. Setting this to zero (0) disables automatic daily
        ///             backups. You can retain automatic daily backups for a maximum of 90 days. For more information, see
        ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/using-backups.html#automatic-backups">Working with Automatic Daily Backups</a>.</p>
        public let automaticBackupRetentionDays: Swift.Int?
        /// <p>The preferred time to start the daily automatic backup, in the UTC time zone, for example, <code>02:00</code>
        ///          </p>
        public let dailyAutomaticBackupStartTime: Swift.String?
        /// <p>The configuration Amazon FSx uses to join the Windows File Server instance to the
        ///             self-managed Microsoft AD directory. You cannot make a self-managed Microsoft AD update request if there is an existing self-managed Microsoft AD update request in progress.</p>
        public let selfManagedActiveDirectoryConfiguration: FSxClientTypes.SelfManagedActiveDirectoryConfigurationUpdates?
        /// <p>Sets the target value for a file system's throughput capacity, in MB/s, that you are updating the file system to. Valid values are
        ///             8, 16, 32, 64, 128, 256, 512, 1024, 2048. You cannot make a throughput capacity update request if there is an existing throughput capacity update request in progress. For more information,
        ///             see <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-throughput-capacity.html">Managing Throughput Capacity</a>.</p>
        public let throughputCapacity: Swift.Int?
        /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        ///             time zone. Where d is the weekday number, from 1 through 7, with 1 = Monday and 7 = Sunday.</p>
        public let weeklyMaintenanceStartTime: Swift.String?

        public init (
            automaticBackupRetentionDays: Swift.Int? = nil,
            dailyAutomaticBackupStartTime: Swift.String? = nil,
            selfManagedActiveDirectoryConfiguration: FSxClientTypes.SelfManagedActiveDirectoryConfigurationUpdates? = nil,
            throughputCapacity: Swift.Int? = nil,
            weeklyMaintenanceStartTime: Swift.String? = nil
        )
        {
            self.automaticBackupRetentionDays = automaticBackupRetentionDays
            self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
            self.selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration
            self.throughputCapacity = throughputCapacity
            self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
        }
    }

}

extension FSxClientTypes {
    public enum WindowsDeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiAz1
        case singleAz1
        case singleAz2
        case sdkUnknown(Swift.String)

        public static var allCases: [WindowsDeploymentType] {
            return [
                .multiAz1,
                .singleAz1,
                .singleAz2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiAz1: return "MULTI_AZ_1"
            case .singleAz1: return "SINGLE_AZ_1"
            case .singleAz2: return "SINGLE_AZ_2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WindowsDeploymentType(rawValue: rawValue) ?? WindowsDeploymentType.sdkUnknown(rawValue)
        }
    }
}

extension FSxClientTypes.WindowsFileSystemConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryId = "ActiveDirectoryId"
        case aliases = "Aliases"
        case automaticBackupRetentionDays = "AutomaticBackupRetentionDays"
        case copyTagsToBackups = "CopyTagsToBackups"
        case dailyAutomaticBackupStartTime = "DailyAutomaticBackupStartTime"
        case deploymentType = "DeploymentType"
        case maintenanceOperationsInProgress = "MaintenanceOperationsInProgress"
        case preferredFileServerIp = "PreferredFileServerIp"
        case preferredSubnetId = "PreferredSubnetId"
        case remoteAdministrationEndpoint = "RemoteAdministrationEndpoint"
        case selfManagedActiveDirectoryConfiguration = "SelfManagedActiveDirectoryConfiguration"
        case throughputCapacity = "ThroughputCapacity"
        case weeklyMaintenanceStartTime = "WeeklyMaintenanceStartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryId = activeDirectoryId {
            try encodeContainer.encode(activeDirectoryId, forKey: .activeDirectoryId)
        }
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for aliases0 in aliases {
                try aliasesContainer.encode(aliases0)
            }
        }
        if let automaticBackupRetentionDays = automaticBackupRetentionDays {
            try encodeContainer.encode(automaticBackupRetentionDays, forKey: .automaticBackupRetentionDays)
        }
        if let copyTagsToBackups = copyTagsToBackups {
            try encodeContainer.encode(copyTagsToBackups, forKey: .copyTagsToBackups)
        }
        if let dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime {
            try encodeContainer.encode(dailyAutomaticBackupStartTime, forKey: .dailyAutomaticBackupStartTime)
        }
        if let deploymentType = deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let maintenanceOperationsInProgress = maintenanceOperationsInProgress {
            var maintenanceOperationsInProgressContainer = encodeContainer.nestedUnkeyedContainer(forKey: .maintenanceOperationsInProgress)
            for filesystemmaintenanceoperations0 in maintenanceOperationsInProgress {
                try maintenanceOperationsInProgressContainer.encode(filesystemmaintenanceoperations0.rawValue)
            }
        }
        if let preferredFileServerIp = preferredFileServerIp {
            try encodeContainer.encode(preferredFileServerIp, forKey: .preferredFileServerIp)
        }
        if let preferredSubnetId = preferredSubnetId {
            try encodeContainer.encode(preferredSubnetId, forKey: .preferredSubnetId)
        }
        if let remoteAdministrationEndpoint = remoteAdministrationEndpoint {
            try encodeContainer.encode(remoteAdministrationEndpoint, forKey: .remoteAdministrationEndpoint)
        }
        if let selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration {
            try encodeContainer.encode(selfManagedActiveDirectoryConfiguration, forKey: .selfManagedActiveDirectoryConfiguration)
        }
        if let throughputCapacity = throughputCapacity {
            try encodeContainer.encode(throughputCapacity, forKey: .throughputCapacity)
        }
        if let weeklyMaintenanceStartTime = weeklyMaintenanceStartTime {
            try encodeContainer.encode(weeklyMaintenanceStartTime, forKey: .weeklyMaintenanceStartTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeDirectoryId)
        activeDirectoryId = activeDirectoryIdDecoded
        let selfManagedActiveDirectoryConfigurationDecoded = try containerValues.decodeIfPresent(FSxClientTypes.SelfManagedActiveDirectoryAttributes.self, forKey: .selfManagedActiveDirectoryConfiguration)
        selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfigurationDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(FSxClientTypes.WindowsDeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let remoteAdministrationEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteAdministrationEndpoint)
        remoteAdministrationEndpoint = remoteAdministrationEndpointDecoded
        let preferredSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredSubnetId)
        preferredSubnetId = preferredSubnetIdDecoded
        let preferredFileServerIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredFileServerIp)
        preferredFileServerIp = preferredFileServerIpDecoded
        let throughputCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughputCapacity)
        throughputCapacity = throughputCapacityDecoded
        let maintenanceOperationsInProgressContainer = try containerValues.decodeIfPresent([FSxClientTypes.FileSystemMaintenanceOperation?].self, forKey: .maintenanceOperationsInProgress)
        var maintenanceOperationsInProgressDecoded0:[FSxClientTypes.FileSystemMaintenanceOperation]? = nil
        if let maintenanceOperationsInProgressContainer = maintenanceOperationsInProgressContainer {
            maintenanceOperationsInProgressDecoded0 = [FSxClientTypes.FileSystemMaintenanceOperation]()
            for string0 in maintenanceOperationsInProgressContainer {
                if let string0 = string0 {
                    maintenanceOperationsInProgressDecoded0?.append(string0)
                }
            }
        }
        maintenanceOperationsInProgress = maintenanceOperationsInProgressDecoded0
        let weeklyMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weeklyMaintenanceStartTime)
        weeklyMaintenanceStartTime = weeklyMaintenanceStartTimeDecoded
        let dailyAutomaticBackupStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dailyAutomaticBackupStartTime)
        dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTimeDecoded
        let automaticBackupRetentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automaticBackupRetentionDays)
        automaticBackupRetentionDays = automaticBackupRetentionDaysDecoded
        let copyTagsToBackupsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToBackups)
        copyTagsToBackups = copyTagsToBackupsDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([FSxClientTypes.Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[FSxClientTypes.Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [FSxClientTypes.Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension FSxClientTypes.WindowsFileSystemConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WindowsFileSystemConfiguration(activeDirectoryId: \(Swift.String(describing: activeDirectoryId)), aliases: \(Swift.String(describing: aliases)), automaticBackupRetentionDays: \(Swift.String(describing: automaticBackupRetentionDays)), copyTagsToBackups: \(Swift.String(describing: copyTagsToBackups)), dailyAutomaticBackupStartTime: \(Swift.String(describing: dailyAutomaticBackupStartTime)), deploymentType: \(Swift.String(describing: deploymentType)), maintenanceOperationsInProgress: \(Swift.String(describing: maintenanceOperationsInProgress)), preferredFileServerIp: \(Swift.String(describing: preferredFileServerIp)), preferredSubnetId: \(Swift.String(describing: preferredSubnetId)), remoteAdministrationEndpoint: \(Swift.String(describing: remoteAdministrationEndpoint)), selfManagedActiveDirectoryConfiguration: \(Swift.String(describing: selfManagedActiveDirectoryConfiguration)), throughputCapacity: \(Swift.String(describing: throughputCapacity)), weeklyMaintenanceStartTime: \(Swift.String(describing: weeklyMaintenanceStartTime)))"}
}

extension FSxClientTypes {
    /// <p>The configuration for this Microsoft Windows file system.</p>
    public struct WindowsFileSystemConfiguration: Swift.Equatable {
        /// <p>The ID for an existing AWS Managed Microsoft Active Directory instance that the file system is joined to.</p>
        public let activeDirectoryId: Swift.String?
        /// <p>An array of one or more DNS aliases that are currently associated with the Amazon FSx file system.
        ///             Aliases allow you to use existing DNS names to access the data in your Amazon FSx file system.
        ///             You can associate up to 50 aliases with a file system at any time.
        ///             You can associate additional DNS aliases after you create the file system using the AssociateFileSystemAliases operation.
        ///             You can remove DNS aliases from the file system after it is created using the DisassociateFileSystemAliases operation.
        ///             You only need to specify the alias name in the request payload. For more information, see
        ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/managing-dns-aliases.html">DNS aliases</a>.</p>
        public let aliases: [FSxClientTypes.Alias]?
        /// <p>The number of days to retain automatic backups. Setting this to 0 disables automatic
        ///             backups. You can retain automatic backups for a maximum of 90 days.</p>
        public let automaticBackupRetentionDays: Swift.Int?
        /// <p>A boolean flag indicating whether tags on the file system should be copied to backups.
        ///             This value defaults to false. If it's set to true, all tags on the file system are
        ///             copied to all automatic backups and any user-initiated backups where the user
        ///             doesn't specify any tags. If this value is true, and you specify one or more tags,
        ///             only the specified tags are copied to backups. If you specify one or more tags when
        ///             creating a user-initiated backup, no tags are copied from the file system,
        ///             regardless of this value.</p>
        public let copyTagsToBackups: Swift.Bool?
        /// <p>The preferred time to take daily automatic backups, in the UTC time zone.</p>
        public let dailyAutomaticBackupStartTime: Swift.String?
        /// <p>Specifies the file system deployment type, valid values are the following:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                   <code>MULTI_AZ_1</code> - Specifies a high availability file system that is configured for Multi-AZ
        ///                     redundancy to tolerate temporary Availability Zone (AZ) unavailability, and supports SSD and HDD storage.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>SINGLE_AZ_1</code> - (Default) Specifies a file system that is configured for single AZ redundancy,
        ///                     only supports SSD storage.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>SINGLE_AZ_2</code> - Latest generation Single AZ file system.
        ///                     Specifies a file system that is configured for single AZ redundancy and supports SSD and HDD storage.</p>
        ///             </li>
        ///          </ul>
        ///         <p>For more information, see
        ///          <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html">Single-AZ and Multi-AZ File Systems</a>.</p>
        public let deploymentType: FSxClientTypes.WindowsDeploymentType?
        /// <p>The list of maintenance operations in progress for this file system.</p>
        public let maintenanceOperationsInProgress: [FSxClientTypes.FileSystemMaintenanceOperation]?
        /// <p>For <code>MULTI_AZ_1</code> deployment types, the IP address of the primary, or preferred, file server.</p>
        ///         <p>Use this IP address when mounting the file system on Linux SMB clients or Windows SMB clients that
        ///             are not joined to a Microsoft Active Directory.
        ///             Applicable for all Windows file system deployment types.
        ///             This IP address is temporarily unavailable
        ///             when the file system is undergoing maintenance. For Linux and Windows
        ///             SMB clients that are joined to an Active Directory, use the file system's DNSName instead. For more information
        ///             on mapping and mounting file shares, see
        ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/accessing-file-shares.html">Accessing File Shares</a>.</p>
        public let preferredFileServerIp: Swift.String?
        /// <p>For <code>MULTI_AZ_1</code> deployment types, it specifies the ID of the subnet where the preferred file server is located.
        ///             Must be one of the two subnet IDs specified in <code>SubnetIds</code> property.
        ///             Amazon FSx serves traffic from this subnet except in the event of a failover to the secondary file server.</p>
        ///         <p>For <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment types, this value is the same as that for <code>SubnetIDs</code>.
        ///             For more information, see
        ///             <a href="https://docs.aws.amazon.com/fsx/latest/WindowsGuide/high-availability-multiAZ.html#single-multi-az-resources">Availability and durability: Single-AZ and Multi-AZ file systems</a>.</p>
        public let preferredSubnetId: Swift.String?
        /// <p>For <code>MULTI_AZ_1</code> deployment types, use this endpoint when performing administrative tasks on the file system using
        ///             Amazon FSx Remote PowerShell.</p>
        ///         <p>For <code>SINGLE_AZ_1</code> and <code>SINGLE_AZ_2</code> deployment types, this is the DNS name of the file system.</p>
        ///         <p>This endpoint is temporarily unavailable when the file system is undergoing maintenance.</p>
        public let remoteAdministrationEndpoint: Swift.String?
        /// <p>The configuration of the self-managed Microsoft Active Directory (AD) directory to
        ///             which the Windows File Server instance is joined.</p>
        public let selfManagedActiveDirectoryConfiguration: FSxClientTypes.SelfManagedActiveDirectoryAttributes?
        /// <p>The throughput of the Amazon FSx file system, measured in megabytes per
        ///             second.</p>
        public let throughputCapacity: Swift.Int?
        /// <p>The preferred start time to perform weekly maintenance, formatted d:HH:MM in the UTC
        ///             time zone. d is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</p>
        public let weeklyMaintenanceStartTime: Swift.String?

        public init (
            activeDirectoryId: Swift.String? = nil,
            aliases: [FSxClientTypes.Alias]? = nil,
            automaticBackupRetentionDays: Swift.Int? = nil,
            copyTagsToBackups: Swift.Bool? = nil,
            dailyAutomaticBackupStartTime: Swift.String? = nil,
            deploymentType: FSxClientTypes.WindowsDeploymentType? = nil,
            maintenanceOperationsInProgress: [FSxClientTypes.FileSystemMaintenanceOperation]? = nil,
            preferredFileServerIp: Swift.String? = nil,
            preferredSubnetId: Swift.String? = nil,
            remoteAdministrationEndpoint: Swift.String? = nil,
            selfManagedActiveDirectoryConfiguration: FSxClientTypes.SelfManagedActiveDirectoryAttributes? = nil,
            throughputCapacity: Swift.Int? = nil,
            weeklyMaintenanceStartTime: Swift.String? = nil
        )
        {
            self.activeDirectoryId = activeDirectoryId
            self.aliases = aliases
            self.automaticBackupRetentionDays = automaticBackupRetentionDays
            self.copyTagsToBackups = copyTagsToBackups
            self.dailyAutomaticBackupStartTime = dailyAutomaticBackupStartTime
            self.deploymentType = deploymentType
            self.maintenanceOperationsInProgress = maintenanceOperationsInProgress
            self.preferredFileServerIp = preferredFileServerIp
            self.preferredSubnetId = preferredSubnetId
            self.remoteAdministrationEndpoint = remoteAdministrationEndpoint
            self.selfManagedActiveDirectoryConfiguration = selfManagedActiveDirectoryConfiguration
            self.throughputCapacity = throughputCapacity
            self.weeklyMaintenanceStartTime = weeklyMaintenanceStartTime
        }
    }

}
