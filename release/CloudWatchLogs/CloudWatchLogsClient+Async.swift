// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension CloudWatchLogsClient {
    /// <p>Associates the specified AWS Key Management Service (AWS KMS) customer master key (CMK) with the specified log group.</p>
    ///          <p>Associating an AWS KMS CMK with a log group overrides any existing associations between the log group and a CMK.
    ///       After a CMK is associated with a log group, all newly ingested data for the log group is encrypted using the CMK.
    ///       This association is stored as long as the data encrypted with the CMK is still within Amazon CloudWatch Logs.
    ///       This enables Amazon CloudWatch Logs to decrypt this data whenever it is requested.</p>
    ///          <important>
    ///             <p>CloudWatch Logs supports only symmetric CMKs. Do not use an associate an asymmetric CMK
    ///         with your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
    ///           Keys</a>.</p>
    ///          </important>
    ///          <p>It can take up to 5 minutes for this operation to take effect.</p>
    ///          <p>If you attempt to associate a CMK with a log group but the CMK does not exist or the
    ///       CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
    func associateKmsKey(input: AssociateKmsKeyInput) async throws -> AssociateKmsKeyOutputResponse
    {
        typealias associateKmsKeyContinuation = CheckedContinuation<AssociateKmsKeyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateKmsKeyContinuation) in
            associateKmsKey(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Cancels the specified export task.</p>
    ///          <p>The task must be in the <code>PENDING</code> or <code>RUNNING</code> state.</p>
    func cancelExportTask(input: CancelExportTaskInput) async throws -> CancelExportTaskOutputResponse
    {
        typealias cancelExportTaskContinuation = CheckedContinuation<CancelExportTaskOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelExportTaskContinuation) in
            cancelExportTask(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates an export task, which allows you to efficiently export data from a
    ///       log group to an Amazon S3 bucket. When you perform a <code>CreateExportTask</code>
    ///       operation, you must use credentials that have permission to write to the S3 bucket
    ///       that you specify as the destination.</p>
    ///          <p>This is an asynchronous call. If all the required information is provided, this
    ///       operation initiates an export task and responds with the ID of the task. After the task has started,
    ///       you can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeExportTasks.html">DescribeExportTasks</a> to get the status of the export task. Each account can
    ///       only have one active (<code>RUNNING</code> or <code>PENDING</code>) export task at a time.
    ///       To cancel an export task, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CancelExportTask.html">CancelExportTask</a>.</p>
    ///          <p>You can export logs from multiple log groups or multiple time ranges to the same S3
    ///       bucket. To separate out log data for each export task, you can specify a prefix to be used as
    ///       the Amazon S3 key prefix for all exported objects.</p>
    ///          <p>Exporting to S3 buckets that are encrypted with AES-256 is supported. Exporting to S3 buckets
    ///       encrypted with SSE-KMS is not supported. </p>
    func createExportTask(input: CreateExportTaskInput) async throws -> CreateExportTaskOutputResponse
    {
        typealias createExportTaskContinuation = CheckedContinuation<CreateExportTaskOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createExportTaskContinuation) in
            createExportTask(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a log group with the specified name. You can create up to 20,000 log groups per account.</p>
    ///          <p>You must use the following guidelines when naming a log group:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Log group names must be unique within a region for an AWS account.</p>
    ///             </li>
    ///             <li>
    ///                <p>Log group names can be between 1 and 512 characters long.</p>
    ///             </li>
    ///             <li>
    ///                <p>Log group names consist of the following characters: a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
    ///           '/' (forward slash), '.' (period), and '#' (number sign)</p>
    ///             </li>
    ///          </ul>
    ///          <p>When you create a log group, by default the log events in the log group never expire. To set
    ///     a retention policy so that events expire and are deleted after a specified time, use
    ///       <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutRetentionPolicy.html">PutRetentionPolicy</a>.</p>
    ///          <p>If you associate a AWS Key Management Service (AWS KMS) customer master key (CMK) with the log group, ingested data is encrypted using the CMK.
    ///       This association is stored as long as the data encrypted with the CMK is still within Amazon CloudWatch Logs.
    ///       This enables Amazon CloudWatch Logs to decrypt this data whenever it is requested.</p>
    ///          <p>If you attempt to associate a CMK with the log group but the CMK does not exist or the
    ///       CMK is disabled, you receive an <code>InvalidParameterException</code> error. </p>
    ///          <important>
    ///             <p> CloudWatch Logs supports only symmetric CMKs. Do not associate an asymmetric CMK with
    ///         your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
    ///           Keys</a>.</p>
    ///          </important>
    func createLogGroup(input: CreateLogGroupInput) async throws -> CreateLogGroupOutputResponse
    {
        typealias createLogGroupContinuation = CheckedContinuation<CreateLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createLogGroupContinuation) in
            createLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates a log stream for the specified log group. A log stream is a sequence of log events
    ///       that originate from a single source, such as an application instance or a resource that is
    ///       being monitored.</p>
    ///          <p>There is no limit on the number of log streams that you can create for a log group. There is a limit
    ///     of 50 TPS on <code>CreateLogStream</code> operations, after which transactions are throttled.</p>
    ///          <p>You must use the following guidelines when naming a log stream:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Log stream names must be unique within the log group.</p>
    ///             </li>
    ///             <li>
    ///                <p>Log stream names can be between 1 and 512 characters long.</p>
    ///             </li>
    ///             <li>
    ///                <p>The ':' (colon) and '*' (asterisk) characters are not allowed.</p>
    ///             </li>
    ///          </ul>
    func createLogStream(input: CreateLogStreamInput) async throws -> CreateLogStreamOutputResponse
    {
        typealias createLogStreamContinuation = CheckedContinuation<CreateLogStreamOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createLogStreamContinuation) in
            createLogStream(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified destination, and eventually disables all the
    ///       subscription filters that publish to it. This operation does not delete the
    ///       physical resource encapsulated by the destination.</p>
    func deleteDestination(input: DeleteDestinationInput) async throws -> DeleteDestinationOutputResponse
    {
        typealias deleteDestinationContinuation = CheckedContinuation<DeleteDestinationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDestinationContinuation) in
            deleteDestination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified log group and permanently deletes all the archived
    ///       log events associated with the log group.</p>
    func deleteLogGroup(input: DeleteLogGroupInput) async throws -> DeleteLogGroupOutputResponse
    {
        typealias deleteLogGroupContinuation = CheckedContinuation<DeleteLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteLogGroupContinuation) in
            deleteLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified log stream and permanently deletes all the archived log events associated
    ///       with the log stream.</p>
    func deleteLogStream(input: DeleteLogStreamInput) async throws -> DeleteLogStreamOutputResponse
    {
        typealias deleteLogStreamContinuation = CheckedContinuation<DeleteLogStreamOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteLogStreamContinuation) in
            deleteLogStream(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified metric filter.</p>
    func deleteMetricFilter(input: DeleteMetricFilterInput) async throws -> DeleteMetricFilterOutputResponse
    {
        typealias deleteMetricFilterContinuation = CheckedContinuation<DeleteMetricFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteMetricFilterContinuation) in
            deleteMetricFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a saved CloudWatch Logs Insights query definition.
    ///       A query definition contains details about a saved CloudWatch Logs Insights query.</p>
    ///          <p>Each <code>DeleteQueryDefinition</code> operation can delete one query definition.</p>
    ///          <p>You must have the <code>logs:DeleteQueryDefinition</code> permission to be able to perform
    ///       this operation.</p>
    func deleteQueryDefinition(input: DeleteQueryDefinitionInput) async throws -> DeleteQueryDefinitionOutputResponse
    {
        typealias deleteQueryDefinitionContinuation = CheckedContinuation<DeleteQueryDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteQueryDefinitionContinuation) in
            deleteQueryDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a resource policy from this account. This revokes
    ///     the access of the identities in that policy to put log events to this account.</p>
    func deleteResourcePolicy(input: DeleteResourcePolicyInput) async throws -> DeleteResourcePolicyOutputResponse
    {
        typealias deleteResourcePolicyContinuation = CheckedContinuation<DeleteResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResourcePolicyContinuation) in
            deleteResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified retention policy.</p>
    ///          <p>Log events do not expire if they belong to log groups without a retention policy.</p>
    func deleteRetentionPolicy(input: DeleteRetentionPolicyInput) async throws -> DeleteRetentionPolicyOutputResponse
    {
        typealias deleteRetentionPolicyContinuation = CheckedContinuation<DeleteRetentionPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRetentionPolicyContinuation) in
            deleteRetentionPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes the specified subscription filter.</p>
    func deleteSubscriptionFilter(input: DeleteSubscriptionFilterInput) async throws -> DeleteSubscriptionFilterOutputResponse
    {
        typealias deleteSubscriptionFilterContinuation = CheckedContinuation<DeleteSubscriptionFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSubscriptionFilterContinuation) in
            deleteSubscriptionFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists all your destinations. The results are ASCII-sorted by destination name.</p>
    func describeDestinations(input: DescribeDestinationsInput) async throws -> DescribeDestinationsOutputResponse
    {
        typealias describeDestinationsContinuation = CheckedContinuation<DescribeDestinationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDestinationsContinuation) in
            describeDestinations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the specified export tasks. You can list all your export tasks or filter
    ///       the results based on task ID or task status.</p>
    func describeExportTasks(input: DescribeExportTasksInput) async throws -> DescribeExportTasksOutputResponse
    {
        typealias describeExportTasksContinuation = CheckedContinuation<DescribeExportTasksOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeExportTasksContinuation) in
            describeExportTasks(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the specified log groups. You can list all your log groups or filter the results by prefix.
    ///       The results are ASCII-sorted by log group name.</p>
    func describeLogGroups(input: DescribeLogGroupsInput) async throws -> DescribeLogGroupsOutputResponse
    {
        typealias describeLogGroupsContinuation = CheckedContinuation<DescribeLogGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeLogGroupsContinuation) in
            describeLogGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the log streams for the specified log group.
    ///       You can list all the log streams or filter the results by prefix.
    ///       You can also control how the results are ordered.</p>
    ///          <p>This operation has a limit of five transactions per second, after which transactions are throttled.</p>
    func describeLogStreams(input: DescribeLogStreamsInput) async throws -> DescribeLogStreamsOutputResponse
    {
        typealias describeLogStreamsContinuation = CheckedContinuation<DescribeLogStreamsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeLogStreamsContinuation) in
            describeLogStreams(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the specified metric filters. You can list all of the metric filters or filter
    ///       the results by log name, prefix, metric name, or metric namespace. The results are
    ///       ASCII-sorted by filter name.</p>
    func describeMetricFilters(input: DescribeMetricFiltersInput) async throws -> DescribeMetricFiltersOutputResponse
    {
        typealias describeMetricFiltersContinuation = CheckedContinuation<DescribeMetricFiltersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeMetricFiltersContinuation) in
            describeMetricFilters(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of CloudWatch Logs Insights queries that are scheduled, executing, or have
    ///       been executed recently in this account. You can request all queries or limit it to queries of
    ///       a specific log group or queries with a certain status.</p>
    func describeQueries(input: DescribeQueriesInput) async throws -> DescribeQueriesOutputResponse
    {
        typealias describeQueriesContinuation = CheckedContinuation<DescribeQueriesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeQueriesContinuation) in
            describeQueries(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>This operation returns a paginated list of your saved CloudWatch Logs Insights query definitions.</p>
    ///          <p>You can use the <code>queryDefinitionNamePrefix</code> parameter to limit the results to only the
    ///       query definitions that have names that start with a certain string.</p>
    func describeQueryDefinitions(input: DescribeQueryDefinitionsInput) async throws -> DescribeQueryDefinitionsOutputResponse
    {
        typealias describeQueryDefinitionsContinuation = CheckedContinuation<DescribeQueryDefinitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeQueryDefinitionsContinuation) in
            describeQueryDefinitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the resource policies in this account.</p>
    func describeResourcePolicies(input: DescribeResourcePoliciesInput) async throws -> DescribeResourcePoliciesOutputResponse
    {
        typealias describeResourcePoliciesContinuation = CheckedContinuation<DescribeResourcePoliciesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeResourcePoliciesContinuation) in
            describeResourcePolicies(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the subscription filters for the specified log group. You can list all the subscription filters or filter the results by prefix.
    ///       The results are ASCII-sorted by filter name.</p>
    func describeSubscriptionFilters(input: DescribeSubscriptionFiltersInput) async throws -> DescribeSubscriptionFiltersOutputResponse
    {
        typealias describeSubscriptionFiltersContinuation = CheckedContinuation<DescribeSubscriptionFiltersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSubscriptionFiltersContinuation) in
            describeSubscriptionFilters(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Disassociates the associated AWS Key Management Service (AWS KMS) customer master key (CMK) from the specified log group.</p>
    ///          <p>After the AWS KMS CMK is disassociated from the log group, AWS CloudWatch Logs stops encrypting newly ingested data for the log group.
    ///       All previously ingested data remains encrypted, and AWS CloudWatch Logs requires permissions for the CMK whenever the encrypted data is requested.</p>
    ///          <p>Note that it can take up to 5 minutes for this operation to take effect.</p>
    func disassociateKmsKey(input: DisassociateKmsKeyInput) async throws -> DisassociateKmsKeyOutputResponse
    {
        typealias disassociateKmsKeyContinuation = CheckedContinuation<DisassociateKmsKeyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateKmsKeyContinuation) in
            disassociateKmsKey(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists log events from the specified log group. You can list all the log events or filter the results
    ///       using a filter pattern, a time range, and the name of the log stream.</p>
    ///          <p>By default, this operation returns as many log events as can fit in 1 MB (up to 10,000
    ///       log events) or all the events found within the time range that you specify. If the results
    ///       include a token, then there are more log events available, and you can get additional results
    ///       by specifying the token in a subsequent call. This operation can return empty results
    ///     while there are more log events available through the token.</p>
    ///          <p>The returned log events are sorted by event timestamp, the timestamp when the event was ingested
    ///     by CloudWatch Logs, and the ID of the <code>PutLogEvents</code> request.</p>
    func filterLogEvents(input: FilterLogEventsInput) async throws -> FilterLogEventsOutputResponse
    {
        typealias filterLogEventsContinuation = CheckedContinuation<FilterLogEventsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: filterLogEventsContinuation) in
            filterLogEvents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists log events from the specified log stream. You can list all of the log events or
    ///       filter using a time range.</p>
    ///
    ///          <p>By default, this operation returns as many log events as can fit in a response size of 1MB (up to 10,000 log events).
    ///       You can get additional log events by specifying one of the tokens in a subsequent call.
    ///       This operation can return empty results while there are more log events available through the token.</p>
    func getLogEvents(input: GetLogEventsInput) async throws -> GetLogEventsOutputResponse
    {
        typealias getLogEventsContinuation = CheckedContinuation<GetLogEventsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLogEventsContinuation) in
            getLogEvents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns a list of the fields that are included in log events in the specified log group, along with the percentage of log events
    ///     that contain each field. The search is limited to a time period that you specify.</p>
    ///          <p>In the results, fields that start with @ are fields generated by CloudWatch Logs. For
    ///       example, <code>@timestamp</code> is the timestamp of each log event. For more information about the fields that are
    ///       generated by CloudWatch logs, see
    ///       <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields</a>.</p>
    ///          <p>The response results are sorted by the frequency percentage, starting
    ///     with the highest percentage.</p>
    func getLogGroupFields(input: GetLogGroupFieldsInput) async throws -> GetLogGroupFieldsOutputResponse
    {
        typealias getLogGroupFieldsContinuation = CheckedContinuation<GetLogGroupFieldsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLogGroupFieldsContinuation) in
            getLogGroupFields(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves all of the fields and values of a single log event. All fields are retrieved,
    ///       even if the original query that produced the <code>logRecordPointer</code> retrieved only a
    ///       subset of fields. Fields are returned as field name/field value pairs.</p>
    ///          <p>The full unparsed log event is returned within <code>@message</code>.</p>
    func getLogRecord(input: GetLogRecordInput) async throws -> GetLogRecordOutputResponse
    {
        typealias getLogRecordContinuation = CheckedContinuation<GetLogRecordOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLogRecordContinuation) in
            getLogRecord(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Returns the results from the specified query.</p>
    ///          <p>Only the fields requested in the query are returned, along with a <code>@ptr</code>
    ///       field, which is the identifier for the log record. You can use the value of <code>@ptr</code>
    ///       in a <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_GetLogRecord.html">GetLogRecord</a>
    ///       operation to get the full log record.</p>
    ///          <p>
    ///             <code>GetQueryResults</code>
    ///       does not start a query execution. To run a query, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_StartQuery.html">StartQuery</a>.</p>
    ///          <p>If the value of the <code>Status</code> field in the output is <code>Running</code>, this operation
    ///       returns only partial results. If you see a value of <code>Scheduled</code> or <code>Running</code> for the status,
    ///       you can retry the operation later to see the final results. </p>
    func getQueryResults(input: GetQueryResultsInput) async throws -> GetQueryResultsOutputResponse
    {
        typealias getQueryResultsContinuation = CheckedContinuation<GetQueryResultsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getQueryResultsContinuation) in
            getQueryResults(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the tags for the specified log group.</p>
    func listTagsLogGroup(input: ListTagsLogGroupInput) async throws -> ListTagsLogGroupOutputResponse
    {
        typealias listTagsLogGroupContinuation = CheckedContinuation<ListTagsLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsLogGroupContinuation) in
            listTagsLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates a destination. This operation is used only to create destinations for cross-account subscriptions.</p>
    ///          <p>A destination encapsulates a physical resource (such
    ///       as an Amazon Kinesis stream) and enables you to subscribe to a real-time stream of log events
    ///       for a different account, ingested using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
    ///          <p>Through an access policy, a destination controls what is written to it.
    ///       By default, <code>PutDestination</code> does not set any access policy with the destination,
    ///       which means a cross-account user cannot call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutSubscriptionFilter.html">PutSubscriptionFilter</a> against
    ///       this destination. To enable this, the destination owner must call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy</a> after <code>PutDestination</code>.</p>
    ///          <p>To perform a <code>PutDestination</code> operation, you must also have the
    ///     <code>iam:PassRole</code> permission.</p>
    func putDestination(input: PutDestinationInput) async throws -> PutDestinationOutputResponse
    {
        typealias putDestinationContinuation = CheckedContinuation<PutDestinationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putDestinationContinuation) in
            putDestination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates an access policy associated with an existing
    ///       destination. An access policy is an <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies_overview.html">IAM policy document</a> that is used
    ///       to authorize claims to register a subscription filter against a given destination.</p>
    ///          <p>If multiple AWS accounts are sending logs to this destination, each sender account must be
    ///     listed separately in the policy. The policy does not support specifying <code>*</code>
    ///     as the Principal or the use of the <code>aws:PrincipalOrgId</code> global key.</p>
    func putDestinationPolicy(input: PutDestinationPolicyInput) async throws -> PutDestinationPolicyOutputResponse
    {
        typealias putDestinationPolicyContinuation = CheckedContinuation<PutDestinationPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putDestinationPolicyContinuation) in
            putDestinationPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Uploads a batch of log events to the specified log stream.</p>
    ///          <p>You must include the sequence token obtained from the response of the previous call. An
    ///       upload in a newly created log stream does not require a sequence token. You can also get the
    ///       sequence token in the <code>expectedSequenceToken</code> field from
    ///         <code>InvalidSequenceTokenException</code>. If you call <code>PutLogEvents</code> twice
    ///       within a narrow time period using the same value for <code>sequenceToken</code>, both calls
    ///       might be successful or one might be rejected.</p>
    ///          <p>The batch of events must satisfy the following constraints:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The maximum batch size is 1,048,576 bytes. This size is calculated as the sum of
    ///           all event messages in UTF-8, plus 26 bytes for each log event.</p>
    ///             </li>
    ///             <li>
    ///                <p>None of the log events in the batch can be more than 2 hours in the future.</p>
    ///             </li>
    ///             <li>
    ///                <p>None of the log events in the batch can be older than 14 days or older than the retention
    ///           period of the log group.</p>
    ///             </li>
    ///             <li>
    ///                <p>The log events in the batch must be in chronological order by their timestamp. The
    ///           timestamp is the time the event occurred, expressed as the number of milliseconds after
    ///           Jan 1, 1970 00:00:00 UTC. (In AWS Tools for PowerShell and the AWS SDK for .NET, the
    ///           timestamp is specified in .NET format: yyyy-mm-ddThh:mm:ss. For example,
    ///           2017-09-15T13:45:30.) </p>
    ///             </li>
    ///             <li>
    ///                <p>A batch of log events in a single request cannot span more than 24 hours. Otherwise, the operation fails.</p>
    ///             </li>
    ///             <li>
    ///                <p>The maximum number of log events in a batch is 10,000.</p>
    ///             </li>
    ///             <li>
    ///                <p>There is a quota of 5 requests per second per log stream. Additional requests are throttled. This quota can't be changed.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If a call to <code>PutLogEvents</code> returns "UnrecognizedClientException" the most likely cause is an invalid AWS access key ID or secret key. </p>
    func putLogEvents(input: PutLogEventsInput) async throws -> PutLogEventsOutputResponse
    {
        typealias putLogEventsContinuation = CheckedContinuation<PutLogEventsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putLogEventsContinuation) in
            putLogEvents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates a metric filter and associates it with the specified log group.
    ///       Metric filters allow you to configure rules to extract metric data from log events ingested
    ///       through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a>.</p>
    ///          <p>The maximum number of metric filters that can be associated with a log group is
    ///       100.</p>
    ///          <p>When you create a metric filter, you can also optionally assign a unit and dimensions
    ///     to the metric that is created.</p>
    ///          <important>
    ///             <p>Metrics extracted from log events are charged as custom metrics.
    ///       To prevent unexpected high charges, do not specify high-cardinality fields such as
    ///       <code>IPAddress</code> or <code>requestID</code> as dimensions. Each different value
    ///       found for
    ///       a dimension is treated as a separate metric and accrues charges as a separate custom metric.
    ///     </p>
    ///             <p>To help prevent accidental high charges, Amazon disables a metric filter
    ///         if it generates 1000 different name/value pairs for the dimensions that you
    ///         have specified within a certain amount of time.</p>
    ///             <p>You can also set up a billing alarm to alert you if your charges are higher than
    ///         expected. For more information,
    ///         see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
    ///           Creating a Billing Alarm to Monitor Your Estimated AWS Charges</a>.
    ///       </p>
    ///          </important>
    func putMetricFilter(input: PutMetricFilterInput) async throws -> PutMetricFilterOutputResponse
    {
        typealias putMetricFilterContinuation = CheckedContinuation<PutMetricFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putMetricFilterContinuation) in
            putMetricFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates a query definition for CloudWatch Logs Insights. For
    ///       more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html">Analyzing Log Data with CloudWatch Logs Insights</a>.</p>
    ///
    ///          <p>To update a query definition, specify its
    ///         <code>queryDefinitionId</code> in your request. The values of <code>name</code>, <code>queryString</code>,
    ///       and <code>logGroupNames</code> are changed to the values that you specify in your update
    ///       operation. No current values are retained from the current query definition. For example, if
    ///       you update a current query definition that includes log groups, and you don't specify the
    ///         <code>logGroupNames</code> parameter in your update operation, the query definition changes
    ///       to contain no log groups.</p>
    ///          <p>You must have the <code>logs:PutQueryDefinition</code> permission to be able to perform
    ///     this operation.</p>
    func putQueryDefinition(input: PutQueryDefinitionInput) async throws -> PutQueryDefinitionOutputResponse
    {
        typealias putQueryDefinitionContinuation = CheckedContinuation<PutQueryDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putQueryDefinitionContinuation) in
            putQueryDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates a resource policy allowing other AWS services to put log events to
    ///       this account, such as Amazon Route 53. An account can have up to 10 resource policies per AWS
    ///       Region.</p>
    func putResourcePolicy(input: PutResourcePolicyInput) async throws -> PutResourcePolicyOutputResponse
    {
        typealias putResourcePolicyContinuation = CheckedContinuation<PutResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putResourcePolicyContinuation) in
            putResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Sets the retention of the specified log group. A retention policy allows you to
    ///       configure the number of days for which to retain log events in the specified log
    ///       group.</p>
    func putRetentionPolicy(input: PutRetentionPolicyInput) async throws -> PutRetentionPolicyOutputResponse
    {
        typealias putRetentionPolicyContinuation = CheckedContinuation<PutRetentionPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putRetentionPolicyContinuation) in
            putRetentionPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Creates or updates a subscription filter and associates it with the specified log
    ///       group. Subscription filters allow you to subscribe to a real-time stream of log events
    ///       ingested through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents</a> and have them delivered to a specific
    ///       destination. When log events are sent to the
    ///       receiving service, they are Base64 encoded
    ///       and compressed with the gzip format.</p>
    ///          <p>The following destinations are supported for subscription filters:</p>
    ///          <ul>
    ///             <li>
    ///                <p>An Amazon Kinesis stream belonging to the same account as the subscription filter,
    ///           for same-account delivery.</p>
    ///             </li>
    ///             <li>
    ///                <p>A logical destination that belongs to a different account, for cross-account delivery.</p>
    ///             </li>
    ///             <li>
    ///                <p>An Amazon Kinesis Firehose delivery stream that belongs to the same account as the
    ///           subscription filter, for same-account delivery.</p>
    ///             </li>
    ///             <li>
    ///                <p>An AWS Lambda function that belongs to the same account as the subscription filter,
    ///           for same-account delivery.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Each log group can have up to two subscription filters associated with it. If you are
    ///       updating an existing filter, you must specify the correct name in <code>filterName</code>.
    ///       </p>
    ///          <p>To perform a <code>PutSubscriptionFilter</code> operation, you must also have the
    ///       <code>iam:PassRole</code> permission.</p>
    func putSubscriptionFilter(input: PutSubscriptionFilterInput) async throws -> PutSubscriptionFilterOutputResponse
    {
        typealias putSubscriptionFilterContinuation = CheckedContinuation<PutSubscriptionFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putSubscriptionFilterContinuation) in
            putSubscriptionFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Schedules a query of a log group using CloudWatch Logs Insights. You specify the log group
    ///       and time range to query and the query string to use.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax</a>.</p>
    ///
    ///          <p>Queries time out after 15 minutes of execution. If your queries are timing out, reduce the
    ///       time range being searched or partition your query into a number of queries.</p>
    func startQuery(input: StartQueryInput) async throws -> StartQueryOutputResponse
    {
        typealias startQueryContinuation = CheckedContinuation<StartQueryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startQueryContinuation) in
            startQuery(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Stops a CloudWatch Logs Insights query that is in progress. If the query has already ended, the operation
    ///     returns an error indicating that the specified query is not running.</p>
    func stopQuery(input: StopQueryInput) async throws -> StopQueryOutputResponse
    {
        typealias stopQueryContinuation = CheckedContinuation<StopQueryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopQueryContinuation) in
            stopQuery(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Adds or updates the specified tags for the specified log group.</p>
    ///          <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
    ///       To remove tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_UntagLogGroup.html">UntagLogGroup</a>.</p>
    ///          <p>For more information about tags, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html#log-group-tagging">Tag Log Groups in Amazon CloudWatch Logs</a>
    ///       in the <i>Amazon CloudWatch Logs User Guide</i>.</p>
    func tagLogGroup(input: TagLogGroupInput) async throws -> TagLogGroupOutputResponse
    {
        typealias tagLogGroupContinuation = CheckedContinuation<TagLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagLogGroupContinuation) in
            tagLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Tests the filter pattern of a metric filter against a sample of log event messages. You
    ///       can use this operation to validate the correctness of a metric filter pattern.</p>
    func testMetricFilter(input: TestMetricFilterInput) async throws -> TestMetricFilterOutputResponse
    {
        typealias testMetricFilterContinuation = CheckedContinuation<TestMetricFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: testMetricFilterContinuation) in
            testMetricFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Removes the specified tags from the specified log group.</p>
    ///          <p>To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup</a>.
    ///       To add tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_TagLogGroup.html">TagLogGroup</a>.</p>
    func untagLogGroup(input: UntagLogGroupInput) async throws -> UntagLogGroupOutputResponse
    {
        typealias untagLogGroupContinuation = CheckedContinuation<UntagLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagLogGroupContinuation) in
            untagLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
