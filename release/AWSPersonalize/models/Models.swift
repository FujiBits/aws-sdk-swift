// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension PersonalizeClientTypes.Algorithm: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
        case algorithmImage
        case creationDateTime
        case defaultHyperParameterRanges
        case defaultHyperParameters
        case defaultResourceConfig
        case lastUpdatedDateTime
        case name
        case roleArn
        case trainingInputMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let algorithmImage = algorithmImage {
            try encodeContainer.encode(algorithmImage, forKey: .algorithmImage)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let defaultHyperParameterRanges = defaultHyperParameterRanges {
            try encodeContainer.encode(defaultHyperParameterRanges, forKey: .defaultHyperParameterRanges)
        }
        if let defaultHyperParameters = defaultHyperParameters {
            var defaultHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultHyperParameters)
            for (dictKey0, hyperparameters0) in defaultHyperParameters {
                try defaultHyperParametersContainer.encode(hyperparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let defaultResourceConfig = defaultResourceConfig {
            var defaultResourceConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultResourceConfig)
            for (dictKey0, resourceconfig0) in defaultResourceConfig {
                try defaultResourceConfigContainer.encode(resourceconfig0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let trainingInputMode = trainingInputMode {
            try encodeContainer.encode(trainingInputMode, forKey: .trainingInputMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let algorithmImageDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.AlgorithmImage.self, forKey: .algorithmImage)
        algorithmImage = algorithmImageDecoded
        let defaultHyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultHyperParameters)
        var defaultHyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultHyperParametersContainer = defaultHyperParametersContainer {
            defaultHyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in defaultHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultHyperParameters = defaultHyperParametersDecoded0
        let defaultHyperParameterRangesDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DefaultHyperParameterRanges.self, forKey: .defaultHyperParameterRanges)
        defaultHyperParameterRanges = defaultHyperParameterRangesDecoded
        let defaultResourceConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultResourceConfig)
        var defaultResourceConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultResourceConfigContainer = defaultResourceConfigContainer {
            defaultResourceConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in defaultResourceConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultResourceConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultResourceConfig = defaultResourceConfigDecoded0
        let trainingInputModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trainingInputMode)
        trainingInputMode = trainingInputModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.Algorithm: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Algorithm(algorithmArn: \(Swift.String(describing: algorithmArn)), algorithmImage: \(Swift.String(describing: algorithmImage)), creationDateTime: \(Swift.String(describing: creationDateTime)), defaultHyperParameterRanges: \(Swift.String(describing: defaultHyperParameterRanges)), defaultHyperParameters: \(Swift.String(describing: defaultHyperParameters)), defaultResourceConfig: \(Swift.String(describing: defaultResourceConfig)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), trainingInputMode: \(Swift.String(describing: trainingInputMode)))"}
}

extension PersonalizeClientTypes {
    /// Describes a custom algorithm.
    public struct Algorithm: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm.
        public var algorithmArn: Swift.String?
        /// The URI of the Docker container for the algorithm image.
        public var algorithmImage: PersonalizeClientTypes.AlgorithmImage?
        /// The date and time (in Unix time) that the algorithm was created.
        public var creationDateTime: ClientRuntime.Date?
        /// Specifies the default hyperparameters, their ranges, and whether they
        ///       are tunable. A tunable hyperparameter can
        ///       have its value determined during hyperparameter optimization (HPO).
        public var defaultHyperParameterRanges: PersonalizeClientTypes.DefaultHyperParameterRanges?
        /// Specifies the default hyperparameters.
        public var defaultHyperParameters: [Swift.String:Swift.String]?
        /// Specifies the default maximum number of training jobs and parallel training jobs.
        public var defaultResourceConfig: [Swift.String:Swift.String]?
        /// The date and time (in Unix time) that the algorithm was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the algorithm.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the role.
        public var roleArn: Swift.String?
        /// The training input mode.
        public var trainingInputMode: Swift.String?

        public init (
            algorithmArn: Swift.String? = nil,
            algorithmImage: PersonalizeClientTypes.AlgorithmImage? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            defaultHyperParameterRanges: PersonalizeClientTypes.DefaultHyperParameterRanges? = nil,
            defaultHyperParameters: [Swift.String:Swift.String]? = nil,
            defaultResourceConfig: [Swift.String:Swift.String]? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            trainingInputMode: Swift.String? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.algorithmImage = algorithmImage
            self.creationDateTime = creationDateTime
            self.defaultHyperParameterRanges = defaultHyperParameterRanges
            self.defaultHyperParameters = defaultHyperParameters
            self.defaultResourceConfig = defaultResourceConfig
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.trainingInputMode = trainingInputMode
        }
    }

}

extension PersonalizeClientTypes.AlgorithmImage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dockerURI
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dockerURI = dockerURI {
            try encodeContainer.encode(dockerURI, forKey: .dockerURI)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dockerURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerURI)
        dockerURI = dockerURIDecoded
    }
}

extension PersonalizeClientTypes.AlgorithmImage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlgorithmImage(dockerURI: \(Swift.String(describing: dockerURI)), name: \(Swift.String(describing: name)))"}
}

extension PersonalizeClientTypes {
    /// Describes an algorithm image.
    public struct AlgorithmImage: Swift.Equatable {
        /// The URI of the Docker container for the algorithm image.
        /// This member is required.
        public var dockerURI: Swift.String?
        /// The name of the algorithm image.
        public var name: Swift.String?

        public init (
            dockerURI: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dockerURI = dockerURI
            self.name = name
        }
    }

}

extension PersonalizeClientTypes.AutoMLConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName
        case recipeList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let recipeList = recipeList {
            var recipeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recipeList)
            for arnlist0 in recipeList {
                try recipeListContainer.encode(arnlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let recipeListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recipeList)
        var recipeListDecoded0:[Swift.String]? = nil
        if let recipeListContainer = recipeListContainer {
            recipeListDecoded0 = [Swift.String]()
            for string0 in recipeListContainer {
                if let string0 = string0 {
                    recipeListDecoded0?.append(string0)
                }
            }
        }
        recipeList = recipeListDecoded0
    }
}

extension PersonalizeClientTypes.AutoMLConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoMLConfig(metricName: \(Swift.String(describing: metricName)), recipeList: \(Swift.String(describing: recipeList)))"}
}

extension PersonalizeClientTypes {
    /// When the solution performs AutoML (performAutoML is true in
    ///       CreateSolution), Amazon Personalize
    ///       determines which recipe, from the specified list, optimizes the given metric.
    ///       Amazon Personalize then uses that recipe for the solution.
    public struct AutoMLConfig: Swift.Equatable {
        /// The metric to optimize.
        public var metricName: Swift.String?
        /// The list of candidate recipes.
        public var recipeList: [Swift.String]?

        public init (
            metricName: Swift.String? = nil,
            recipeList: [Swift.String]? = nil
        )
        {
            self.metricName = metricName
            self.recipeList = recipeList
        }
    }

}

extension PersonalizeClientTypes.AutoMLResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bestRecipeArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bestRecipeArn = bestRecipeArn {
            try encodeContainer.encode(bestRecipeArn, forKey: .bestRecipeArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bestRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bestRecipeArn)
        bestRecipeArn = bestRecipeArnDecoded
    }
}

extension PersonalizeClientTypes.AutoMLResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AutoMLResult(bestRecipeArn: \(Swift.String(describing: bestRecipeArn)))"}
}

extension PersonalizeClientTypes {
    /// When the solution performs AutoML (performAutoML is true in
    ///       CreateSolution), specifies the recipe that best optimized the
    ///       specified metric.
    public struct AutoMLResult: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the best recipe.
        public var bestRecipeArn: Swift.String?

        public init (
            bestRecipeArn: Swift.String? = nil
        )
        {
            self.bestRecipeArn = bestRecipeArn
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
        case batchInferenceJobConfig
        case creationDateTime
        case failureReason
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case numResults
        case roleArn
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
        if let batchInferenceJobConfig = batchInferenceJobConfig {
            try encodeContainer.encode(batchInferenceJobConfig, forKey: .batchInferenceJobConfig)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let numResults = numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let batchInferenceJobConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobConfig.self, forKey: .batchInferenceJobConfig)
        batchInferenceJobConfig = batchInferenceJobConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.BatchInferenceJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchInferenceJob(batchInferenceJobArn: \(Swift.String(describing: batchInferenceJobArn)), batchInferenceJobConfig: \(Swift.String(describing: batchInferenceJobConfig)), creationDateTime: \(Swift.String(describing: creationDateTime)), failureReason: \(Swift.String(describing: failureReason)), filterArn: \(Swift.String(describing: filterArn)), jobInput: \(Swift.String(describing: jobInput)), jobName: \(Swift.String(describing: jobName)), jobOutput: \(Swift.String(describing: jobOutput)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), numResults: \(Swift.String(describing: numResults)), roleArn: \(Swift.String(describing: roleArn)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Contains information on a batch inference job.
    public struct BatchInferenceJob: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public var batchInferenceJobArn: Swift.String?
        /// A string to string map of the configuration details of a batch inference job.
        public var batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
        /// The time at which the batch inference job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch inference job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter used on the batch inference job.
        public var filterArn: Swift.String?
        /// The Amazon S3 path that leads to the input data used to generate the batch inference
        ///       job.
        public var jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
        /// The name of the batch inference job.
        public var jobName: Swift.String?
        /// The Amazon S3 bucket that contains the output data generated by the batch inference job.
        public var jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
        /// The time at which the batch inference job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The number of recommendations generated by the batch inference job. This number includes
        ///       the error messages generated for failed input records.
        public var numResults: Swift.Int?
        /// The ARN of the Amazon Identity and Access Management (IAM) role that requested the batch inference job.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution version from which the batch inference job
        ///       was created.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch inference job. The status is one of the following values:
        ///
        ///
        ///                PENDING
        ///
        ///
        ///                IN PROGRESS
        ///
        ///
        ///                ACTIVE
        ///
        ///
        ///                CREATE FAILED
        ///
        ///
        public var status: Swift.String?

        public init (
            batchInferenceJobArn: Swift.String? = nil,
            batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            jobInput: PersonalizeClientTypes.BatchInferenceJobInput? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            numResults: Swift.Int? = nil,
            roleArn: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.batchInferenceJobConfig = batchInferenceJobConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.jobInput = jobInput
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.numResults = numResults
            self.roleArn = roleArn
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemExplorationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperparameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
    }
}

extension PersonalizeClientTypes.BatchInferenceJobConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchInferenceJobConfig(itemExplorationConfig: \(Swift.String(describing: itemExplorationConfig)))"}
}

extension PersonalizeClientTypes {
    /// The configuration details of a batch inference job.
    public struct BatchInferenceJobConfig: Swift.Equatable {
        /// A string to string map specifying the exploration configuration hyperparameters, including explorationWeight and
        ///       explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when
        ///       recommending items.
        ///       See <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html">User-Personalization.
        public var itemExplorationConfig: [Swift.String:Swift.String]?

        public init (
            itemExplorationConfig: [Swift.String:Swift.String]? = nil
        )
        {
            self.itemExplorationConfig = itemExplorationConfig
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataSource = s3DataSource {
            try encodeContainer.encode(s3DataSource, forKey: .s3DataSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataSource)
        s3DataSource = s3DataSourceDecoded
    }
}

extension PersonalizeClientTypes.BatchInferenceJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchInferenceJobInput(s3DataSource: \(Swift.String(describing: s3DataSource)))"}
}

extension PersonalizeClientTypes {
    /// The input configuration of a batch inference job.
    public struct BatchInferenceJobInput: Swift.Equatable {
        /// The URI of the Amazon S3 location that contains your input data. The Amazon S3 bucket must be in the
        ///       same region as the API endpoint you are calling.
        /// This member is required.
        public var s3DataSource: PersonalizeClientTypes.S3DataConfig?

        public init (
            s3DataSource: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataSource = s3DataSource
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension PersonalizeClientTypes.BatchInferenceJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchInferenceJobOutput(s3DataDestination: \(Swift.String(describing: s3DataDestination)))"}
}

extension PersonalizeClientTypes {
    /// The output configuration parameters of a batch inference job.
    public struct BatchInferenceJobOutput: Swift.Equatable {
        /// Information on the Amazon S3 bucket in which the batch inference job's output is stored.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init (
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.BatchInferenceJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
        case creationDateTime
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension PersonalizeClientTypes.BatchInferenceJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchInferenceJobSummary(batchInferenceJobArn: \(Swift.String(describing: batchInferenceJobArn)), creationDateTime: \(Swift.String(describing: creationDateTime)), failureReason: \(Swift.String(describing: failureReason)), jobName: \(Swift.String(describing: jobName)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// A truncated version of the BatchInferenceJob datatype. The ListBatchInferenceJobs operation returns a list of batch inference job
    ///       summaries.
    public struct BatchInferenceJobSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the batch inference job.
        public var batchInferenceJobArn: Swift.String?
        /// The time at which the batch inference job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If the batch inference job failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The name of the batch inference job.
        public var jobName: Swift.String?
        /// The time at which the batch inference job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The ARN of the solution version used by the batch inference job.
        public var solutionVersionArn: Swift.String?
        /// The status of the batch inference job. The status is one of the following values:
        ///
        ///
        ///                PENDING
        ///
        ///
        ///                IN PROGRESS
        ///
        ///
        ///                ACTIVE
        ///
        ///
        ///                CREATE FAILED
        ///
        ///
        public var status: Swift.String?

        public init (
            batchInferenceJobArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.batchInferenceJobArn = batchInferenceJobArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.Campaign: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case campaignConfig
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case latestCampaignUpdate
        case minProvisionedTPS
        case name
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let campaignConfig = campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let latestCampaignUpdate = latestCampaignUpdate {
            try encodeContainer.encode(latestCampaignUpdate, forKey: .latestCampaignUpdate)
        }
        if let minProvisionedTPS = minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let latestCampaignUpdateDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignUpdateSummary.self, forKey: .latestCampaignUpdate)
        latestCampaignUpdate = latestCampaignUpdateDecoded
    }
}

extension PersonalizeClientTypes.Campaign: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Campaign(campaignArn: \(Swift.String(describing: campaignArn)), campaignConfig: \(Swift.String(describing: campaignConfig)), creationDateTime: \(Swift.String(describing: creationDateTime)), failureReason: \(Swift.String(describing: failureReason)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), latestCampaignUpdate: \(Swift.String(describing: latestCampaignUpdate)), minProvisionedTPS: \(Swift.String(describing: minProvisionedTPS)), name: \(Swift.String(describing: name)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Describes a deployed solution version, otherwise known as a campaign.
    ///       For more information on campaigns, see CreateCampaign.
    public struct Campaign: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the campaign.
        public var campaignArn: Swift.String?
        /// The configuration details of a campaign.
        public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
        /// The date and time (in Unix format) that the campaign was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a campaign fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix format) that the campaign was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Provides a summary of the properties of a campaign update. For a complete listing, call the
        ///       DescribeCampaign API.
        public var latestCampaignUpdate: PersonalizeClientTypes.CampaignUpdateSummary?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second.
        public var minProvisionedTPS: Swift.Int?
        /// The name of the campaign.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of a specific version of the solution.
        public var solutionVersionArn: Swift.String?
        /// The status of the campaign.
        ///          A campaign can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING > DELETE IN_PROGRESS
        ///
        ///
        public var status: Swift.String?

        public init (
            campaignArn: Swift.String? = nil,
            campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestCampaignUpdate: PersonalizeClientTypes.CampaignUpdateSummary? = nil,
            minProvisionedTPS: Swift.Int? = nil,
            name: Swift.String? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignArn = campaignArn
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestCampaignUpdate = latestCampaignUpdate
            self.minProvisionedTPS = minProvisionedTPS
            self.name = name
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.CampaignConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemExplorationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemExplorationConfig = itemExplorationConfig {
            var itemExplorationConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .itemExplorationConfig)
            for (dictKey0, hyperparameters0) in itemExplorationConfig {
                try itemExplorationConfigContainer.encode(hyperparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemExplorationConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .itemExplorationConfig)
        var itemExplorationConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let itemExplorationConfigContainer = itemExplorationConfigContainer {
            itemExplorationConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in itemExplorationConfigContainer {
                if let parametervalue0 = parametervalue0 {
                    itemExplorationConfigDecoded0?[key0] = parametervalue0
                }
            }
        }
        itemExplorationConfig = itemExplorationConfigDecoded0
    }
}

extension PersonalizeClientTypes.CampaignConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CampaignConfig(itemExplorationConfig: \(Swift.String(describing: itemExplorationConfig)))"}
}

extension PersonalizeClientTypes {
    /// The configuration details of a campaign.
    public struct CampaignConfig: Swift.Equatable {
        /// A string to string map specifying the exploration configuration hyperparameters, including explorationWeight and
        ///       explorationItemAgeCutOff, you want to use to configure the amount of item exploration Amazon Personalize uses when
        ///       recommending items. Provide itemExplorationConfig data only if your solution uses the
        ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html">User-Personalization recipe.
        public var itemExplorationConfig: [Swift.String:Swift.String]?

        public init (
            itemExplorationConfig: [Swift.String:Swift.String]? = nil
        )
        {
            self.itemExplorationConfig = itemExplorationConfig
        }
    }

}

extension PersonalizeClientTypes.CampaignSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes.CampaignSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CampaignSummary(campaignArn: \(Swift.String(describing: campaignArn)), creationDateTime: \(Swift.String(describing: creationDateTime)), failureReason: \(Swift.String(describing: failureReason)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a campaign. For a complete listing, call the
    ///       DescribeCampaign API.
    public struct CampaignSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the campaign.
        public var campaignArn: Swift.String?
        /// The date and time (in Unix time) that the campaign was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a campaign fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the campaign was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the campaign.
        public var name: Swift.String?
        /// The status of the campaign.
        ///          A campaign can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING > DELETE IN_PROGRESS
        ///
        ///
        public var status: Swift.String?

        public init (
            campaignArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignArn = campaignArn
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.CampaignUpdateSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignConfig
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case minProvisionedTPS
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignConfig = campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let minProvisionedTPS = minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.CampaignUpdateSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CampaignUpdateSummary(campaignConfig: \(Swift.String(describing: campaignConfig)), creationDateTime: \(Swift.String(describing: creationDateTime)), failureReason: \(Swift.String(describing: failureReason)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), minProvisionedTPS: \(Swift.String(describing: minProvisionedTPS)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a campaign update. For a complete listing, call the
    ///       DescribeCampaign API.
    public struct CampaignUpdateSummary: Swift.Equatable {
        /// The configuration details of a campaign.
        public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
        /// The date and time (in Unix time) that the campaign update was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a campaign update fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the campaign update was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Specifies the requested minimum provisioned transactions (recommendations) per second that
        ///       Amazon Personalize will support.
        public var minProvisionedTPS: Swift.Int?
        /// The Amazon Resource Name (ARN) of the deployed solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the campaign update.
        ///          A campaign update can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING > DELETE IN_PROGRESS
        ///
        ///
        public var status: Swift.String?

        public init (
            campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            minProvisionedTPS: Swift.Int? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.campaignConfig = campaignConfig
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.minProvisionedTPS = minProvisionedTPS
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.CategoricalHyperParameterRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for categoricalvalues0 in values {
                try valuesContainer.encode(categoricalvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension PersonalizeClientTypes.CategoricalHyperParameterRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CategoricalHyperParameterRange(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension PersonalizeClientTypes {
    /// Provides the name and range of a categorical hyperparameter.
    public struct CategoricalHyperParameterRange: Swift.Equatable {
        /// The name of the hyperparameter.
        public var name: Swift.String?
        /// A list of the categories for the hyperparameter.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension PersonalizeClientTypes.ContinuousHyperParameterRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxValue != 0.0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0.0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decode(Swift.Double.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decode(Swift.Double.self, forKey: .maxValue)
        maxValue = maxValueDecoded
    }
}

extension PersonalizeClientTypes.ContinuousHyperParameterRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContinuousHyperParameterRange(maxValue: \(Swift.String(describing: maxValue)), minValue: \(Swift.String(describing: minValue)), name: \(Swift.String(describing: name)))"}
}

extension PersonalizeClientTypes {
    /// Provides the name and range of a continuous hyperparameter.
    public struct ContinuousHyperParameterRange: Swift.Equatable {
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Double
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Double
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init (
            maxValue: Swift.Double = 0.0,
            minValue: Swift.Double = 0.0,
            name: Swift.String? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

public struct CreateBatchInferenceJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBatchInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBatchInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBatchInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBatchInferenceJobOutputError>
}

extension CreateBatchInferenceJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBatchInferenceJobInput(batchInferenceJobConfig: \(Swift.String(describing: batchInferenceJobConfig)), filterArn: \(Swift.String(describing: filterArn)), jobInput: \(Swift.String(describing: jobInput)), jobName: \(Swift.String(describing: jobName)), jobOutput: \(Swift.String(describing: jobOutput)), numResults: \(Swift.String(describing: numResults)), roleArn: \(Swift.String(describing: roleArn)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)))"}
}

extension CreateBatchInferenceJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobConfig
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobConfig = batchInferenceJobConfig {
            try encodeContainer.encode(batchInferenceJobConfig, forKey: .batchInferenceJobConfig)
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let jobInput = jobInput {
            try encodeContainer.encode(jobInput, forKey: .jobInput)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let numResults = numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct CreateBatchInferenceJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBatchInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBatchInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBatchInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBatchInferenceJobOutputError>
}

public struct CreateBatchInferenceJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBatchInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBatchInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBatchInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBatchInferenceJobOutputError>
}

public struct CreateBatchInferenceJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBatchInferenceJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateBatchInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateBatchInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBatchInferenceJobOutputError>
}

public struct CreateBatchInferenceJobInput: Swift.Equatable {
    /// The configuration details of a batch inference job.
    public var batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
    /// The ARN of the filter to apply to the batch inference job. For more information on using
    ///       filters, see
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/filter-batch.html">Filtering Batch Recommendations..
    public var filterArn: Swift.String?
    /// The Amazon S3 path that leads to the input file to base your recommendations on. The input
    ///       material must be in JSON format.
    /// This member is required.
    public var jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
    /// The name of the batch inference job to create.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the Amazon S3 bucket where the job's output will be stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
    /// The number of recommendations to retreive.
    public var numResults: Swift.Int?
    /// The ARN of the Amazon Identity and Access Management role that has permissions to read and write to your input and output
    ///       Amazon S3 buckets respectively.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version that will be used to generate the
    ///       batch inference recommendations.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init (
        batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig? = nil,
        filterArn: Swift.String? = nil,
        jobInput: PersonalizeClientTypes.BatchInferenceJobInput? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput? = nil,
        numResults: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.batchInferenceJobConfig = batchInferenceJobConfig
        self.filterArn = filterArn
        self.jobInput = jobInput
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.numResults = numResults
        self.roleArn = roleArn
        self.solutionVersionArn = solutionVersionArn
    }
}

struct CreateBatchInferenceJobInputBody: Swift.Equatable {
    public let jobName: Swift.String?
    public let solutionVersionArn: Swift.String?
    public let filterArn: Swift.String?
    public let numResults: Swift.Int?
    public let jobInput: PersonalizeClientTypes.BatchInferenceJobInput?
    public let jobOutput: PersonalizeClientTypes.BatchInferenceJobOutput?
    public let roleArn: Swift.String?
    public let batchInferenceJobConfig: PersonalizeClientTypes.BatchInferenceJobConfig?
}

extension CreateBatchInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobConfig
        case filterArn
        case jobInput
        case jobName
        case jobOutput
        case numResults
        case roleArn
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let jobInputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobInput.self, forKey: .jobInput)
        jobInput = jobInputDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let batchInferenceJobConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJobConfig.self, forKey: .batchInferenceJobConfig)
        batchInferenceJobConfig = batchInferenceJobConfigDecoded
    }
}

extension CreateBatchInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBatchInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBatchInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBatchInferenceJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBatchInferenceJobOutputResponse(batchInferenceJobArn: \(Swift.String(describing: batchInferenceJobArn)))"}
}

extension CreateBatchInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBatchInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchInferenceJobArn = output.batchInferenceJobArn
        } else {
            self.batchInferenceJobArn = nil
        }
    }
}

public struct CreateBatchInferenceJobOutputResponse: Swift.Equatable {
    /// The ARN of the batch inference job.
    public var batchInferenceJobArn: Swift.String?

    public init (
        batchInferenceJobArn: Swift.String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

struct CreateBatchInferenceJobOutputResponseBody: Swift.Equatable {
    public let batchInferenceJobArn: Swift.String?
}

extension CreateBatchInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
    }
}

public struct CreateCampaignInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCampaignOutputError>
}

extension CreateCampaignInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCampaignInput(campaignConfig: \(Swift.String(describing: campaignConfig)), minProvisionedTPS: \(Swift.String(describing: minProvisionedTPS)), name: \(Swift.String(describing: name)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)))"}
}

extension CreateCampaignInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignConfig
        case minProvisionedTPS
        case name
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignConfig = campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let minProvisionedTPS = minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct CreateCampaignInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCampaignOutputError>
}

public struct CreateCampaignInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCampaignOutputError>
}

public struct CreateCampaignInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCampaignInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateCampaignInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateCampaignInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCampaignOutputError>
}

public struct CreateCampaignInput: Swift.Equatable {
    /// The configuration details of a campaign.
    public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
    /// Specifies the requested minimum provisioned transactions (recommendations) per second that
    ///       Amazon Personalize will support.
    public var minProvisionedTPS: Swift.Int?
    /// A name for the new campaign. The campaign name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version to deploy.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init (
        campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
        minProvisionedTPS: Swift.Int? = nil,
        name: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.name = name
        self.solutionVersionArn = solutionVersionArn
    }
}

struct CreateCampaignInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let solutionVersionArn: Swift.String?
    public let minProvisionedTPS: Swift.Int?
    public let campaignConfig: PersonalizeClientTypes.CampaignConfig?
}

extension CreateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignConfig
        case minProvisionedTPS
        case name
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
    }
}

extension CreateCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCampaignOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCampaignOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCampaignOutputResponse(campaignArn: \(Swift.String(describing: campaignArn)))"}
}

extension CreateCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaignArn = output.campaignArn
        } else {
            self.campaignArn = nil
        }
    }
}

public struct CreateCampaignOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var campaignArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct CreateCampaignOutputResponseBody: Swift.Equatable {
    public let campaignArn: Swift.String?
}

extension CreateCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

public struct CreateDatasetExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetExportJobOutputError>
}

extension CreateDatasetExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetExportJobInput(datasetArn: \(Swift.String(describing: datasetArn)), ingestionMode: \(Swift.String(describing: ingestionMode)), jobName: \(Swift.String(describing: jobName)), jobOutput: \(Swift.String(describing: jobOutput)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension CreateDatasetExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case ingestionMode
        case jobName
        case jobOutput
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let ingestionMode = ingestionMode {
            try encodeContainer.encode(ingestionMode.rawValue, forKey: .ingestionMode)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct CreateDatasetExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetExportJobOutputError>
}

public struct CreateDatasetExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetExportJobOutputError>
}

public struct CreateDatasetExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDatasetExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDatasetExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetExportJobOutputError>
}

public struct CreateDatasetExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset that contains the data to export.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The data to export, based on how you imported the data. You can choose to export only BULK data that you imported using a dataset import job,
    ///       only PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL
    ///       for both types. The default value is PUT.
    ///
    public var ingestionMode: PersonalizeClientTypes.IngestionMode?
    /// The name for the dataset export job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The path to the Amazon S3 bucket where the job's output is stored.
    /// This member is required.
    public var jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
    /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your
    ///       output Amazon S3 bucket.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil,
        ingestionMode: PersonalizeClientTypes.IngestionMode? = nil,
        jobName: Swift.String? = nil,
        jobOutput: PersonalizeClientTypes.DatasetExportJobOutput? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.ingestionMode = ingestionMode
        self.jobName = jobName
        self.jobOutput = jobOutput
        self.roleArn = roleArn
    }
}

struct CreateDatasetExportJobInputBody: Swift.Equatable {
    public let jobName: Swift.String?
    public let datasetArn: Swift.String?
    public let ingestionMode: PersonalizeClientTypes.IngestionMode?
    public let roleArn: Swift.String?
    public let jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
}

extension CreateDatasetExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case ingestionMode
        case jobName
        case jobOutput
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.IngestionMode.self, forKey: .ingestionMode)
        ingestionMode = ingestionModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetExportJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
    }
}

extension CreateDatasetExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetExportJobOutputResponse(datasetExportJobArn: \(Swift.String(describing: datasetExportJobArn)))"}
}

extension CreateDatasetExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetExportJobArn = output.datasetExportJobArn
        } else {
            self.datasetExportJobArn = nil
        }
    }
}

public struct CreateDatasetExportJobOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset export job.
    public var datasetExportJobArn: Swift.String?

    public init (
        datasetExportJobArn: Swift.String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

struct CreateDatasetExportJobOutputResponseBody: Swift.Equatable {
    public let datasetExportJobArn: Swift.String?
}

extension CreateDatasetExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
    }
}

public struct CreateDatasetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetGroupOutputError>
}

extension CreateDatasetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetGroupInput(kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension CreateDatasetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
        case name
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct CreateDatasetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDatasetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDatasetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of a Key Management Service (KMS) key used to encrypt the datasets.
    public var kmsKeyArn: Swift.String?
    /// The name for the new dataset group.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the Identity and Access Management (IAM) role that has permissions to access the Key Management Service (KMS) key. Supplying an IAM
    ///       role is only valid when also specifying a KMS key.
    public var roleArn: Swift.String?

    public init (
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.roleArn = roleArn
    }
}

struct CreateDatasetGroupInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let roleArn: Swift.String?
    public let kmsKeyArn: Swift.String?
}

extension CreateDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
        case name
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension CreateDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetGroupOutputResponse(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)))"}
}

extension CreateDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroupArn = output.datasetGroupArn
        } else {
            self.datasetGroupArn = nil
        }
    }
}

public struct CreateDatasetGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the new dataset group.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct CreateDatasetGroupOutputResponseBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
}

extension CreateDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

public struct CreateDatasetImportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetImportJobOutputError>
}

extension CreateDatasetImportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetImportJobInput(dataSource: \(Swift.String(describing: dataSource)), datasetArn: \(Swift.String(describing: datasetArn)), jobName: \(Swift.String(describing: jobName)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension CreateDatasetImportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case datasetArn
        case jobName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct CreateDatasetImportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetImportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDatasetImportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDatasetImportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInput: Swift.Equatable {
    /// The Amazon S3 bucket that contains the training data to import.
    /// This member is required.
    public var dataSource: PersonalizeClientTypes.DataSource?
    /// The ARN of the dataset that receives the imported data.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The name for the dataset import job.
    /// This member is required.
    public var jobName: Swift.String?
    /// The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        dataSource: PersonalizeClientTypes.DataSource? = nil,
        datasetArn: Swift.String? = nil,
        jobName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.jobName = jobName
        self.roleArn = roleArn
    }
}

struct CreateDatasetImportJobInputBody: Swift.Equatable {
    public let jobName: Swift.String?
    public let datasetArn: Swift.String?
    public let dataSource: PersonalizeClientTypes.DataSource?
    public let roleArn: Swift.String?
}

extension CreateDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case datasetArn
        case jobName
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CreateDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetImportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetImportJobOutputResponse(datasetImportJobArn: \(Swift.String(describing: datasetImportJobArn)))"}
}

extension CreateDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobArn = output.datasetImportJobArn
        } else {
            self.datasetImportJobArn = nil
        }
    }
}

public struct CreateDatasetImportJobOutputResponse: Swift.Equatable {
    /// The ARN of the dataset import job.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct CreateDatasetImportJobOutputResponseBody: Swift.Equatable {
    public let datasetImportJobArn: Swift.String?
}

extension CreateDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), datasetType: \(Swift.String(describing: datasetType)), name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension CreateDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case datasetType
        case name
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDatasetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to add the dataset to.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The type of dataset.
    ///          One of the following (case insensitive) values:
    ///
    ///
    ///                Interactions
    ///
    ///
    ///                Items
    ///
    ///
    ///                Users
    ///
    ///
    /// This member is required.
    public var datasetType: Swift.String?
    /// The name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the schema to associate with the dataset. The schema defines the dataset
    ///       fields.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        datasetType: Swift.String? = nil,
        name: Swift.String? = nil,
        schemaArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.datasetType = datasetType
        self.name = name
        self.schemaArn = schemaArn
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let schemaArn: Swift.String?
    public let datasetGroupArn: Swift.String?
    public let datasetType: Swift.String?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case datasetType
        case name
        case schemaArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDatasetOutputResponse(datasetArn: \(Swift.String(describing: datasetArn)))"}
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// The ARN of the dataset.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    public let datasetArn: Swift.String?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

public struct CreateEventTrackerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventTrackerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventTrackerOutputError>
}

extension CreateEventTrackerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventTrackerInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), name: \(Swift.String(describing: name)))"}
}

extension CreateEventTrackerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateEventTrackerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventTrackerOutputError>
}

public struct CreateEventTrackerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEventTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEventTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventTrackerOutputError>
}

public struct CreateEventTrackerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEventTrackerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateEventTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEventTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEventTrackerOutputError>
}

public struct CreateEventTrackerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The name for the event tracker.
    /// This member is required.
    public var name: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.name = name
    }
}

struct CreateEventTrackerInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let datasetGroupArn: Swift.String?
}

extension CreateEventTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension CreateEventTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventTrackerOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventTrackerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEventTrackerOutputResponse(eventTrackerArn: \(Swift.String(describing: eventTrackerArn)), trackingId: \(Swift.String(describing: trackingId)))"}
}

extension CreateEventTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEventTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventTrackerArn = output.eventTrackerArn
            self.trackingId = output.trackingId
        } else {
            self.eventTrackerArn = nil
            self.trackingId = nil
        }
    }
}

public struct CreateEventTrackerOutputResponse: Swift.Equatable {
    /// The ARN of the event tracker.
    public var eventTrackerArn: Swift.String?
    /// The ID of the event tracker. Include this ID in requests to the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents API.
    public var trackingId: Swift.String?

    public init (
        eventTrackerArn: Swift.String? = nil,
        trackingId: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
        self.trackingId = trackingId
    }
}

struct CreateEventTrackerOutputResponseBody: Swift.Equatable {
    public let eventTrackerArn: Swift.String?
    public let trackingId: Swift.String?
}

extension CreateEventTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
        case trackingId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let trackingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingId)
        trackingId = trackingIdDecoded
    }
}

public struct CreateFilterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFilterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFilterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFilterOutputError>
}

extension CreateFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFilterInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), filterExpression: \(Swift.String(describing: filterExpression)), name: \(Swift.String(describing: name)))"}
}

extension CreateFilterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case filterExpression
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let filterExpression = filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateFilterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFilterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFilterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFilterOutputError>
}

public struct CreateFilterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFilterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFilterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFilterOutputError>
}

public struct CreateFilterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFilterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateFilterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFilterInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFilterOutputError>
}

public struct CreateFilterInput: Swift.Equatable {
    /// The ARN of the dataset group that the filter will belong to.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// The filter expression defines which items are included or excluded from recommendations. Filter expression must follow specific format rules.
    ///             For information about filter expression structure and syntax, see
    ///              filter-expressions.
    /// This member is required.
    public var filterExpression: Swift.String?
    /// The name of the filter to create.
    /// This member is required.
    public var name: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        filterExpression: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.filterExpression = filterExpression
        self.name = name
    }
}

struct CreateFilterInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let datasetGroupArn: Swift.String?
    public let filterExpression: Swift.String?
}

extension CreateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case filterExpression
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
    }
}

extension CreateFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFilterOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFilterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFilterOutputResponse(filterArn: \(Swift.String(describing: filterArn)))"}
}

extension CreateFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filterArn = output.filterArn
        } else {
            self.filterArn = nil
        }
    }
}

public struct CreateFilterOutputResponse: Swift.Equatable {
    /// The ARN of the new filter.
    public var filterArn: Swift.String?

    public init (
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct CreateFilterOutputResponseBody: Swift.Equatable {
    public let filterArn: Swift.String?
}

extension CreateFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

public struct CreateSchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSchemaOutputError>
}

extension CreateSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSchemaInput(name: \(Swift.String(describing: name)), schema: \(Swift.String(describing: schema)))"}
}

extension CreateSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

public struct CreateSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSchemaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSchemaOutputError>
}

public struct CreateSchemaInput: Swift.Equatable {
    /// The name for the schema.
    /// This member is required.
    public var name: Swift.String?
    /// A schema in Avro JSON format.
    /// This member is required.
    public var schema: Swift.String?

    public init (
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.name = name
        self.schema = schema
    }
}

struct CreateSchemaInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let schema: Swift.String?
}

extension CreateSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension CreateSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSchemaOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSchemaOutputResponse(schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension CreateSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.schemaArn = output.schemaArn
        } else {
            self.schemaArn = nil
        }
    }
}

public struct CreateSchemaOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created schema.
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct CreateSchemaOutputResponseBody: Swift.Equatable {
    public let schemaArn: Swift.String?
}

extension CreateSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

public struct CreateSolutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSolutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSolutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSolutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSolutionOutputError>
}

extension CreateSolutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolutionInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), eventType: \(Swift.String(describing: eventType)), name: \(Swift.String(describing: name)), performAutoML: \(Swift.String(describing: performAutoML)), performHPO: \(Swift.String(describing: performHPO)), recipeArn: \(Swift.String(describing: recipeArn)), solutionConfig: \(Swift.String(describing: solutionConfig)))"}
}

extension CreateSolutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case eventType
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if let performHPO = performHPO {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionConfig = solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
    }
}

public struct CreateSolutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSolutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSolutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSolutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSolutionOutputError>
}

public struct CreateSolutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSolutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSolutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSolutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSolutionOutputError>
}

public struct CreateSolutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSolutionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSolutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSolutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSolutionOutputError>
}

public struct CreateSolutionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
    /// This member is required.
    public var datasetGroupArn: Swift.String?
    /// When your have multiple event types (using an EVENT_TYPE schema field),
    ///       this parameter specifies which event type (for example, 'click' or 'like') is used for
    ///       training the model.
    ///          If you do not provide an eventType, Amazon Personalize will use all interactions for training with
    ///        equal weight regardless of type.
    public var eventType: Swift.String?
    /// The name for the solution.
    /// This member is required.
    public var name: Swift.String?
    /// Whether to perform automated machine learning (AutoML). The default is false.
    ///       For this case, you must specify recipeArn.
    ///          When set to true, Amazon Personalize analyzes your training data and selects
    ///       the optimal USER_PERSONALIZATION recipe and hyperparameters. In this case, you must omit
    ///       recipeArn. Amazon Personalize determines the optimal recipe by running tests with
    ///       different values for the hyperparameters.
    ///       AutoML lengthens the training process as compared to selecting a specific recipe.
    public var performAutoML: Swift.Bool
    /// Whether to perform hyperparameter optimization (HPO) on the specified or selected recipe.
    ///       The default is false.
    ///          When performing AutoML, this parameter is always true and you
    ///       should not set it to false.
    public var performHPO: Swift.Bool?
    /// The ARN of the recipe to use for model training. Only specified when
    ///       performAutoML is false.
    public var recipeArn: Swift.String?
    /// The configuration to use with the solution. When performAutoML is set to
    ///       true, Amazon Personalize only evaluates the autoMLConfig section
    ///       of the solution configuration.
    ///
    ///             Amazon Personalize doesn't support configuring the hpoObjective
    ///         at this time.
    ///
    public var solutionConfig: PersonalizeClientTypes.SolutionConfig?

    public init (
        datasetGroupArn: Swift.String? = nil,
        eventType: Swift.String? = nil,
        name: Swift.String? = nil,
        performAutoML: Swift.Bool = false,
        performHPO: Swift.Bool? = nil,
        recipeArn: Swift.String? = nil,
        solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.eventType = eventType
        self.name = name
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.recipeArn = recipeArn
        self.solutionConfig = solutionConfig
    }
}

struct CreateSolutionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let performHPO: Swift.Bool?
    public let performAutoML: Swift.Bool
    public let recipeArn: Swift.String?
    public let datasetGroupArn: Swift.String?
    public let eventType: Swift.String?
    public let solutionConfig: PersonalizeClientTypes.SolutionConfig?
}

extension CreateSolutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case eventType
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decode(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
    }
}

extension CreateSolutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSolutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSolutionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSolutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolutionOutputResponse(solutionArn: \(Swift.String(describing: solutionArn)))"}
}

extension CreateSolutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSolutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.solutionArn = output.solutionArn
        } else {
            self.solutionArn = nil
        }
    }
}

public struct CreateSolutionOutputResponse: Swift.Equatable {
    /// The ARN of the solution.
    public var solutionArn: Swift.String?

    public init (
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct CreateSolutionOutputResponseBody: Swift.Equatable {
    public let solutionArn: Swift.String?
}

extension CreateSolutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

public struct CreateSolutionVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSolutionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSolutionVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSolutionVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSolutionVersionOutputError>
}

extension CreateSolutionVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolutionVersionInput(solutionArn: \(Swift.String(describing: solutionArn)), trainingMode: \(Swift.String(describing: trainingMode)))"}
}

extension CreateSolutionVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
        case trainingMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let trainingMode = trainingMode {
            try encodeContainer.encode(trainingMode.rawValue, forKey: .trainingMode)
        }
    }
}

public struct CreateSolutionVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSolutionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSolutionVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSolutionVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSolutionVersionOutputError>
}

public struct CreateSolutionVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSolutionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateSolutionVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateSolutionVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSolutionVersionOutputError>
}

public struct CreateSolutionVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateSolutionVersionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateSolutionVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateSolutionVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateSolutionVersionOutputError>
}

public struct CreateSolutionVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution containing the training configuration
    ///       information.
    /// This member is required.
    public var solutionArn: Swift.String?
    /// The scope of training to be performed when creating the solution version. The
    ///         FULL option trains the solution version based on the entirety of the input
    ///       solution's training data, while the UPDATE option processes only the data that
    ///       has changed in comparison to the input solution. Choose UPDATE when you want to
    ///       incrementally update your solution version instead of creating an entirely new one.
    ///
    ///             The UPDATE option can only be used when you already have an active solution
    ///         version created from the input solution using the FULL option and the input
    ///         solution was trained with the
    ///         <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html">User-Personalization
    ///         recipe or the
    ///         <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-hrnn-coldstart.html">HRNN-Coldstart recipe.
    ///
    public var trainingMode: PersonalizeClientTypes.TrainingMode?

    public init (
        solutionArn: Swift.String? = nil,
        trainingMode: PersonalizeClientTypes.TrainingMode? = nil
    )
    {
        self.solutionArn = solutionArn
        self.trainingMode = trainingMode
    }
}

struct CreateSolutionVersionInputBody: Swift.Equatable {
    public let solutionArn: Swift.String?
    public let trainingMode: PersonalizeClientTypes.TrainingMode?
}

extension CreateSolutionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
        case trainingMode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let trainingModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TrainingMode.self, forKey: .trainingMode)
        trainingMode = trainingModeDecoded
    }
}

extension CreateSolutionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSolutionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSolutionVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSolutionVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSolutionVersionOutputResponse(solutionVersionArn: \(Swift.String(describing: solutionVersionArn)))"}
}

extension CreateSolutionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSolutionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.solutionVersionArn = output.solutionVersionArn
        } else {
            self.solutionVersionArn = nil
        }
    }
}

public struct CreateSolutionVersionOutputResponse: Swift.Equatable {
    /// The ARN of the new solution version.
    public var solutionVersionArn: Swift.String?

    public init (
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct CreateSolutionVersionOutputResponseBody: Swift.Equatable {
    public let solutionVersionArn: Swift.String?
}

extension CreateSolutionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension PersonalizeClientTypes.DataSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataLocation = dataLocation {
            try encodeContainer.encode(dataLocation, forKey: .dataLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
    }
}

extension PersonalizeClientTypes.DataSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataSource(dataLocation: \(Swift.String(describing: dataLocation)))"}
}

extension PersonalizeClientTypes {
    /// Describes the data source that contains the data to upload to a dataset.
    public struct DataSource: Swift.Equatable {
        /// The path to the Amazon S3 bucket where the data that you want to upload to your dataset is
        ///       stored. For example:
        ///
        ///             s3://bucket-name/folder-name/
        ///
        public var dataLocation: Swift.String?

        public init (
            dataLocation: Swift.String? = nil
        )
        {
            self.dataLocation = dataLocation
        }
    }

}

extension PersonalizeClientTypes.Dataset: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetArn
        case datasetGroupArn
        case datasetType
        case lastUpdatedDateTime
        case name
        case schemaArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.Dataset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Dataset(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetArn: \(Swift.String(describing: datasetArn)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), datasetType: \(Swift.String(describing: datasetType)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides metadata for a dataset.
    public struct Dataset: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset that you want metadata for.
        public var datasetArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// One of the following values:
        ///
        ///
        ///                Interactions
        ///
        ///
        ///                Items
        ///
        ///
        ///                Users
        ///
        ///
        public var datasetType: Swift.String?
        /// A time stamp that shows when the dataset was updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset.
        public var name: Swift.String?
        /// The ARN of the associated schema.
        public var schemaArn: Swift.String?
        /// The status of the dataset.
        ///          A dataset can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING > DELETE IN_PROGRESS
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetGroupArn: Swift.String? = nil,
            datasetType: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetGroupArn = datasetGroupArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetExportJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetArn
        case datasetExportJobArn
        case failureReason
        case ingestionMode
        case jobName
        case jobOutput
        case lastUpdatedDateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetExportJobArn = datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let ingestionMode = ingestionMode {
            try encodeContainer.encode(ingestionMode.rawValue, forKey: .ingestionMode)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutput = jobOutput {
            try encodeContainer.encode(jobOutput, forKey: .jobOutput)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.IngestionMode.self, forKey: .ingestionMode)
        ingestionMode = ingestionModeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let jobOutputDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetExportJobOutput.self, forKey: .jobOutput)
        jobOutput = jobOutputDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes.DatasetExportJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetExportJob(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetArn: \(Swift.String(describing: datasetArn)), datasetExportJobArn: \(Swift.String(describing: datasetExportJobArn)), failureReason: \(Swift.String(describing: failureReason)), ingestionMode: \(Swift.String(describing: ingestionMode)), jobName: \(Swift.String(describing: jobName)), jobOutput: \(Swift.String(describing: jobOutput)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Describes a job that exports a dataset to an Amazon S3 bucket. For more information, see CreateDatasetExportJob.
    ///          A dataset export job can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    public struct DatasetExportJob: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset export job.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset to export.
        public var datasetArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public var datasetExportJobArn: Swift.String?
        /// If a dataset export job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The data to export, based on how you imported the data. You can choose to export BULK data that you imported using a dataset import job,
        ///       PUT data that you imported incrementally (using the console, PutEvents, PutUsers and PutItems operations), or ALL
        ///       for both types. The default value is PUT.
        ///
        public var ingestionMode: PersonalizeClientTypes.IngestionMode?
        /// The name of the export job.
        public var jobName: Swift.String?
        /// The path to the Amazon S3 bucket where the job's output is stored.  For example:
        ///
        ///             s3://bucket-name/folder-name/
        ///
        public var jobOutput: PersonalizeClientTypes.DatasetExportJobOutput?
        /// The date and time (in Unix time) the status of the dataset export job was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the IAM service role that has permissions to add data to your
        ///       output Amazon S3 bucket.
        public var roleArn: Swift.String?
        /// The status of the dataset export job.
        ///          A dataset export job can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetExportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            ingestionMode: PersonalizeClientTypes.IngestionMode? = nil,
            jobName: Swift.String? = nil,
            jobOutput: PersonalizeClientTypes.DatasetExportJobOutput? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.ingestionMode = ingestionMode
            self.jobName = jobName
            self.jobOutput = jobOutput
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetExportJobOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DataDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3DataDestination = s3DataDestination {
            try encodeContainer.encode(s3DataDestination, forKey: .s3DataDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DataDestinationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.S3DataConfig.self, forKey: .s3DataDestination)
        s3DataDestination = s3DataDestinationDecoded
    }
}

extension PersonalizeClientTypes.DatasetExportJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetExportJobOutput(s3DataDestination: \(Swift.String(describing: s3DataDestination)))"}
}

extension PersonalizeClientTypes {
    /// The output configuration parameters of a dataset export job.
    public struct DatasetExportJobOutput: Swift.Equatable {
        /// The configuration details of an Amazon S3 input or output bucket.
        /// This member is required.
        public var s3DataDestination: PersonalizeClientTypes.S3DataConfig?

        public init (
            s3DataDestination: PersonalizeClientTypes.S3DataConfig? = nil
        )
        {
            self.s3DataDestination = s3DataDestination
        }
    }

}

extension PersonalizeClientTypes.DatasetExportJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetExportJobArn
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetExportJobArn = datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes.DatasetExportJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetExportJobSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetExportJobArn: \(Swift.String(describing: datasetExportJobArn)), failureReason: \(Swift.String(describing: failureReason)), jobName: \(Swift.String(describing: jobName)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset export job. For a complete listing, call the
    ///       DescribeDatasetExportJob API.
    public struct DatasetExportJobSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset export job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset export job.
        public var datasetExportJobArn: Swift.String?
        /// If a dataset export job fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The name of the dataset export job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) that the dataset export job status was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The status of the dataset export job.
        ///          A dataset export job can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetExportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetExportJobArn = datasetExportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetGroup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case kmsKeyArn
        case lastUpdatedDateTime
        case name
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes.DatasetGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetGroup(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), failureReason: \(Swift.String(describing: failureReason)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// A dataset group is a collection of related datasets (Interactions, User, and Item). You
    ///       create a dataset group by calling CreateDatasetGroup. You then create a
    ///       dataset and add it to a dataset group by calling CreateDataset. The dataset
    ///       group is used to create and train a solution by calling CreateSolution. A
    ///       dataset group can contain only one of each type of dataset.
    ///          You can specify an Key Management Service (KMS) key to encrypt the datasets in the group.
    public struct DatasetGroup: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset group.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// If creating a dataset group fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the datasets.
        public var kmsKeyArn: Swift.String?
        /// The last update date and time (in Unix time) of the dataset group.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset group.
        public var name: Swift.String?
        /// The ARN of the IAM role that has permissions to create the dataset group.
        public var roleArn: Swift.String?
        /// The current status of the dataset group.
        ///          A dataset group can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.kmsKeyArn = kmsKeyArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetGroupSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes.DatasetGroupSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetGroupSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), failureReason: \(Swift.String(describing: failureReason)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset group. For a complete listing, call the
    ///       DescribeDatasetGroup API.
    public struct DatasetGroupSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset group was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public var datasetGroupArn: Swift.String?
        /// If creating a dataset group fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the dataset group was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset group.
        public var name: Swift.String?
        /// The status of the dataset group.
        ///          A dataset group can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetImportJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case dataSource
        case datasetArn
        case datasetImportJobArn
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes.DatasetImportJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetImportJob(creationDateTime: \(Swift.String(describing: creationDateTime)), dataSource: \(Swift.String(describing: dataSource)), datasetArn: \(Swift.String(describing: datasetArn)), datasetImportJobArn: \(Swift.String(describing: datasetImportJobArn)), failureReason: \(Swift.String(describing: failureReason)), jobName: \(Swift.String(describing: jobName)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Describes a job that imports training data from a data source (Amazon S3 bucket) to an
    ///       Amazon Personalize dataset. For more information, see CreateDatasetImportJob.
    ///          A dataset import job can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    public struct DatasetImportJob: Swift.Equatable {
        /// The creation date and time (in Unix time) of the dataset import job.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon S3 bucket that contains the training data to import.
        public var dataSource: PersonalizeClientTypes.DataSource?
        /// The Amazon Resource Name (ARN) of the dataset that receives the imported data.
        public var datasetArn: Swift.String?
        /// The ARN of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// If a dataset import job fails, provides the reason why.
        public var failureReason: Swift.String?
        /// The name of the import job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) the dataset was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The ARN of the IAM role that has permissions to read from the Amazon S3 data
        ///       source.
        public var roleArn: Swift.String?
        /// The status of the dataset import job.
        ///          A dataset import job can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            dataSource: PersonalizeClientTypes.DataSource? = nil,
            datasetArn: Swift.String? = nil,
            datasetImportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.dataSource = dataSource
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetImportJobSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetImportJobArn
        case failureReason
        case jobName
        case lastUpdatedDateTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes.DatasetImportJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetImportJobSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetImportJobArn: \(Swift.String(describing: datasetImportJobArn)), failureReason: \(Swift.String(describing: failureReason)), jobName: \(Swift.String(describing: jobName)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset import job. For a complete listing, call the
    ///       DescribeDatasetImportJob API.
    public struct DatasetImportJobSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset import job was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public var datasetImportJobArn: Swift.String?
        /// If a dataset import job fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The name of the dataset import job.
        public var jobName: Swift.String?
        /// The date and time (in Unix time) that the dataset import job status was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The status of the dataset import job.
        ///          A dataset import job can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetImportJobArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            jobName: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetImportJobArn = datasetImportJobArn
            self.failureReason = failureReason
            self.jobName = jobName
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DatasetSchema: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case schema
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.DatasetSchema: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetSchema(creationDateTime: \(Swift.String(describing: creationDateTime)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), schema: \(Swift.String(describing: schema)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension PersonalizeClientTypes {
    /// Describes the schema for a dataset. For more information on schemas, see
    ///       CreateSchema.
    public struct DatasetSchema: Swift.Equatable {
        /// The date and time (in Unix time) that the schema was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The date and time (in Unix time) that the schema was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the schema.
        public var name: Swift.String?
        /// The schema.
        public var schema: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema.
        public var schemaArn: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schema = schema
            self.schemaArn = schemaArn
        }
    }

}

extension PersonalizeClientTypes.DatasetSchemaSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.DatasetSchemaSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetSchemaSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset schema. For a complete listing, call the
    ///       DescribeSchema API.
    public struct DatasetSchemaSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the schema was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The date and time (in Unix time) that the schema was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the schema.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the schema.
        public var schemaArn: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            schemaArn: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.schemaArn = schemaArn
        }
    }

}

extension PersonalizeClientTypes.DatasetSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetArn
        case datasetType
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.DatasetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetArn: \(Swift.String(describing: datasetArn)), datasetType: \(Swift.String(describing: datasetType)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a dataset. For a complete listing, call the
    ///       DescribeDataset API.
    public struct DatasetSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the dataset was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The dataset type. One of the following values:
        ///
        ///
        ///                Interactions
        ///
        ///
        ///                Items
        ///
        ///
        ///                Users
        ///
        ///
        ///                Event-Interactions
        ///
        ///
        public var datasetType: Swift.String?
        /// The date and time (in Unix time) that the dataset was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the dataset.
        public var name: Swift.String?
        /// The status of the dataset.
        ///          A dataset can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING > DELETE IN_PROGRESS
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetArn: Swift.String? = nil,
            datasetType: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetArn = datasetArn
            self.datasetType = datasetType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.DefaultCategoricalHyperParameterRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTunable
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for categoricalvalues0 in values {
                try valuesContainer.encode(categoricalvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let isTunableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTunable)
        isTunable = isTunableDecoded
    }
}

extension PersonalizeClientTypes.DefaultCategoricalHyperParameterRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefaultCategoricalHyperParameterRange(isTunable: \(Swift.String(describing: isTunable)), name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension PersonalizeClientTypes {
    /// Provides the name and default range of a categorical hyperparameter
    ///       and whether the hyperparameter is tunable. A tunable hyperparameter can
    ///       have its value determined during hyperparameter optimization (HPO).
    public struct DefaultCategoricalHyperParameterRange: Swift.Equatable {
        /// Whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The name of the hyperparameter.
        public var name: Swift.String?
        /// A list of the categories for the hyperparameter.
        public var values: [Swift.String]?

        public init (
            isTunable: Swift.Bool = false,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.isTunable = isTunable
            self.name = name
            self.values = values
        }
    }

}

extension PersonalizeClientTypes.DefaultContinuousHyperParameterRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTunable
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if maxValue != 0.0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0.0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decode(Swift.Double.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decode(Swift.Double.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let isTunableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTunable)
        isTunable = isTunableDecoded
    }
}

extension PersonalizeClientTypes.DefaultContinuousHyperParameterRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefaultContinuousHyperParameterRange(isTunable: \(Swift.String(describing: isTunable)), maxValue: \(Swift.String(describing: maxValue)), minValue: \(Swift.String(describing: minValue)), name: \(Swift.String(describing: name)))"}
}

extension PersonalizeClientTypes {
    /// Provides the name and default range of a continuous hyperparameter
    ///       and whether the hyperparameter is tunable. A tunable hyperparameter can
    ///       have its value determined during hyperparameter optimization (HPO).
    public struct DefaultContinuousHyperParameterRange: Swift.Equatable {
        /// Whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Double
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Double
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init (
            isTunable: Swift.Bool = false,
            maxValue: Swift.Double = 0.0,
            minValue: Swift.Double = 0.0,
            name: Swift.String? = nil
        )
        {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension PersonalizeClientTypes.DefaultHyperParameterRanges: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalHyperParameterRanges
        case continuousHyperParameterRanges
        case integerHyperParameterRanges
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalHyperParameterRanges = categoricalHyperParameterRanges {
            var categoricalHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalHyperParameterRanges)
            for defaultcategoricalhyperparameterranges0 in categoricalHyperParameterRanges {
                try categoricalHyperParameterRangesContainer.encode(defaultcategoricalhyperparameterranges0)
            }
        }
        if let continuousHyperParameterRanges = continuousHyperParameterRanges {
            var continuousHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousHyperParameterRanges)
            for defaultcontinuoushyperparameterranges0 in continuousHyperParameterRanges {
                try continuousHyperParameterRangesContainer.encode(defaultcontinuoushyperparameterranges0)
            }
        }
        if let integerHyperParameterRanges = integerHyperParameterRanges {
            var integerHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerHyperParameterRanges)
            for defaultintegerhyperparameterranges0 in integerHyperParameterRanges {
                try integerHyperParameterRangesContainer.encode(defaultintegerhyperparameterranges0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integerHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DefaultIntegerHyperParameterRange?].self, forKey: .integerHyperParameterRanges)
        var integerHyperParameterRangesDecoded0:[PersonalizeClientTypes.DefaultIntegerHyperParameterRange]? = nil
        if let integerHyperParameterRangesContainer = integerHyperParameterRangesContainer {
            integerHyperParameterRangesDecoded0 = [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]()
            for structure0 in integerHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    integerHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerHyperParameterRanges = integerHyperParameterRangesDecoded0
        let continuousHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DefaultContinuousHyperParameterRange?].self, forKey: .continuousHyperParameterRanges)
        var continuousHyperParameterRangesDecoded0:[PersonalizeClientTypes.DefaultContinuousHyperParameterRange]? = nil
        if let continuousHyperParameterRangesContainer = continuousHyperParameterRangesContainer {
            continuousHyperParameterRangesDecoded0 = [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]()
            for structure0 in continuousHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousHyperParameterRanges = continuousHyperParameterRangesDecoded0
        let categoricalHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DefaultCategoricalHyperParameterRange?].self, forKey: .categoricalHyperParameterRanges)
        var categoricalHyperParameterRangesDecoded0:[PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]? = nil
        if let categoricalHyperParameterRangesContainer = categoricalHyperParameterRangesContainer {
            categoricalHyperParameterRangesDecoded0 = [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]()
            for structure0 in categoricalHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalHyperParameterRanges = categoricalHyperParameterRangesDecoded0
    }
}

extension PersonalizeClientTypes.DefaultHyperParameterRanges: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefaultHyperParameterRanges(categoricalHyperParameterRanges: \(Swift.String(describing: categoricalHyperParameterRanges)), continuousHyperParameterRanges: \(Swift.String(describing: continuousHyperParameterRanges)), integerHyperParameterRanges: \(Swift.String(describing: integerHyperParameterRanges)))"}
}

extension PersonalizeClientTypes {
    /// Specifies the hyperparameters and their default ranges.
    ///     Hyperparameters can be categorical, continuous, or integer-valued.
    public struct DefaultHyperParameterRanges: Swift.Equatable {
        /// The categorical hyperparameters and their default ranges.
        public var categoricalHyperParameterRanges: [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their default ranges.
        public var continuousHyperParameterRanges: [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their default ranges.
        public var integerHyperParameterRanges: [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]?

        public init (
            categoricalHyperParameterRanges: [PersonalizeClientTypes.DefaultCategoricalHyperParameterRange]? = nil,
            continuousHyperParameterRanges: [PersonalizeClientTypes.DefaultContinuousHyperParameterRange]? = nil,
            integerHyperParameterRanges: [PersonalizeClientTypes.DefaultIntegerHyperParameterRange]? = nil
        )
        {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }
    }

}

extension PersonalizeClientTypes.DefaultIntegerHyperParameterRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isTunable
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isTunable != false {
            try encodeContainer.encode(isTunable, forKey: .isTunable)
        }
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decode(Swift.Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let isTunableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTunable)
        isTunable = isTunableDecoded
    }
}

extension PersonalizeClientTypes.DefaultIntegerHyperParameterRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DefaultIntegerHyperParameterRange(isTunable: \(Swift.String(describing: isTunable)), maxValue: \(Swift.String(describing: maxValue)), minValue: \(Swift.String(describing: minValue)), name: \(Swift.String(describing: name)))"}
}

extension PersonalizeClientTypes {
    /// Provides the name and default range of a integer-valued hyperparameter
    ///       and whether the hyperparameter is tunable. A tunable hyperparameter can
    ///       have its value determined during hyperparameter optimization (HPO).
    public struct DefaultIntegerHyperParameterRange: Swift.Equatable {
        /// Indicates whether the hyperparameter is tunable.
        public var isTunable: Swift.Bool
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Int
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Int
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init (
            isTunable: Swift.Bool = false,
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.isTunable = isTunable
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

public struct DeleteCampaignInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCampaignOutputError>
}

extension DeleteCampaignInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCampaignInput(campaignArn: \(Swift.String(describing: campaignArn)))"}
}

extension DeleteCampaignInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
    }
}

public struct DeleteCampaignInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCampaignOutputError>
}

public struct DeleteCampaignInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCampaignOutputError>
}

public struct DeleteCampaignInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCampaignInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteCampaignInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteCampaignInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCampaignOutputError>
}

public struct DeleteCampaignInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign to delete.
    /// This member is required.
    public var campaignArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct DeleteCampaignInputBody: Swift.Equatable {
    public let campaignArn: Swift.String?
}

extension DeleteCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension DeleteCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCampaignOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCampaignOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCampaignOutputResponse()"}
}

extension DeleteCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCampaignOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCampaignOutputResponseBody: Swift.Equatable {
}

extension DeleteCampaignOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDatasetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetGroupOutputError>
}

extension DeleteDatasetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetGroupInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)))"}
}

extension DeleteDatasetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct DeleteDatasetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDatasetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDatasetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInput: Swift.Equatable {
    /// The ARN of the dataset group to delete.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DeleteDatasetGroupInputBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
}

extension DeleteDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DeleteDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetGroupOutputResponse()"}
}

extension DeleteDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatasetGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteDatasetGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

extension DeleteDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetInput(datasetArn: \(Swift.String(describing: datasetArn)))"}
}

extension DeleteDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

public struct DeleteDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDatasetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to delete.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
    public let datasetArn: Swift.String?
}

extension DeleteDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDatasetOutputResponse()"}
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDatasetOutputResponseBody: Swift.Equatable {
}

extension DeleteDatasetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteEventTrackerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventTrackerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventTrackerOutputError>
}

extension DeleteEventTrackerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventTrackerInput(eventTrackerArn: \(Swift.String(describing: eventTrackerArn)))"}
}

extension DeleteEventTrackerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTrackerArn = eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
    }
}

public struct DeleteEventTrackerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventTrackerOutputError>
}

public struct DeleteEventTrackerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEventTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEventTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventTrackerOutputError>
}

public struct DeleteEventTrackerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEventTrackerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteEventTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEventTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEventTrackerOutputError>
}

public struct DeleteEventTrackerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event tracker to delete.
    /// This member is required.
    public var eventTrackerArn: Swift.String?

    public init (
        eventTrackerArn: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

struct DeleteEventTrackerInputBody: Swift.Equatable {
    public let eventTrackerArn: Swift.String?
}

extension DeleteEventTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
    }
}

extension DeleteEventTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventTrackerOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventTrackerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEventTrackerOutputResponse()"}
}

extension DeleteEventTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventTrackerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEventTrackerOutputResponseBody: Swift.Equatable {
}

extension DeleteEventTrackerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteFilterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFilterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFilterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFilterOutputError>
}

extension DeleteFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFilterInput(filterArn: \(Swift.String(describing: filterArn)))"}
}

extension DeleteFilterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
    }
}

public struct DeleteFilterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFilterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFilterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFilterOutputError>
}

public struct DeleteFilterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFilterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFilterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFilterOutputError>
}

public struct DeleteFilterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFilterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteFilterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFilterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFilterOutputError>
}

public struct DeleteFilterInput: Swift.Equatable {
    /// The ARN of the filter to delete.
    /// This member is required.
    public var filterArn: Swift.String?

    public init (
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct DeleteFilterInputBody: Swift.Equatable {
    public let filterArn: Swift.String?
}

extension DeleteFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension DeleteFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFilterOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFilterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFilterOutputResponse()"}
}

extension DeleteFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFilterOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteFilterOutputResponseBody: Swift.Equatable {
}

extension DeleteFilterOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteSchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSchemaOutputError>
}

extension DeleteSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSchemaInput(schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension DeleteSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct DeleteSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSchemaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSchemaOutputError>
}

public struct DeleteSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schema to delete.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DeleteSchemaInputBody: Swift.Equatable {
    public let schemaArn: Swift.String?
}

extension DeleteSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension DeleteSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSchemaOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSchemaOutputResponse()"}
}

extension DeleteSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSchemaOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSchemaOutputResponseBody: Swift.Equatable {
}

extension DeleteSchemaOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteSolutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSolutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSolutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSolutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSolutionOutputError>
}

extension DeleteSolutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSolutionInput(solutionArn: \(Swift.String(describing: solutionArn)))"}
}

extension DeleteSolutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

public struct DeleteSolutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSolutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSolutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSolutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSolutionOutputError>
}

public struct DeleteSolutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSolutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteSolutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteSolutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSolutionOutputError>
}

public struct DeleteSolutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteSolutionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteSolutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteSolutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteSolutionOutputError>
}

public struct DeleteSolutionInput: Swift.Equatable {
    /// The ARN of the solution to delete.
    /// This member is required.
    public var solutionArn: Swift.String?

    public init (
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct DeleteSolutionInputBody: Swift.Equatable {
    public let solutionArn: Swift.String?
}

extension DeleteSolutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

extension DeleteSolutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSolutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSolutionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSolutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSolutionOutputResponse()"}
}

extension DeleteSolutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSolutionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteSolutionOutputResponseBody: Swift.Equatable {
}

extension DeleteSolutionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeAlgorithmInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlgorithmInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAlgorithmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlgorithmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAlgorithmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlgorithmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlgorithmOutputError>
}

extension DescribeAlgorithmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAlgorithmInput(algorithmArn: \(Swift.String(describing: algorithmArn)))"}
}

extension DescribeAlgorithmInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
    }
}

public struct DescribeAlgorithmInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlgorithmInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAlgorithmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlgorithmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAlgorithmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlgorithmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlgorithmOutputError>
}

public struct DescribeAlgorithmInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlgorithmInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAlgorithmInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlgorithmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAlgorithmInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlgorithmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlgorithmOutputError>
}

public struct DescribeAlgorithmInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlgorithmInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAlgorithmInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlgorithmOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAlgorithmInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlgorithmOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlgorithmOutputError>
}

public struct DescribeAlgorithmInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the algorithm to describe.
    /// This member is required.
    public var algorithmArn: Swift.String?

    public init (
        algorithmArn: Swift.String? = nil
    )
    {
        self.algorithmArn = algorithmArn
    }
}

struct DescribeAlgorithmInputBody: Swift.Equatable {
    public let algorithmArn: Swift.String?
}

extension DescribeAlgorithmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
    }
}

extension DescribeAlgorithmOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlgorithmOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAlgorithmOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlgorithmOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAlgorithmOutputResponse(algorithm: \(Swift.String(describing: algorithm)))"}
}

extension DescribeAlgorithmOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAlgorithmOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.algorithm = output.algorithm
        } else {
            self.algorithm = nil
        }
    }
}

public struct DescribeAlgorithmOutputResponse: Swift.Equatable {
    /// A listing of the properties of the algorithm.
    public var algorithm: PersonalizeClientTypes.Algorithm?

    public init (
        algorithm: PersonalizeClientTypes.Algorithm? = nil
    )
    {
        self.algorithm = algorithm
    }
}

struct DescribeAlgorithmOutputResponseBody: Swift.Equatable {
    public let algorithm: PersonalizeClientTypes.Algorithm?
}

extension DescribeAlgorithmOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
    }
}

public struct DescribeBatchInferenceJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBatchInferenceJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBatchInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBatchInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBatchInferenceJobOutputError>
}

extension DescribeBatchInferenceJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBatchInferenceJobInput(batchInferenceJobArn: \(Swift.String(describing: batchInferenceJobArn)))"}
}

extension DescribeBatchInferenceJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchInferenceJobArn = batchInferenceJobArn {
            try encodeContainer.encode(batchInferenceJobArn, forKey: .batchInferenceJobArn)
        }
    }
}

public struct DescribeBatchInferenceJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBatchInferenceJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBatchInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBatchInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBatchInferenceJobOutputError>
}

public struct DescribeBatchInferenceJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBatchInferenceJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBatchInferenceJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBatchInferenceJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBatchInferenceJobOutputError>
}

public struct DescribeBatchInferenceJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBatchInferenceJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeBatchInferenceJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBatchInferenceJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeBatchInferenceJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBatchInferenceJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBatchInferenceJobOutputError>
}

public struct DescribeBatchInferenceJobInput: Swift.Equatable {
    /// The ARN of the batch inference job to describe.
    /// This member is required.
    public var batchInferenceJobArn: Swift.String?

    public init (
        batchInferenceJobArn: Swift.String? = nil
    )
    {
        self.batchInferenceJobArn = batchInferenceJobArn
    }
}

struct DescribeBatchInferenceJobInputBody: Swift.Equatable {
    public let batchInferenceJobArn: Swift.String?
}

extension DescribeBatchInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchInferenceJobArn)
        batchInferenceJobArn = batchInferenceJobArnDecoded
    }
}

extension DescribeBatchInferenceJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBatchInferenceJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBatchInferenceJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBatchInferenceJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBatchInferenceJobOutputResponse(batchInferenceJob: \(Swift.String(describing: batchInferenceJob)))"}
}

extension DescribeBatchInferenceJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBatchInferenceJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchInferenceJob = output.batchInferenceJob
        } else {
            self.batchInferenceJob = nil
        }
    }
}

public struct DescribeBatchInferenceJobOutputResponse: Swift.Equatable {
    /// Information on the specified batch inference job.
    public var batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob?

    public init (
        batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob? = nil
    )
    {
        self.batchInferenceJob = batchInferenceJob
    }
}

struct DescribeBatchInferenceJobOutputResponseBody: Swift.Equatable {
    public let batchInferenceJob: PersonalizeClientTypes.BatchInferenceJob?
}

extension DescribeBatchInferenceJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJob
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.BatchInferenceJob.self, forKey: .batchInferenceJob)
        batchInferenceJob = batchInferenceJobDecoded
    }
}

public struct DescribeCampaignInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCampaignOutputError>
}

extension DescribeCampaignInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCampaignInput(campaignArn: \(Swift.String(describing: campaignArn)))"}
}

extension DescribeCampaignInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
    }
}

public struct DescribeCampaignInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCampaignOutputError>
}

public struct DescribeCampaignInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCampaignOutputError>
}

public struct DescribeCampaignInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCampaignInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeCampaignInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCampaignInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCampaignOutputError>
}

public struct DescribeCampaignInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    /// This member is required.
    public var campaignArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct DescribeCampaignInputBody: Swift.Equatable {
    public let campaignArn: Swift.String?
}

extension DescribeCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}

extension DescribeCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCampaignOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCampaignOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCampaignOutputResponse(campaign: \(Swift.String(describing: campaign)))"}
}

extension DescribeCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaign = output.campaign
        } else {
            self.campaign = nil
        }
    }
}

public struct DescribeCampaignOutputResponse: Swift.Equatable {
    /// The properties of the campaign.
    public var campaign: PersonalizeClientTypes.Campaign?

    public init (
        campaign: PersonalizeClientTypes.Campaign? = nil
    )
    {
        self.campaign = campaign
    }
}

struct DescribeCampaignOutputResponseBody: Swift.Equatable {
    public let campaign: PersonalizeClientTypes.Campaign?
}

extension DescribeCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaign
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Campaign.self, forKey: .campaign)
        campaign = campaignDecoded
    }
}

public struct DescribeDatasetExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetExportJobOutputError>
}

extension DescribeDatasetExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetExportJobInput(datasetExportJobArn: \(Swift.String(describing: datasetExportJobArn)))"}
}

extension DescribeDatasetExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetExportJobArn = datasetExportJobArn {
            try encodeContainer.encode(datasetExportJobArn, forKey: .datasetExportJobArn)
        }
    }
}

public struct DescribeDatasetExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetExportJobOutputError>
}

public struct DescribeDatasetExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetExportJobOutputError>
}

public struct DescribeDatasetExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDatasetExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDatasetExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetExportJobOutputError>
}

public struct DescribeDatasetExportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset export job to describe.
    /// This member is required.
    public var datasetExportJobArn: Swift.String?

    public init (
        datasetExportJobArn: Swift.String? = nil
    )
    {
        self.datasetExportJobArn = datasetExportJobArn
    }
}

struct DescribeDatasetExportJobInputBody: Swift.Equatable {
    public let datasetExportJobArn: Swift.String?
}

extension DescribeDatasetExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetExportJobArn)
        datasetExportJobArn = datasetExportJobArnDecoded
    }
}

extension DescribeDatasetExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetExportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetExportJobOutputResponse(datasetExportJob: \(Swift.String(describing: datasetExportJob)))"}
}

extension DescribeDatasetExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetExportJob = output.datasetExportJob
        } else {
            self.datasetExportJob = nil
        }
    }
}

public struct DescribeDatasetExportJobOutputResponse: Swift.Equatable {
    /// Information about the dataset export job, including the status.
    ///          The status is one of the following values:
    ///
    ///
    ///                CREATE PENDING
    ///
    ///
    ///                CREATE IN_PROGRESS
    ///
    ///
    ///                ACTIVE
    ///
    ///
    ///                CREATE FAILED
    ///
    ///
    public var datasetExportJob: PersonalizeClientTypes.DatasetExportJob?

    public init (
        datasetExportJob: PersonalizeClientTypes.DatasetExportJob? = nil
    )
    {
        self.datasetExportJob = datasetExportJob
    }
}

struct DescribeDatasetExportJobOutputResponseBody: Swift.Equatable {
    public let datasetExportJob: PersonalizeClientTypes.DatasetExportJob?
}

extension DescribeDatasetExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJob
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetExportJob.self, forKey: .datasetExportJob)
        datasetExportJob = datasetExportJobDecoded
    }
}

public struct DescribeDatasetGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetGroupOutputError>
}

extension DescribeDatasetGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetGroupInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)))"}
}

extension DescribeDatasetGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct DescribeDatasetGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetGroupInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDatasetGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDatasetGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group to describe.
    /// This member is required.
    public var datasetGroupArn: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DescribeDatasetGroupInputBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
}

extension DescribeDatasetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DescribeDatasetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetGroupOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetGroupOutputResponse(datasetGroup: \(Swift.String(describing: datasetGroup)))"}
}

extension DescribeDatasetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroup = output.datasetGroup
        } else {
            self.datasetGroup = nil
        }
    }
}

public struct DescribeDatasetGroupOutputResponse: Swift.Equatable {
    /// A listing of the dataset group's properties.
    public var datasetGroup: PersonalizeClientTypes.DatasetGroup?

    public init (
        datasetGroup: PersonalizeClientTypes.DatasetGroup? = nil
    )
    {
        self.datasetGroup = datasetGroup
    }
}

struct DescribeDatasetGroupOutputResponseBody: Swift.Equatable {
    public let datasetGroup: PersonalizeClientTypes.DatasetGroup?
}

extension DescribeDatasetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetGroup.self, forKey: .datasetGroup)
        datasetGroup = datasetGroupDecoded
    }
}

public struct DescribeDatasetImportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetImportJobOutputError>
}

extension DescribeDatasetImportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetImportJobInput(datasetImportJobArn: \(Swift.String(describing: datasetImportJobArn)))"}
}

extension DescribeDatasetImportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

public struct DescribeDatasetImportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetImportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDatasetImportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDatasetImportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset import job to describe.
    /// This member is required.
    public var datasetImportJobArn: Swift.String?

    public init (
        datasetImportJobArn: Swift.String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DescribeDatasetImportJobInputBody: Swift.Equatable {
    public let datasetImportJobArn: Swift.String?
}

extension DescribeDatasetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DescribeDatasetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetImportJobOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetImportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetImportJobOutputResponse(datasetImportJob: \(Swift.String(describing: datasetImportJob)))"}
}

extension DescribeDatasetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJob = output.datasetImportJob
        } else {
            self.datasetImportJob = nil
        }
    }
}

public struct DescribeDatasetImportJobOutputResponse: Swift.Equatable {
    /// Information about the dataset import job, including the status.
    ///          The status is one of the following values:
    ///
    ///
    ///                CREATE PENDING
    ///
    ///
    ///                CREATE IN_PROGRESS
    ///
    ///
    ///                ACTIVE
    ///
    ///
    ///                CREATE FAILED
    ///
    ///
    public var datasetImportJob: PersonalizeClientTypes.DatasetImportJob?

    public init (
        datasetImportJob: PersonalizeClientTypes.DatasetImportJob? = nil
    )
    {
        self.datasetImportJob = datasetImportJob
    }
}

struct DescribeDatasetImportJobOutputResponseBody: Swift.Equatable {
    public let datasetImportJob: PersonalizeClientTypes.DatasetImportJob?
}

extension DescribeDatasetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJob
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetImportJob.self, forKey: .datasetImportJob)
        datasetImportJob = datasetImportJobDecoded
    }
}

public struct DescribeDatasetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

extension DescribeDatasetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetInput(datasetArn: \(Swift.String(describing: datasetArn)))"}
}

extension DescribeDatasetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

public struct DescribeDatasetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDatasetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDatasetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDatasetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to describe.
    /// This member is required.
    public var datasetArn: Swift.String?

    public init (
        datasetArn: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DescribeDatasetInputBody: Swift.Equatable {
    public let datasetArn: Swift.String?
}

extension DescribeDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DescribeDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDatasetOutputResponse(dataset: \(Swift.String(describing: dataset)))"}
}

extension DescribeDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataset = output.dataset
        } else {
            self.dataset = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Swift.Equatable {
    /// A listing of the dataset's properties.
    public var dataset: PersonalizeClientTypes.Dataset?

    public init (
        dataset: PersonalizeClientTypes.Dataset? = nil
    )
    {
        self.dataset = dataset
    }
}

struct DescribeDatasetOutputResponseBody: Swift.Equatable {
    public let dataset: PersonalizeClientTypes.Dataset?
}

extension DescribeDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataset
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Dataset.self, forKey: .dataset)
        dataset = datasetDecoded
    }
}

public struct DescribeEventTrackerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventTrackerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventTrackerOutputError>
}

extension DescribeEventTrackerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventTrackerInput(eventTrackerArn: \(Swift.String(describing: eventTrackerArn)))"}
}

extension DescribeEventTrackerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTrackerArn = eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
    }
}

public struct DescribeEventTrackerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventTrackerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventTrackerOutputError>
}

public struct DescribeEventTrackerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventTrackerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventTrackerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventTrackerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventTrackerOutputError>
}

public struct DescribeEventTrackerInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventTrackerInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeEventTrackerInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventTrackerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeEventTrackerInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventTrackerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventTrackerOutputError>
}

public struct DescribeEventTrackerInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the event tracker to describe.
    /// This member is required.
    public var eventTrackerArn: Swift.String?

    public init (
        eventTrackerArn: Swift.String? = nil
    )
    {
        self.eventTrackerArn = eventTrackerArn
    }
}

struct DescribeEventTrackerInputBody: Swift.Equatable {
    public let eventTrackerArn: Swift.String?
}

extension DescribeEventTrackerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackerArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
    }
}

extension DescribeEventTrackerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventTrackerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventTrackerOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventTrackerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventTrackerOutputResponse(eventTracker: \(Swift.String(describing: eventTracker)))"}
}

extension DescribeEventTrackerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventTrackerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventTracker = output.eventTracker
        } else {
            self.eventTracker = nil
        }
    }
}

public struct DescribeEventTrackerOutputResponse: Swift.Equatable {
    /// An object that describes the event tracker.
    public var eventTracker: PersonalizeClientTypes.EventTracker?

    public init (
        eventTracker: PersonalizeClientTypes.EventTracker? = nil
    )
    {
        self.eventTracker = eventTracker
    }
}

struct DescribeEventTrackerOutputResponseBody: Swift.Equatable {
    public let eventTracker: PersonalizeClientTypes.EventTracker?
}

extension DescribeEventTrackerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTracker
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackerDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.EventTracker.self, forKey: .eventTracker)
        eventTracker = eventTrackerDecoded
    }
}

public struct DescribeFeatureTransformationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFeatureTransformationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFeatureTransformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFeatureTransformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFeatureTransformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFeatureTransformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFeatureTransformationOutputError>
}

extension DescribeFeatureTransformationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFeatureTransformationInput(featureTransformationArn: \(Swift.String(describing: featureTransformationArn)))"}
}

extension DescribeFeatureTransformationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureTransformationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureTransformationArn = featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
    }
}

public struct DescribeFeatureTransformationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFeatureTransformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFeatureTransformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFeatureTransformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFeatureTransformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFeatureTransformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFeatureTransformationOutputError>
}

public struct DescribeFeatureTransformationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFeatureTransformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFeatureTransformationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFeatureTransformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFeatureTransformationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFeatureTransformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFeatureTransformationOutputError>
}

public struct DescribeFeatureTransformationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFeatureTransformationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeFeatureTransformationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFeatureTransformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFeatureTransformationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFeatureTransformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFeatureTransformationOutputError>
}

public struct DescribeFeatureTransformationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the feature transformation to describe.
    /// This member is required.
    public var featureTransformationArn: Swift.String?

    public init (
        featureTransformationArn: Swift.String? = nil
    )
    {
        self.featureTransformationArn = featureTransformationArn
    }
}

struct DescribeFeatureTransformationInputBody: Swift.Equatable {
    public let featureTransformationArn: Swift.String?
}

extension DescribeFeatureTransformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureTransformationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
    }
}

extension DescribeFeatureTransformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFeatureTransformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFeatureTransformationOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFeatureTransformationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFeatureTransformationOutputResponse(featureTransformation: \(Swift.String(describing: featureTransformation)))"}
}

extension DescribeFeatureTransformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFeatureTransformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.featureTransformation = output.featureTransformation
        } else {
            self.featureTransformation = nil
        }
    }
}

public struct DescribeFeatureTransformationOutputResponse: Swift.Equatable {
    /// A listing of the FeatureTransformation properties.
    public var featureTransformation: PersonalizeClientTypes.FeatureTransformation?

    public init (
        featureTransformation: PersonalizeClientTypes.FeatureTransformation? = nil
    )
    {
        self.featureTransformation = featureTransformation
    }
}

struct DescribeFeatureTransformationOutputResponseBody: Swift.Equatable {
    public let featureTransformation: PersonalizeClientTypes.FeatureTransformation?
}

extension DescribeFeatureTransformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureTransformation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureTransformationDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.FeatureTransformation.self, forKey: .featureTransformation)
        featureTransformation = featureTransformationDecoded
    }
}

public struct DescribeFilterInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFilterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFilterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFilterOutputError>
}

extension DescribeFilterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFilterInput(filterArn: \(Swift.String(describing: filterArn)))"}
}

extension DescribeFilterInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
    }
}

public struct DescribeFilterInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFilterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFilterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFilterOutputError>
}

public struct DescribeFilterInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFilterInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFilterInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFilterOutputError>
}

public struct DescribeFilterInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFilterInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeFilterInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFilterInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFilterOutputError>
}

public struct DescribeFilterInput: Swift.Equatable {
    /// The ARN of the filter to describe.
    /// This member is required.
    public var filterArn: Swift.String?

    public init (
        filterArn: Swift.String? = nil
    )
    {
        self.filterArn = filterArn
    }
}

struct DescribeFilterInputBody: Swift.Equatable {
    public let filterArn: Swift.String?
}

extension DescribeFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension DescribeFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFilterOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFilterOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFilterOutputResponse(filter: \(Swift.String(describing: filter)))"}
}

extension DescribeFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filter = output.filter
        } else {
            self.filter = nil
        }
    }
}

public struct DescribeFilterOutputResponse: Swift.Equatable {
    /// The filter's details.
    public var filter: PersonalizeClientTypes.Filter?

    public init (
        filter: PersonalizeClientTypes.Filter? = nil
    )
    {
        self.filter = filter
    }
}

struct DescribeFilterOutputResponseBody: Swift.Equatable {
    public let filter: PersonalizeClientTypes.Filter?
}

extension DescribeFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Filter.self, forKey: .filter)
        filter = filterDecoded
    }
}

public struct DescribeRecipeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecipeOutputError>
}

extension DescribeRecipeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRecipeInput(recipeArn: \(Swift.String(describing: recipeArn)))"}
}

extension DescribeRecipeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipeArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
    }
}

public struct DescribeRecipeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecipeOutputError>
}

public struct DescribeRecipeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecipeOutputError>
}

public struct DescribeRecipeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecipeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecipeOutputError>
}

public struct DescribeRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the recipe to describe.
    /// This member is required.
    public var recipeArn: Swift.String?

    public init (
        recipeArn: Swift.String? = nil
    )
    {
        self.recipeArn = recipeArn
    }
}

struct DescribeRecipeInputBody: Swift.Equatable {
    public let recipeArn: Swift.String?
}

extension DescribeRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipeArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
    }
}

extension DescribeRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecipeOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecipeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRecipeOutputResponse(recipe: \(Swift.String(describing: recipe)))"}
}

extension DescribeRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recipe = output.recipe
        } else {
            self.recipe = nil
        }
    }
}

public struct DescribeRecipeOutputResponse: Swift.Equatable {
    /// An object that describes the recipe.
    public var recipe: PersonalizeClientTypes.Recipe?

    public init (
        recipe: PersonalizeClientTypes.Recipe? = nil
    )
    {
        self.recipe = recipe
    }
}

struct DescribeRecipeOutputResponseBody: Swift.Equatable {
    public let recipe: PersonalizeClientTypes.Recipe?
}

extension DescribeRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recipe
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Recipe.self, forKey: .recipe)
        recipe = recipeDecoded
    }
}

public struct DescribeSchemaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSchemaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSchemaOutputError>
}

extension DescribeSchemaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSchemaInput(schemaArn: \(Swift.String(describing: schemaArn)))"}
}

extension DescribeSchemaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let schemaArn = schemaArn {
            try encodeContainer.encode(schemaArn, forKey: .schemaArn)
        }
    }
}

public struct DescribeSchemaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSchemaOutputError>
}

public struct DescribeSchemaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSchemaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSchemaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSchemaOutputError>
}

public struct DescribeSchemaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSchemaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSchemaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSchemaInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSchemaOutputError>
}

public struct DescribeSchemaInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the schema to retrieve.
    /// This member is required.
    public var schemaArn: Swift.String?

    public init (
        schemaArn: Swift.String? = nil
    )
    {
        self.schemaArn = schemaArn
    }
}

struct DescribeSchemaInputBody: Swift.Equatable {
    public let schemaArn: Swift.String?
}

extension DescribeSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schemaArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaArn)
        schemaArn = schemaArnDecoded
    }
}

extension DescribeSchemaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSchemaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSchemaOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSchemaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSchemaOutputResponse(schema: \(Swift.String(describing: schema)))"}
}

extension DescribeSchemaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSchemaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.schema = output.schema
        } else {
            self.schema = nil
        }
    }
}

public struct DescribeSchemaOutputResponse: Swift.Equatable {
    /// The requested schema.
    public var schema: PersonalizeClientTypes.DatasetSchema?

    public init (
        schema: PersonalizeClientTypes.DatasetSchema? = nil
    )
    {
        self.schema = schema
    }
}

struct DescribeSchemaOutputResponseBody: Swift.Equatable {
    public let schema: PersonalizeClientTypes.DatasetSchema?
}

extension DescribeSchemaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.DatasetSchema.self, forKey: .schema)
        schema = schemaDecoded
    }
}

public struct DescribeSolutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSolutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSolutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSolutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSolutionOutputError>
}

extension DescribeSolutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSolutionInput(solutionArn: \(Swift.String(describing: solutionArn)))"}
}

extension DescribeSolutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

public struct DescribeSolutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSolutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSolutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSolutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSolutionOutputError>
}

public struct DescribeSolutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSolutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSolutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSolutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSolutionOutputError>
}

public struct DescribeSolutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSolutionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSolutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSolutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSolutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSolutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSolutionOutputError>
}

public struct DescribeSolutionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution to describe.
    /// This member is required.
    public var solutionArn: Swift.String?

    public init (
        solutionArn: Swift.String? = nil
    )
    {
        self.solutionArn = solutionArn
    }
}

struct DescribeSolutionInputBody: Swift.Equatable {
    public let solutionArn: Swift.String?
}

extension DescribeSolutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
    }
}

extension DescribeSolutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSolutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSolutionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSolutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSolutionOutputResponse(solution: \(Swift.String(describing: solution)))"}
}

extension DescribeSolutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSolutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.solution = output.solution
        } else {
            self.solution = nil
        }
    }
}

public struct DescribeSolutionOutputResponse: Swift.Equatable {
    /// An object that describes the solution.
    public var solution: PersonalizeClientTypes.Solution?

    public init (
        solution: PersonalizeClientTypes.Solution? = nil
    )
    {
        self.solution = solution
    }
}

struct DescribeSolutionOutputResponseBody: Swift.Equatable {
    public let solution: PersonalizeClientTypes.Solution?
}

extension DescribeSolutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solution
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.Solution.self, forKey: .solution)
        solution = solutionDecoded
    }
}

public struct DescribeSolutionVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSolutionVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSolutionVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSolutionVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSolutionVersionOutputError>
}

extension DescribeSolutionVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSolutionVersionInput(solutionVersionArn: \(Swift.String(describing: solutionVersionArn)))"}
}

extension DescribeSolutionVersionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct DescribeSolutionVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSolutionVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSolutionVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSolutionVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSolutionVersionOutputError>
}

public struct DescribeSolutionVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSolutionVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeSolutionVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeSolutionVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSolutionVersionOutputError>
}

public struct DescribeSolutionVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeSolutionVersionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeSolutionVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeSolutionVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeSolutionVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeSolutionVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeSolutionVersionOutputError>
}

public struct DescribeSolutionVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution version.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init (
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct DescribeSolutionVersionInputBody: Swift.Equatable {
    public let solutionVersionArn: Swift.String?
}

extension DescribeSolutionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension DescribeSolutionVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSolutionVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSolutionVersionOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSolutionVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSolutionVersionOutputResponse(solutionVersion: \(Swift.String(describing: solutionVersion)))"}
}

extension DescribeSolutionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSolutionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.solutionVersion = output.solutionVersion
        } else {
            self.solutionVersion = nil
        }
    }
}

public struct DescribeSolutionVersionOutputResponse: Swift.Equatable {
    /// The solution version.
    public var solutionVersion: PersonalizeClientTypes.SolutionVersion?

    public init (
        solutionVersion: PersonalizeClientTypes.SolutionVersion? = nil
    )
    {
        self.solutionVersion = solutionVersion
    }
}

struct DescribeSolutionVersionOutputResponseBody: Swift.Equatable {
    public let solutionVersion: PersonalizeClientTypes.SolutionVersion?
}

extension DescribeSolutionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionVersion.self, forKey: .solutionVersion)
        solutionVersion = solutionVersionDecoded
    }
}

extension PersonalizeClientTypes.EventTracker: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case creationDateTime
        case datasetGroupArn
        case eventTrackerArn
        case lastUpdatedDateTime
        case name
        case status
        case trackingId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventTrackerArn = eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trackingId = trackingId {
            try encodeContainer.encode(trackingId, forKey: .trackingId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let trackingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingId)
        trackingId = trackingIdDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.EventTracker: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventTracker(accountId: \(Swift.String(describing: accountId)), creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), eventTrackerArn: \(Swift.String(describing: eventTrackerArn)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), trackingId: \(Swift.String(describing: trackingId)))"}
}

extension PersonalizeClientTypes {
    /// Provides information about an event tracker.
    public struct EventTracker: Swift.Equatable {
        /// The Amazon Web Services account that owns the event tracker.
        public var accountId: Swift.String?
        /// The date and time (in Unix format) that the event tracker was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that receives the event data.
        public var datasetGroupArn: Swift.String?
        /// The ARN of the event tracker.
        public var eventTrackerArn: Swift.String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the event tracker.
        public var name: Swift.String?
        /// The status of the event tracker.
        ///          An event tracker can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING > DELETE IN_PROGRESS
        ///
        ///
        public var status: Swift.String?
        /// The ID of the event tracker. Include this ID in requests to the
        ///     <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents API.
        public var trackingId: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventTrackerArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil,
            trackingId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
            self.trackingId = trackingId
        }
    }

}

extension PersonalizeClientTypes.EventTrackerSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case eventTrackerArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let eventTrackerArn = eventTrackerArn {
            try encodeContainer.encode(eventTrackerArn, forKey: .eventTrackerArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let eventTrackerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTrackerArn)
        eventTrackerArn = eventTrackerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.EventTrackerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventTrackerSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), eventTrackerArn: \(Swift.String(describing: eventTrackerArn)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of an event tracker. For a complete listing, call the
    ///       DescribeEventTracker API.
    public struct EventTrackerSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the event tracker was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the event tracker.
        public var eventTrackerArn: Swift.String?
        /// The date and time (in Unix time) that the event tracker was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the event tracker.
        public var name: Swift.String?
        /// The status of the event tracker.
        ///          An event tracker can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING > DELETE IN_PROGRESS
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            eventTrackerArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.eventTrackerArn = eventTrackerArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.FeatureTransformation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case defaultParameters
        case featureTransformationArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let defaultParameters = defaultParameters {
            var defaultParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .defaultParameters)
            for (dictKey0, featurizationparameters0) in defaultParameters {
                try defaultParametersContainer.encode(featurizationparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let featureTransformationArn = featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
        let defaultParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .defaultParameters)
        var defaultParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let defaultParametersContainer = defaultParametersContainer {
            defaultParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in defaultParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    defaultParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        defaultParameters = defaultParametersDecoded0
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PersonalizeClientTypes.FeatureTransformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FeatureTransformation(creationDateTime: \(Swift.String(describing: creationDateTime)), defaultParameters: \(Swift.String(describing: defaultParameters)), featureTransformationArn: \(Swift.String(describing: featureTransformationArn)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides feature transformation information. Feature transformation is the process
    ///       of modifying raw input data into a form more suitable for model training.
    public struct FeatureTransformation: Swift.Equatable {
        /// The creation date and time (in Unix time) of the feature transformation.
        public var creationDateTime: ClientRuntime.Date?
        /// Provides the default parameters for feature transformation.
        public var defaultParameters: [Swift.String:Swift.String]?
        /// The Amazon Resource Name (ARN) of the FeatureTransformation object.
        public var featureTransformationArn: Swift.String?
        /// The last update date and time (in Unix time) of the feature transformation.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the feature transformation.
        public var name: Swift.String?
        /// The status of the feature transformation.
        ///          A feature transformation can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            defaultParameters: [Swift.String:Swift.String]? = nil,
            featureTransformationArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.defaultParameters = defaultParameters
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case filterArn
        case filterExpression
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterExpression = filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PersonalizeClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), failureReason: \(Swift.String(describing: failureReason)), filterArn: \(Swift.String(describing: filterArn)), filterExpression: \(Swift.String(describing: filterExpression)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Contains information on a recommendation filter, including its ARN, status, and filter
    ///             expression.
    public struct Filter: Swift.Equatable {
        /// The time at which the filter was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The ARN of the dataset group to which the filter belongs.
        public var datasetGroupArn: Swift.String?
        /// If the filter failed, the reason for its failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter.
        public var filterArn: Swift.String?
        /// Specifies the type of item interactions to filter out of recommendation results. The
        ///             filter expression must follow specific format rules. For information about filter expression structure and syntax, see
        ///             filter-expressions.
        public var filterExpression: Swift.String?
        /// The time at which the filter was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the filter.
        public var name: Swift.String?
        /// The status of the filter.
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            filterExpression: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.filterExpression = filterExpression
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.FilterSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case failureReason
        case filterArn
        case lastUpdatedDateTime
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension PersonalizeClientTypes.FilterSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FilterSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), failureReason: \(Swift.String(describing: failureReason)), filterArn: \(Swift.String(describing: filterArn)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// A short summary of a filter's attributes.
    public struct FilterSummary: Swift.Equatable {
        /// The time at which the filter was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The ARN of the dataset group to which the filter belongs.
        public var datasetGroupArn: Swift.String?
        /// If the filter failed, the reason for the failure.
        public var failureReason: Swift.String?
        /// The ARN of the filter.
        public var filterArn: Swift.String?
        /// The time at which the filter was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the filter.
        public var name: Swift.String?
        /// The status of the filter.
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            filterArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.failureReason = failureReason
            self.filterArn = filterArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.status = status
        }
    }

}

public struct GetSolutionMetricsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSolutionMetricsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSolutionMetricsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSolutionMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSolutionMetricsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSolutionMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSolutionMetricsOutputError>
}

extension GetSolutionMetricsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolutionMetricsInput(solutionVersionArn: \(Swift.String(describing: solutionVersionArn)))"}
}

extension GetSolutionMetricsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct GetSolutionMetricsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSolutionMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSolutionMetricsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSolutionMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSolutionMetricsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSolutionMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSolutionMetricsOutputError>
}

public struct GetSolutionMetricsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSolutionMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetSolutionMetricsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSolutionMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetSolutionMetricsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetSolutionMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSolutionMetricsOutputError>
}

public struct GetSolutionMetricsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetSolutionMetricsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetSolutionMetricsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetSolutionMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetSolutionMetricsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetSolutionMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetSolutionMetricsOutputError>
}

public struct GetSolutionMetricsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution version for which to get metrics.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init (
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct GetSolutionMetricsInputBody: Swift.Equatable {
    public let solutionVersionArn: Swift.String?
}

extension GetSolutionMetricsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension GetSolutionMetricsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSolutionMetricsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSolutionMetricsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSolutionMetricsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSolutionMetricsOutputResponse(metrics: \(Swift.String(describing: metrics)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)))"}
}

extension GetSolutionMetricsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSolutionMetricsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metrics = output.metrics
            self.solutionVersionArn = output.solutionVersionArn
        } else {
            self.metrics = nil
            self.solutionVersionArn = nil
        }
    }
}

public struct GetSolutionMetricsOutputResponse: Swift.Equatable {
    /// The metrics for the solution version.
    public var metrics: [Swift.String:Swift.Double]?
    /// The same solution version ARN as specified in the request.
    public var solutionVersionArn: Swift.String?

    public init (
        metrics: [Swift.String:Swift.Double]? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.metrics = metrics
        self.solutionVersionArn = solutionVersionArn
    }
}

struct GetSolutionMetricsOutputResponseBody: Swift.Equatable {
    public let solutionVersionArn: Swift.String?
    public let metrics: [Swift.String:Swift.Double]?
}

extension GetSolutionMetricsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metrics
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Double?].self, forKey: .metrics)
        var metricsDecoded0: [Swift.String:Swift.Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String:Swift.Double]()
            for (key0, metricvalue0) in metricsContainer {
                if let metricvalue0 = metricvalue0 {
                    metricsDecoded0?[key0] = metricvalue0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

extension PersonalizeClientTypes.HPOConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmHyperParameterRanges
        case hpoObjective
        case hpoResourceConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameterRanges = algorithmHyperParameterRanges {
            try encodeContainer.encode(algorithmHyperParameterRanges, forKey: .algorithmHyperParameterRanges)
        }
        if let hpoObjective = hpoObjective {
            try encodeContainer.encode(hpoObjective, forKey: .hpoObjective)
        }
        if let hpoResourceConfig = hpoResourceConfig {
            try encodeContainer.encode(hpoResourceConfig, forKey: .hpoResourceConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hpoObjectiveDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HPOObjective.self, forKey: .hpoObjective)
        hpoObjective = hpoObjectiveDecoded
        let hpoResourceConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HPOResourceConfig.self, forKey: .hpoResourceConfig)
        hpoResourceConfig = hpoResourceConfigDecoded
        let algorithmHyperParameterRangesDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HyperParameterRanges.self, forKey: .algorithmHyperParameterRanges)
        algorithmHyperParameterRanges = algorithmHyperParameterRangesDecoded
    }
}

extension PersonalizeClientTypes.HPOConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HPOConfig(algorithmHyperParameterRanges: \(Swift.String(describing: algorithmHyperParameterRanges)), hpoObjective: \(Swift.String(describing: hpoObjective)), hpoResourceConfig: \(Swift.String(describing: hpoResourceConfig)))"}
}

extension PersonalizeClientTypes {
    /// Describes the properties for hyperparameter optimization (HPO).
    public struct HPOConfig: Swift.Equatable {
        /// The hyperparameters and their allowable ranges.
        public var algorithmHyperParameterRanges: PersonalizeClientTypes.HyperParameterRanges?
        /// The metric to optimize during HPO.
        ///
        ///             Amazon Personalize doesn't support configuring the hpoObjective
        ///         at this time.
        ///
        public var hpoObjective: PersonalizeClientTypes.HPOObjective?
        /// Describes the resource configuration for HPO.
        public var hpoResourceConfig: PersonalizeClientTypes.HPOResourceConfig?

        public init (
            algorithmHyperParameterRanges: PersonalizeClientTypes.HyperParameterRanges? = nil,
            hpoObjective: PersonalizeClientTypes.HPOObjective? = nil,
            hpoResourceConfig: PersonalizeClientTypes.HPOResourceConfig? = nil
        )
        {
            self.algorithmHyperParameterRanges = algorithmHyperParameterRanges
            self.hpoObjective = hpoObjective
            self.hpoResourceConfig = hpoResourceConfig
        }
    }

}

extension PersonalizeClientTypes.HPOObjective: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName
        case metricRegex
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricRegex = metricRegex {
            try encodeContainer.encode(metricRegex, forKey: .metricRegex)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let metricRegexDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricRegex)
        metricRegex = metricRegexDecoded
    }
}

extension PersonalizeClientTypes.HPOObjective: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HPOObjective(metricName: \(Swift.String(describing: metricName)), metricRegex: \(Swift.String(describing: metricRegex)), type: \(Swift.String(describing: type)))"}
}

extension PersonalizeClientTypes {
    /// The metric to optimize during hyperparameter optimization (HPO).
    ///
    ///             Amazon Personalize doesn't support configuring the hpoObjective
    ///         at this time.
    ///
    public struct HPOObjective: Swift.Equatable {
        /// The name of the metric.
        public var metricName: Swift.String?
        /// A regular expression for finding the metric in the training job logs.
        public var metricRegex: Swift.String?
        /// The type of the metric. Valid values are Maximize and Minimize.
        public var type: Swift.String?

        public init (
            metricName: Swift.String? = nil,
            metricRegex: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.metricRegex = metricRegex
            self.type = type
        }
    }

}

extension PersonalizeClientTypes.HPOResourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxNumberOfTrainingJobs
        case maxParallelTrainingJobs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxNumberOfTrainingJobs = maxNumberOfTrainingJobs {
            try encodeContainer.encode(maxNumberOfTrainingJobs, forKey: .maxNumberOfTrainingJobs)
        }
        if let maxParallelTrainingJobs = maxParallelTrainingJobs {
            try encodeContainer.encode(maxParallelTrainingJobs, forKey: .maxParallelTrainingJobs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxNumberOfTrainingJobsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxNumberOfTrainingJobs)
        maxNumberOfTrainingJobs = maxNumberOfTrainingJobsDecoded
        let maxParallelTrainingJobsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxParallelTrainingJobs)
        maxParallelTrainingJobs = maxParallelTrainingJobsDecoded
    }
}

extension PersonalizeClientTypes.HPOResourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HPOResourceConfig(maxNumberOfTrainingJobs: \(Swift.String(describing: maxNumberOfTrainingJobs)), maxParallelTrainingJobs: \(Swift.String(describing: maxParallelTrainingJobs)))"}
}

extension PersonalizeClientTypes {
    /// Describes the resource configuration for hyperparameter optimization (HPO).
    public struct HPOResourceConfig: Swift.Equatable {
        /// The maximum number of training
        ///       jobs when you create a
        ///       solution
        ///       version.
        ///       The maximum value for maxNumberOfTrainingJobs is
        ///       40.
        public var maxNumberOfTrainingJobs: Swift.String?
        /// The maximum number of parallel training
        ///       jobs when you create a
        ///       solution
        ///       version.
        ///       The maximum value for maxParallelTrainingJobs is
        ///       10.
        public var maxParallelTrainingJobs: Swift.String?

        public init (
            maxNumberOfTrainingJobs: Swift.String? = nil,
            maxParallelTrainingJobs: Swift.String? = nil
        )
        {
            self.maxNumberOfTrainingJobs = maxNumberOfTrainingJobs
            self.maxParallelTrainingJobs = maxParallelTrainingJobs
        }
    }

}

extension PersonalizeClientTypes.HyperParameterRanges: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalHyperParameterRanges
        case continuousHyperParameterRanges
        case integerHyperParameterRanges
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalHyperParameterRanges = categoricalHyperParameterRanges {
            var categoricalHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalHyperParameterRanges)
            for categoricalhyperparameterranges0 in categoricalHyperParameterRanges {
                try categoricalHyperParameterRangesContainer.encode(categoricalhyperparameterranges0)
            }
        }
        if let continuousHyperParameterRanges = continuousHyperParameterRanges {
            var continuousHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousHyperParameterRanges)
            for continuoushyperparameterranges0 in continuousHyperParameterRanges {
                try continuousHyperParameterRangesContainer.encode(continuoushyperparameterranges0)
            }
        }
        if let integerHyperParameterRanges = integerHyperParameterRanges {
            var integerHyperParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerHyperParameterRanges)
            for integerhyperparameterranges0 in integerHyperParameterRanges {
                try integerHyperParameterRangesContainer.encode(integerhyperparameterranges0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let integerHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.IntegerHyperParameterRange?].self, forKey: .integerHyperParameterRanges)
        var integerHyperParameterRangesDecoded0:[PersonalizeClientTypes.IntegerHyperParameterRange]? = nil
        if let integerHyperParameterRangesContainer = integerHyperParameterRangesContainer {
            integerHyperParameterRangesDecoded0 = [PersonalizeClientTypes.IntegerHyperParameterRange]()
            for structure0 in integerHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    integerHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerHyperParameterRanges = integerHyperParameterRangesDecoded0
        let continuousHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.ContinuousHyperParameterRange?].self, forKey: .continuousHyperParameterRanges)
        var continuousHyperParameterRangesDecoded0:[PersonalizeClientTypes.ContinuousHyperParameterRange]? = nil
        if let continuousHyperParameterRangesContainer = continuousHyperParameterRangesContainer {
            continuousHyperParameterRangesDecoded0 = [PersonalizeClientTypes.ContinuousHyperParameterRange]()
            for structure0 in continuousHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousHyperParameterRanges = continuousHyperParameterRangesDecoded0
        let categoricalHyperParameterRangesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.CategoricalHyperParameterRange?].self, forKey: .categoricalHyperParameterRanges)
        var categoricalHyperParameterRangesDecoded0:[PersonalizeClientTypes.CategoricalHyperParameterRange]? = nil
        if let categoricalHyperParameterRangesContainer = categoricalHyperParameterRangesContainer {
            categoricalHyperParameterRangesDecoded0 = [PersonalizeClientTypes.CategoricalHyperParameterRange]()
            for structure0 in categoricalHyperParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalHyperParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalHyperParameterRanges = categoricalHyperParameterRangesDecoded0
    }
}

extension PersonalizeClientTypes.HyperParameterRanges: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HyperParameterRanges(categoricalHyperParameterRanges: \(Swift.String(describing: categoricalHyperParameterRanges)), continuousHyperParameterRanges: \(Swift.String(describing: continuousHyperParameterRanges)), integerHyperParameterRanges: \(Swift.String(describing: integerHyperParameterRanges)))"}
}

extension PersonalizeClientTypes {
    /// Specifies the hyperparameters and their ranges.
    ///     Hyperparameters can be categorical, continuous, or integer-valued.
    public struct HyperParameterRanges: Swift.Equatable {
        /// The categorical hyperparameters and their ranges.
        public var categoricalHyperParameterRanges: [PersonalizeClientTypes.CategoricalHyperParameterRange]?
        /// The continuous hyperparameters and their ranges.
        public var continuousHyperParameterRanges: [PersonalizeClientTypes.ContinuousHyperParameterRange]?
        /// The integer-valued hyperparameters and their ranges.
        public var integerHyperParameterRanges: [PersonalizeClientTypes.IntegerHyperParameterRange]?

        public init (
            categoricalHyperParameterRanges: [PersonalizeClientTypes.CategoricalHyperParameterRange]? = nil,
            continuousHyperParameterRanges: [PersonalizeClientTypes.ContinuousHyperParameterRange]? = nil,
            integerHyperParameterRanges: [PersonalizeClientTypes.IntegerHyperParameterRange]? = nil
        )
        {
            self.categoricalHyperParameterRanges = categoricalHyperParameterRanges
            self.continuousHyperParameterRanges = continuousHyperParameterRanges
            self.integerHyperParameterRanges = integerHyperParameterRanges
        }
    }

}

extension PersonalizeClientTypes {
    public enum IngestionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case bulk
        case put
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionMode] {
            return [
                .all,
                .bulk,
                .put,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .bulk: return "BULK"
            case .put: return "PUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionMode(rawValue: rawValue) ?? IngestionMode.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.IntegerHyperParameterRange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxValue
        case minValue
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxValue != 0 {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if minValue != 0 {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decode(Swift.Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
    }
}

extension PersonalizeClientTypes.IntegerHyperParameterRange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntegerHyperParameterRange(maxValue: \(Swift.String(describing: maxValue)), minValue: \(Swift.String(describing: minValue)), name: \(Swift.String(describing: name)))"}
}

extension PersonalizeClientTypes {
    /// Provides the name and range of an integer-valued hyperparameter.
    public struct IntegerHyperParameterRange: Swift.Equatable {
        /// The maximum allowable value for the hyperparameter.
        public var maxValue: Swift.Int
        /// The minimum allowable value for the hyperparameter.
        public var minValue: Swift.Int
        /// The name of the hyperparameter.
        public var name: Swift.String?

        public init (
            maxValue: Swift.Int = 0,
            minValue: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
        }
    }

}

extension InvalidInputException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidInputException(message: \(Swift.String(describing: message)))"}
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Provide a valid value for the field or parameter.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The token is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of requests per second has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListBatchInferenceJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBatchInferenceJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBatchInferenceJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBatchInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBatchInferenceJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBatchInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBatchInferenceJobsOutputError>
}

extension ListBatchInferenceJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBatchInferenceJobsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)))"}
}

extension ListBatchInferenceJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct ListBatchInferenceJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBatchInferenceJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBatchInferenceJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBatchInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBatchInferenceJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBatchInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBatchInferenceJobsOutputError>
}

public struct ListBatchInferenceJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBatchInferenceJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBatchInferenceJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBatchInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBatchInferenceJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBatchInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBatchInferenceJobsOutputError>
}

public struct ListBatchInferenceJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBatchInferenceJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListBatchInferenceJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBatchInferenceJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBatchInferenceJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBatchInferenceJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBatchInferenceJobsOutputError>
}

public struct ListBatchInferenceJobsInput: Swift.Equatable {
    /// The maximum number of batch inference job results to return in each page. The default
    ///       value is 100.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution version from which the batch inference jobs
    ///       were created.
    public var solutionVersionArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionVersionArn = solutionVersionArn
    }
}

struct ListBatchInferenceJobsInputBody: Swift.Equatable {
    public let solutionVersionArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListBatchInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBatchInferenceJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBatchInferenceJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBatchInferenceJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBatchInferenceJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBatchInferenceJobsOutputResponse(batchInferenceJobs: \(Swift.String(describing: batchInferenceJobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBatchInferenceJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBatchInferenceJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchInferenceJobs = output.batchInferenceJobs
            self.nextToken = output.nextToken
        } else {
            self.batchInferenceJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBatchInferenceJobsOutputResponse: Swift.Equatable {
    /// A list containing information on each job that is returned.
    public var batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]?
    /// The token to use to retrieve the next page of results. The value is null when
    ///       there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchInferenceJobs = batchInferenceJobs
        self.nextToken = nextToken
    }
}

struct ListBatchInferenceJobsOutputResponseBody: Swift.Equatable {
    public let batchInferenceJobs: [PersonalizeClientTypes.BatchInferenceJobSummary]?
    public let nextToken: Swift.String?
}

extension ListBatchInferenceJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchInferenceJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchInferenceJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.BatchInferenceJobSummary?].self, forKey: .batchInferenceJobs)
        var batchInferenceJobsDecoded0:[PersonalizeClientTypes.BatchInferenceJobSummary]? = nil
        if let batchInferenceJobsContainer = batchInferenceJobsContainer {
            batchInferenceJobsDecoded0 = [PersonalizeClientTypes.BatchInferenceJobSummary]()
            for structure0 in batchInferenceJobsContainer {
                if let structure0 = structure0 {
                    batchInferenceJobsDecoded0?.append(structure0)
                }
            }
        }
        batchInferenceJobs = batchInferenceJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCampaignsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCampaignsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCampaignsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCampaignsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCampaignsOutputError>
}

extension ListCampaignsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCampaignsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), solutionArn: \(Swift.String(describing: solutionArn)))"}
}

extension ListCampaignsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

public struct ListCampaignsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCampaignsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCampaignsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCampaignsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCampaignsOutputError>
}

public struct ListCampaignsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCampaignsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCampaignsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCampaignsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCampaignsOutputError>
}

public struct ListCampaignsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCampaignsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListCampaignsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListCampaignsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCampaignsOutputError>
}

public struct ListCampaignsInput: Swift.Equatable {
    /// The maximum number of campaigns to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListCampaigns for getting
    ///       the next set of campaigns (if they exist).
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution to list the campaigns for. When
    ///         a solution is not specified, all the campaigns associated with the account are listed.
    public var solutionArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

struct ListCampaignsInputBody: Swift.Equatable {
    public let solutionArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListCampaignsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCampaignsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCampaignsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCampaignsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCampaignsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCampaignsOutputResponse(campaigns: \(Swift.String(describing: campaigns)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCampaignsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCampaignsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaigns = output.campaigns
            self.nextToken = output.nextToken
        } else {
            self.campaigns = nil
            self.nextToken = nil
        }
    }
}

public struct ListCampaignsOutputResponse: Swift.Equatable {
    /// A list of the campaigns.
    public var campaigns: [PersonalizeClientTypes.CampaignSummary]?
    /// A token for getting the next set of campaigns (if they exist).
    public var nextToken: Swift.String?

    public init (
        campaigns: [PersonalizeClientTypes.CampaignSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaigns = campaigns
        self.nextToken = nextToken
    }
}

struct ListCampaignsOutputResponseBody: Swift.Equatable {
    public let campaigns: [PersonalizeClientTypes.CampaignSummary]?
    public let nextToken: Swift.String?
}

extension ListCampaignsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaigns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.CampaignSummary?].self, forKey: .campaigns)
        var campaignsDecoded0:[PersonalizeClientTypes.CampaignSummary]? = nil
        if let campaignsContainer = campaignsContainer {
            campaignsDecoded0 = [PersonalizeClientTypes.CampaignSummary]()
            for structure0 in campaignsContainer {
                if let structure0 = structure0 {
                    campaignsDecoded0?.append(structure0)
                }
            }
        }
        campaigns = campaignsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetExportJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetExportJobsOutputError>
}

extension ListDatasetExportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetExportJobsInput(datasetArn: \(Swift.String(describing: datasetArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetExportJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetExportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetExportJobsOutputError>
}

public struct ListDatasetExportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetExportJobsOutputError>
}

public struct ListDatasetExportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetExportJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDatasetExportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetExportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetExportJobsOutputError>
}

public struct ListDatasetExportJobsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to list the dataset export jobs for.
    public var datasetArn: Swift.String?
    /// The maximum number of dataset export jobs to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetExportJobs for getting
    ///       the next set of dataset export jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetExportJobsInputBody: Swift.Equatable {
    public let datasetArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDatasetExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetExportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetExportJobsOutputResponse(datasetExportJobs: \(Swift.String(describing: datasetExportJobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetExportJobs = output.datasetExportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetExportJobsOutputResponse: Swift.Equatable {
    /// The list of dataset export jobs.
    public var datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]?
    /// A token for getting the next set of dataset export jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetExportJobs = datasetExportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetExportJobsOutputResponseBody: Swift.Equatable {
    public let datasetExportJobs: [PersonalizeClientTypes.DatasetExportJobSummary]?
    public let nextToken: Swift.String?
}

extension ListDatasetExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetExportJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetExportJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetExportJobSummary?].self, forKey: .datasetExportJobs)
        var datasetExportJobsDecoded0:[PersonalizeClientTypes.DatasetExportJobSummary]? = nil
        if let datasetExportJobsContainer = datasetExportJobsContainer {
            datasetExportJobsDecoded0 = [PersonalizeClientTypes.DatasetExportJobSummary]()
            for structure0 in datasetExportJobsContainer {
                if let structure0 = structure0 {
                    datasetExportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetExportJobs = datasetExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetGroupsOutputError>
}

extension ListDatasetGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetGroupsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDatasetGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInput: Swift.Equatable {
    /// The maximum number of dataset groups to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetGroups for getting the
    ///       next set of dataset groups (if they exist).
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDatasetGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetGroupsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetGroupsOutputResponse(datasetGroups: \(Swift.String(describing: datasetGroups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetGroups = output.datasetGroups
            self.nextToken = output.nextToken
        } else {
            self.datasetGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetGroupsOutputResponse: Swift.Equatable {
    /// The list of your dataset groups.
    public var datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]?
    /// A token for getting the next set of dataset groups (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsOutputResponseBody: Swift.Equatable {
    public let datasetGroups: [PersonalizeClientTypes.DatasetGroupSummary]?
    public let nextToken: Swift.String?
}

extension ListDatasetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroups
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetGroupSummary?].self, forKey: .datasetGroups)
        var datasetGroupsDecoded0:[PersonalizeClientTypes.DatasetGroupSummary]? = nil
        if let datasetGroupsContainer = datasetGroupsContainer {
            datasetGroupsDecoded0 = [PersonalizeClientTypes.DatasetGroupSummary]()
            for structure0 in datasetGroupsContainer {
                if let structure0 = structure0 {
                    datasetGroupsDecoded0?.append(structure0)
                }
            }
        }
        datasetGroups = datasetGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetImportJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetImportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetImportJobsOutputError>
}

extension ListDatasetImportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetImportJobsInput(datasetArn: \(Swift.String(describing: datasetArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetImportJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetImportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetImportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetImportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetImportJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDatasetImportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetImportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset to list the dataset import jobs for.
    public var datasetArn: Swift.String?
    /// The maximum number of dataset import jobs to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetImportJobs for getting
    ///       the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsInputBody: Swift.Equatable {
    public let datasetArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDatasetImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetImportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetImportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetImportJobsOutputResponse(datasetImportJobs: \(Swift.String(describing: datasetImportJobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetImportJobs = output.datasetImportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetImportJobsOutputResponse: Swift.Equatable {
    /// The list of dataset import jobs.
    public var datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]?
    /// A token for getting the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsOutputResponseBody: Swift.Equatable {
    public let datasetImportJobs: [PersonalizeClientTypes.DatasetImportJobSummary]?
    public let nextToken: Swift.String?
}

extension ListDatasetImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetImportJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetImportJobSummary?].self, forKey: .datasetImportJobs)
        var datasetImportJobsDecoded0:[PersonalizeClientTypes.DatasetImportJobSummary]? = nil
        if let datasetImportJobsContainer = datasetImportJobsContainer {
            datasetImportJobsDecoded0 = [PersonalizeClientTypes.DatasetImportJobSummary]()
            for structure0 in datasetImportJobsContainer {
                if let structure0 = structure0 {
                    datasetImportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetImportJobs = datasetImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

extension ListDatasetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDatasetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDatasetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDatasetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group that contains the datasets to
    ///       list.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of datasets to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListDatasetImportJobs for getting
    ///       the next set of dataset import jobs (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListDatasetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDatasetsOutputResponse(datasets: \(Swift.String(describing: datasets)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Swift.Equatable {
    /// An array of Dataset objects. Each object provides metadata
    ///       information.
    public var datasets: [PersonalizeClientTypes.DatasetSummary]?
    /// A token for getting the next set of datasets (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasets: [PersonalizeClientTypes.DatasetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Swift.Equatable {
    public let datasets: [PersonalizeClientTypes.DatasetSummary]?
    public let nextToken: Swift.String?
}

extension ListDatasetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetSummary?].self, forKey: .datasets)
        var datasetsDecoded0:[PersonalizeClientTypes.DatasetSummary]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [PersonalizeClientTypes.DatasetSummary]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEventTrackersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventTrackersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventTrackersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventTrackersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventTrackersOutputError>
}

extension ListEventTrackersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventTrackersInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEventTrackersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEventTrackersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventTrackersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventTrackersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventTrackersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventTrackersOutputError>
}

public struct ListEventTrackersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventTrackersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEventTrackersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEventTrackersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventTrackersOutputError>
}

public struct ListEventTrackersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEventTrackersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListEventTrackersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEventTrackersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEventTrackersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEventTrackersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEventTrackersOutputError>
}

public struct ListEventTrackersInput: Swift.Equatable {
    /// The ARN of a dataset group used to filter the response.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of event trackers to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListEventTrackers for getting
    ///       the next set of event trackers (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEventTrackersInputBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListEventTrackersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventTrackersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventTrackersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventTrackersOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventTrackersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEventTrackersOutputResponse(eventTrackers: \(Swift.String(describing: eventTrackers)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEventTrackersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEventTrackersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventTrackers = output.eventTrackers
            self.nextToken = output.nextToken
        } else {
            self.eventTrackers = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventTrackersOutputResponse: Swift.Equatable {
    /// A list of event trackers.
    public var eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]?
    /// A token for getting the next set of event trackers (if they exist).
    public var nextToken: Swift.String?

    public init (
        eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTrackers = eventTrackers
        self.nextToken = nextToken
    }
}

struct ListEventTrackersOutputResponseBody: Swift.Equatable {
    public let eventTrackers: [PersonalizeClientTypes.EventTrackerSummary]?
    public let nextToken: Swift.String?
}

extension ListEventTrackersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTrackers
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTrackersContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.EventTrackerSummary?].self, forKey: .eventTrackers)
        var eventTrackersDecoded0:[PersonalizeClientTypes.EventTrackerSummary]? = nil
        if let eventTrackersContainer = eventTrackersContainer {
            eventTrackersDecoded0 = [PersonalizeClientTypes.EventTrackerSummary]()
            for structure0 in eventTrackersContainer {
                if let structure0 = structure0 {
                    eventTrackersDecoded0?.append(structure0)
                }
            }
        }
        eventTrackers = eventTrackersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFiltersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFiltersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFiltersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFiltersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFiltersOutputError>
}

extension ListFiltersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFiltersInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFiltersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFiltersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFiltersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFiltersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFiltersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFiltersOutputError>
}

public struct ListFiltersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFiltersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFiltersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFiltersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFiltersOutputError>
}

public struct ListFiltersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFiltersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFiltersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFiltersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFiltersOutputError>
}

public struct ListFiltersInput: Swift.Equatable {
    /// The ARN of the dataset group that contains the filters.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of filters to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListFilters for getting the
    ///             next set of filters (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListFiltersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFiltersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFiltersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFiltersOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFiltersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFiltersOutputResponse(filters: \(Swift.String(describing: filters)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFiltersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFiltersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filters = output.filters
            self.nextToken = output.nextToken
        } else {
            self.filters = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutputResponse: Swift.Equatable {
    /// A list of returned filters.
    public var filters: [PersonalizeClientTypes.FilterSummary]?
    /// A token for getting the next set of filters (if they exist).
    public var nextToken: Swift.String?

    public init (
        filters: [PersonalizeClientTypes.FilterSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputResponseBody: Swift.Equatable {
    public let filters: [PersonalizeClientTypes.FilterSummary]?
    public let nextToken: Swift.String?
}

extension ListFiltersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.FilterSummary?].self, forKey: .filters)
        var filtersDecoded0:[PersonalizeClientTypes.FilterSummary]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [PersonalizeClientTypes.FilterSummary]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRecipesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecipesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecipesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecipesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecipesOutputError>
}

extension ListRecipesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecipesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), recipeProvider: \(Swift.String(describing: recipeProvider)))"}
}

extension ListRecipesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case recipeProvider
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let recipeProvider = recipeProvider {
            try encodeContainer.encode(recipeProvider.rawValue, forKey: .recipeProvider)
        }
    }
}

public struct ListRecipesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecipesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecipesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecipesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecipesOutputError>
}

public struct ListRecipesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecipesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecipesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecipesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecipesOutputError>
}

public struct ListRecipesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecipesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListRecipesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecipesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecipesOutputError>
}

public struct ListRecipesInput: Swift.Equatable {
    /// The maximum number of recipes to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListRecipes for getting
    ///       the next set of recipes (if they exist).
    public var nextToken: Swift.String?
    /// The default is SERVICE.
    public var recipeProvider: PersonalizeClientTypes.RecipeProvider?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recipeProvider: PersonalizeClientTypes.RecipeProvider? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recipeProvider = recipeProvider
    }
}

struct ListRecipesInputBody: Swift.Equatable {
    public let recipeProvider: PersonalizeClientTypes.RecipeProvider?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListRecipesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case recipeProvider
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipeProviderDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.RecipeProvider.self, forKey: .recipeProvider)
        recipeProvider = recipeProviderDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRecipesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecipesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecipesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecipesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecipesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), recipes: \(Swift.String(describing: recipes)))"}
}

extension ListRecipesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecipesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recipes = output.recipes
        } else {
            self.nextToken = nil
            self.recipes = nil
        }
    }
}

public struct ListRecipesOutputResponse: Swift.Equatable {
    /// A token for getting the next set of recipes.
    public var nextToken: Swift.String?
    /// The list of available recipes.
    public var recipes: [PersonalizeClientTypes.RecipeSummary]?

    public init (
        nextToken: Swift.String? = nil,
        recipes: [PersonalizeClientTypes.RecipeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recipes = recipes
    }
}

struct ListRecipesOutputResponseBody: Swift.Equatable {
    public let recipes: [PersonalizeClientTypes.RecipeSummary]?
    public let nextToken: Swift.String?
}

extension ListRecipesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recipes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recipesContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.RecipeSummary?].self, forKey: .recipes)
        var recipesDecoded0:[PersonalizeClientTypes.RecipeSummary]? = nil
        if let recipesContainer = recipesContainer {
            recipesDecoded0 = [PersonalizeClientTypes.RecipeSummary]()
            for structure0 in recipesContainer {
                if let structure0 = structure0 {
                    recipesDecoded0?.append(structure0)
                }
            }
        }
        recipes = recipesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSchemasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSchemasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSchemasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSchemasOutputError>
}

extension ListSchemasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSchemasInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSchemasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSchemasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSchemasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSchemasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSchemasOutputError>
}

public struct ListSchemasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSchemasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSchemasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSchemasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSchemasOutputError>
}

public struct ListSchemasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSchemasInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListSchemasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSchemasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSchemasInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSchemasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSchemasOutputError>
}

public struct ListSchemasInput: Swift.Equatable {
    /// The maximum number of schemas to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSchemas for getting
    ///       the next set of schemas (if they exist).
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSchemasInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListSchemasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSchemasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSchemasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSchemasOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSchemasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSchemasOutputResponse(nextToken: \(Swift.String(describing: nextToken)), schemas: \(Swift.String(describing: schemas)))"}
}

extension ListSchemasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSchemasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemas = output.schemas
        } else {
            self.nextToken = nil
            self.schemas = nil
        }
    }
}

public struct ListSchemasOutputResponse: Swift.Equatable {
    /// A token used to get the next set of schemas (if they exist).
    public var nextToken: Swift.String?
    /// A list of schemas.
    public var schemas: [PersonalizeClientTypes.DatasetSchemaSummary]?

    public init (
        nextToken: Swift.String? = nil,
        schemas: [PersonalizeClientTypes.DatasetSchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

struct ListSchemasOutputResponseBody: Swift.Equatable {
    public let schemas: [PersonalizeClientTypes.DatasetSchemaSummary]?
    public let nextToken: Swift.String?
}

extension ListSchemasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case schemas
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.DatasetSchemaSummary?].self, forKey: .schemas)
        var schemasDecoded0:[PersonalizeClientTypes.DatasetSchemaSummary]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [PersonalizeClientTypes.DatasetSchemaSummary]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSolutionVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSolutionVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSolutionVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSolutionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSolutionVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSolutionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSolutionVersionsOutputError>
}

extension ListSolutionVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSolutionVersionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), solutionArn: \(Swift.String(describing: solutionArn)))"}
}

extension ListSolutionVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
    }
}

public struct ListSolutionVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSolutionVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSolutionVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSolutionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSolutionVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSolutionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSolutionVersionsOutputError>
}

public struct ListSolutionVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSolutionVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSolutionVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSolutionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSolutionVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSolutionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSolutionVersionsOutputError>
}

public struct ListSolutionVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSolutionVersionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListSolutionVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSolutionVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSolutionVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSolutionVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSolutionVersionsOutputError>
}

public struct ListSolutionVersionsInput: Swift.Equatable {
    /// The maximum number of solution versions to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSolutionVersions for getting
    ///       the next set of solution versions (if they exist).
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the solution.
    public var solutionArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        solutionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.solutionArn = solutionArn
    }
}

struct ListSolutionVersionsInputBody: Swift.Equatable {
    public let solutionArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListSolutionVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case solutionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSolutionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolutionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSolutionVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolutionVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSolutionVersionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), solutionVersions: \(Swift.String(describing: solutionVersions)))"}
}

extension ListSolutionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSolutionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.solutionVersions = output.solutionVersions
        } else {
            self.nextToken = nil
            self.solutionVersions = nil
        }
    }
}

public struct ListSolutionVersionsOutputResponse: Swift.Equatable {
    /// A token for getting the next set of solution versions (if they exist).
    public var nextToken: Swift.String?
    /// A list of solution versions describing the version properties.
    public var solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutionVersions = solutionVersions
    }
}

struct ListSolutionVersionsOutputResponseBody: Swift.Equatable {
    public let solutionVersions: [PersonalizeClientTypes.SolutionVersionSummary]?
    public let nextToken: Swift.String?
}

extension ListSolutionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case solutionVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.SolutionVersionSummary?].self, forKey: .solutionVersions)
        var solutionVersionsDecoded0:[PersonalizeClientTypes.SolutionVersionSummary]? = nil
        if let solutionVersionsContainer = solutionVersionsContainer {
            solutionVersionsDecoded0 = [PersonalizeClientTypes.SolutionVersionSummary]()
            for structure0 in solutionVersionsContainer {
                if let structure0 = structure0 {
                    solutionVersionsDecoded0?.append(structure0)
                }
            }
        }
        solutionVersions = solutionVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListSolutionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSolutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSolutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSolutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSolutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSolutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSolutionsOutputError>
}

extension ListSolutionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSolutionsInput(datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListSolutionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSolutionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSolutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSolutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSolutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSolutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSolutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSolutionsOutputError>
}

public struct ListSolutionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSolutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListSolutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSolutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListSolutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListSolutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSolutionsOutputError>
}

public struct ListSolutionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListSolutionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListSolutionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListSolutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListSolutionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListSolutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListSolutionsOutputError>
}

public struct ListSolutionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the dataset group.
    public var datasetGroupArn: Swift.String?
    /// The maximum number of solutions to return.
    public var maxResults: Swift.Int?
    /// A token returned from the previous call to ListSolutions for getting
    ///       the next set of solutions (if they exist).
    public var nextToken: Swift.String?

    public init (
        datasetGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSolutionsInputBody: Swift.Equatable {
    public let datasetGroupArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListSolutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetGroupArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSolutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSolutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSolutionsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSolutionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSolutionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), solutions: \(Swift.String(describing: solutions)))"}
}

extension ListSolutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSolutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.solutions = output.solutions
        } else {
            self.nextToken = nil
            self.solutions = nil
        }
    }
}

public struct ListSolutionsOutputResponse: Swift.Equatable {
    /// A token for getting the next set of solutions (if they exist).
    public var nextToken: Swift.String?
    /// A list of the current solutions.
    public var solutions: [PersonalizeClientTypes.SolutionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        solutions: [PersonalizeClientTypes.SolutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.solutions = solutions
    }
}

struct ListSolutionsOutputResponseBody: Swift.Equatable {
    public let solutions: [PersonalizeClientTypes.SolutionSummary]?
    public let nextToken: Swift.String?
}

extension ListSolutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case solutions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionsContainer = try containerValues.decodeIfPresent([PersonalizeClientTypes.SolutionSummary?].self, forKey: .solutions)
        var solutionsDecoded0:[PersonalizeClientTypes.SolutionSummary]? = nil
        if let solutionsContainer = solutionsContainer {
            solutionsDecoded0 = [PersonalizeClientTypes.SolutionSummary]()
            for structure0 in solutionsContainer {
                if let structure0 = structure0 {
                    solutionsDecoded0?.append(structure0)
                }
            }
        }
        solutions = solutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PersonalizeClientTypes {
    public enum ObjectiveSensitivity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [ObjectiveSensitivity] {
            return [
                .high,
                .low,
                .medium,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObjectiveSensitivity(rawValue: rawValue) ?? ObjectiveSensitivity.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.OptimizationObjective: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemAttribute
        case objectiveSensitivity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemAttribute = itemAttribute {
            try encodeContainer.encode(itemAttribute, forKey: .itemAttribute)
        }
        if let objectiveSensitivity = objectiveSensitivity {
            try encodeContainer.encode(objectiveSensitivity.rawValue, forKey: .objectiveSensitivity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemAttribute)
        itemAttribute = itemAttributeDecoded
        let objectiveSensitivityDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.ObjectiveSensitivity.self, forKey: .objectiveSensitivity)
        objectiveSensitivity = objectiveSensitivityDecoded
    }
}

extension PersonalizeClientTypes.OptimizationObjective: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptimizationObjective(itemAttribute: \(Swift.String(describing: itemAttribute)), objectiveSensitivity: \(Swift.String(describing: objectiveSensitivity)))"}
}

extension PersonalizeClientTypes {
    /// Describes the additional objective for the solution, such as maximizing streaming
    ///       minutes or increasing revenue. For more information see <a href="https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html">Optimizing a solution.
    public struct OptimizationObjective: Swift.Equatable {
        /// The numerical metadata column in an Items dataset related to the optimization objective. For example, VIDEO_LENGTH (to maximize streaming minutes), or PRICE (to maximize revenue).
        public var itemAttribute: Swift.String?
        /// Specifies how Amazon Personalize balances the importance of your optimization objective versus relevance.
        public var objectiveSensitivity: PersonalizeClientTypes.ObjectiveSensitivity?

        public init (
            itemAttribute: Swift.String? = nil,
            objectiveSensitivity: PersonalizeClientTypes.ObjectiveSensitivity? = nil
        )
        {
            self.itemAttribute = itemAttribute
            self.objectiveSensitivity = objectiveSensitivity
        }
    }

}

extension PersonalizeClientTypes.Recipe: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmArn
        case creationDateTime
        case description
        case featureTransformationArn
        case lastUpdatedDateTime
        case name
        case recipeArn
        case recipeType
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let featureTransformationArn = featureTransformationArn {
            try encodeContainer.encode(featureTransformationArn, forKey: .featureTransformationArn)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let recipeType = recipeType {
            try encodeContainer.encode(recipeType, forKey: .recipeType)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let featureTransformationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureTransformationArn)
        featureTransformationArn = featureTransformationArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let recipeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeType)
        recipeType = recipeTypeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.Recipe: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Recipe(algorithmArn: \(Swift.String(describing: algorithmArn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), featureTransformationArn: \(Swift.String(describing: featureTransformationArn)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), recipeArn: \(Swift.String(describing: recipeArn)), recipeType: \(Swift.String(describing: recipeType)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides information about a recipe. Each recipe provides an algorithm
    ///       that Amazon Personalize uses in model training when you use the CreateSolution
    ///       operation.
    public struct Recipe: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the algorithm that Amazon Personalize uses to train
        ///       the model.
        public var algorithmArn: Swift.String?
        /// The date and time (in Unix format) that the recipe was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The description of the recipe.
        public var description: Swift.String?
        /// The ARN of the FeatureTransformation object.
        public var featureTransformationArn: Swift.String?
        /// The date and time (in Unix format) that the recipe was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the recipe.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public var recipeArn: Swift.String?
        /// One of the following values:
        ///
        ///
        ///                PERSONALIZED_RANKING
        ///
        ///
        ///                RELATED_ITEMS
        ///
        ///
        ///                USER_PERSONALIZATION
        ///
        ///
        public var recipeType: Swift.String?
        /// The status of the recipe.
        public var status: Swift.String?

        public init (
            algorithmArn: Swift.String? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            featureTransformationArn: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            recipeType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.algorithmArn = algorithmArn
            self.creationDateTime = creationDateTime
            self.description = description
            self.featureTransformationArn = featureTransformationArn
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.recipeType = recipeType
            self.status = status
        }
    }

}

extension PersonalizeClientTypes {
    public enum RecipeProvider: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [RecipeProvider] {
            return [
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecipeProvider(rawValue: rawValue) ?? RecipeProvider.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.RecipeSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case recipeArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.RecipeSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecipeSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), recipeArn: \(Swift.String(describing: recipeArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a recipe. For a complete listing, call the
    ///       DescribeRecipe API.
    public struct RecipeSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the recipe was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The date and time (in Unix time) that the recipe was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the recipe.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the recipe.
        public var recipeArn: Swift.String?
        /// The status of the recipe.
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            recipeArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.recipeArn = recipeArn
            self.status = status
        }
    }

}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Could not find the specified resource.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PersonalizeClientTypes.S3DataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
        case path
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension PersonalizeClientTypes.S3DataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3DataConfig(kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), path: \(Swift.String(describing: path)))"}
}

extension PersonalizeClientTypes {
    /// The configuration details of an Amazon S3 input or output bucket.
    public struct S3DataConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key that Amazon Personalize uses to
        ///       encrypt or decrypt the input and output files of a batch inference job.
        public var kmsKeyArn: Swift.String?
        /// The file path of the Amazon S3 bucket.
        /// This member is required.
        public var path: Swift.String?

        public init (
            kmsKeyArn: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
        }
    }

}

extension PersonalizeClientTypes.Solution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoMLResult
        case creationDateTime
        case datasetGroupArn
        case eventType
        case lastUpdatedDateTime
        case latestSolutionVersion
        case name
        case performAutoML
        case performHPO
        case recipeArn
        case solutionArn
        case solutionConfig
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoMLResult = autoMLResult {
            try encodeContainer.encode(autoMLResult, forKey: .autoMLResult)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let latestSolutionVersion = latestSolutionVersion {
            try encodeContainer.encode(latestSolutionVersion, forKey: .latestSolutionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if performHPO != false {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let solutionConfig = solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let performHPODecoded = try containerValues.decode(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decode(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let autoMLResultDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.AutoMLResult.self, forKey: .autoMLResult)
        autoMLResult = autoMLResultDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let latestSolutionVersionDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionVersionSummary.self, forKey: .latestSolutionVersion)
        latestSolutionVersion = latestSolutionVersionDecoded
    }
}

extension PersonalizeClientTypes.Solution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Solution(autoMLResult: \(Swift.String(describing: autoMLResult)), creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), eventType: \(Swift.String(describing: eventType)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), latestSolutionVersion: \(Swift.String(describing: latestSolutionVersion)), name: \(Swift.String(describing: name)), performAutoML: \(Swift.String(describing: performAutoML)), performHPO: \(Swift.String(describing: performHPO)), recipeArn: \(Swift.String(describing: recipeArn)), solutionArn: \(Swift.String(describing: solutionArn)), solutionConfig: \(Swift.String(describing: solutionConfig)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// An object that provides information about a solution. A solution is a trained model
    ///       that can be deployed as a campaign.
    public struct Solution: Swift.Equatable {
        /// When performAutoML is true, specifies the best recipe found.
        public var autoMLResult: PersonalizeClientTypes.AutoMLResult?
        /// The creation date and time (in Unix time) of the solution.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provides the training data.
        public var datasetGroupArn: Swift.String?
        /// The event type (for example, 'click' or 'like') that is used for training the model.
        ///       If no eventType is provided, Amazon Personalize uses all interactions for training with
        ///       equal weight regardless of type.
        public var eventType: Swift.String?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// Describes the latest version of the solution, including the status and the ARN.
        public var latestSolutionVersion: PersonalizeClientTypes.SolutionVersionSummary?
        /// The name of the solution.
        public var name: Swift.String?
        /// When true, Amazon Personalize performs a search for the best USER_PERSONALIZATION recipe from
        ///       the list specified in the solution configuration (recipeArn must not be specified).
        ///       When false (the default), Amazon Personalize uses recipeArn for training.
        public var performAutoML: Swift.Bool
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The
        ///       default is false.
        public var performHPO: Swift.Bool
        /// The ARN of the recipe used to create the solution.
        public var recipeArn: Swift.String?
        /// The ARN of the solution.
        public var solutionArn: Swift.String?
        /// Describes the configuration properties for the solution.
        public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
        /// The status of the solution.
        ///          A solution can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING > DELETE IN_PROGRESS
        ///
        ///
        public var status: Swift.String?

        public init (
            autoMLResult: PersonalizeClientTypes.AutoMLResult? = nil,
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventType: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            latestSolutionVersion: PersonalizeClientTypes.SolutionVersionSummary? = nil,
            name: Swift.String? = nil,
            performAutoML: Swift.Bool = false,
            performHPO: Swift.Bool = false,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
            status: Swift.String? = nil
        )
        {
            self.autoMLResult = autoMLResult
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.latestSolutionVersion = latestSolutionVersion
            self.name = name
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.SolutionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmHyperParameters
        case autoMLConfig
        case eventValueThreshold
        case featureTransformationParameters
        case hpoConfig
        case optimizationObjective
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameters = algorithmHyperParameters {
            var algorithmHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .algorithmHyperParameters)
            for (dictKey0, hyperparameters0) in algorithmHyperParameters {
                try algorithmHyperParametersContainer.encode(hyperparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let autoMLConfig = autoMLConfig {
            try encodeContainer.encode(autoMLConfig, forKey: .autoMLConfig)
        }
        if let eventValueThreshold = eventValueThreshold {
            try encodeContainer.encode(eventValueThreshold, forKey: .eventValueThreshold)
        }
        if let featureTransformationParameters = featureTransformationParameters {
            var featureTransformationParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .featureTransformationParameters)
            for (dictKey0, featuretransformationparameters0) in featureTransformationParameters {
                try featureTransformationParametersContainer.encode(featuretransformationparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let hpoConfig = hpoConfig {
            try encodeContainer.encode(hpoConfig, forKey: .hpoConfig)
        }
        if let optimizationObjective = optimizationObjective {
            try encodeContainer.encode(optimizationObjective, forKey: .optimizationObjective)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventValueThresholdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventValueThreshold)
        eventValueThreshold = eventValueThresholdDecoded
        let hpoConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.HPOConfig.self, forKey: .hpoConfig)
        hpoConfig = hpoConfigDecoded
        let algorithmHyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .algorithmHyperParameters)
        var algorithmHyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let algorithmHyperParametersContainer = algorithmHyperParametersContainer {
            algorithmHyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in algorithmHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    algorithmHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        algorithmHyperParameters = algorithmHyperParametersDecoded0
        let featureTransformationParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .featureTransformationParameters)
        var featureTransformationParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let featureTransformationParametersContainer = featureTransformationParametersContainer {
            featureTransformationParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in featureTransformationParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    featureTransformationParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        featureTransformationParameters = featureTransformationParametersDecoded0
        let autoMLConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.AutoMLConfig.self, forKey: .autoMLConfig)
        autoMLConfig = autoMLConfigDecoded
        let optimizationObjectiveDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.OptimizationObjective.self, forKey: .optimizationObjective)
        optimizationObjective = optimizationObjectiveDecoded
    }
}

extension PersonalizeClientTypes.SolutionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SolutionConfig(algorithmHyperParameters: \(Swift.String(describing: algorithmHyperParameters)), autoMLConfig: \(Swift.String(describing: autoMLConfig)), eventValueThreshold: \(Swift.String(describing: eventValueThreshold)), featureTransformationParameters: \(Swift.String(describing: featureTransformationParameters)), hpoConfig: \(Swift.String(describing: hpoConfig)), optimizationObjective: \(Swift.String(describing: optimizationObjective)))"}
}

extension PersonalizeClientTypes {
    /// Describes the configuration properties for the solution.
    public struct SolutionConfig: Swift.Equatable {
        /// Lists the hyperparameter names and ranges.
        public var algorithmHyperParameters: [Swift.String:Swift.String]?
        /// The AutoMLConfig object containing a list of recipes to search
        ///       when AutoML is performed.
        public var autoMLConfig: PersonalizeClientTypes.AutoMLConfig?
        /// Only events with a value greater than or equal to this threshold are
        ///       used for training a model.
        public var eventValueThreshold: Swift.String?
        /// Lists the feature transformation parameters.
        public var featureTransformationParameters: [Swift.String:Swift.String]?
        /// Describes the properties for hyperparameter optimization (HPO).
        public var hpoConfig: PersonalizeClientTypes.HPOConfig?
        /// Describes the additional objective for the solution, such as maximizing streaming
        ///       minutes or increasing revenue. For more information see <a href="https://docs.aws.amazon.com/personalize/latest/dg/optimizing-solution-for-objective.html">Optimizing a solution.
        public var optimizationObjective: PersonalizeClientTypes.OptimizationObjective?

        public init (
            algorithmHyperParameters: [Swift.String:Swift.String]? = nil,
            autoMLConfig: PersonalizeClientTypes.AutoMLConfig? = nil,
            eventValueThreshold: Swift.String? = nil,
            featureTransformationParameters: [Swift.String:Swift.String]? = nil,
            hpoConfig: PersonalizeClientTypes.HPOConfig? = nil,
            optimizationObjective: PersonalizeClientTypes.OptimizationObjective? = nil
        )
        {
            self.algorithmHyperParameters = algorithmHyperParameters
            self.autoMLConfig = autoMLConfig
            self.eventValueThreshold = eventValueThreshold
            self.featureTransformationParameters = featureTransformationParameters
            self.hpoConfig = hpoConfig
            self.optimizationObjective = optimizationObjective
        }
    }

}

extension PersonalizeClientTypes.SolutionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case lastUpdatedDateTime
        case name
        case solutionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.SolutionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SolutionSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), name: \(Swift.String(describing: name)), solutionArn: \(Swift.String(describing: solutionArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a solution. For a complete listing, call the
    ///       DescribeSolution API.
    public struct SolutionSummary: Swift.Equatable {
        /// The date and time (in Unix time) that the solution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The date and time (in Unix time) that the solution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The name of the solution.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the solution.
        public var solutionArn: Swift.String?
        /// The status of the solution.
        ///          A solution can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        ///                DELETE PENDING > DELETE IN_PROGRESS
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.name = name
            self.solutionArn = solutionArn
            self.status = status
        }
    }

}

extension PersonalizeClientTypes.SolutionVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case datasetGroupArn
        case eventType
        case failureReason
        case lastUpdatedDateTime
        case performAutoML
        case performHPO
        case recipeArn
        case solutionArn
        case solutionConfig
        case solutionVersionArn
        case status
        case trainingHours
        case trainingMode
        case tunedHPOParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if performAutoML != false {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if performHPO != false {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let recipeArn = recipeArn {
            try encodeContainer.encode(recipeArn, forKey: .recipeArn)
        }
        if let solutionArn = solutionArn {
            try encodeContainer.encode(solutionArn, forKey: .solutionArn)
        }
        if let solutionConfig = solutionConfig {
            try encodeContainer.encode(solutionConfig, forKey: .solutionConfig)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trainingHours = trainingHours {
            try encodeContainer.encode(trainingHours, forKey: .trainingHours)
        }
        if let trainingMode = trainingMode {
            try encodeContainer.encode(trainingMode.rawValue, forKey: .trainingMode)
        }
        if let tunedHPOParams = tunedHPOParams {
            try encodeContainer.encode(tunedHPOParams, forKey: .tunedHPOParams)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let solutionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionArn)
        solutionArn = solutionArnDecoded
        let performHPODecoded = try containerValues.decode(Swift.Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let performAutoMLDecoded = try containerValues.decode(Swift.Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let recipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipeArn)
        recipeArn = recipeArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let solutionConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.SolutionConfig.self, forKey: .solutionConfig)
        solutionConfig = solutionConfigDecoded
        let trainingHoursDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .trainingHours)
        trainingHours = trainingHoursDecoded
        let trainingModeDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TrainingMode.self, forKey: .trainingMode)
        trainingMode = trainingModeDecoded
        let tunedHPOParamsDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.TunedHPOParams.self, forKey: .tunedHPOParams)
        tunedHPOParams = tunedHPOParamsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
    }
}

extension PersonalizeClientTypes.SolutionVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SolutionVersion(creationDateTime: \(Swift.String(describing: creationDateTime)), datasetGroupArn: \(Swift.String(describing: datasetGroupArn)), eventType: \(Swift.String(describing: eventType)), failureReason: \(Swift.String(describing: failureReason)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), performAutoML: \(Swift.String(describing: performAutoML)), performHPO: \(Swift.String(describing: performHPO)), recipeArn: \(Swift.String(describing: recipeArn)), solutionArn: \(Swift.String(describing: solutionArn)), solutionConfig: \(Swift.String(describing: solutionConfig)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)), status: \(Swift.String(describing: status)), trainingHours: \(Swift.String(describing: trainingHours)), trainingMode: \(Swift.String(describing: trainingMode)), tunedHPOParams: \(Swift.String(describing: tunedHPOParams)))"}
}

extension PersonalizeClientTypes {
    /// An object that provides information about a specific version of a Solution.
    public struct SolutionVersion: Swift.Equatable {
        /// The date and
        ///       time
        ///       (in Unix time) that this version of the solution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the dataset group providing the training data.
        public var datasetGroupArn: Swift.String?
        /// The event type (for example, 'click' or 'like') that is used for training the
        ///       model.
        public var eventType: Swift.String?
        /// If training a solution version fails, the reason for the failure.
        public var failureReason: Swift.String?
        /// The date and time (in
        ///       Unix
        ///       time) that the solution was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// When true, Amazon Personalize searches for the most optimal recipe according to the solution
        ///       configuration. When false (the default), Amazon Personalize uses recipeArn.
        public var performAutoML: Swift.Bool
        /// Whether to perform hyperparameter optimization (HPO) on the chosen recipe. The default is
        ///         false.
        public var performHPO: Swift.Bool
        /// The ARN of the recipe used in the solution.
        public var recipeArn: Swift.String?
        /// The ARN of the solution.
        public var solutionArn: Swift.String?
        /// Describes the configuration properties for the solution.
        public var solutionConfig: PersonalizeClientTypes.SolutionConfig?
        /// The ARN of the solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the solution version.
        ///          A solution version can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING
        ///
        ///
        ///                CREATE IN_PROGRESS
        ///
        ///
        ///                ACTIVE
        ///
        ///
        ///                CREATE FAILED
        ///
        ///
        ///                CREATE STOPPING
        ///
        ///
        ///                CREATE STOPPED
        ///
        ///
        public var status: Swift.String?
        /// The time used to train the model. You are billed for the time it takes to train a model.
        ///       This field is visible only after Amazon Personalize successfully trains a model.
        public var trainingHours: Swift.Double?
        /// The scope of training to be performed when creating the solution version. The
        ///       FULL option trains the solution version based on the entirety of the input
        ///       solution's training data, while the UPDATE option processes only the data that
        ///       has changed in comparison to the input solution. Choose UPDATE when you want to
        ///       incrementally update your solution version instead of creating an entirely new one.
        ///
        ///             The UPDATE option can only be used when you already have an active solution
        ///         version created from the input solution using the FULL option and the input
        ///         solution was trained with the
        ///         <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-new-item-USER_PERSONALIZATION.html">User-Personalization
        ///         recipe or the
        ///         <a href="https://docs.aws.amazon.com/personalize/latest/dg/native-recipe-hrnn-coldstart.html">HRNN-Coldstart recipe.
        ///
        public var trainingMode: PersonalizeClientTypes.TrainingMode?
        /// If hyperparameter optimization was performed, contains the hyperparameter values of the
        ///       best performing model.
        public var tunedHPOParams: PersonalizeClientTypes.TunedHPOParams?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            datasetGroupArn: Swift.String? = nil,
            eventType: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            performAutoML: Swift.Bool = false,
            performHPO: Swift.Bool = false,
            recipeArn: Swift.String? = nil,
            solutionArn: Swift.String? = nil,
            solutionConfig: PersonalizeClientTypes.SolutionConfig? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil,
            trainingHours: Swift.Double? = nil,
            trainingMode: PersonalizeClientTypes.TrainingMode? = nil,
            tunedHPOParams: PersonalizeClientTypes.TunedHPOParams? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.datasetGroupArn = datasetGroupArn
            self.eventType = eventType
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.recipeArn = recipeArn
            self.solutionArn = solutionArn
            self.solutionConfig = solutionConfig
            self.solutionVersionArn = solutionVersionArn
            self.status = status
            self.trainingHours = trainingHours
            self.trainingMode = trainingMode
            self.tunedHPOParams = tunedHPOParams
        }
    }

}

extension PersonalizeClientTypes.SolutionVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime
        case failureReason
        case lastUpdatedDateTime
        case solutionVersionArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime.timeIntervalSince1970, forKey: .creationDateTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime.timeIntervalSince1970, forKey: .lastUpdatedDateTime)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension PersonalizeClientTypes.SolutionVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SolutionVersionSummary(creationDateTime: \(Swift.String(describing: creationDateTime)), failureReason: \(Swift.String(describing: failureReason)), lastUpdatedDateTime: \(Swift.String(describing: lastUpdatedDateTime)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)), status: \(Swift.String(describing: status)))"}
}

extension PersonalizeClientTypes {
    /// Provides a summary of the properties of a solution version. For a complete listing, call the
    ///       DescribeSolutionVersion API.
    public struct SolutionVersionSummary: Swift.Equatable {
        /// The date and time (in Unix time) that this version of a solution was created.
        public var creationDateTime: ClientRuntime.Date?
        /// If a solution version fails, the reason behind the failure.
        public var failureReason: Swift.String?
        /// The date and time (in Unix time) that the solution version was last updated.
        public var lastUpdatedDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the solution version.
        public var solutionVersionArn: Swift.String?
        /// The status of the solution version.
        ///          A solution version can be in one of the following states:
        ///
        ///
        ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
        ///
        ///
        public var status: Swift.String?

        public init (
            creationDateTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            lastUpdatedDateTime: ClientRuntime.Date? = nil,
            solutionVersionArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.failureReason = failureReason
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.solutionVersionArn = solutionVersionArn
            self.status = status
        }
    }

}

public struct StopSolutionVersionCreationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopSolutionVersionCreationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopSolutionVersionCreationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopSolutionVersionCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopSolutionVersionCreationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopSolutionVersionCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopSolutionVersionCreationOutputError>
}

extension StopSolutionVersionCreationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopSolutionVersionCreationInput(solutionVersionArn: \(Swift.String(describing: solutionVersionArn)))"}
}

extension StopSolutionVersionCreationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct StopSolutionVersionCreationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopSolutionVersionCreationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopSolutionVersionCreationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopSolutionVersionCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopSolutionVersionCreationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopSolutionVersionCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopSolutionVersionCreationOutputError>
}

public struct StopSolutionVersionCreationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopSolutionVersionCreationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopSolutionVersionCreationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopSolutionVersionCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopSolutionVersionCreationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopSolutionVersionCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopSolutionVersionCreationOutputError>
}

public struct StopSolutionVersionCreationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopSolutionVersionCreationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StopSolutionVersionCreationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopSolutionVersionCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopSolutionVersionCreationInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopSolutionVersionCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopSolutionVersionCreationOutputError>
}

public struct StopSolutionVersionCreationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the solution version you want to stop creating.
    /// This member is required.
    public var solutionVersionArn: Swift.String?

    public init (
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.solutionVersionArn = solutionVersionArn
    }
}

struct StopSolutionVersionCreationInputBody: Swift.Equatable {
    public let solutionVersionArn: Swift.String?
}

extension StopSolutionVersionCreationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
    }
}

extension StopSolutionVersionCreationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopSolutionVersionCreationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopSolutionVersionCreationOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopSolutionVersionCreationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopSolutionVersionCreationOutputResponse()"}
}

extension StopSolutionVersionCreationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopSolutionVersionCreationOutputResponse: Swift.Equatable {

    public init() {}
}

struct StopSolutionVersionCreationOutputResponseBody: Swift.Equatable {
}

extension StopSolutionVersionCreationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PersonalizeClientTypes {
    public enum TrainingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [TrainingMode] {
            return [
                .full,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrainingMode(rawValue: rawValue) ?? TrainingMode.sdkUnknown(rawValue)
        }
    }
}

extension PersonalizeClientTypes.TunedHPOParams: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithmHyperParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmHyperParameters = algorithmHyperParameters {
            var algorithmHyperParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .algorithmHyperParameters)
            for (dictKey0, hyperparameters0) in algorithmHyperParameters {
                try algorithmHyperParametersContainer.encode(hyperparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmHyperParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .algorithmHyperParameters)
        var algorithmHyperParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let algorithmHyperParametersContainer = algorithmHyperParametersContainer {
            algorithmHyperParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in algorithmHyperParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    algorithmHyperParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        algorithmHyperParameters = algorithmHyperParametersDecoded0
    }
}

extension PersonalizeClientTypes.TunedHPOParams: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TunedHPOParams(algorithmHyperParameters: \(Swift.String(describing: algorithmHyperParameters)))"}
}

extension PersonalizeClientTypes {
    /// If hyperparameter optimization (HPO) was performed, contains the hyperparameter values of
    ///       the best performing model.
    public struct TunedHPOParams: Swift.Equatable {
        /// A list of the hyperparameter values of the best performing model.
        public var algorithmHyperParameters: [Swift.String:Swift.String]?

        public init (
            algorithmHyperParameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.algorithmHyperParameters = algorithmHyperParameters
        }
    }

}

public struct UpdateCampaignInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCampaignOutputError>
}

extension UpdateCampaignInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCampaignInput(campaignArn: \(Swift.String(describing: campaignArn)), campaignConfig: \(Swift.String(describing: campaignConfig)), minProvisionedTPS: \(Swift.String(describing: minProvisionedTPS)), solutionVersionArn: \(Swift.String(describing: solutionVersionArn)))"}
}

extension UpdateCampaignInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case campaignConfig
        case minProvisionedTPS
        case solutionVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let campaignConfig = campaignConfig {
            try encodeContainer.encode(campaignConfig, forKey: .campaignConfig)
        }
        if let minProvisionedTPS = minProvisionedTPS {
            try encodeContainer.encode(minProvisionedTPS, forKey: .minProvisionedTPS)
        }
        if let solutionVersionArn = solutionVersionArn {
            try encodeContainer.encode(solutionVersionArn, forKey: .solutionVersionArn)
        }
    }
}

public struct UpdateCampaignInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCampaignOutputError>
}

public struct UpdateCampaignInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCampaignInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCampaignInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCampaignOutputError>
}

public struct UpdateCampaignInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCampaignInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateCampaignInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateCampaignInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCampaignOutputError>
}

public struct UpdateCampaignInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    /// This member is required.
    public var campaignArn: Swift.String?
    /// The configuration details of a campaign.
    public var campaignConfig: PersonalizeClientTypes.CampaignConfig?
    /// Specifies the requested minimum provisioned transactions (recommendations) per second that
    ///       Amazon Personalize will support.
    public var minProvisionedTPS: Swift.Int?
    /// The ARN of a new solution version to deploy.
    public var solutionVersionArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil,
        campaignConfig: PersonalizeClientTypes.CampaignConfig? = nil,
        minProvisionedTPS: Swift.Int? = nil,
        solutionVersionArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.campaignConfig = campaignConfig
        self.minProvisionedTPS = minProvisionedTPS
        self.solutionVersionArn = solutionVersionArn
    }
}

struct UpdateCampaignInputBody: Swift.Equatable {
    public let campaignArn: Swift.String?
    public let solutionVersionArn: Swift.String?
    public let minProvisionedTPS: Swift.Int?
    public let campaignConfig: PersonalizeClientTypes.CampaignConfig?
}

extension UpdateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case campaignConfig
        case minProvisionedTPS
        case solutionVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let solutionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionVersionArn)
        solutionVersionArn = solutionVersionArnDecoded
        let minProvisionedTPSDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minProvisionedTPS)
        minProvisionedTPS = minProvisionedTPSDecoded
        let campaignConfigDecoded = try containerValues.decodeIfPresent(PersonalizeClientTypes.CampaignConfig.self, forKey: .campaignConfig)
        campaignConfig = campaignConfigDecoded
    }
}

extension UpdateCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCampaignOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCampaignOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCampaignOutputResponse(campaignArn: \(Swift.String(describing: campaignArn)))"}
}

extension UpdateCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaignArn = output.campaignArn
        } else {
            self.campaignArn = nil
        }
    }
}

public struct UpdateCampaignOutputResponse: Swift.Equatable {
    /// The same campaign ARN as given in the request.
    public var campaignArn: Swift.String?

    public init (
        campaignArn: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
    }
}

struct UpdateCampaignOutputResponseBody: Swift.Equatable {
    public let campaignArn: Swift.String?
}

extension UpdateCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
    }
}
