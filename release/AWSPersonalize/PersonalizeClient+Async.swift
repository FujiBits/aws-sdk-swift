// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension PersonalizeClient {
    /// Creates a batch inference job. The operation can handle up to 50 million records and the
    ///       input file must be in JSON format. For more information, see recommendations-batch.
    func createBatchInferenceJob(input: CreateBatchInferenceJobInput) async throws -> CreateBatchInferenceJobOutputResponse
    {
        typealias createBatchInferenceJobContinuation = CheckedContinuation<CreateBatchInferenceJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createBatchInferenceJobContinuation) in
            createBatchInferenceJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a campaign by deploying a solution version. When a client calls the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations
    ///       and
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetPersonalizedRanking.html">GetPersonalizedRanking
    ///       APIs, a campaign is specified in the request.
    ///
    ///
    ///             Minimum Provisioned TPS and Auto-Scaling
    ///
    ///
    ///          A transaction is a single GetRecommendations or
    ///        GetPersonalizedRanking call. Transactions per second (TPS) is the throughput
    ///        and unit of billing for Amazon Personalize. The minimum provisioned TPS
    ///        (minProvisionedTPS) specifies the baseline throughput provisioned by
    ///        Amazon Personalize, and thus, the minimum billing charge.
    ///
    ///
    ///        If your TPS increases beyond
    ///        minProvisionedTPS, Amazon Personalize auto-scales the provisioned capacity up and down,
    ///        but never below minProvisionedTPS.
    ///        There's a short time delay while the capacity is increased that might cause loss of
    ///        transactions.
    ///          The actual TPS used is calculated as the average requests/second within a 5-minute window.
    ///       You pay for maximum of either the minimum provisioned TPS or the actual TPS.
    ///       We recommend starting with a low minProvisionedTPS, track
    ///        your usage using Amazon CloudWatch metrics, and then increase the minProvisionedTPS
    ///        as necessary.
    ///
    ///
    ///             Status
    ///
    ///          A campaign can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    ///                DELETE PENDING > DELETE IN_PROGRESS
    ///
    ///
    ///          To get the campaign status, call DescribeCampaign.
    ///
    ///             Wait until the status of the campaign
    ///         is ACTIVE before asking the campaign for recommendations.
    ///
    ///
    ///          <p class="title">
    ///             Related APIs
    ///
    ///
    ///
    ///
    ///                   ListCampaigns
    ///
    ///
    ///
    ///
    ///                   DescribeCampaign
    ///
    ///
    ///
    ///
    ///                   UpdateCampaign
    ///
    ///
    ///
    ///
    ///                   DeleteCampaign
    ///
    ///
    ///
    func createCampaign(input: CreateCampaignInput) async throws -> CreateCampaignOutputResponse
    {
        typealias createCampaignContinuation = CheckedContinuation<CreateCampaignOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createCampaignContinuation) in
            createCampaign(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an empty dataset and adds it to the specified dataset group. Use CreateDatasetImportJob to import your training data to a dataset.
    ///          There are three types of datasets:
    ///
    ///
    ///                Interactions
    ///
    ///
    ///                Items
    ///
    ///
    ///                Users
    ///
    ///
    ///          Each dataset type has an associated schema with required field types. Only the
    ///         Interactions dataset is required in order to train a model (also referred to as
    ///       creating a solution).
    ///          A dataset can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    ///                DELETE PENDING > DELETE IN_PROGRESS
    ///
    ///
    ///          To get the status of the dataset, call DescribeDataset.
    ///          <p class="title">
    ///             Related APIs
    ///
    ///
    ///
    ///
    ///                   CreateDatasetGroup
    ///
    ///
    ///
    ///
    ///                   ListDatasets
    ///
    ///
    ///
    ///
    ///                   DescribeDataset
    ///
    ///
    ///
    ///
    ///                   DeleteDataset
    ///
    ///
    ///
    func createDataset(input: CreateDatasetInput) async throws -> CreateDatasetOutputResponse
    {
        typealias createDatasetContinuation = CheckedContinuation<CreateDatasetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDatasetContinuation) in
            createDataset(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///
    ///       Creates a job that exports data from your dataset to an Amazon S3 bucket.
    ///       To allow Amazon Personalize to export the training data, you must specify an
    ///       service-linked IAM role that gives Amazon Personalize PutObject permissions for your Amazon S3 bucket.
    ///       For information, see <a href="https://docs.aws.amazon.com/personalize/latest/dg/export-data.html">Exporting a dataset
    ///       in the Amazon Personalize developer guide.
    ///
    ///
    ///             Status
    ///
    ///          A dataset export job can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    ///
    ///       To get the status of the export job, call DescribeDatasetExportJob,
    ///       and specify the Amazon Resource Name (ARN) of the dataset export job. The dataset export is
    ///       complete when the status shows as ACTIVE. If the status shows as CREATE FAILED, the response
    ///       includes a failureReason key, which describes why the job failed.
    ///
    func createDatasetExportJob(input: CreateDatasetExportJobInput) async throws -> CreateDatasetExportJobOutputResponse
    {
        typealias createDatasetExportJobContinuation = CheckedContinuation<CreateDatasetExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDatasetExportJobContinuation) in
            createDatasetExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an empty dataset group. A dataset group contains related datasets that supply data
    ///       for training a model. A dataset group can contain at most three datasets, one for each type of
    ///       dataset:
    ///
    ///
    ///                Interactions
    ///
    ///
    ///                Items
    ///
    ///
    ///                Users
    ///
    ///
    ///          To train a model (create a solution), a dataset group that contains an
    ///         Interactions dataset is required. Call CreateDataset to add a
    ///       dataset to the group.
    ///          A dataset group can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    ///                DELETE PENDING
    ///
    ///
    ///          To get the status of the dataset group, call DescribeDatasetGroup. If
    ///       the status shows as CREATE FAILED, the response includes a failureReason key,
    ///       which describes why the creation failed.
    ///
    ///             You must wait until the status of the dataset group is ACTIVE
    ///         before adding a dataset to the group.
    ///
    ///          You can specify an Key Management Service (KMS) key to encrypt the datasets in the group. If you
    ///       specify a KMS key, you must also include an Identity and Access Management (IAM) role that has permission to
    ///       access the key.
    ///          <p class="title">
    ///             APIs that require a dataset group ARN in the request
    ///
    ///
    ///
    ///
    ///                   CreateDataset
    ///
    ///
    ///
    ///
    ///                   CreateEventTracker
    ///
    ///
    ///
    ///
    ///                   CreateSolution
    ///
    ///
    ///
    ///          <p class="title">
    ///             Related APIs
    ///
    ///
    ///
    ///
    ///                   ListDatasetGroups
    ///
    ///
    ///
    ///
    ///                   DescribeDatasetGroup
    ///
    ///
    ///
    ///
    ///                   DeleteDatasetGroup
    ///
    ///
    ///
    func createDatasetGroup(input: CreateDatasetGroupInput) async throws -> CreateDatasetGroupOutputResponse
    {
        typealias createDatasetGroupContinuation = CheckedContinuation<CreateDatasetGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDatasetGroupContinuation) in
            createDatasetGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a job that imports training data from your data source (an Amazon S3 bucket) to an
    ///       Amazon Personalize dataset. To allow Amazon Personalize to import the training data, you must specify an
    ///       IAM service role that has permission to read from the data source, as Amazon Personalize makes a
    ///       copy of your data and processes it internally. For information on granting access
    ///       to your Amazon S3 bucket, see <a href="https://docs.aws.amazon.com/personalize/latest/dg/granting-personalize-s3-access.html">Giving Amazon Personalize
    ///       Access to Amazon S3 Resources.
    ///
    ///             The dataset import job replaces any existing data in the dataset that you imported in bulk.
    ///
    ///
    ///             Status
    ///
    ///          A dataset import job can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    ///          To get the status of the import job, call DescribeDatasetImportJob,
    ///       providing the Amazon Resource Name (ARN) of the dataset import job. The dataset import is
    ///       complete when the status shows as ACTIVE. If the status shows as CREATE FAILED, the response
    ///       includes a failureReason key, which describes why the job failed.
    ///
    ///             Importing takes time. You must wait until the status shows as ACTIVE before training a
    ///         model using the dataset.
    ///
    ///
    ///          <p class="title">
    ///             Related APIs
    ///
    ///
    ///
    ///
    ///                   ListDatasetImportJobs
    ///
    ///
    ///
    ///
    ///                   DescribeDatasetImportJob
    ///
    ///
    ///
    func createDatasetImportJob(input: CreateDatasetImportJobInput) async throws -> CreateDatasetImportJobOutputResponse
    {
        typealias createDatasetImportJobContinuation = CheckedContinuation<CreateDatasetImportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDatasetImportJobContinuation) in
            createDatasetImportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an event tracker that you use when adding event data to a specified dataset
    ///       group using the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents API.
    ///
    ///             Only one event tracker can be associated with a dataset group. You will get
    ///         an error if you call CreateEventTracker using the same dataset group as an
    ///         existing event tracker.
    ///
    ///          When you create an event tracker, the response includes a tracking ID, which you pass as a parameter when you use the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html">PutEvents operation.
    ///       Amazon Personalize then appends the event data to the Interactions dataset of the dataset group you specify
    ///       in your event tracker.
    ///
    ///          The event tracker can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    ///                DELETE PENDING > DELETE IN_PROGRESS
    ///
    ///
    ///          To get the status of the event tracker, call DescribeEventTracker.
    ///
    ///             The event tracker must be in the ACTIVE state before using the tracking ID.
    ///
    ///          <p class="title">
    ///             Related APIs
    ///
    ///
    ///
    ///
    ///                   ListEventTrackers
    ///
    ///
    ///
    ///
    ///                   DescribeEventTracker
    ///
    ///
    ///
    ///
    ///                   DeleteEventTracker
    ///
    ///
    ///
    func createEventTracker(input: CreateEventTrackerInput) async throws -> CreateEventTrackerOutputResponse
    {
        typealias createEventTrackerContinuation = CheckedContinuation<CreateEventTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createEventTrackerContinuation) in
            createEventTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a recommendation filter. For more information, see filter.
    func createFilter(input: CreateFilterInput) async throws -> CreateFilterOutputResponse
    {
        typealias createFilterContinuation = CheckedContinuation<CreateFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createFilterContinuation) in
            createFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an Amazon Personalize schema from the specified schema string. The schema you create
    ///       must be in Avro JSON format.
    ///          Amazon Personalize recognizes three schema variants. Each schema is associated with a dataset
    ///       type and has a set of required field and keywords.
    ///       You specify a schema when you call CreateDataset.
    ///
    ///          <p class="title">
    ///             Related APIs
    ///
    ///
    ///
    ///
    ///                   ListSchemas
    ///
    ///
    ///
    ///
    ///                   DescribeSchema
    ///
    ///
    ///
    ///
    ///                   DeleteSchema
    ///
    ///
    ///
    func createSchema(input: CreateSchemaInput) async throws -> CreateSchemaOutputResponse
    {
        typealias createSchemaContinuation = CheckedContinuation<CreateSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSchemaContinuation) in
            createSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates the configuration for training a model. A trained model is known as
    ///       a solution. After the configuration is created, you train the model (create a solution)
    ///       by calling the CreateSolutionVersion operation. Every time you call
    ///       CreateSolutionVersion, a new version of the solution is created.
    ///          After creating a solution version, you check its accuracy by calling
    ///       GetSolutionMetrics. When you are satisfied with the version, you
    ///       deploy it using CreateCampaign. The campaign provides recommendations
    ///       to a client through the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations API.
    ///          To train a model, Amazon Personalize requires training data and a recipe. The training data
    ///       comes from the dataset group that you provide in the request. A recipe specifies
    ///       the training algorithm and a feature transformation. You can specify one of the predefined
    ///       recipes provided by Amazon Personalize. Alternatively, you can specify
    ///       performAutoML and Amazon Personalize will analyze your data and select the
    ///       optimum USER_PERSONALIZATION recipe for you.
    ///
    ///             Amazon Personalize doesn't support configuring the hpoObjective
    ///         for solution hyperparameter optimization at this time.
    ///
    ///
    ///             Status
    ///
    ///          A solution can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    ///                DELETE PENDING > DELETE IN_PROGRESS
    ///
    ///
    ///          To get the status of the solution, call DescribeSolution. Wait
    ///       until the status shows as ACTIVE before calling CreateSolutionVersion.
    ///
    ///
    ///
    ///          <p class="title">
    ///             Related APIs
    ///
    ///
    ///
    ///
    ///                   ListSolutions
    ///
    ///
    ///
    ///
    ///                   CreateSolutionVersion
    ///
    ///
    ///
    ///
    ///                   DescribeSolution
    ///
    ///
    ///
    ///
    ///                   DeleteSolution
    ///
    ///
    ///
    ///
    ///
    ///
    ///                   ListSolutionVersions
    ///
    ///
    ///
    ///
    ///                   DescribeSolutionVersion
    ///
    ///
    ///
    func createSolution(input: CreateSolutionInput) async throws -> CreateSolutionOutputResponse
    {
        typealias createSolutionContinuation = CheckedContinuation<CreateSolutionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSolutionContinuation) in
            createSolution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Trains or retrains an active solution. A solution is created using the CreateSolution operation and must be in the ACTIVE state before calling
    ///         CreateSolutionVersion. A new version of the solution is created every time you
    ///       call this operation.
    ///
    ///             Status
    ///
    ///          A solution version can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING
    ///
    ///
    ///                CREATE IN_PROGRESS
    ///
    ///
    ///                ACTIVE
    ///
    ///
    ///                CREATE FAILED
    ///
    ///
    ///                CREATE STOPPING
    ///
    ///
    ///                CREATE STOPPED
    ///
    ///
    ///          To get the status of the version, call DescribeSolutionVersion. Wait
    ///       until the status shows as ACTIVE before calling CreateCampaign.
    ///          If the status shows as CREATE FAILED, the response includes a failureReason
    ///       key, which describes why the job failed.
    ///          <p class="title">
    ///             Related APIs
    ///
    ///
    ///
    ///
    ///                   ListSolutionVersions
    ///
    ///
    ///
    ///
    ///                   DescribeSolutionVersion
    ///
    ///
    ///
    ///
    ///
    ///
    ///                   ListSolutions
    ///
    ///
    ///
    ///
    ///                   CreateSolution
    ///
    ///
    ///
    ///
    ///                   DescribeSolution
    ///
    ///
    ///
    ///
    ///                   DeleteSolution
    ///
    ///
    ///
    func createSolutionVersion(input: CreateSolutionVersionInput) async throws -> CreateSolutionVersionOutputResponse
    {
        typealias createSolutionVersionContinuation = CheckedContinuation<CreateSolutionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createSolutionVersionContinuation) in
            createSolutionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes a campaign by deleting the solution deployment. The solution that
    ///       the campaign is based on is not deleted and can be redeployed when needed. A deleted campaign can no
    ///       longer be specified in a
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations
    ///       request.
    ///       For more information on campaigns, see CreateCampaign.
    func deleteCampaign(input: DeleteCampaignInput) async throws -> DeleteCampaignOutputResponse
    {
        typealias deleteCampaignContinuation = CheckedContinuation<DeleteCampaignOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteCampaignContinuation) in
            deleteCampaign(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a dataset. You can't delete a dataset if an associated
    ///         DatasetImportJob or SolutionVersion is in the CREATE PENDING or IN
    ///       PROGRESS state. For more information on datasets, see CreateDataset.
    func deleteDataset(input: DeleteDatasetInput) async throws -> DeleteDatasetOutputResponse
    {
        typealias deleteDatasetContinuation = CheckedContinuation<DeleteDatasetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDatasetContinuation) in
            deleteDataset(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a dataset group. Before you delete a dataset group, you must delete the
    ///       following:
    ///
    ///
    ///                All associated event trackers.
    ///
    ///
    ///                All associated solutions.
    ///
    ///
    ///                All datasets in the dataset group.
    ///
    ///
    func deleteDatasetGroup(input: DeleteDatasetGroupInput) async throws -> DeleteDatasetGroupOutputResponse
    {
        typealias deleteDatasetGroupContinuation = CheckedContinuation<DeleteDatasetGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDatasetGroupContinuation) in
            deleteDatasetGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the event tracker. Does not delete the event-interactions dataset from
    ///         the associated dataset group. For more
    ///         information on event trackers, see CreateEventTracker.
    func deleteEventTracker(input: DeleteEventTrackerInput) async throws -> DeleteEventTrackerOutputResponse
    {
        typealias deleteEventTrackerContinuation = CheckedContinuation<DeleteEventTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteEventTrackerContinuation) in
            deleteEventTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a filter.
    func deleteFilter(input: DeleteFilterInput) async throws -> DeleteFilterOutputResponse
    {
        typealias deleteFilterContinuation = CheckedContinuation<DeleteFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteFilterContinuation) in
            deleteFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a schema. Before deleting a schema, you must delete all
    ///       datasets referencing the schema. For more information on schemas, see
    ///       CreateSchema.
    func deleteSchema(input: DeleteSchemaInput) async throws -> DeleteSchemaOutputResponse
    {
        typealias deleteSchemaContinuation = CheckedContinuation<DeleteSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSchemaContinuation) in
            deleteSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes all versions of a solution and the Solution object itself.
    ///       Before deleting a solution, you must delete all campaigns based on
    ///       the solution. To determine what campaigns are using the solution, call
    ///       ListCampaigns and supply the Amazon Resource Name (ARN) of the solution.
    ///       You can't delete a solution if an associated SolutionVersion is in the
    ///       CREATE PENDING or IN PROGRESS state.
    ///       For more information on solutions, see CreateSolution.
    func deleteSolution(input: DeleteSolutionInput) async throws -> DeleteSolutionOutputResponse
    {
        typealias deleteSolutionContinuation = CheckedContinuation<DeleteSolutionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSolutionContinuation) in
            deleteSolution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the given algorithm.
    func describeAlgorithm(input: DescribeAlgorithmInput) async throws -> DescribeAlgorithmOutputResponse
    {
        typealias describeAlgorithmContinuation = CheckedContinuation<DescribeAlgorithmOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeAlgorithmContinuation) in
            describeAlgorithm(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets the properties of a batch inference job including name, Amazon Resource Name (ARN),
    ///       status, input and output configurations, and the ARN of the solution version used to generate
    ///       the recommendations.
    func describeBatchInferenceJob(input: DescribeBatchInferenceJobInput) async throws -> DescribeBatchInferenceJobOutputResponse
    {
        typealias describeBatchInferenceJobContinuation = CheckedContinuation<DescribeBatchInferenceJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeBatchInferenceJobContinuation) in
            describeBatchInferenceJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the given campaign, including its status.
    ///          A campaign can be in one of the following states:
    ///
    ///
    ///                CREATE PENDING > CREATE IN_PROGRESS > ACTIVE -or- CREATE FAILED
    ///
    ///
    ///                DELETE PENDING > DELETE IN_PROGRESS
    ///
    ///
    ///          When the status is CREATE FAILED, the response includes the
    ///       failureReason key, which describes why.
    ///          For more information on campaigns, see CreateCampaign.
    func describeCampaign(input: DescribeCampaignInput) async throws -> DescribeCampaignOutputResponse
    {
        typealias describeCampaignContinuation = CheckedContinuation<DescribeCampaignOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeCampaignContinuation) in
            describeCampaign(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the given dataset. For more information on datasets, see CreateDataset.
    func describeDataset(input: DescribeDatasetInput) async throws -> DescribeDatasetOutputResponse
    {
        typealias describeDatasetContinuation = CheckedContinuation<DescribeDatasetOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDatasetContinuation) in
            describeDataset(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the dataset export job created by CreateDatasetExportJob,
    ///       including the export job status.
    func describeDatasetExportJob(input: DescribeDatasetExportJobInput) async throws -> DescribeDatasetExportJobOutputResponse
    {
        typealias describeDatasetExportJobContinuation = CheckedContinuation<DescribeDatasetExportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDatasetExportJobContinuation) in
            describeDatasetExportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the given dataset group. For more information on dataset groups, see CreateDatasetGroup.
    func describeDatasetGroup(input: DescribeDatasetGroupInput) async throws -> DescribeDatasetGroupOutputResponse
    {
        typealias describeDatasetGroupContinuation = CheckedContinuation<DescribeDatasetGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDatasetGroupContinuation) in
            describeDatasetGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the dataset import job created by CreateDatasetImportJob,
    ///       including the import job status.
    func describeDatasetImportJob(input: DescribeDatasetImportJobInput) async throws -> DescribeDatasetImportJobOutputResponse
    {
        typealias describeDatasetImportJobContinuation = CheckedContinuation<DescribeDatasetImportJobOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDatasetImportJobContinuation) in
            describeDatasetImportJob(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes an event tracker. The response includes the trackingId and
    ///       status of the event tracker.
    ///       For more information on event trackers, see CreateEventTracker.
    func describeEventTracker(input: DescribeEventTrackerInput) async throws -> DescribeEventTrackerOutputResponse
    {
        typealias describeEventTrackerContinuation = CheckedContinuation<DescribeEventTrackerOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeEventTrackerContinuation) in
            describeEventTracker(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes the given feature transformation.
    func describeFeatureTransformation(input: DescribeFeatureTransformationInput) async throws -> DescribeFeatureTransformationOutputResponse
    {
        typealias describeFeatureTransformationContinuation = CheckedContinuation<DescribeFeatureTransformationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeFeatureTransformationContinuation) in
            describeFeatureTransformation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a filter's properties.
    func describeFilter(input: DescribeFilterInput) async throws -> DescribeFilterOutputResponse
    {
        typealias describeFilterContinuation = CheckedContinuation<DescribeFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeFilterContinuation) in
            describeFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a recipe.
    ///          A recipe contains three items:
    ///
    ///
    ///                An algorithm that trains a model.
    ///
    ///
    ///                Hyperparameters that govern the training.
    ///
    ///
    ///                Feature transformation information for modifying the input data before training.
    ///
    ///
    ///          Amazon Personalize provides a set of predefined recipes. You specify a recipe when you create a
    ///       solution with the CreateSolution API.
    ///       CreateSolution trains a model by using the algorithm
    ///       in the specified recipe and a training dataset. The solution, when deployed as a campaign,
    ///       can provide recommendations using the
    ///       <a href="https://docs.aws.amazon.com/personalize/latest/dg/API_RS_GetRecommendations.html">GetRecommendations API.
    func describeRecipe(input: DescribeRecipeInput) async throws -> DescribeRecipeOutputResponse
    {
        typealias describeRecipeContinuation = CheckedContinuation<DescribeRecipeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeRecipeContinuation) in
            describeRecipe(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a schema. For more information on schemas, see
    ///       CreateSchema.
    func describeSchema(input: DescribeSchemaInput) async throws -> DescribeSchemaOutputResponse
    {
        typealias describeSchemaContinuation = CheckedContinuation<DescribeSchemaOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSchemaContinuation) in
            describeSchema(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a solution.
    ///       For more information on solutions, see CreateSolution.
    func describeSolution(input: DescribeSolutionInput) async throws -> DescribeSolutionOutputResponse
    {
        typealias describeSolutionContinuation = CheckedContinuation<DescribeSolutionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSolutionContinuation) in
            describeSolution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Describes a specific version of a solution. For more information on solutions, see CreateSolution.
    func describeSolutionVersion(input: DescribeSolutionVersionInput) async throws -> DescribeSolutionVersionOutputResponse
    {
        typealias describeSolutionVersionContinuation = CheckedContinuation<DescribeSolutionVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSolutionVersionContinuation) in
            describeSolutionVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets the metrics for the specified solution version.
    func getSolutionMetrics(input: GetSolutionMetricsInput) async throws -> GetSolutionMetricsOutputResponse
    {
        typealias getSolutionMetricsContinuation = CheckedContinuation<GetSolutionMetricsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getSolutionMetricsContinuation) in
            getSolutionMetrics(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Gets a list of the batch inference jobs that have been performed off of a solution
    ///       version.
    func listBatchInferenceJobs(input: ListBatchInferenceJobsInput) async throws -> ListBatchInferenceJobsOutputResponse
    {
        typealias listBatchInferenceJobsContinuation = CheckedContinuation<ListBatchInferenceJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listBatchInferenceJobsContinuation) in
            listBatchInferenceJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of campaigns that use the given solution.
    ///       When a solution is not specified, all the campaigns associated with the account are listed.
    ///       The response provides the properties for each campaign, including the Amazon Resource Name (ARN).
    ///       For more information on campaigns, see CreateCampaign.
    func listCampaigns(input: ListCampaignsInput) async throws -> ListCampaignsOutputResponse
    {
        typealias listCampaignsContinuation = CheckedContinuation<ListCampaignsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listCampaignsContinuation) in
            listCampaigns(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of dataset export jobs that use the given dataset. When a dataset is not
    ///       specified, all the dataset export jobs associated with the account are listed. The response
    ///       provides the properties for each dataset export job, including the Amazon Resource Name (ARN).
    ///       For more information on dataset export jobs, see CreateDatasetExportJob. For
    ///       more information on datasets, see CreateDataset.
    func listDatasetExportJobs(input: ListDatasetExportJobsInput) async throws -> ListDatasetExportJobsOutputResponse
    {
        typealias listDatasetExportJobsContinuation = CheckedContinuation<ListDatasetExportJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDatasetExportJobsContinuation) in
            listDatasetExportJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of dataset groups. The response provides the properties for each dataset
    ///       group, including the Amazon Resource Name (ARN). For more information on dataset groups, see
    ///         CreateDatasetGroup.
    func listDatasetGroups(input: ListDatasetGroupsInput) async throws -> ListDatasetGroupsOutputResponse
    {
        typealias listDatasetGroupsContinuation = CheckedContinuation<ListDatasetGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDatasetGroupsContinuation) in
            listDatasetGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of dataset import jobs that use the given dataset. When a dataset is not
    ///       specified, all the dataset import jobs associated with the account are listed. The response
    ///       provides the properties for each dataset import job, including the Amazon Resource Name (ARN).
    ///       For more information on dataset import jobs, see CreateDatasetImportJob. For
    ///       more information on datasets, see CreateDataset.
    func listDatasetImportJobs(input: ListDatasetImportJobsInput) async throws -> ListDatasetImportJobsOutputResponse
    {
        typealias listDatasetImportJobsContinuation = CheckedContinuation<ListDatasetImportJobsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDatasetImportJobsContinuation) in
            listDatasetImportJobs(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the list of datasets contained in the given dataset group. The response provides
    ///       the properties for each dataset, including the Amazon Resource Name (ARN). For more
    ///       information on datasets, see CreateDataset.
    func listDatasets(input: ListDatasetsInput) async throws -> ListDatasetsOutputResponse
    {
        typealias listDatasetsContinuation = CheckedContinuation<ListDatasetsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDatasetsContinuation) in
            listDatasets(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the list of event trackers associated with the account.
    ///       The response provides the properties for each event tracker, including the Amazon Resource
    ///       Name (ARN) and tracking ID. For more
    ///       information on event trackers, see CreateEventTracker.
    func listEventTrackers(input: ListEventTrackersInput) async throws -> ListEventTrackersOutputResponse
    {
        typealias listEventTrackersContinuation = CheckedContinuation<ListEventTrackersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listEventTrackersContinuation) in
            listEventTrackers(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists all filters that belong to a given dataset group.
    func listFilters(input: ListFiltersInput) async throws -> ListFiltersOutputResponse
    {
        typealias listFiltersContinuation = CheckedContinuation<ListFiltersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listFiltersContinuation) in
            listFilters(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of available recipes. The response provides the properties
    ///        for each recipe, including the recipe's Amazon Resource Name (ARN).
    func listRecipes(input: ListRecipesInput) async throws -> ListRecipesOutputResponse
    {
        typealias listRecipesContinuation = CheckedContinuation<ListRecipesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listRecipesContinuation) in
            listRecipes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the list of schemas associated with the account. The response provides the
    ///       properties for each schema, including the Amazon Resource Name (ARN).
    ///       For more information on schemas, see CreateSchema.
    func listSchemas(input: ListSchemasInput) async throws -> ListSchemasOutputResponse
    {
        typealias listSchemasContinuation = CheckedContinuation<ListSchemasOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSchemasContinuation) in
            listSchemas(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of solution versions for the given solution. When a solution is not
    ///       specified, all the solution versions associated with the account are listed. The response
    ///       provides the properties for each solution version, including the Amazon Resource Name (ARN).
    ///       For more information on solutions, see CreateSolution.
    func listSolutionVersions(input: ListSolutionVersionsInput) async throws -> ListSolutionVersionsOutputResponse
    {
        typealias listSolutionVersionsContinuation = CheckedContinuation<ListSolutionVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSolutionVersionsContinuation) in
            listSolutionVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of solutions that use the given dataset group.
    ///       When a dataset group is not specified, all the solutions associated with the account are listed.
    ///       The response provides the properties for each solution, including the Amazon Resource Name (ARN).
    ///       For more information on solutions, see CreateSolution.
    func listSolutions(input: ListSolutionsInput) async throws -> ListSolutionsOutputResponse
    {
        typealias listSolutionsContinuation = CheckedContinuation<ListSolutionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listSolutionsContinuation) in
            listSolutions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stops creating a solution version that is in a state of CREATE_PENDING or CREATE IN_PROGRESS.
    ///
    ///          Depending on the current state of the solution version, the solution version state changes as follows:
    ///
    ///
    ///                CREATE_PENDING > CREATE_STOPPED
    ///                or
    ///
    ///
    ///                CREATE_IN_PROGRESS > CREATE_STOPPING > CREATE_STOPPED
    ///
    ///
    ///          You are billed for all of the training completed up
    ///       until you stop the solution version creation. You cannot resume creating a solution version once it has been stopped.
    func stopSolutionVersionCreation(input: StopSolutionVersionCreationInput) async throws -> StopSolutionVersionCreationOutputResponse
    {
        typealias stopSolutionVersionCreationContinuation = CheckedContinuation<StopSolutionVersionCreationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopSolutionVersionCreationContinuation) in
            stopSolutionVersionCreation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a campaign by either deploying a new solution or changing the value of the
    ///       campaign's minProvisionedTPS parameter.
    ///          To update a campaign, the campaign status must be ACTIVE or CREATE FAILED.
    ///       Check the campaign status using the DescribeCampaign API.
    ///
    ///             You must wait until the status of the
    ///         updated campaign is ACTIVE before asking the campaign for recommendations.
    ///
    ///          For more information on campaigns, see CreateCampaign.
    func updateCampaign(input: UpdateCampaignInput) async throws -> UpdateCampaignOutputResponse
    {
        typealias updateCampaignContinuation = CheckedContinuation<UpdateCampaignOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateCampaignContinuation) in
            updateCampaign(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
