// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension FisClientTypes.Action: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case parameters
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, actionparametermap0) in parameters {
                try parametersContainer.encode(actionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, actiontargetmap0) in targets {
                try targetsContainer.encode(actiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ActionParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:FisClientTypes.ActionParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:FisClientTypes.ActionParameter]()
            for (key0, actionparameter0) in parametersContainer {
                if let actionparameter0 = actionparameter0 {
                    parametersDecoded0?[key0] = actionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ActionTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ActionTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ActionTarget]()
            for (key0, actiontarget0) in targetsContainer {
                if let actiontarget0 = actiontarget0 {
                    targetsDecoded0?[key0] = actiontarget0
                }
            }
        }
        targets = targetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes.Action: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Action(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), parameters: \(Swift.String(describing: parameters)), tags: \(Swift.String(describing: tags)), targets: \(Swift.String(describing: targets)))"}
}

extension FisClientTypes {
    /// Describes an action. For more information, see <a href="https://docs.aws.amazon.com/fis/latest/userguide/fis-actions-reference.html">AWS FIS actions
    ///          in the AWS Fault Injection Simulator User Guide.
    public struct Action: Swift.Equatable {
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The action parameters, if applicable.
        public var parameters: [Swift.String:FisClientTypes.ActionParameter]?
        /// The tags for the action.
        public var tags: [Swift.String:Swift.String]?
        /// The supported targets for the action.
        public var targets: [Swift.String:FisClientTypes.ActionTarget]?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: [Swift.String:FisClientTypes.ActionParameter]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ActionTarget]? = nil
        )
        {
            self.description = description
            self.id = id
            self.parameters = parameters
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ActionParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let requiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension FisClientTypes.ActionParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionParameter(description: \(Swift.String(describing: description)), required: \(Swift.String(describing: `required`)))"}
}

extension FisClientTypes {
    /// Describes a parameter for an action.
    public struct ActionParameter: Swift.Equatable {
        /// Indicates whether the parameter is required.
        public var `required`: Swift.Bool
        /// The parameter description.
        public var description: Swift.String?

        public init (
            `required`: Swift.Bool = false,
            description: Swift.String? = nil
        )
        {
            self.`required` = `required`
            self.description = description
        }
    }

}

extension FisClientTypes.ActionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, actiontargetmap0) in targets {
                try targetsContainer.encode(actiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ActionTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ActionTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ActionTarget]()
            for (key0, actiontarget0) in targetsContainer {
                if let actiontarget0 = actiontarget0 {
                    targetsDecoded0?[key0] = actiontarget0
                }
            }
        }
        targets = targetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes.ActionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionSummary(description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), tags: \(Swift.String(describing: tags)), targets: \(Swift.String(describing: targets)))"}
}

extension FisClientTypes {
    /// Provides a summary of an action.
    public struct ActionSummary: Swift.Equatable {
        /// The description for the action.
        public var description: Swift.String?
        /// The ID of the action.
        public var id: Swift.String?
        /// The tags for the action.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:FisClientTypes.ActionTarget]?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ActionTarget]? = nil
        )
        {
            self.description = description
            self.id = id
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ActionTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension FisClientTypes.ActionTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTarget(resourceType: \(Swift.String(describing: resourceType)))"}
}

extension FisClientTypes {
    /// Describes a target for an action.
    public struct ActionTarget: Swift.Equatable {
        /// The resource type of the target.
        public var resourceType: Swift.String?

        public init (
            resourceType: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of a conflict.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FisClientTypes.CreateExperimentTemplateActionInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimenttemplateactionparametermap0) in parameters {
                try parametersContainer.encode(experimenttemplateactionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafterlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttemplateactiontargetmap0) in targets {
                try targetsContainer.encode(experimenttemplateactiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension FisClientTypes.CreateExperimentTemplateActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateExperimentTemplateActionInput(actionId: \(Swift.String(describing: actionId)), description: \(Swift.String(describing: description)), parameters: \(Swift.String(describing: parameters)), startAfter: \(Swift.String(describing: startAfter)), targets: \(Swift.String(describing: targets)))"}
}

extension FisClientTypes {
    /// Specifies an action for an experiment template.
    public struct CreateExperimentTemplateActionInput: Swift.Equatable {
        /// The ID of the action.
        /// This member is required.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init (
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

public struct CreateExperimentTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateExperimentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateExperimentTemplateOutputError>
}

extension CreateExperimentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateExperimentTemplateInput(actions: \(Swift.String(describing: actions)), clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), roleArn: \(Swift.String(describing: roleArn)), stopConditions: \(Swift.String(describing: stopConditions)), tags: \(Swift.String(describing: tags)), targets: \(Swift.String(describing: targets)))"}
}

extension CreateExperimentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case clientToken
        case description
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, createexperimenttemplateactioninputmap0) in actions {
                try actionsContainer.encode(createexperimenttemplateactioninputmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for createexperimenttemplatestopconditioninputlist0 in stopConditions {
                try stopConditionsContainer.encode(createexperimenttemplatestopconditioninputlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, createexperimenttemplatetargetinputmap0) in targets {
                try targetsContainer.encode(createexperimenttemplatetargetinputmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateExperimentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateExperimentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateExperimentTemplateOutputError>
}

public struct CreateExperimentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateExperimentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateExperimentTemplateOutputError>
}

public struct CreateExperimentTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateExperimentTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateExperimentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateExperimentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateExperimentTemplateOutputError>
}

public struct CreateExperimentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateExperimentTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateExperimentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/experimentTemplates"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateExperimentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateExperimentTemplateOutputError>
}

public struct CreateExperimentTemplateInput: Swift.Equatable {
    /// The actions for the experiment.
    /// This member is required.
    public var actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A description for the experiment template. Can contain up to 64 letters (A-Z and a-z).
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The stop conditions.
    /// This member is required.
    public var stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]?
    /// The tags to apply to the experiment template.
    public var tags: [Swift.String:Swift.String]?
    /// The targets for the experiment.
    public var targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]?

    public init (
        actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.clientToken = clientToken
        self.description = description
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.tags = tags
        self.targets = targets
    }
}

struct CreateExperimentTemplateInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let description: Swift.String?
    public let stopConditions: [FisClientTypes.CreateExperimentTemplateStopConditionInput]?
    public let targets: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]?
    public let actions: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]?
    public let roleArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateExperimentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case clientToken
        case description
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.CreateExperimentTemplateStopConditionInput?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.CreateExperimentTemplateStopConditionInput]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.CreateExperimentTemplateStopConditionInput]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.CreateExperimentTemplateTargetInput?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.CreateExperimentTemplateTargetInput]()
            for (key0, createexperimenttemplatetargetinput0) in targetsContainer {
                if let createexperimenttemplatetargetinput0 = createexperimenttemplatetargetinput0 {
                    targetsDecoded0?[key0] = createexperimenttemplatetargetinput0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.CreateExperimentTemplateActionInput?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.CreateExperimentTemplateActionInput]()
            for (key0, createexperimenttemplateactioninput0) in actionsContainer {
                if let createexperimenttemplateactioninput0 = createexperimenttemplateactioninput0 {
                    actionsDecoded0?[key0] = createexperimenttemplateactioninput0
                }
            }
        }
        actions = actionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExperimentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExperimentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExperimentTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExperimentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateExperimentTemplateOutputResponse(experimentTemplate: \(Swift.String(describing: experimentTemplate)))"}
}

extension CreateExperimentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct CreateExperimentTemplateOutputResponse: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init (
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct CreateExperimentTemplateOutputResponseBody: Swift.Equatable {
    public let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension CreateExperimentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension FisClientTypes.CreateExperimentTemplateStopConditionInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes.CreateExperimentTemplateStopConditionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateExperimentTemplateStopConditionInput(source: \(Swift.String(describing: source)), value: \(Swift.String(describing: value)))"}
}

extension FisClientTypes {
    /// Specifies a stop condition for an experiment template.
    public struct CreateExperimentTemplateStopConditionInput: Swift.Equatable {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop
        ///          condition is defined by a CloudWatch alarm. Specify none if there is no stop
        ///          condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm. This is required if the source is
        ///          a CloudWatch alarm.
        public var value: Swift.String?

        public init (
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.CreateExperimentTemplateTargetInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilterinputlist0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilterinputlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateTargetInputFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTemplateTargetInputFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension FisClientTypes.CreateExperimentTemplateTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateExperimentTemplateTargetInput(filters: \(Swift.String(describing: filters)), resourceArns: \(Swift.String(describing: resourceArns)), resourceTags: \(Swift.String(describing: resourceTags)), resourceType: \(Swift.String(describing: resourceType)), selectionMode: \(Swift.String(describing: selectionMode)))"}
}

extension FisClientTypes {
    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or
    ///          at least one resource tag. You cannot specify both ARNs and tags.
    public struct CreateExperimentTemplateTargetInput: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The AWS resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count of the resources at random, or a percentage of the resources. All identified resources are included in the target.
        ///
        ///
        ///                ALL - Run the action on all identified targets. This is the default.
        ///
        ///
        ///                COUNT(n) - Run the action on the specified number of targets, chosen from the identified targets at random.
        ///                 For example, COUNT(1) selects one of the targets.
        ///
        ///
        ///                PERCENT(n) - Run the action on the specified percentage of targets, chosen from the identified targets
        ///                at random. For example, PERCENT(25) selects 25% of the targets.
        ///
        ///
        /// This member is required.
        public var selectionMode: Swift.String?

        public init (
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension DeleteExperimentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteExperimentTemplateInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteExperimentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteExperimentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExperimentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExperimentTemplateOutputError>
}

public struct DeleteExperimentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExperimentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExperimentTemplateOutputError>
}

public struct DeleteExperimentTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExperimentTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteExperimentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteExperimentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExperimentTemplateOutputError>
}

public struct DeleteExperimentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteExperimentTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteExperimentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/experimentTemplates/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteExperimentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteExperimentTemplateOutputError>
}

public struct DeleteExperimentTemplateInput: Swift.Equatable {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteExperimentTemplateInputBody: Swift.Equatable {
}

extension DeleteExperimentTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteExperimentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteExperimentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteExperimentTemplateOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteExperimentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteExperimentTemplateOutputResponse(experimentTemplate: \(Swift.String(describing: experimentTemplate)))"}
}

extension DeleteExperimentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct DeleteExperimentTemplateOutputResponse: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init (
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct DeleteExperimentTemplateOutputResponseBody: Swift.Equatable {
    public let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension DeleteExperimentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension FisClientTypes.Experiment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case creationTime
        case endTime
        case experimentTemplateId
        case id
        case roleArn
        case startTime
        case state
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, experimentactionmap0) in actions {
                try actionsContainer.encode(experimentactionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let experimentTemplateId = experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for experimentstopconditionlist0 in stopConditions {
                try stopConditionsContainer.encode(experimentstopconditionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttargetmap0) in targets {
                try targetsContainer.encode(experimenttargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentState.self, forKey: .state)
        state = stateDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ExperimentTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ExperimentTarget]()
            for (key0, experimenttarget0) in targetsContainer {
                if let experimenttarget0 = experimenttarget0 {
                    targetsDecoded0?[key0] = experimenttarget0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentAction?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.ExperimentAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.ExperimentAction]()
            for (key0, experimentaction0) in actionsContainer {
                if let experimentaction0 = experimentaction0 {
                    actionsDecoded0?[key0] = experimentaction0
                }
            }
        }
        actions = actionsDecoded0
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentStopCondition?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.ExperimentStopCondition]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.ExperimentStopCondition]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes.Experiment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Experiment(actions: \(Swift.String(describing: actions)), creationTime: \(Swift.String(describing: creationTime)), endTime: \(Swift.String(describing: endTime)), experimentTemplateId: \(Swift.String(describing: experimentTemplateId)), id: \(Swift.String(describing: id)), roleArn: \(Swift.String(describing: roleArn)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)), stopConditions: \(Swift.String(describing: stopConditions)), tags: \(Swift.String(describing: tags)), targets: \(Swift.String(describing: targets)))"}
}

extension FisClientTypes {
    /// Describes an experiment.
    public struct Experiment: Swift.Equatable {
        /// The actions for the experiment.
        public var actions: [Swift.String:FisClientTypes.ExperimentAction]?
        /// The time the experiment was created.
        public var creationTime: ClientRuntime.Date?
        /// The time that the experiment ended.
        public var endTime: ClientRuntime.Date?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.
        public var roleArn: Swift.String?
        /// The time that the experiment was started.
        public var startTime: ClientRuntime.Date?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentStopCondition]?
        /// The tags for the experiment.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the experiment.
        public var targets: [Swift.String:FisClientTypes.ExperimentTarget]?

        public init (
            actions: [Swift.String:FisClientTypes.ExperimentAction]? = nil,
            creationTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            stopConditions: [FisClientTypes.ExperimentStopCondition]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ExperimentTarget]? = nil
        )
        {
            self.actions = actions
            self.creationTime = creationTime
            self.endTime = endTime
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.roleArn = roleArn
            self.startTime = startTime
            self.state = state
            self.stopConditions = stopConditions
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case state
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimentactionparametermap0) in parameters {
                try parametersContainer.encode(experimentactionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimentactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimentactionstartafterlist0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimentactiontargetmap0) in targets {
                try targetsContainer.encode(experimentactiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimentactionparameter0) in parametersContainer {
                if let experimentactionparameter0 = experimentactionparameter0 {
                    parametersDecoded0?[key0] = experimentactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttargetname0) in targetsContainer {
                if let experimenttargetname0 = experimenttargetname0 {
                    targetsDecoded0?[key0] = experimenttargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentActionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension FisClientTypes.ExperimentAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentAction(actionId: \(Swift.String(describing: actionId)), description: \(Swift.String(describing: description)), parameters: \(Swift.String(describing: parameters)), startAfter: \(Swift.String(describing: startAfter)), state: \(Swift.String(describing: state)), targets: \(Swift.String(describing: targets)))"}
}

extension FisClientTypes {
    /// Describes the action for an experiment.
    public struct ExperimentAction: Swift.Equatable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// The description for the action.
        public var description: Swift.String?
        /// The parameters for the action.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before this action starts.
        public var startAfter: [Swift.String]?
        /// The state of the action.
        public var state: FisClientTypes.ExperimentActionState?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init (
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            state: FisClientTypes.ExperimentActionState? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.state = state
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentActionState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentActionStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension FisClientTypes.ExperimentActionState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentActionState(reason: \(Swift.String(describing: reason)), status: \(Swift.String(describing: status)))"}
}

extension FisClientTypes {
    /// Describes the state of an action.
    public struct ExperimentActionState: Swift.Equatable {
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the action.
        public var status: FisClientTypes.ExperimentActionStatus?

        public init (
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentActionStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension FisClientTypes {
    public enum ExperimentActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initiating
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentActionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "cancelled"
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentActionStatus(rawValue: rawValue) ?? ExperimentActionStatus.sdkUnknown(rawValue)
        }
    }
}

extension FisClientTypes.ExperimentState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension FisClientTypes.ExperimentState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentState(reason: \(Swift.String(describing: reason)), status: \(Swift.String(describing: status)))"}
}

extension FisClientTypes {
    /// Describes the state of an experiment.
    public struct ExperimentState: Swift.Equatable {
        /// The reason for the state.
        public var reason: Swift.String?
        /// The state of the experiment.
        public var status: FisClientTypes.ExperimentStatus?

        public init (
            reason: Swift.String? = nil,
            status: FisClientTypes.ExperimentStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension FisClientTypes {
    public enum ExperimentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case initiating
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExperimentStatus] {
            return [
                .completed,
                .failed,
                .initiating,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "completed"
            case .failed: return "failed"
            case .initiating: return "initiating"
            case .pending: return "pending"
            case .running: return "running"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExperimentStatus(rawValue: rawValue) ?? ExperimentStatus.sdkUnknown(rawValue)
        }
    }
}

extension FisClientTypes.ExperimentStopCondition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes.ExperimentStopCondition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentStopCondition(source: \(Swift.String(describing: source)), value: \(Swift.String(describing: value)))"}
}

extension FisClientTypes {
    /// Describes the stop condition for an experiment.
    public struct ExperimentStopCondition: Swift.Equatable {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init (
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.ExperimentSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case experimentTemplateId
        case id
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let experimentTemplateId = experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentState.self, forKey: .state)
        state = stateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes.ExperimentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentSummary(creationTime: \(Swift.String(describing: creationTime)), experimentTemplateId: \(Swift.String(describing: experimentTemplateId)), id: \(Swift.String(describing: id)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)))"}
}

extension FisClientTypes {
    /// Provides a summary of an experiment.
    public struct ExperimentSummary: Swift.Equatable {
        /// The time that the experiment was created.
        public var creationTime: ClientRuntime.Date?
        /// The ID of the experiment template.
        public var experimentTemplateId: Swift.String?
        /// The ID of the experiment.
        public var id: Swift.String?
        /// The state of the experiment.
        public var state: FisClientTypes.ExperimentState?
        /// The tags for the experiment.
        public var tags: [Swift.String:Swift.String]?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            experimentTemplateId: Swift.String? = nil,
            id: Swift.String? = nil,
            state: FisClientTypes.ExperimentState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.creationTime = creationTime
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.state = state
            self.tags = tags
        }
    }

}

extension FisClientTypes.ExperimentTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttargetfilterlist0 in filters {
                try filtersContainer.encode(experimenttargetfilterlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTargetFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTargetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTargetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension FisClientTypes.ExperimentTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentTarget(filters: \(Swift.String(describing: filters)), resourceArns: \(Swift.String(describing: resourceArns)), resourceTags: \(Swift.String(describing: resourceTags)), resourceType: \(Swift.String(describing: resourceType)), selectionMode: \(Swift.String(describing: selectionMode)))"}
}

extension FisClientTypes {
    /// Describes a target for an experiment.
    public struct ExperimentTarget: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTargetFilter]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init (
            filters: [FisClientTypes.ExperimentTargetFilter]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension FisClientTypes.ExperimentTargetFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttargetfiltervalues0 in values {
                try valuesContainer.encode(experimenttargetfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FisClientTypes.ExperimentTargetFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentTargetFilter(path: \(Swift.String(describing: path)), values: \(Swift.String(describing: values)))"}
}

extension FisClientTypes {
    /// Describes a filter used for the target resources in an experiment.
    public struct ExperimentTargetFilter: Swift.Equatable {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init (
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension FisClientTypes.ExperimentTemplate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case creationTime
        case description
        case id
        case lastUpdateTime
        case roleArn
        case stopConditions
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, experimenttemplateactionmap0) in actions {
                try actionsContainer.encode(experimenttemplateactionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for experimenttemplatestopconditionlist0 in stopConditions {
                try stopConditionsContainer.encode(experimenttemplatestopconditionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttemplatetargetmap0) in targets {
                try targetsContainer.encode(experimenttemplatetargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentTemplateTarget?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.ExperimentTemplateTarget]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.ExperimentTemplateTarget]()
            for (key0, experimenttemplatetarget0) in targetsContainer {
                if let experimenttemplatetarget0 = experimenttemplatetarget0 {
                    targetsDecoded0?[key0] = experimenttemplatetarget0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.ExperimentTemplateAction?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.ExperimentTemplateAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.ExperimentTemplateAction]()
            for (key0, experimenttemplateaction0) in actionsContainer {
                if let experimenttemplateaction0 = experimenttemplateaction0 {
                    actionsDecoded0?[key0] = experimenttemplateaction0
                }
            }
        }
        actions = actionsDecoded0
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateStopCondition?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.ExperimentTemplateStopCondition]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.ExperimentTemplateStopCondition]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes.ExperimentTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentTemplate(actions: \(Swift.String(describing: actions)), creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), roleArn: \(Swift.String(describing: roleArn)), stopConditions: \(Swift.String(describing: stopConditions)), tags: \(Swift.String(describing: tags)), targets: \(Swift.String(describing: targets)))"}
}

extension FisClientTypes {
    /// Describes an experiment template.
    public struct ExperimentTemplate: Swift.Equatable {
        /// The actions for the experiment.
        public var actions: [Swift.String:FisClientTypes.ExperimentTemplateAction]?
        /// The time the experiment template was created.
        public var creationTime: ClientRuntime.Date?
        /// The description for the experiment template.
        public var description: Swift.String?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time the experiment template was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of an IAM role.
        public var roleArn: Swift.String?
        /// The stop conditions for the experiment.
        public var stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]?
        /// The tags for the experiment template.
        public var tags: [Swift.String:Swift.String]?
        /// The targets for the experiment.
        public var targets: [Swift.String:FisClientTypes.ExperimentTemplateTarget]?

        public init (
            actions: [Swift.String:FisClientTypes.ExperimentTemplateAction]? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            roleArn: Swift.String? = nil,
            stopConditions: [FisClientTypes.ExperimentTemplateStopCondition]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targets: [Swift.String:FisClientTypes.ExperimentTemplateTarget]? = nil
        )
        {
            self.actions = actions
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.roleArn = roleArn
            self.stopConditions = stopConditions
            self.tags = tags
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentTemplateAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimenttemplateactionparametermap0) in parameters {
                try parametersContainer.encode(experimenttemplateactionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafterlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttemplateactiontargetmap0) in targets {
                try targetsContainer.encode(experimenttemplateactiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension FisClientTypes.ExperimentTemplateAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentTemplateAction(actionId: \(Swift.String(describing: actionId)), description: \(Swift.String(describing: description)), parameters: \(Swift.String(describing: parameters)), startAfter: \(Swift.String(describing: startAfter)), targets: \(Swift.String(describing: targets)))"}
}

extension FisClientTypes {
    /// Describes an action for an experiment template.
    public struct ExperimentTemplateAction: Swift.Equatable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init (
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

extension FisClientTypes.ExperimentTemplateStopCondition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes.ExperimentTemplateStopCondition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentTemplateStopCondition(source: \(Swift.String(describing: source)), value: \(Swift.String(describing: value)))"}
}

extension FisClientTypes {
    /// Describes a stop condition for an experiment template.
    public struct ExperimentTemplateStopCondition: Swift.Equatable {
        /// The source for the stop condition.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public var value: Swift.String?

        public init (
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.ExperimentTemplateSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case lastUpdateTime
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FisClientTypes.ExperimentTemplateSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentTemplateSummary(creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), tags: \(Swift.String(describing: tags)))"}
}

extension FisClientTypes {
    /// Provides a summary of an experiment template.
    public struct ExperimentTemplateSummary: Swift.Equatable {
        /// The time that the experiment template was created.
        public var creationTime: ClientRuntime.Date?
        /// The description of the experiment template.
        public var description: Swift.String?
        /// The ID of the experiment template.
        public var id: Swift.String?
        /// The time that the experiment template was last updated.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The tags for the experiment template.
        public var tags: [Swift.String:Swift.String]?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.tags = tags
        }
    }

}

extension FisClientTypes.ExperimentTemplateTarget: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilterlist0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilterlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateTargetFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTemplateTargetFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTemplateTargetFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension FisClientTypes.ExperimentTemplateTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentTemplateTarget(filters: \(Swift.String(describing: filters)), resourceArns: \(Swift.String(describing: resourceArns)), resourceTags: \(Swift.String(describing: resourceTags)), resourceType: \(Swift.String(describing: resourceType)), selectionMode: \(Swift.String(describing: selectionMode)))"}
}

extension FisClientTypes {
    /// Describes a target for an experiment template.
    public struct ExperimentTemplateTarget: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetFilter]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The resource type.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        public var selectionMode: Swift.String?

        public init (
            filters: [FisClientTypes.ExperimentTemplateTargetFilter]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension FisClientTypes.ExperimentTemplateTargetFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttemplatetargetfiltervalues0 in values {
                try valuesContainer.encode(experimenttemplatetargetfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FisClientTypes.ExperimentTemplateTargetFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentTemplateTargetFilter(path: \(Swift.String(describing: path)), values: \(Swift.String(describing: values)))"}
}

extension FisClientTypes {
    /// Describes a filter used for the target resources in an experiment template.
    public struct ExperimentTemplateTargetFilter: Swift.Equatable {
        /// The attribute path for the filter.
        public var path: Swift.String?
        /// The attribute values for the filter.
        public var values: [Swift.String]?

        public init (
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension FisClientTypes.ExperimentTemplateTargetInputFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for experimenttemplatetargetfiltervalues0 in values {
                try valuesContainer.encode(experimenttemplatetargetfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FisClientTypes.ExperimentTemplateTargetInputFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExperimentTemplateTargetInputFilter(path: \(Swift.String(describing: path)), values: \(Swift.String(describing: values)))"}
}

extension FisClientTypes {
    /// Describes a filter used for the target resource input in an experiment template.
    public struct ExperimentTemplateTargetInputFilter: Swift.Equatable {
        /// The attribute path for the filter.
        /// This member is required.
        public var path: Swift.String?
        /// The attribute values for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            path: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.path = path
            self.values = values
        }
    }

}

extension GetActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetActionInput(id: \(Swift.String(describing: id)))"}
}

extension GetActionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetActionOutputError>
}

public struct GetActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetActionOutputError>
}

public struct GetActionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetActionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetActionOutputError>
}

public struct GetActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetActionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/actions/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetActionOutputError>
}

public struct GetActionInput: Swift.Equatable {
    /// The ID of the action.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetActionInputBody: Swift.Equatable {
}

extension GetActionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetActionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetActionOutputResponse(action: \(Swift.String(describing: action)))"}
}

extension GetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
        } else {
            self.action = nil
        }
    }
}

public struct GetActionOutputResponse: Swift.Equatable {
    /// Information about the action.
    public var action: FisClientTypes.Action?

    public init (
        action: FisClientTypes.Action? = nil
    )
    {
        self.action = action
    }
}

struct GetActionOutputResponseBody: Swift.Equatable {
    public let action: FisClientTypes.Action?
}

extension GetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(FisClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension GetExperimentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetExperimentInput(id: \(Swift.String(describing: id)))"}
}

extension GetExperimentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetExperimentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExperimentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExperimentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExperimentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExperimentOutputError>
}

public struct GetExperimentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExperimentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExperimentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExperimentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExperimentOutputError>
}

public struct GetExperimentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExperimentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetExperimentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetExperimentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExperimentOutputError>
}

public struct GetExperimentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExperimentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetExperimentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/experiments/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetExperimentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExperimentOutputError>
}

public struct GetExperimentInput: Swift.Equatable {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetExperimentInputBody: Swift.Equatable {
}

extension GetExperimentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExperimentOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExperimentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetExperimentOutputResponse(experiment: \(Swift.String(describing: experiment)))"}
}

extension GetExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct GetExperimentOutputResponse: Swift.Equatable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init (
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct GetExperimentOutputResponseBody: Swift.Equatable {
    public let experiment: FisClientTypes.Experiment?
}

extension GetExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(FisClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension GetExperimentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetExperimentTemplateInput(id: \(Swift.String(describing: id)))"}
}

extension GetExperimentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetExperimentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExperimentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExperimentTemplateOutputError>
}

public struct GetExperimentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExperimentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExperimentTemplateOutputError>
}

public struct GetExperimentTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExperimentTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetExperimentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetExperimentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExperimentTemplateOutputError>
}

public struct GetExperimentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetExperimentTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetExperimentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/experimentTemplates/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetExperimentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetExperimentTemplateOutputError>
}

public struct GetExperimentTemplateInput: Swift.Equatable {
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetExperimentTemplateInputBody: Swift.Equatable {
}

extension GetExperimentTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetExperimentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExperimentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExperimentTemplateOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExperimentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetExperimentTemplateOutputResponse(experimentTemplate: \(Swift.String(describing: experimentTemplate)))"}
}

extension GetExperimentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct GetExperimentTemplateOutputResponse: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init (
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct GetExperimentTemplateOutputResponseBody: Swift.Equatable {
    public let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension GetExperimentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension ListActionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListActionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListActionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListActionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionsOutputError>
}

public struct ListActionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionsOutputError>
}

public struct ListActionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListActionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListActionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionsOutputError>
}

public struct ListActionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListActionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/actions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListActionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionsOutputError>
}

public struct ListActionsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListActionsInputBody: Swift.Equatable {
}

extension ListActionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActionsOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListActionsOutputResponse(actions: \(Swift.String(describing: actions)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct ListActionsOutputResponse: Swift.Equatable {
    /// The actions.
    public var actions: [FisClientTypes.ActionSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        actions: [FisClientTypes.ActionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct ListActionsOutputResponseBody: Swift.Equatable {
    public let actions: [FisClientTypes.ActionSummary]?
    public let nextToken: Swift.String?
}

extension ListActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([FisClientTypes.ActionSummary?].self, forKey: .actions)
        var actionsDecoded0:[FisClientTypes.ActionSummary]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [FisClientTypes.ActionSummary]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExperimentTemplatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListExperimentTemplatesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListExperimentTemplatesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListExperimentTemplatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExperimentTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListExperimentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExperimentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListExperimentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListExperimentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExperimentTemplatesOutputError>
}

public struct ListExperimentTemplatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExperimentTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListExperimentTemplatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExperimentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListExperimentTemplatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListExperimentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExperimentTemplatesOutputError>
}

public struct ListExperimentTemplatesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExperimentTemplatesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListExperimentTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExperimentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListExperimentTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListExperimentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExperimentTemplatesOutputError>
}

public struct ListExperimentTemplatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExperimentTemplatesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListExperimentTemplatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExperimentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/experimentTemplates"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListExperimentTemplatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListExperimentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExperimentTemplatesOutputError>
}

public struct ListExperimentTemplatesInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExperimentTemplatesInputBody: Swift.Equatable {
}

extension ListExperimentTemplatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListExperimentTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExperimentTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExperimentTemplatesOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExperimentTemplatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListExperimentTemplatesOutputResponse(experimentTemplates: \(Swift.String(describing: experimentTemplates)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListExperimentTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExperimentTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplates = output.experimentTemplates
            self.nextToken = output.nextToken
        } else {
            self.experimentTemplates = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentTemplatesOutputResponse: Swift.Equatable {
    /// The experiment templates.
    public var experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experimentTemplates = experimentTemplates
        self.nextToken = nextToken
    }
}

struct ListExperimentTemplatesOutputResponseBody: Swift.Equatable {
    public let experimentTemplates: [FisClientTypes.ExperimentTemplateSummary]?
    public let nextToken: Swift.String?
}

extension ListExperimentTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplates
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplatesContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateSummary?].self, forKey: .experimentTemplates)
        var experimentTemplatesDecoded0:[FisClientTypes.ExperimentTemplateSummary]? = nil
        if let experimentTemplatesContainer = experimentTemplatesContainer {
            experimentTemplatesDecoded0 = [FisClientTypes.ExperimentTemplateSummary]()
            for structure0 in experimentTemplatesContainer {
                if let structure0 = structure0 {
                    experimentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        experimentTemplates = experimentTemplatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExperimentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListExperimentsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListExperimentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListExperimentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExperimentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListExperimentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExperimentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListExperimentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListExperimentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExperimentsOutputError>
}

public struct ListExperimentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExperimentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListExperimentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExperimentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListExperimentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListExperimentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExperimentsOutputError>
}

public struct ListExperimentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExperimentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListExperimentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExperimentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListExperimentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListExperimentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExperimentsOutputError>
}

public struct ListExperimentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListExperimentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListExperimentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListExperimentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/experiments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListExperimentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListExperimentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListExperimentsOutputError>
}

public struct ListExperimentsInput: Swift.Equatable {
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
    public var maxResults: Swift.Int
    /// The token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExperimentsInputBody: Swift.Equatable {
}

extension ListExperimentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListExperimentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExperimentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExperimentsOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExperimentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListExperimentsOutputResponse(experiments: \(Swift.String(describing: experiments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListExperimentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListExperimentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiments = output.experiments
            self.nextToken = output.nextToken
        } else {
            self.experiments = nil
            self.nextToken = nil
        }
    }
}

public struct ListExperimentsOutputResponse: Swift.Equatable {
    /// The experiments.
    public var experiments: [FisClientTypes.ExperimentSummary]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        experiments: [FisClientTypes.ExperimentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.experiments = experiments
        self.nextToken = nextToken
    }
}

struct ListExperimentsOutputResponseBody: Swift.Equatable {
    public let experiments: [FisClientTypes.ExperimentSummary]?
    public let nextToken: Swift.String?
}

extension ListExperimentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiments
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentsContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentSummary?].self, forKey: .experiments)
        var experimentsDecoded0:[FisClientTypes.ExperimentSummary]? = nil
        if let experimentsContainer = experimentsContainer {
            experimentsDecoded0 = [FisClientTypes.ExperimentSummary]()
            for structure0 in experimentsContainer {
                if let structure0 = structure0 {
                    experimentsDecoded0?.append(structure0)
                }
            }
        }
        experiments = experimentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource cannot be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartExperimentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartExperimentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartExperimentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartExperimentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartExperimentOutputError>
}

extension StartExperimentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartExperimentInput(clientToken: \(Swift.String(describing: clientToken)), experimentTemplateId: \(Swift.String(describing: experimentTemplateId)), tags: \(Swift.String(describing: tags)))"}
}

extension StartExperimentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case experimentTemplateId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let experimentTemplateId = experimentTemplateId {
            try encodeContainer.encode(experimentTemplateId, forKey: .experimentTemplateId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartExperimentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartExperimentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartExperimentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartExperimentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartExperimentOutputError>
}

public struct StartExperimentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartExperimentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartExperimentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartExperimentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartExperimentOutputError>
}

public struct StartExperimentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartExperimentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartExperimentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartExperimentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartExperimentOutputError>
}

public struct StartExperimentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartExperimentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartExperimentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/experiments"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartExperimentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartExperimentOutputError>
}

public struct StartExperimentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var experimentTemplateId: Swift.String?
    /// The tags to apply to the experiment.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        experimentTemplateId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.experimentTemplateId = experimentTemplateId
        self.tags = tags
    }
}

struct StartExperimentInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let experimentTemplateId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension StartExperimentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case experimentTemplateId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let experimentTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .experimentTemplateId)
        experimentTemplateId = experimentTemplateIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartExperimentOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExperimentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartExperimentOutputResponse(experiment: \(Swift.String(describing: experiment)))"}
}

extension StartExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct StartExperimentOutputResponse: Swift.Equatable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init (
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct StartExperimentOutputResponseBody: Swift.Equatable {
    public let experiment: FisClientTypes.Experiment?
}

extension StartExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(FisClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

extension StopExperimentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopExperimentInput(id: \(Swift.String(describing: id)))"}
}

extension StopExperimentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StopExperimentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopExperimentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopExperimentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopExperimentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopExperimentOutputError>
}

public struct StopExperimentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopExperimentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopExperimentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopExperimentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopExperimentOutputError>
}

public struct StopExperimentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopExperimentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StopExperimentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopExperimentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopExperimentOutputError>
}

public struct StopExperimentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopExperimentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StopExperimentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopExperimentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/experiments/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StopExperimentInput
    public typealias MOutput = ClientRuntime.OperationOutput<StopExperimentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopExperimentOutputError>
}

public struct StopExperimentInput: Swift.Equatable {
    /// The ID of the experiment.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StopExperimentInputBody: Swift.Equatable {
}

extension StopExperimentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopExperimentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopExperimentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopExperimentOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopExperimentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopExperimentOutputResponse(experiment: \(Swift.String(describing: experiment)))"}
}

extension StopExperimentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopExperimentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experiment = output.experiment
        } else {
            self.experiment = nil
        }
    }
}

public struct StopExperimentOutputResponse: Swift.Equatable {
    /// Information about the experiment.
    public var experiment: FisClientTypes.Experiment?

    public init (
        experiment: FisClientTypes.Experiment? = nil
    )
    {
        self.experiment = experiment
    }
}

struct StopExperimentOutputResponseBody: Swift.Equatable {
    public let experiment: FisClientTypes.Experiment?
}

extension StopExperimentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experiment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentDecoded = try containerValues.decodeIfPresent(FisClientTypes.Experiment.self, forKey: .experiment)
        experiment = experimentDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension FisClientTypes.UpdateExperimentTemplateActionInputItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case description
        case parameters
        case startAfter
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, experimenttemplateactionparametermap0) in parameters {
                try parametersContainer.encode(experimenttemplateactionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startAfter = startAfter {
            var startAfterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startAfter)
            for experimenttemplateactionstartafterlist0 in startAfter {
                try startAfterContainer.encode(experimenttemplateactionstartafterlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, experimenttemplateactiontargetmap0) in targets {
                try targetsContainer.encode(experimenttemplateactiontargetmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplateactionparameter0) in parametersContainer {
                if let experimenttemplateactionparameter0 = experimenttemplateactionparameter0 {
                    parametersDecoded0?[key0] = experimenttemplateactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:Swift.String]()
            for (key0, experimenttemplatetargetname0) in targetsContainer {
                if let experimenttemplatetargetname0 = experimenttemplatetargetname0 {
                    targetsDecoded0?[key0] = experimenttemplatetargetname0
                }
            }
        }
        targets = targetsDecoded0
        let startAfterContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .startAfter)
        var startAfterDecoded0:[Swift.String]? = nil
        if let startAfterContainer = startAfterContainer {
            startAfterDecoded0 = [Swift.String]()
            for string0 in startAfterContainer {
                if let string0 = string0 {
                    startAfterDecoded0?.append(string0)
                }
            }
        }
        startAfter = startAfterDecoded0
    }
}

extension FisClientTypes.UpdateExperimentTemplateActionInputItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateExperimentTemplateActionInputItem(actionId: \(Swift.String(describing: actionId)), description: \(Swift.String(describing: description)), parameters: \(Swift.String(describing: parameters)), startAfter: \(Swift.String(describing: startAfter)), targets: \(Swift.String(describing: targets)))"}
}

extension FisClientTypes {
    /// Specifies an action for an experiment template.
    public struct UpdateExperimentTemplateActionInputItem: Swift.Equatable {
        /// The ID of the action.
        public var actionId: Swift.String?
        /// A description for the action.
        public var description: Swift.String?
        /// The parameters for the action, if applicable.
        public var parameters: [Swift.String:Swift.String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public var startAfter: [Swift.String]?
        /// The targets for the action.
        public var targets: [Swift.String:Swift.String]?

        public init (
            actionId: Swift.String? = nil,
            description: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            startAfter: [Swift.String]? = nil,
            targets: [Swift.String:Swift.String]? = nil
        )
        {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }
    }

}

public struct UpdateExperimentTemplateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateExperimentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateExperimentTemplateOutputError>
}

extension UpdateExperimentTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateExperimentTemplateInput(actions: \(Swift.String(describing: actions)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), roleArn: \(Swift.String(describing: roleArn)), stopConditions: \(Swift.String(describing: stopConditions)), targets: \(Swift.String(describing: targets)))"}
}

extension UpdateExperimentTemplateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case description
        case roleArn
        case stopConditions
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .actions)
            for (dictKey0, updateexperimenttemplateactioninputmap0) in actions {
                try actionsContainer.encode(updateexperimenttemplateactioninputmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stopConditions = stopConditions {
            var stopConditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopConditions)
            for updateexperimenttemplatestopconditioninputlist0 in stopConditions {
                try stopConditionsContainer.encode(updateexperimenttemplatestopconditioninputlist0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .targets)
            for (dictKey0, updateexperimenttemplatetargetinputmap0) in targets {
                try targetsContainer.encode(updateexperimenttemplatetargetinputmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateExperimentTemplateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateExperimentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateExperimentTemplateOutputError>
}

public struct UpdateExperimentTemplateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateExperimentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateExperimentTemplateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateExperimentTemplateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateExperimentTemplateOutputError>
}

public struct UpdateExperimentTemplateInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateExperimentTemplateInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateExperimentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateExperimentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateExperimentTemplateOutputError>
}

public struct UpdateExperimentTemplateInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateExperimentTemplateInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateExperimentTemplateInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let id = input.id else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("id is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/experimentTemplates/\(id.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateExperimentTemplateInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateExperimentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateExperimentTemplateOutputError>
}

public struct UpdateExperimentTemplateInput: Swift.Equatable {
    /// The actions for the experiment.
    public var actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]?
    /// A description for the template.
    public var description: Swift.String?
    /// The ID of the experiment template.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that grants the AWS FIS service permission to perform service actions on your behalf.
    public var roleArn: Swift.String?
    /// The stop conditions for the experiment.
    public var stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]?
    /// The targets for the experiment.
    public var targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]?

    public init (
        actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]? = nil,
        targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.id = id
        self.roleArn = roleArn
        self.stopConditions = stopConditions
        self.targets = targets
    }
}

struct UpdateExperimentTemplateInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let stopConditions: [FisClientTypes.UpdateExperimentTemplateStopConditionInput]?
    public let targets: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]?
    public let actions: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]?
    public let roleArn: Swift.String?
}

extension UpdateExperimentTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case description
        case roleArn
        case stopConditions
        case targets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stopConditionsContainer = try containerValues.decodeIfPresent([FisClientTypes.UpdateExperimentTemplateStopConditionInput?].self, forKey: .stopConditions)
        var stopConditionsDecoded0:[FisClientTypes.UpdateExperimentTemplateStopConditionInput]? = nil
        if let stopConditionsContainer = stopConditionsContainer {
            stopConditionsDecoded0 = [FisClientTypes.UpdateExperimentTemplateStopConditionInput]()
            for structure0 in stopConditionsContainer {
                if let structure0 = structure0 {
                    stopConditionsDecoded0?.append(structure0)
                }
            }
        }
        stopConditions = stopConditionsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.UpdateExperimentTemplateTargetInput?].self, forKey: .targets)
        var targetsDecoded0: [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String:FisClientTypes.UpdateExperimentTemplateTargetInput]()
            for (key0, updateexperimenttemplatetargetinput0) in targetsContainer {
                if let updateexperimenttemplatetargetinput0 = updateexperimenttemplatetargetinput0 {
                    targetsDecoded0?[key0] = updateexperimenttemplatetargetinput0
                }
            }
        }
        targets = targetsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String: FisClientTypes.UpdateExperimentTemplateActionInputItem?].self, forKey: .actions)
        var actionsDecoded0: [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String:FisClientTypes.UpdateExperimentTemplateActionInputItem]()
            for (key0, updateexperimenttemplateactioninputitem0) in actionsContainer {
                if let updateexperimenttemplateactioninputitem0 = updateexperimenttemplateactioninputitem0 {
                    actionsDecoded0?[key0] = updateexperimenttemplateactioninputitem0
                }
            }
        }
        actions = actionsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateExperimentTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateExperimentTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateExperimentTemplateOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateExperimentTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateExperimentTemplateOutputResponse(experimentTemplate: \(Swift.String(describing: experimentTemplate)))"}
}

extension UpdateExperimentTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateExperimentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.experimentTemplate = output.experimentTemplate
        } else {
            self.experimentTemplate = nil
        }
    }
}

public struct UpdateExperimentTemplateOutputResponse: Swift.Equatable {
    /// Information about the experiment template.
    public var experimentTemplate: FisClientTypes.ExperimentTemplate?

    public init (
        experimentTemplate: FisClientTypes.ExperimentTemplate? = nil
    )
    {
        self.experimentTemplate = experimentTemplate
    }
}

struct UpdateExperimentTemplateOutputResponseBody: Swift.Equatable {
    public let experimentTemplate: FisClientTypes.ExperimentTemplate?
}

extension UpdateExperimentTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case experimentTemplate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let experimentTemplateDecoded = try containerValues.decodeIfPresent(FisClientTypes.ExperimentTemplate.self, forKey: .experimentTemplate)
        experimentTemplate = experimentTemplateDecoded
    }
}

extension FisClientTypes.UpdateExperimentTemplateStopConditionInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FisClientTypes.UpdateExperimentTemplateStopConditionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateExperimentTemplateStopConditionInput(source: \(Swift.String(describing: source)), value: \(Swift.String(describing: value)))"}
}

extension FisClientTypes {
    /// Specifies a stop condition for an experiment. You can define a stop condition as a CloudWatch alarm.
    public struct UpdateExperimentTemplateStopConditionInput: Swift.Equatable {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop
        ///          condition is defined by a CloudWatch alarm. Specify none if there is no stop
        ///          condition.
        /// This member is required.
        public var source: Swift.String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm.
        public var value: Swift.String?

        public init (
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.source = source
            self.value = value
        }
    }

}

extension FisClientTypes.UpdateExperimentTemplateTargetInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case resourceArns
        case resourceTags
        case resourceType
        case selectionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for experimenttemplatetargetfilterinputlist0 in filters {
                try filtersContainer.encode(experimenttemplatetargetfilterinputlist0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, tagmap0) in resourceTags {
                try resourceTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let selectionMode = selectionMode {
            try encodeContainer.encode(selectionMode, forKey: .selectionMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([FisClientTypes.ExperimentTemplateTargetInputFilter?].self, forKey: .filters)
        var filtersDecoded0:[FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [FisClientTypes.ExperimentTemplateTargetInputFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let selectionModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionMode)
        selectionMode = selectionModeDecoded
    }
}

extension FisClientTypes.UpdateExperimentTemplateTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateExperimentTemplateTargetInput(filters: \(Swift.String(describing: filters)), resourceArns: \(Swift.String(describing: resourceArns)), resourceTags: \(Swift.String(describing: resourceTags)), resourceType: \(Swift.String(describing: resourceType)), selectionMode: \(Swift.String(describing: selectionMode)))"}
}

extension FisClientTypes {
    /// Specifies a target for an experiment. You must specify at least one Amazon Resource Name (ARN) or at least one resource tag. You cannot specify both.
    public struct UpdateExperimentTemplateTargetInput: Swift.Equatable {
        /// The filters to apply to identify target resources using specific attributes.
        public var filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public var resourceArns: [Swift.String]?
        /// The tags for the target resources.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The AWS resource type. The resource type must be supported for the specified action.
        /// This member is required.
        public var resourceType: Swift.String?
        /// Scopes the identified resources to a specific count or percentage.
        /// This member is required.
        public var selectionMode: Swift.String?

        public init (
            filters: [FisClientTypes.ExperimentTemplateTargetInputFilter]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil,
            selectionMode: Swift.String? = nil
        )
        {
            self.filters = filters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified input is not valid, or fails to satisfy the constraints for the request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
