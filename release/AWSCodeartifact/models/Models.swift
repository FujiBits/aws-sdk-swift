// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///         The operation did not succeed because of an unauthorized access attempt.
///
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeartifactClientTypes.AssetSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashes
        case name
        case size
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashes = hashes {
            var hashesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .hashes)
            for (dictKey0, assethashes0) in hashes {
                try hashesContainer.encode(assethashes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let hashesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hashes)
        var hashesDecoded0: [Swift.String:Swift.String]? = nil
        if let hashesContainer = hashesContainer {
            hashesDecoded0 = [Swift.String:Swift.String]()
            for (key0, hashvalue0) in hashesContainer {
                if let hashvalue0 = hashvalue0 {
                    hashesDecoded0?[key0] = hashvalue0
                }
            }
        }
        hashes = hashesDecoded0
    }
}

extension CodeartifactClientTypes.AssetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetSummary(hashes: \(Swift.String(describing: hashes)), name: \(Swift.String(describing: name)), size: \(Swift.String(describing: size)))"}
}

extension CodeartifactClientTypes {
    ///
    ///         Contains details about a package version asset.
    ///
    public struct AssetSummary: Swift.Equatable {
        ///
        ///       The hashes of the asset.
        ///
        public var hashes: [Swift.String:Swift.String]?
        ///
        ///          The name of the asset.
        ///
        /// This member is required.
        public var name: Swift.String?
        ///
        ///       The size of the asset.
        ///
        public var size: Swift.Int?

        public init (
            hashes: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            size: Swift.Int? = nil
        )
        {
            self.hashes = hashes
            self.name = name
            self.size = size
        }
    }

}

extension AssociateExternalConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateExternalConnectionInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), externalConnection: \(Swift.String(describing: externalConnection)), repository: \(Swift.String(describing: repository)))"}
}

extension AssociateExternalConnectionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct AssociateExternalConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateExternalConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateExternalConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateExternalConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateExternalConnectionOutputError>
}

public struct AssociateExternalConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateExternalConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateExternalConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let externalConnection = input.operationInput.externalConnection {
            let externalConnectionQueryItem = ClientRuntime.URLQueryItem(name: "external-connection".urlPercentEncoding(), value: Swift.String(externalConnection).urlPercentEncoding())
            input.builder.withQueryItem(externalConnectionQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateExternalConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateExternalConnectionOutputError>
}

public struct AssociateExternalConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateExternalConnectionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateExternalConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository/external-connection"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateExternalConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateExternalConnectionOutputError>
}

public struct AssociateExternalConnectionInput: Swift.Equatable {
    /// The name of the domain that contains the repository.
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       The name of the external connection to add to the repository. The following values are supported:
    ///
    ///
    ///
    ///
    ///                   public:npmjs - for the npm public repository.
    ///
    ///
    ///
    ///
    ///                   public:pypi - for the Python Package Index.
    ///
    ///
    ///
    ///
    ///                   public:maven-central - for Maven Central.
    ///
    ///
    ///
    ///
    ///                   public:maven-googleandroid - for the Google Android repository.
    ///
    ///
    ///
    ///
    ///                   public:maven-gradleplugins - for the Gradle plugins repository.
    ///
    ///
    ///
    ///
    ///                   public:maven-commonsware - for the CommonsWare Android repository.
    ///
    ///
    ///
    /// This member is required.
    public var externalConnection: Swift.String?
    ///
    ///       The name of the repository to which the external connection is added.
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        externalConnection: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.externalConnection = externalConnection
        self.repository = repository
    }
}

struct AssociateExternalConnectionInputBody: Swift.Equatable {
}

extension AssociateExternalConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociateExternalConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateExternalConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateExternalConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateExternalConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateExternalConnectionOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension AssociateExternalConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateExternalConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct AssociateExternalConnectionOutputResponse: Swift.Equatable {
    ///
    ///         Information about the connected repository after processing the request.
    ///
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct AssociateExternalConnectionOutputResponseBody: Swift.Equatable {
    public let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension AssociateExternalConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///         The operation did not succeed because prerequisites are not met.
///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    ///       The ID of the resource.
    ///
    public var resourceId: Swift.String?
    ///
    ///       The type of AWS resource.
    ///
    public var resourceType: CodeartifactClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CodeartifactClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: CodeartifactClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CopyPackageVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyPackageVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyPackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyPackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyPackageVersionsOutputError>
}

extension CopyPackageVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyPackageVersionsInput(allowOverwrite: \(Swift.String(describing: allowOverwrite)), destinationRepository: \(Swift.String(describing: destinationRepository)), domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), format: \(Swift.String(describing: format)), includeFromUpstream: \(Swift.String(describing: includeFromUpstream)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)), sourceRepository: \(Swift.String(describing: sourceRepository)), versionRevisions: \(Swift.String(describing: versionRevisions)), versions: \(Swift.String(describing: versions)))"}
}

extension CopyPackageVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowOverwrite
        case includeFromUpstream
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowOverwrite = allowOverwrite {
            try encodeContainer.encode(allowOverwrite, forKey: .allowOverwrite)
        }
        if let includeFromUpstream = includeFromUpstream {
            try encodeContainer.encode(includeFromUpstream, forKey: .includeFromUpstream)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRevisions)
            for (dictKey0, packageversionrevisionmap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageversionrevisionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

public struct CopyPackageVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyPackageVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyPackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyPackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyPackageVersionsOutputError>
}

public struct CopyPackageVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyPackageVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyPackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sourceRepository = input.operationInput.sourceRepository {
            let sourceRepositoryQueryItem = ClientRuntime.URLQueryItem(name: "source-repository".urlPercentEncoding(), value: Swift.String(sourceRepository).urlPercentEncoding())
            input.builder.withQueryItem(sourceRepositoryQueryItem)
        }
        if let destinationRepository = input.operationInput.destinationRepository {
            let destinationRepositoryQueryItem = ClientRuntime.URLQueryItem(name: "destination-repository".urlPercentEncoding(), value: Swift.String(destinationRepository).urlPercentEncoding())
            input.builder.withQueryItem(destinationRepositoryQueryItem)
        }
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyPackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyPackageVersionsOutputError>
}

public struct CopyPackageVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyPackageVersionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CopyPackageVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/versions/copy"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CopyPackageVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<CopyPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyPackageVersionsOutputError>
}

public struct CopyPackageVersionsInput: Swift.Equatable {
    ///
    ///        Set to true to overwrite a package version that already exists in the destination repository.
    ///        If set to false and the package version already exists in the destination repository,
    ///        the package version is returned in the failedVersions field of the response with
    ///        an ALREADY_EXISTS error code.
    ///
    public var allowOverwrite: Swift.Bool?
    ///
    ///       The name of the repository into which package versions are copied.
    ///
    /// This member is required.
    public var destinationRepository: Swift.String?
    ///
    ///         The name of the domain that contains the source and destination repositories.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       The format of the package that is copied. The valid package types are:
    ///
    ///
    ///
    ///
    ///                   npm: A Node Package Manager (npm) package.
    ///
    ///
    ///
    ///
    ///                   pypi: A Python Package Index (PyPI) package.
    ///
    ///
    ///
    ///
    ///                   maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///  Set to true to copy packages from repositories that are upstream from the source
    ///       repository to the destination repository. The default setting is false. For more information,
    ///       see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with
    ///         upstream repositories.
    public var includeFromUpstream: Swift.Bool?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///       The name of the package that is copied.
    ///
    /// This member is required.
    public var package: Swift.String?
    ///
    ///          The name of the repository that contains the package versions to copy.
    ///
    /// This member is required.
    public var sourceRepository: Swift.String?
    ///
    ///        A list of key-value pairs. The keys are package versions and the values are package version revisions. A CopyPackageVersion operation
    ///       succeeds if the specified versions in the source repository match the specified package version revision.
    ///
    ///
    ///
    ///         You must specify versions or versionRevisions. You cannot specify both.
    ///
    ///
    public var versionRevisions: [Swift.String:Swift.String]?
    ///
    ///         The versions of the package to copy.
    ///
    ///
    ///
    ///         You must specify versions or versionRevisions. You cannot specify both.
    ///
    ///
    public var versions: [Swift.String]?

    public init (
        allowOverwrite: Swift.Bool? = nil,
        destinationRepository: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        includeFromUpstream: Swift.Bool? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        sourceRepository: Swift.String? = nil,
        versionRevisions: [Swift.String:Swift.String]? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.allowOverwrite = allowOverwrite
        self.destinationRepository = destinationRepository
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.includeFromUpstream = includeFromUpstream
        self.namespace = namespace
        self.package = package
        self.sourceRepository = sourceRepository
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct CopyPackageVersionsInputBody: Swift.Equatable {
    public let versions: [Swift.String]?
    public let versionRevisions: [Swift.String:Swift.String]?
    public let allowOverwrite: Swift.Bool?
    public let includeFromUpstream: Swift.Bool?
}

extension CopyPackageVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowOverwrite
        case includeFromUpstream
        case versionRevisions
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let allowOverwriteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowOverwrite)
        allowOverwrite = allowOverwriteDecoded
        let includeFromUpstreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeFromUpstream)
        includeFromUpstream = includeFromUpstreamDecoded
    }
}

extension CopyPackageVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyPackageVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyPackageVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyPackageVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyPackageVersionsOutputResponse(failedVersions: \(Swift.String(describing: failedVersions)), successfulVersions: \(Swift.String(describing: successfulVersions)))"}
}

extension CopyPackageVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyPackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct CopyPackageVersionsOutputResponse: Swift.Equatable {
    ///
    ///       A map of package versions that failed to copy and their error codes. The possible error codes are in
    ///       the PackageVersionError data type. They are:
    ///
    ///
    ///
    ///
    ///                   ALREADY_EXISTS
    ///
    ///
    ///
    ///
    ///                   MISMATCHED_REVISION
    ///
    ///
    ///
    ///
    ///                   MISMATCHED_STATUS
    ///
    ///
    ///
    ///
    ///                   NOT_ALLOWED
    ///
    ///
    ///
    ///
    ///                   NOT_FOUND
    ///
    ///
    ///
    ///
    ///                   SKIPPED
    ///
    ///
    ///
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    ///
    ///       A list of the package versions that were successfully copied to your repository.
    ///
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct CopyPackageVersionsOutputResponseBody: Swift.Equatable {
    public let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    public let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension CopyPackageVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

public struct CreateDomainInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

extension CreateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainInput(domain: \(Swift.String(describing: domain)), encryptionKey: \(Swift.String(describing: encryptionKey)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDomainInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKey
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDomainInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/domain"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDomainOutputError>
}

public struct CreateDomainInput: Swift.Equatable {
    ///  The name of the domain to create. All domain names in an AWS Region that are in the
    ///       same AWS account must be unique. The domain name is used as the prefix in DNS hostnames. Do
    ///       not use sensitive information in a domain name because it is publicly discoverable.
    /// This member is required.
    public var domain: Swift.String?
    ///  The encryption key for the domain. This is used to encrypt content stored in a domain.
    ///       An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key
    ///       alias ARN. To specify an encryptionKey, your IAM role must have
    ///         kms:DescribeKey and kms:CreateGrant permissions on the encryption
    ///       key that is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax">DescribeKey in the AWS Key Management Service API Reference
    ///       and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">AWS KMS API Permissions
    ///         Reference in the AWS Key Management Service Developer Guide.
    ///
    ///              CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your
    ///         domain. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric
    ///           keys in the AWS Key Management Service Developer Guide.
    ///
    public var encryptionKey: Swift.String?
    /// One or more tag key-value pairs for the domain.
    public var tags: [CodeartifactClientTypes.Tag]?

    public init (
        domain: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        tags: [CodeartifactClientTypes.Tag]? = nil
    )
    {
        self.domain = domain
        self.encryptionKey = encryptionKey
        self.tags = tags
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    public let encryptionKey: Swift.String?
    public let tags: [CodeartifactClientTypes.Tag]?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKey
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainOutputResponse(domain: \(Swift.String(describing: domain)))"}
}

extension CreateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct CreateDomainOutputResponse: Swift.Equatable {
    ///
    ///         Contains information about the created domain after processing the request.
    ///
    public var domain: CodeartifactClientTypes.DomainDescription?

    public init (
        domain: CodeartifactClientTypes.DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct CreateDomainOutputResponseBody: Swift.Equatable {
    public let domain: CodeartifactClientTypes.DomainDescription?
}

extension CreateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

public struct CreateRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

extension CreateRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRepositoryInput(description: \(Swift.String(describing: description)), domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), repository: \(Swift.String(describing: repository)), tags: \(Swift.String(describing: tags)), upstreams: \(Swift.String(describing: upstreams)))"}
}

extension CreateRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case upstreams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositorylist0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositorylist0)
            }
        }
    }
}

public struct CreateRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInput: Swift.Equatable {
    ///
    ///       A description of the created repository.
    ///
    public var description: Swift.String?
    ///
    ///         The name of the domain that contains the created repository.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///  The name of the repository to create.
    /// This member is required.
    public var repository: Swift.String?
    /// One or more tag key-value pairs for the repository.
    public var tags: [CodeartifactClientTypes.Tag]?
    ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories
    ///         in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more
    ///         information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories.
    public var upstreams: [CodeartifactClientTypes.UpstreamRepository]?

    public init (
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil,
        tags: [CodeartifactClientTypes.Tag]? = nil,
        upstreams: [CodeartifactClientTypes.UpstreamRepository]? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
        self.tags = tags
        self.upstreams = upstreams
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let upstreams: [CodeartifactClientTypes.UpstreamRepository]?
    public let tags: [CodeartifactClientTypes.Tag]?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case upstreams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.UpstreamRepository?].self, forKey: .upstreams)
        var upstreamsDecoded0:[CodeartifactClientTypes.UpstreamRepository]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [CodeartifactClientTypes.UpstreamRepository]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension CreateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutputResponse: Swift.Equatable {
    ///
    ///         Information about the created repository after processing the request.
    ///
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct CreateRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension CreateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DeleteDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDomainInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)))"}
}

extension DeleteDomainInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/domain"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainOutputError>
}

public struct DeleteDomainInput: Swift.Equatable {
    ///
    ///          The name of the domain to delete.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDomainOutputResponse(domain: \(Swift.String(describing: domain)))"}
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DeleteDomainOutputResponse: Swift.Equatable {
    ///
    ///         Contains information about the deleted domain after processing the request.
    ///
    public var domain: CodeartifactClientTypes.DomainDescription?

    public init (
        domain: CodeartifactClientTypes.DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct DeleteDomainOutputResponseBody: Swift.Equatable {
    public let domain: CodeartifactClientTypes.DomainDescription?
}

extension DeleteDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DeleteDomainPermissionsPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDomainPermissionsPolicyInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), policyRevision: \(Swift.String(describing: policyRevision)))"}
}

extension DeleteDomainPermissionsPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDomainPermissionsPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDomainPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainPermissionsPolicyOutputError>
}

public struct DeleteDomainPermissionsPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let policyRevision = input.operationInput.policyRevision {
            let policyRevisionQueryItem = ClientRuntime.URLQueryItem(name: "policy-revision".urlPercentEncoding(), value: Swift.String(policyRevision).urlPercentEncoding())
            input.builder.withQueryItem(policyRevisionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDomainPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainPermissionsPolicyOutputError>
}

public struct DeleteDomainPermissionsPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDomainPermissionsPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDomainPermissionsPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/domain/permissions/policy"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDomainPermissionsPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDomainPermissionsPolicyOutputError>
}

public struct DeleteDomainPermissionsPolicyInput: Swift.Equatable {
    ///
    ///         The name of the domain associated with the resource policy to be deleted.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///         The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which
    ///         prevents others from overwriting your changes to the domain's resource policy.
    ///
    public var policyRevision: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyRevision: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyRevision = policyRevision
    }
}

struct DeleteDomainPermissionsPolicyInputBody: Swift.Equatable {
}

extension DeleteDomainPermissionsPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainPermissionsPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDomainPermissionsPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension DeleteDomainPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDomainPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteDomainPermissionsPolicyOutputResponse: Swift.Equatable {
    ///
    ///         Information about the deleted resource policy after processing the request.
    ///
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteDomainPermissionsPolicyOutputResponseBody: Swift.Equatable {
    public let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension DeleteDomainPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct DeletePackageVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePackageVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePackageVersionsOutputError>
}

extension DeletePackageVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePackageVersionsInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), expectedStatus: \(Swift.String(describing: expectedStatus)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)), repository: \(Swift.String(describing: repository)), versions: \(Swift.String(describing: versions)))"}
}

extension DeletePackageVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

public struct DeletePackageVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePackageVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePackageVersionsOutputError>
}

public struct DeletePackageVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePackageVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePackageVersionsOutputError>
}

public struct DeletePackageVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePackageVersionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeletePackageVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/versions/delete"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePackageVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePackageVersionsOutputError>
}

public struct DeletePackageVersionsInput: Swift.Equatable {
    ///
    ///         The name of the domain that contains the package to delete.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///         The expected status of the package version to delete. Valid values are:
    ///
    ///
    ///
    ///
    ///                   Published
    ///
    ///
    ///
    ///
    ///                   Unfinished
    ///
    ///
    ///
    ///
    ///                   Unlisted
    ///
    ///
    ///
    ///
    ///                   Archived
    ///
    ///
    ///
    ///
    ///                   Disposed
    ///
    ///
    ///
    public var expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    ///
    ///         The format of the package versions to delete. The valid values are:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///         The name of the package with the versions to delete.
    ///
    /// This member is required.
    public var package: Swift.String?
    ///
    ///         The name of the repository that contains the package versions to delete.
    ///
    /// This member is required.
    public var repository: Swift.String?
    ///
    ///         An array of strings that specify the versions of the package to delete.
    ///
    /// This member is required.
    public var versions: [Swift.String]?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        expectedStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.versions = versions
    }
}

struct DeletePackageVersionsInputBody: Swift.Equatable {
    public let versions: [Swift.String]?
    public let expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
}

extension DeletePackageVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
    }
}

extension DeletePackageVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePackageVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePackageVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePackageVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePackageVersionsOutputResponse(failedVersions: \(Swift.String(describing: failedVersions)), successfulVersions: \(Swift.String(describing: successfulVersions)))"}
}

extension DeletePackageVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeletePackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct DeletePackageVersionsOutputResponse: Swift.Equatable {
    ///
    ///        A PackageVersionError object that contains a map of errors codes for the
    ///        deleted package that failed. The possible error codes are:
    ///
    ///
    ///
    ///
    ///                   ALREADY_EXISTS
    ///
    ///
    ///
    ///
    ///                   MISMATCHED_REVISION
    ///
    ///
    ///
    ///
    ///                   MISMATCHED_STATUS
    ///
    ///
    ///
    ///
    ///                   NOT_ALLOWED
    ///
    ///
    ///
    ///
    ///                   NOT_FOUND
    ///
    ///
    ///
    ///
    ///                   SKIPPED
    ///
    ///
    ///
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    ///
    ///        A list of the package versions that were successfully deleted.
    ///
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct DeletePackageVersionsOutputResponseBody: Swift.Equatable {
    public let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    public let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension DeletePackageVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

extension DeleteRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), repository: \(Swift.String(describing: repository)))"}
}

extension DeleteRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInput: Swift.Equatable {
    ///
    ///          The name of the domain that contains the repository to delete.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///  The name of the repository to delete.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
}

extension DeleteRepositoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension DeleteRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutputResponse: Swift.Equatable {
    ///
    ///         Information about the deleted repository after processing the request.
    ///
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension DeleteRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DeleteRepositoryPermissionsPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryPermissionsPolicyInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), policyRevision: \(Swift.String(describing: policyRevision)), repository: \(Swift.String(describing: repository)))"}
}

extension DeleteRepositoryPermissionsPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRepositoryPermissionsPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPermissionsPolicyOutputError>
}

public struct DeleteRepositoryPermissionsPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let policyRevision = input.operationInput.policyRevision {
            let policyRevisionQueryItem = ClientRuntime.URLQueryItem(name: "policy-revision".urlPercentEncoding(), value: Swift.String(policyRevision).urlPercentEncoding())
            input.builder.withQueryItem(policyRevisionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPermissionsPolicyOutputError>
}

public struct DeleteRepositoryPermissionsPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPermissionsPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteRepositoryPermissionsPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository/permissions/policies"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRepositoryPermissionsPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPermissionsPolicyOutputError>
}

public struct DeleteRepositoryPermissionsPolicyInput: Swift.Equatable {
    ///
    ///         The name of the domain that contains the repository associated with the resource policy to be deleted.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which
    ///       prevents others from accidentally overwriting your changes to the repository's resource policy.
    ///
    public var policyRevision: Swift.String?
    ///
    ///       The name of the repository that is associated with the resource policy to be deleted
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyRevision: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyRevision = policyRevision
        self.repository = repository
    }
}

struct DeleteRepositoryPermissionsPolicyInputBody: Swift.Equatable {
}

extension DeleteRepositoryPermissionsPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRepositoryPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryPermissionsPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryPermissionsPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension DeleteRepositoryPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRepositoryPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteRepositoryPermissionsPolicyOutputResponse: Swift.Equatable {
    ///
    ///       Information about the deleted policy after processing the request.
    ///
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteRepositoryPermissionsPolicyOutputResponseBody: Swift.Equatable {
    public let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension DeleteRepositoryPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension DescribeDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)))"}
}

extension DescribeDomainInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDomainInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/domain"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInput: Swift.Equatable {
    ///
    ///          A string that specifies the name of the requested domain.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
}

extension DescribeDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDomainOutputResponse(domain: \(Swift.String(describing: domain)))"}
}

extension DescribeDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DescribeDomainOutputResponse: Swift.Equatable {
    ///
    ///        Information about a domain. A domain is a container for repositories. When you create a domain, it is empty until you
    ///        add one or more repositories.
    ///
    public var domain: CodeartifactClientTypes.DomainDescription?

    public init (
        domain: CodeartifactClientTypes.DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct DescribeDomainOutputResponseBody: Swift.Equatable {
    public let domain: CodeartifactClientTypes.DomainDescription?
}

extension DescribeDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DescribePackageVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePackageVersionInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)), packageVersion: \(Swift.String(describing: packageVersion)), repository: \(Swift.String(describing: repository)))"}
}

extension DescribePackageVersionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribePackageVersionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePackageVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePackageVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePackageVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePackageVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePackageVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePackageVersionOutputError>
}

public struct DescribePackageVersionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePackageVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePackageVersionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePackageVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePackageVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePackageVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePackageVersionOutputError>
}

public struct DescribePackageVersionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePackageVersionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribePackageVersionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePackageVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/version"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePackageVersionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePackageVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePackageVersionOutputError>
}

public struct DescribePackageVersionInput: Swift.Equatable {
    ///
    ///       The name of the domain that contains the repository that contains the package version.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       A format that specifies the type of the requested package version. The valid values are:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///  The name of the requested package version.
    /// This member is required.
    public var package: Swift.String?
    ///
    ///       A string that contains the package version (for example, 3.5.2).
    ///
    /// This member is required.
    public var packageVersion: Swift.String?
    ///  The name of the repository that contains the package version.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct DescribePackageVersionInputBody: Swift.Equatable {
}

extension DescribePackageVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackageVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePackageVersionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackageVersionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePackageVersionOutputResponse(packageVersion: \(Swift.String(describing: packageVersion)))"}
}

extension DescribePackageVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePackageVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.packageVersion = output.packageVersion
        } else {
            self.packageVersion = nil
        }
    }
}

public struct DescribePackageVersionOutputResponse: Swift.Equatable {
    ///
    ///       A <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionDescription.html">PackageVersionDescription
    ///       object that contains information about the requested package version.
    ///
    /// This member is required.
    public var packageVersion: CodeartifactClientTypes.PackageVersionDescription?

    public init (
        packageVersion: CodeartifactClientTypes.PackageVersionDescription? = nil
    )
    {
        self.packageVersion = packageVersion
    }
}

struct DescribePackageVersionOutputResponseBody: Swift.Equatable {
    public let packageVersion: CodeartifactClientTypes.PackageVersionDescription?
}

extension DescribePackageVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionDescription.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
    }
}

extension DescribeRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRepositoryInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), repository: \(Swift.String(describing: repository)))"}
}

extension DescribeRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoryOutputError>
}

public struct DescribeRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoryOutputError>
}

public struct DescribeRepositoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoryOutputError>
}

public struct DescribeRepositoryInput: Swift.Equatable {
    ///
    ///          The name of the domain that contains the repository to describe.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///         A string that specifies the name of the requested repository.
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct DescribeRepositoryInputBody: Swift.Equatable {
}

extension DescribeRepositoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension DescribeRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DescribeRepositoryOutputResponse: Swift.Equatable {
    ///
    ///          A RepositoryDescription object that contains the requested repository information.
    ///
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DescribeRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension DescribeRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DisassociateExternalConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateExternalConnectionInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), externalConnection: \(Swift.String(describing: externalConnection)), repository: \(Swift.String(describing: repository)))"}
}

extension DisassociateExternalConnectionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateExternalConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateExternalConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateExternalConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateExternalConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateExternalConnectionOutputError>
}

public struct DisassociateExternalConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateExternalConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateExternalConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let externalConnection = input.operationInput.externalConnection {
            let externalConnectionQueryItem = ClientRuntime.URLQueryItem(name: "external-connection".urlPercentEncoding(), value: Swift.String(externalConnection).urlPercentEncoding())
            input.builder.withQueryItem(externalConnectionQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateExternalConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateExternalConnectionOutputError>
}

public struct DisassociateExternalConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateExternalConnectionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateExternalConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateExternalConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository/external-connection"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateExternalConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateExternalConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateExternalConnectionOutputError>
}

public struct DisassociateExternalConnectionInput: Swift.Equatable {
    /// The name of the domain that contains the repository from which to remove the external
    ///       repository.
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    /// The name of the external connection to be removed from the repository.
    /// This member is required.
    public var externalConnection: Swift.String?
    /// The name of the repository from which the external connection will be removed.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        externalConnection: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.externalConnection = externalConnection
        self.repository = repository
    }
}

struct DisassociateExternalConnectionInputBody: Swift.Equatable {
}

extension DisassociateExternalConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateExternalConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateExternalConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateExternalConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateExternalConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateExternalConnectionOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension DisassociateExternalConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateExternalConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DisassociateExternalConnectionOutputResponse: Swift.Equatable {
    ///
    ///       The repository associated with the removed external connection.
    ///
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DisassociateExternalConnectionOutputResponseBody: Swift.Equatable {
    public let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension DisassociateExternalConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct DisposePackageVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisposePackageVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisposePackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisposePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisposePackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisposePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisposePackageVersionsOutputError>
}

extension DisposePackageVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisposePackageVersionsInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), expectedStatus: \(Swift.String(describing: expectedStatus)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)), repository: \(Swift.String(describing: repository)), versionRevisions: \(Swift.String(describing: versionRevisions)), versions: \(Swift.String(describing: versions)))"}
}

extension DisposePackageVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRevisions)
            for (dictKey0, packageversionrevisionmap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageversionrevisionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

public struct DisposePackageVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisposePackageVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisposePackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisposePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisposePackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisposePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisposePackageVersionsOutputError>
}

public struct DisposePackageVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisposePackageVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisposePackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisposePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisposePackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisposePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisposePackageVersionsOutputError>
}

public struct DisposePackageVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisposePackageVersionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisposePackageVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisposePackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/versions/dispose"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisposePackageVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisposePackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisposePackageVersionsOutputError>
}

public struct DisposePackageVersionsInput: Swift.Equatable {
    ///
    ///       The name of the domain that contains the repository you want to dispose.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       The expected status of the package version to dispose. Valid values are:
    ///
    ///
    ///
    ///
    ///                   Published
    ///
    ///
    ///
    ///
    ///                   Unfinished
    ///
    ///
    ///
    ///
    ///                   Unlisted
    ///
    ///
    ///
    ///
    ///                   Archived
    ///
    ///
    ///
    ///
    ///                   Disposed
    ///
    ///
    ///
    public var expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    ///
    ///       A format that specifies the type of package versions you want to dispose. The valid values are:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///       The name of the package with the versions you want to dispose.
    ///
    /// This member is required.
    public var package: Swift.String?
    ///
    ///       The name of the repository that contains the package versions you want to dispose.
    ///
    /// This member is required.
    public var repository: Swift.String?
    ///
    ///       The revisions of the package versions you want to dispose.
    ///
    public var versionRevisions: [Swift.String:Swift.String]?
    ///
    ///       The versions of the package you want to dispose.
    ///
    /// This member is required.
    public var versions: [Swift.String]?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        expectedStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        versionRevisions: [Swift.String:Swift.String]? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct DisposePackageVersionsInputBody: Swift.Equatable {
    public let versions: [Swift.String]?
    public let versionRevisions: [Swift.String:Swift.String]?
    public let expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
}

extension DisposePackageVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versionRevisions
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
    }
}

extension DisposePackageVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisposePackageVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisposePackageVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisposePackageVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisposePackageVersionsOutputResponse(failedVersions: \(Swift.String(describing: failedVersions)), successfulVersions: \(Swift.String(describing: successfulVersions)))"}
}

extension DisposePackageVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisposePackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct DisposePackageVersionsOutputResponse: Swift.Equatable {
    ///
    ///       A PackageVersionError object that contains a map of errors codes for the
    ///       disposed package versions that failed. The possible error codes are:
    ///
    ///
    ///
    ///
    ///                   ALREADY_EXISTS
    ///
    ///
    ///
    ///
    ///                   MISMATCHED_REVISION
    ///
    ///
    ///
    ///
    ///                   MISMATCHED_STATUS
    ///
    ///
    ///
    ///
    ///                   NOT_ALLOWED
    ///
    ///
    ///
    ///
    ///                   NOT_FOUND
    ///
    ///
    ///
    ///
    ///                   SKIPPED
    ///
    ///
    ///
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    ///
    ///       A list of the package versions that were successfully disposed.
    ///
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct DisposePackageVersionsOutputResponseBody: Swift.Equatable {
    public let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    public let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension DisposePackageVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

extension CodeartifactClientTypes.DomainDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetSizeBytes
        case createdTime
        case encryptionKey
        case name
        case owner
        case repositoryCount
        case s3BucketArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if assetSizeBytes != 0 {
            try encodeContainer.encode(assetSizeBytes, forKey: .assetSizeBytes)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if repositoryCount != 0 {
            try encodeContainer.encode(repositoryCount, forKey: .repositoryCount)
        }
        if let s3BucketArn = s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let repositoryCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .repositoryCount)
        repositoryCount = repositoryCountDecoded
        let assetSizeBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .assetSizeBytes)
        assetSizeBytes = assetSizeBytesDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
    }
}

extension CodeartifactClientTypes.DomainDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainDescription(arn: \(Swift.String(describing: arn)), assetSizeBytes: \(Swift.String(describing: assetSizeBytes)), createdTime: \(Swift.String(describing: createdTime)), encryptionKey: \(Swift.String(describing: encryptionKey)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), repositoryCount: \(Swift.String(describing: repositoryCount)), s3BucketArn: \(Swift.String(describing: s3BucketArn)), status: \(Swift.String(describing: status)))"}
}

extension CodeartifactClientTypes {
    ///
    ///        Information about a domain. A domain is a container for repositories. When you create a domain, it is empty until you
    ///        add one or more repositories.
    ///
    public struct DomainDescription: Swift.Equatable {
        ///  The Amazon Resource Name (ARN) of the domain.
        public var arn: Swift.String?
        ///
        ///       The total size of all assets in the domain.
        ///
        public var assetSizeBytes: Swift.Int
        ///
        ///       A timestamp that represents the date and time the domain was created.
        ///
        public var createdTime: ClientRuntime.Date?
        ///  The ARN of an AWS Key Management Service (AWS KMS) key associated with a domain.
        public var encryptionKey: Swift.String?
        ///
        ///          The name of the domain.
        ///
        public var name: Swift.String?
        ///  The AWS account ID that owns the domain.
        public var owner: Swift.String?
        ///
        ///       The number of repositories in the domain.
        ///
        public var repositoryCount: Swift.Int
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket that is used to store package assets in the domain.
        public var s3BucketArn: Swift.String?
        ///  The current status of a domain. The valid values are
        ///
        ///
        ///
        ///                   Active
        ///
        ///
        ///
        ///
        ///                   Deleted
        ///
        ///
        ///
        public var status: CodeartifactClientTypes.DomainStatus?

        public init (
            arn: Swift.String? = nil,
            assetSizeBytes: Swift.Int = 0,
            createdTime: ClientRuntime.Date? = nil,
            encryptionKey: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            repositoryCount: Swift.Int = 0,
            s3BucketArn: Swift.String? = nil,
            status: CodeartifactClientTypes.DomainStatus? = nil
        )
        {
            self.arn = arn
            self.assetSizeBytes = assetSizeBytes
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.repositoryCount = repositoryCount
            self.s3BucketArn = s3BucketArn
            self.status = status
        }
    }

}

extension CodeartifactClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .deleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.DomainSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case encryptionKey
        case name
        case owner
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension CodeartifactClientTypes.DomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainSummary(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), encryptionKey: \(Swift.String(describing: encryptionKey)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), status: \(Swift.String(describing: status)))"}
}

extension CodeartifactClientTypes {
    ///  Information about a domain, including its name, Amazon Resource Name (ARN), and status.
    ///       The <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListDomains.html">ListDomains operation returns a list of DomainSummary
    ///       objects.
    public struct DomainSummary: Swift.Equatable {
        ///
        ///       The ARN of the domain.
        ///
        public var arn: Swift.String?
        ///
        ///       A timestamp that contains the date and time the domain was created.
        ///
        public var createdTime: ClientRuntime.Date?
        ///
        ///       The key used to encrypt the domain.
        ///
        public var encryptionKey: Swift.String?
        ///
        ///       The name of the domain.
        ///
        public var name: Swift.String?
        ///
        ///         The 12-digit account number of the AWS account that owns the domain. It does not include
        ///         dashes or spaces.
        ///
        public var owner: Swift.String?
        ///
        ///       A string that contains the status of the domain. The valid values are:
        ///
        ///
        ///
        ///
        ///                   Active
        ///
        ///
        ///
        ///
        ///                   Deleted
        ///
        ///
        ///
        public var status: CodeartifactClientTypes.DomainStatus?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            encryptionKey: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            status: CodeartifactClientTypes.DomainStatus? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.status = status
        }
    }

}

extension CodeartifactClientTypes {
    public enum ExternalConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalConnectionStatus] {
            return [
                .available,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExternalConnectionStatus(rawValue: rawValue) ?? ExternalConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetAuthorizationTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAuthorizationTokenInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), durationSeconds: \(Swift.String(describing: durationSeconds)))"}
}

extension GetAuthorizationTokenInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAuthorizationTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let durationSeconds = input.operationInput.durationSeconds {
            let durationSecondsQueryItem = ClientRuntime.URLQueryItem(name: "duration".urlPercentEncoding(), value: Swift.String(durationSeconds).urlPercentEncoding())
            input.builder.withQueryItem(durationSecondsQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAuthorizationTokenInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/authorization-token"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAuthorizationTokenInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInput: Swift.Equatable {
    ///
    ///         The name of the domain that is in scope for the generated authorization token.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    /// The time, in seconds, that the generated authorization token is valid. Valid values are
    ///     0 and any number between 900 (15 minutes) and 43200 (12 hours).
    ///     A value of 0 will set the expiration of the authorization token to the same expiration of
    ///     the user's role's temporary credentials.
    public var durationSeconds: Swift.Int?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        durationSeconds: Swift.Int? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.durationSeconds = durationSeconds
    }
}

struct GetAuthorizationTokenInputBody: Swift.Equatable {
}

extension GetAuthorizationTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizationTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizationTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizationTokenOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizationTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAuthorizationTokenOutputResponse(authorizationToken: \(Swift.String(describing: authorizationToken)), expiration: \(Swift.String(describing: expiration)))"}
}

extension GetAuthorizationTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAuthorizationTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizationToken = output.authorizationToken
            self.expiration = output.expiration
        } else {
            self.authorizationToken = nil
            self.expiration = nil
        }
    }
}

public struct GetAuthorizationTokenOutputResponse: Swift.Equatable {
    ///
    ///         The returned authentication token.
    ///
    public var authorizationToken: Swift.String?
    ///
    ///       A timestamp that specifies the date and time the authorization token expires.
    ///
    public var expiration: ClientRuntime.Date?

    public init (
        authorizationToken: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil
    )
    {
        self.authorizationToken = authorizationToken
        self.expiration = expiration
    }
}

struct GetAuthorizationTokenOutputResponseBody: Swift.Equatable {
    public let authorizationToken: Swift.String?
    public let expiration: ClientRuntime.Date?
}

extension GetAuthorizationTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationToken
        case expiration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension GetDomainPermissionsPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainPermissionsPolicyInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)))"}
}

extension GetDomainPermissionsPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDomainPermissionsPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDomainPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDomainPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDomainPermissionsPolicyOutputError>
}

public struct GetDomainPermissionsPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDomainPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDomainPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDomainPermissionsPolicyOutputError>
}

public struct GetDomainPermissionsPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDomainPermissionsPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetDomainPermissionsPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/domain/permissions/policy"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDomainPermissionsPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDomainPermissionsPolicyOutputError>
}

public struct GetDomainPermissionsPolicyInput: Swift.Equatable {
    ///
    ///         The name of the domain to which the resource policy is attached.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct GetDomainPermissionsPolicyInputBody: Swift.Equatable {
}

extension GetDomainPermissionsPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainPermissionsPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDomainPermissionsPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension GetDomainPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDomainPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetDomainPermissionsPolicyOutputResponse: Swift.Equatable {
    ///
    ///         The returned resource policy.
    ///
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetDomainPermissionsPolicyOutputResponseBody: Swift.Equatable {
    public let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension GetDomainPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetPackageVersionAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPackageVersionAssetInput(asset: \(Swift.String(describing: asset)), domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)), packageVersion: \(Swift.String(describing: packageVersion)), packageVersionRevision: \(Swift.String(describing: packageVersionRevision)), repository: \(Swift.String(describing: repository)))"}
}

extension GetPackageVersionAssetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPackageVersionAssetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPackageVersionAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPackageVersionAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPackageVersionAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPackageVersionAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPackageVersionAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPackageVersionAssetOutputError>
}

public struct GetPackageVersionAssetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPackageVersionAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPackageVersionAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPackageVersionAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let packageVersionRevision = input.operationInput.packageVersionRevision {
            let packageVersionRevisionQueryItem = ClientRuntime.URLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(packageVersionRevision).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionRevisionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        if let asset = input.operationInput.asset {
            let assetQueryItem = ClientRuntime.URLQueryItem(name: "asset".urlPercentEncoding(), value: Swift.String(asset).urlPercentEncoding())
            input.builder.withQueryItem(assetQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPackageVersionAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPackageVersionAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPackageVersionAssetOutputError>
}

public struct GetPackageVersionAssetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPackageVersionAssetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetPackageVersionAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPackageVersionAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/version/asset"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPackageVersionAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPackageVersionAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPackageVersionAssetOutputError>
}

public struct GetPackageVersionAssetInput: Swift.Equatable {
    ///
    ///       The name of the requested asset.
    ///
    /// This member is required.
    public var asset: Swift.String?
    ///
    ///       The name of the domain that contains the repository that contains the package version with the requested asset.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       A format that specifies the type of the package version with the requested asset file. The valid values are:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///       The name of the package that contains the requested asset.
    ///
    /// This member is required.
    public var package: Swift.String?
    ///
    ///       A string that contains the package version (for example, 3.5.2).
    ///
    /// This member is required.
    public var packageVersion: Swift.String?
    ///
    ///         The name of the package version revision that contains the requested asset.
    ///
    public var packageVersionRevision: Swift.String?
    ///
    ///       The repository that contains the package version with the requested asset.
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        asset: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        packageVersionRevision: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.asset = asset
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.packageVersionRevision = packageVersionRevision
        self.repository = repository
    }
}

struct GetPackageVersionAssetInputBody: Swift.Equatable {
}

extension GetPackageVersionAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageVersionAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPackageVersionAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPackageVersionAssetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPackageVersionAssetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPackageVersionAssetOutputResponse(asset: \(Swift.String(describing: asset)), assetName: \(Swift.String(describing: assetName)), packageVersion: \(Swift.String(describing: packageVersion)), packageVersionRevision: \(Swift.String(describing: packageVersionRevision)))"}
}

extension GetPackageVersionAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let assetNameHeaderValue = httpResponse.headers.value(for: "X-AssetName") {
            self.assetName = assetNameHeaderValue
        } else {
            self.assetName = nil
        }
        if let packageVersionHeaderValue = httpResponse.headers.value(for: "X-PackageVersion") {
            self.packageVersion = packageVersionHeaderValue
        } else {
            self.packageVersion = nil
        }
        if let packageVersionRevisionHeaderValue = httpResponse.headers.value(for: "X-PackageVersionRevision") {
            self.packageVersionRevision = packageVersionRevisionHeaderValue
        } else {
            self.packageVersionRevision = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.asset = data
        } else {
            self.asset = nil
        }
    }
}

public struct GetPackageVersionAssetOutputResponse: Swift.Equatable {
    ///  The binary file, or asset, that is downloaded.
    public var asset: ClientRuntime.ByteStream?
    ///
    ///       The name of the asset that is downloaded.
    ///
    public var assetName: Swift.String?
    ///
    ///       A string that contains the package version (for example, 3.5.2).
    ///
    public var packageVersion: Swift.String?
    ///
    ///       The name of the package version revision that contains the downloaded asset.
    ///
    public var packageVersionRevision: Swift.String?

    public init (
        asset: ClientRuntime.ByteStream? = nil,
        assetName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        packageVersionRevision: Swift.String? = nil
    )
    {
        self.asset = asset
        self.assetName = assetName
        self.packageVersion = packageVersion
        self.packageVersionRevision = packageVersionRevision
    }
}

struct GetPackageVersionAssetOutputResponseBody: Swift.Equatable {
    public let asset: ClientRuntime.ByteStream?
}

extension GetPackageVersionAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asset
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .asset)
        asset = assetDecoded
    }
}

extension GetPackageVersionReadmeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPackageVersionReadmeInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)), packageVersion: \(Swift.String(describing: packageVersion)), repository: \(Swift.String(describing: repository)))"}
}

extension GetPackageVersionReadmeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPackageVersionReadmeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPackageVersionReadmeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPackageVersionReadmeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPackageVersionReadmeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPackageVersionReadmeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPackageVersionReadmeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPackageVersionReadmeOutputError>
}

public struct GetPackageVersionReadmeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPackageVersionReadmeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPackageVersionReadmeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPackageVersionReadmeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPackageVersionReadmeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPackageVersionReadmeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPackageVersionReadmeOutputError>
}

public struct GetPackageVersionReadmeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPackageVersionReadmeInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetPackageVersionReadmeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPackageVersionReadmeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/version/readme"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetPackageVersionReadmeInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetPackageVersionReadmeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPackageVersionReadmeOutputError>
}

public struct GetPackageVersionReadmeInput: Swift.Equatable {
    ///
    ///       The name of the domain that contains the repository that contains the package version with the requested readme file.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       A format that specifies the type of the package version with the requested readme file. The valid values are:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///       The name of the package version that contains the requested readme file.
    ///
    /// This member is required.
    public var package: Swift.String?
    ///
    ///       A string that contains the package version (for example, 3.5.2).
    ///
    /// This member is required.
    public var packageVersion: Swift.String?
    ///
    ///       The repository that contains the package with the requested readme file.
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct GetPackageVersionReadmeInputBody: Swift.Equatable {
}

extension GetPackageVersionReadmeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageVersionReadmeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPackageVersionReadmeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPackageVersionReadmeOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPackageVersionReadmeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPackageVersionReadmeOutputResponse(format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)), readme: \(Swift.String(describing: readme)), version: \(Swift.String(describing: version)), versionRevision: \(Swift.String(describing: versionRevision)))"}
}

extension GetPackageVersionReadmeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPackageVersionReadmeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.namespace = output.namespace
            self.package = output.package
            self.readme = output.readme
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.format = nil
            self.namespace = nil
            self.package = nil
            self.readme = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct GetPackageVersionReadmeOutputResponse: Swift.Equatable {
    ///
    ///       The format of the package with the requested readme file. Valid format types are:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///       The name of the package that contains the returned readme file.
    ///
    public var package: Swift.String?
    ///
    ///       The text of the returned readme file.
    ///
    public var readme: Swift.String?
    ///
    ///       The version of the package with the requested readme file.
    ///
    public var version: Swift.String?
    ///
    ///       The current revision associated with the package version.
    ///
    public var versionRevision: Swift.String?

    public init (
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        readme: Swift.String? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.format = format
        self.namespace = namespace
        self.package = package
        self.readme = readme
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct GetPackageVersionReadmeOutputResponseBody: Swift.Equatable {
    public let format: CodeartifactClientTypes.PackageFormat?
    public let namespace: Swift.String?
    public let package: Swift.String?
    public let version: Swift.String?
    public let versionRevision: Swift.String?
    public let readme: Swift.String?
}

extension GetPackageVersionReadmeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case namespace
        case package
        case readme
        case version
        case versionRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let readmeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readme)
        readme = readmeDecoded
    }
}

extension GetRepositoryEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryEndpointInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), format: \(Swift.String(describing: format)), repository: \(Swift.String(describing: repository)))"}
}

extension GetRepositoryEndpointInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRepositoryEndpointInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryEndpointOutputError>
}

public struct GetRepositoryEndpointInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryEndpointInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryEndpointInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryEndpointOutputError>
}

public struct GetRepositoryEndpointInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryEndpointInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetRepositoryEndpointInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository/endpoint"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositoryEndpointInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryEndpointOutputError>
}

public struct GetRepositoryEndpointInput: Swift.Equatable {
    ///
    ///          The name of the domain that contains the repository.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       Returns which endpoint of a repository to return. A repository has one endpoint for each
    ///       package format:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///          The name of the repository.
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.repository = repository
    }
}

struct GetRepositoryEndpointInputBody: Swift.Equatable {
}

extension GetRepositoryEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRepositoryEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryEndpointOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryEndpointOutputResponse(repositoryEndpoint: \(Swift.String(describing: repositoryEndpoint)))"}
}

extension GetRepositoryEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRepositoryEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repositoryEndpoint = output.repositoryEndpoint
        } else {
            self.repositoryEndpoint = nil
        }
    }
}

public struct GetRepositoryEndpointOutputResponse: Swift.Equatable {
    ///
    ///          A string that specifies the URL of the returned endpoint.
    ///
    public var repositoryEndpoint: Swift.String?

    public init (
        repositoryEndpoint: Swift.String? = nil
    )
    {
        self.repositoryEndpoint = repositoryEndpoint
    }
}

struct GetRepositoryEndpointOutputResponseBody: Swift.Equatable {
    public let repositoryEndpoint: Swift.String?
}

extension GetRepositoryEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryEndpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryEndpoint)
        repositoryEndpoint = repositoryEndpointDecoded
    }
}

extension GetRepositoryPermissionsPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryPermissionsPolicyInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), repository: \(Swift.String(describing: repository)))"}
}

extension GetRepositoryPermissionsPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRepositoryPermissionsPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPermissionsPolicyOutputError>
}

public struct GetRepositoryPermissionsPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPermissionsPolicyOutputError>
}

public struct GetRepositoryPermissionsPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPermissionsPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetRepositoryPermissionsPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository/permissions/policy"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetRepositoryPermissionsPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPermissionsPolicyOutputError>
}

public struct GetRepositoryPermissionsPolicyInput: Swift.Equatable {
    ///
    ///         The name of the domain containing the repository whose associated resource policy is to be retrieved.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///         The name of the repository whose associated resource policy is to be retrieved.
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct GetRepositoryPermissionsPolicyInputBody: Swift.Equatable {
}

extension GetRepositoryPermissionsPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRepositoryPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryPermissionsPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryPermissionsPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension GetRepositoryPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRepositoryPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetRepositoryPermissionsPolicyOutputResponse: Swift.Equatable {
    ///
    ///         The returned resource policy.
    ///
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetRepositoryPermissionsPolicyOutputResponseBody: Swift.Equatable {
    public let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension GetRepositoryPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CodeartifactClientTypes {
    public enum HashAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case md5
        case sha1
        case sha256
        case sha512
        case sdkUnknown(Swift.String)

        public static var allCases: [HashAlgorithm] {
            return [
                .md5,
                .sha1,
                .sha256,
                .sha512,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .md5: return "MD5"
            case .sha1: return "SHA-1"
            case .sha256: return "SHA-256"
            case .sha512: return "SHA-512"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HashAlgorithm(rawValue: rawValue) ?? HashAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///  The operation did not succeed because of an error that occurred inside AWS CodeArtifact.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeartifactClientTypes.LicenseInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension CodeartifactClientTypes.LicenseInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseInfo(name: \(Swift.String(describing: name)), url: \(Swift.String(describing: url)))"}
}

extension CodeartifactClientTypes {
    ///
    ///         Details of the license data.
    ///
    public struct LicenseInfo: Swift.Equatable {
        ///
        ///         Name of the license.
        ///
        public var name: Swift.String?
        ///
        ///         The URL for license data.
        ///
        public var url: Swift.String?

        public init (
            name: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.name = name
            self.url = url
        }
    }

}

public struct ListDomainsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

extension ListDomainsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDomainsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDomainsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDomainsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDomainsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDomainsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/domains"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDomainsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDomainsOutputError>
}

public struct ListDomainsInput: Swift.Equatable {
    ///
    ///         The maximum number of results to return per page.
    ///
    public var maxResults: Swift.Int?
    ///
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDomainsOutputResponse(domains: \(Swift.String(describing: domains)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Swift.Equatable {
    ///
    ///       The returned list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_DomainSummary.html">DomainSummary objects.
    ///
    public var domains: [CodeartifactClientTypes.DomainSummary]?
    ///
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///
    public var nextToken: Swift.String?

    public init (
        domains: [CodeartifactClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Swift.Equatable {
    public let domains: [CodeartifactClientTypes.DomainSummary]?
    public let nextToken: Swift.String?
}

extension ListDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[CodeartifactClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [CodeartifactClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackageVersionAssetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPackageVersionAssetsInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), format: \(Swift.String(describing: format)), maxResults: \(Swift.String(describing: maxResults)), namespace: \(Swift.String(describing: namespace)), nextToken: \(Swift.String(describing: nextToken)), package: \(Swift.String(describing: package)), packageVersion: \(Swift.String(describing: packageVersion)), repository: \(Swift.String(describing: repository)))"}
}

extension ListPackageVersionAssetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPackageVersionAssetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackageVersionAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPackageVersionAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackageVersionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPackageVersionAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackageVersionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackageVersionAssetsOutputError>
}

public struct ListPackageVersionAssetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackageVersionAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPackageVersionAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackageVersionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPackageVersionAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackageVersionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackageVersionAssetsOutputError>
}

public struct ListPackageVersionAssetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackageVersionAssetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPackageVersionAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackageVersionAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/version/assets"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPackageVersionAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackageVersionAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackageVersionAssetsOutputError>
}

public struct ListPackageVersionAssetsInput: Swift.Equatable {
    ///
    ///          The name of the domain that contains the repository associated with the package version assets.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       The format of the package that contains the returned package version assets. The valid package types are:
    ///
    ///
    ///
    ///
    ///                   npm: A Node Package Manager (npm) package.
    ///
    ///
    ///
    ///
    ///                   pypi: A Python Package Index (PyPI) package.
    ///
    ///
    ///
    ///
    ///                   maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///         The maximum number of results to return per page.
    ///
    public var maxResults: Swift.Int?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///          The name of the package that contains the returned package version assets.
    ///
    /// This member is required.
    public var package: Swift.String?
    ///
    ///       A string that contains the package version (for example, 3.5.2).
    ///
    /// This member is required.
    public var packageVersion: Swift.String?
    ///
    ///       The name of the repository that contains the package that contains the returned package version assets.
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct ListPackageVersionAssetsInputBody: Swift.Equatable {
}

extension ListPackageVersionAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageVersionAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackageVersionAssetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageVersionAssetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPackageVersionAssetsOutputResponse(assets: \(Swift.String(describing: assets)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), nextToken: \(Swift.String(describing: nextToken)), package: \(Swift.String(describing: package)), version: \(Swift.String(describing: version)), versionRevision: \(Swift.String(describing: versionRevision)))"}
}

extension ListPackageVersionAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPackageVersionAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.assets = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct ListPackageVersionAssetsOutputResponse: Swift.Equatable {
    ///
    ///       The returned list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_AssetSummary.html">AssetSummary objects.
    ///
    public var assets: [CodeartifactClientTypes.AssetSummary]?
    ///
    ///       The format of the package that contains the returned package version assets.
    ///
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///         If there are additional results, this is the token for the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///       The name of the package that contains the returned package version assets.
    ///
    public var package: Swift.String?
    ///
    ///       The version of the package associated with the returned assets.
    ///
    public var version: Swift.String?
    ///
    ///       The current revision associated with the package version.
    ///
    public var versionRevision: Swift.String?

    public init (
        assets: [CodeartifactClientTypes.AssetSummary]? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.assets = assets
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct ListPackageVersionAssetsOutputResponseBody: Swift.Equatable {
    public let format: CodeartifactClientTypes.PackageFormat?
    public let namespace: Swift.String?
    public let package: Swift.String?
    public let version: Swift.String?
    public let versionRevision: Swift.String?
    public let nextToken: Swift.String?
    public let assets: [CodeartifactClientTypes.AssetSummary]?
}

extension ListPackageVersionAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets
        case format
        case namespace
        case nextToken
        case package
        case version
        case versionRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let assetsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.AssetSummary?].self, forKey: .assets)
        var assetsDecoded0:[CodeartifactClientTypes.AssetSummary]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [CodeartifactClientTypes.AssetSummary]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
    }
}

extension ListPackageVersionDependenciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPackageVersionDependenciesInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), nextToken: \(Swift.String(describing: nextToken)), package: \(Swift.String(describing: package)), packageVersion: \(Swift.String(describing: packageVersion)), repository: \(Swift.String(describing: repository)))"}
}

extension ListPackageVersionDependenciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPackageVersionDependenciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackageVersionDependenciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPackageVersionDependenciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackageVersionDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPackageVersionDependenciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackageVersionDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackageVersionDependenciesOutputError>
}

public struct ListPackageVersionDependenciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackageVersionDependenciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPackageVersionDependenciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackageVersionDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let packageVersion = input.operationInput.packageVersion {
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            input.builder.withQueryItem(packageVersionQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPackageVersionDependenciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackageVersionDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackageVersionDependenciesOutputError>
}

public struct ListPackageVersionDependenciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackageVersionDependenciesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPackageVersionDependenciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackageVersionDependenciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/version/dependencies"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPackageVersionDependenciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackageVersionDependenciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackageVersionDependenciesOutputError>
}

public struct ListPackageVersionDependenciesInput: Swift.Equatable {
    ///
    ///       The name of the domain that contains the repository that contains the requested package version dependencies.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       The format of the package with the requested dependencies. The valid package types are:
    ///
    ///
    ///
    ///
    ///                   npm: A Node Package Manager (npm) package.
    ///
    ///
    ///
    ///
    ///                   pypi: A Python Package Index (PyPI) package.
    ///
    ///
    ///
    ///
    ///                   maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///       The name of the package versions' package.
    ///
    /// This member is required.
    public var package: Swift.String?
    ///
    ///       A string that contains the package version (for example, 3.5.2).
    ///
    /// This member is required.
    public var packageVersion: Swift.String?
    ///
    ///       The name of the repository that contains the requested package version.
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct ListPackageVersionDependenciesInputBody: Swift.Equatable {
}

extension ListPackageVersionDependenciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionDependenciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageVersionDependenciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackageVersionDependenciesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageVersionDependenciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPackageVersionDependenciesOutputResponse(dependencies: \(Swift.String(describing: dependencies)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), nextToken: \(Swift.String(describing: nextToken)), package: \(Swift.String(describing: package)), version: \(Swift.String(describing: version)), versionRevision: \(Swift.String(describing: versionRevision)))"}
}

extension ListPackageVersionDependenciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPackageVersionDependenciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dependencies = output.dependencies
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.dependencies = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct ListPackageVersionDependenciesOutputResponse: Swift.Equatable {
    ///
    ///       The returned list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageDependency.html">PackageDependency objects.
    ///
    public var dependencies: [CodeartifactClientTypes.PackageDependency]?
    ///
    ///       A format that specifies the type of the package that contains the returned dependencies. The valid values are:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///       The name of the package that contains the returned package versions dependencies.
    ///
    public var package: Swift.String?
    ///
    ///       The version of the package that is specified in the request.
    ///
    public var version: Swift.String?
    ///
    ///       The current revision associated with the package version.
    ///
    public var versionRevision: Swift.String?

    public init (
        dependencies: [CodeartifactClientTypes.PackageDependency]? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.dependencies = dependencies
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct ListPackageVersionDependenciesOutputResponseBody: Swift.Equatable {
    public let format: CodeartifactClientTypes.PackageFormat?
    public let namespace: Swift.String?
    public let package: Swift.String?
    public let version: Swift.String?
    public let versionRevision: Swift.String?
    public let nextToken: Swift.String?
    public let dependencies: [CodeartifactClientTypes.PackageDependency]?
}

extension ListPackageVersionDependenciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencies
        case format
        case namespace
        case nextToken
        case package
        case version
        case versionRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dependenciesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.PackageDependency?].self, forKey: .dependencies)
        var dependenciesDecoded0:[CodeartifactClientTypes.PackageDependency]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [CodeartifactClientTypes.PackageDependency]()
            for structure0 in dependenciesContainer {
                if let structure0 = structure0 {
                    dependenciesDecoded0?.append(structure0)
                }
            }
        }
        dependencies = dependenciesDecoded0
    }
}

extension ListPackageVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPackageVersionsInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), format: \(Swift.String(describing: format)), maxResults: \(Swift.String(describing: maxResults)), namespace: \(Swift.String(describing: namespace)), nextToken: \(Swift.String(describing: nextToken)), package: \(Swift.String(describing: package)), repository: \(Swift.String(describing: repository)), sortBy: \(Swift.String(describing: sortBy)), status: \(Swift.String(describing: status)))"}
}

extension ListPackageVersionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPackageVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackageVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackageVersionsOutputError>
}

public struct ListPackageVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackageVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPackageVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let sortBy = input.operationInput.sortBy {
            let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(sortByQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        if let status = input.operationInput.status {
            let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(statusQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPackageVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackageVersionsOutputError>
}

public struct ListPackageVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackageVersionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPackageVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackageVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/versions"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPackageVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackageVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackageVersionsOutputError>
}

public struct ListPackageVersionsInput: Swift.Equatable {
    ///
    ///          The name of the domain that contains the repository that contains the returned package versions.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       The format of the returned packages. The valid package types are:
    ///
    ///
    ///
    ///
    ///                   npm: A Node Package Manager (npm) package.
    ///
    ///
    ///
    ///
    ///                   pypi: A Python Package Index (PyPI) package.
    ///
    ///
    ///
    ///
    ///                   maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///         The maximum number of results to return per page.
    ///
    public var maxResults: Swift.Int?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///       The name of the package for which you want to return a list of package versions.
    ///
    /// This member is required.
    public var package: Swift.String?
    ///
    ///          The name of the repository that contains the package.
    ///
    /// This member is required.
    public var repository: Swift.String?
    ///
    ///       How to sort the returned list of package versions.
    ///
    public var sortBy: CodeartifactClientTypes.PackageVersionSortType?
    ///
    ///       A string that specifies the status of the package versions to include in the returned list. It can be one of the following:
    ///
    ///
    ///
    ///
    ///                   Published
    ///
    ///
    ///
    ///
    ///                   Unfinished
    ///
    ///
    ///
    ///
    ///                   Unlisted
    ///
    ///
    ///
    ///
    ///                   Archived
    ///
    ///
    ///
    ///
    ///                   Disposed
    ///
    ///
    ///
    public var status: CodeartifactClientTypes.PackageVersionStatus?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        sortBy: CodeartifactClientTypes.PackageVersionSortType? = nil,
        status: CodeartifactClientTypes.PackageVersionStatus? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.repository = repository
        self.sortBy = sortBy
        self.status = status
    }
}

struct ListPackageVersionsInputBody: Swift.Equatable {
}

extension ListPackageVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackageVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackageVersionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackageVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPackageVersionsOutputResponse(defaultDisplayVersion: \(Swift.String(describing: defaultDisplayVersion)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), nextToken: \(Swift.String(describing: nextToken)), package: \(Swift.String(describing: package)), versions: \(Swift.String(describing: versions)))"}
}

extension ListPackageVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPackageVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.defaultDisplayVersion = output.defaultDisplayVersion
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.versions = output.versions
        } else {
            self.defaultDisplayVersion = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.versions = nil
        }
    }
}

public struct ListPackageVersionsOutputResponse: Swift.Equatable {
    ///
    ///       The default package version to display. This depends on the package format:
    ///
    ///
    ///
    ///
    ///           For Maven and PyPI packages, it's the most recently published package version.
    ///
    ///
    ///
    ///
    ///           For npm packages, it's the version referenced by the
    ///           latest tag. If the  latest tag is not set, it's the most recently published package version.
    ///
    ///
    ///
    public var defaultDisplayVersion: Swift.String?
    ///
    ///       A format of the package. Valid package format values are:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///         If there are additional results, this is the token for the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///          The name of the package.
    ///
    public var package: Swift.String?
    ///
    ///         The returned list of
    ///         <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionSummary.html">PackageVersionSummary
    ///         objects.
    ///
    public var versions: [CodeartifactClientTypes.PackageVersionSummary]?

    public init (
        defaultDisplayVersion: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        versions: [CodeartifactClientTypes.PackageVersionSummary]? = nil
    )
    {
        self.defaultDisplayVersion = defaultDisplayVersion
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.versions = versions
    }
}

struct ListPackageVersionsOutputResponseBody: Swift.Equatable {
    public let defaultDisplayVersion: Swift.String?
    public let format: CodeartifactClientTypes.PackageFormat?
    public let namespace: Swift.String?
    public let package: Swift.String?
    public let versions: [CodeartifactClientTypes.PackageVersionSummary]?
    public let nextToken: Swift.String?
}

extension ListPackageVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultDisplayVersion
        case format
        case namespace
        case nextToken
        case package
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultDisplayVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultDisplayVersion)
        defaultDisplayVersion = defaultDisplayVersionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.PackageVersionSummary?].self, forKey: .versions)
        var versionsDecoded0:[CodeartifactClientTypes.PackageVersionSummary]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [CodeartifactClientTypes.PackageVersionSummary]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPackagesInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), format: \(Swift.String(describing: format)), maxResults: \(Swift.String(describing: maxResults)), namespace: \(Swift.String(describing: namespace)), nextToken: \(Swift.String(describing: nextToken)), packagePrefix: \(Swift.String(describing: packagePrefix)), repository: \(Swift.String(describing: repository)))"}
}

extension ListPackagesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPackagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackagesOutputError>
}

public struct ListPackagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let packagePrefix = input.operationInput.packagePrefix {
            let packagePrefixQueryItem = ClientRuntime.URLQueryItem(name: "package-prefix".urlPercentEncoding(), value: Swift.String(packagePrefix).urlPercentEncoding())
            input.builder.withQueryItem(packagePrefixQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackagesOutputError>
}

public struct ListPackagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPackagesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPackagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/packages"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPackagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPackagesOutputError>
}

public struct ListPackagesInput: Swift.Equatable {
    ///
    ///         The name of the domain that contains the repository that contains the requested list of packages.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///       The format of the packages. The valid package types are:
    ///
    ///
    ///
    ///
    ///                   npm: A Node Package Manager (npm) package.
    ///
    ///
    ///
    ///
    ///                   pypi: A Python Package Index (PyPI) package.
    ///
    ///
    ///
    ///
    ///                   maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
    ///
    ///
    ///
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///         The maximum number of results to return per page.
    ///
    public var maxResults: Swift.Int?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///       A prefix used to filter returned packages. Only packages with names that start with
    ///       packagePrefix are returned.
    ///
    public var packagePrefix: Swift.String?
    ///
    ///          The name of the repository from which packages are to be listed.
    ///
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        packagePrefix: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.packagePrefix = packagePrefix
        self.repository = repository
    }
}

struct ListPackagesInputBody: Swift.Equatable {
}

extension ListPackagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPackagesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), packages: \(Swift.String(describing: packages)))"}
}

extension ListPackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packages = output.packages
        } else {
            self.nextToken = nil
            self.packages = nil
        }
    }
}

public struct ListPackagesOutputResponse: Swift.Equatable {
    ///
    ///         If there are additional results, this is the token for the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///         The list of returned <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageSummary.html">PackageSummary
    ///         objects.
    ///
    public var packages: [CodeartifactClientTypes.PackageSummary]?

    public init (
        nextToken: Swift.String? = nil,
        packages: [CodeartifactClientTypes.PackageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.packages = packages
    }
}

struct ListPackagesOutputResponseBody: Swift.Equatable {
    public let packages: [CodeartifactClientTypes.PackageSummary]?
    public let nextToken: Swift.String?
}

extension ListPackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case packages
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.PackageSummary?].self, forKey: .packages)
        var packagesDecoded0:[CodeartifactClientTypes.PackageSummary]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [CodeartifactClientTypes.PackageSummary]()
            for structure0 in packagesContainer {
                if let structure0 = structure0 {
                    packagesDecoded0?.append(structure0)
                }
            }
        }
        packages = packagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoriesInDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositoriesInDomainInput(administratorAccount: \(Swift.String(describing: administratorAccount)), domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), repositoryPrefix: \(Swift.String(describing: repositoryPrefix)))"}
}

extension ListRepositoriesInDomainInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRepositoriesInDomainInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositoriesInDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesInDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositoriesInDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesInDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesInDomainOutputError>
}

public struct ListRepositoriesInDomainInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositoriesInDomainInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesInDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let repositoryPrefix = input.operationInput.repositoryPrefix {
            let repositoryPrefixQueryItem = ClientRuntime.URLQueryItem(name: "repository-prefix".urlPercentEncoding(), value: Swift.String(repositoryPrefix).urlPercentEncoding())
            input.builder.withQueryItem(repositoryPrefixQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let administratorAccount = input.operationInput.administratorAccount {
            let administratorAccountQueryItem = ClientRuntime.URLQueryItem(name: "administrator-account".urlPercentEncoding(), value: Swift.String(administratorAccount).urlPercentEncoding())
            input.builder.withQueryItem(administratorAccountQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositoriesInDomainInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesInDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesInDomainOutputError>
}

public struct ListRepositoriesInDomainInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInDomainInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListRepositoriesInDomainInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesInDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/domain/repositories"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRepositoriesInDomainInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesInDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesInDomainOutputError>
}

public struct ListRepositoriesInDomainInput: Swift.Equatable {
    ///
    ///          Filter the list of repositories to only include those that are managed by the AWS account ID.
    ///
    public var administratorAccount: Swift.String?
    ///
    ///          The name of the domain that contains the returned list of repositories.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///         The maximum number of results to return per page.
    ///
    public var maxResults: Swift.Int?
    ///
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///       A prefix used to filter returned repositories. Only repositories with names that start with
    ///       repositoryPrefix are returned.
    ///
    public var repositoryPrefix: Swift.String?

    public init (
        administratorAccount: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryPrefix: Swift.String? = nil
    )
    {
        self.administratorAccount = administratorAccount
        self.domain = domain
        self.domainOwner = domainOwner
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryPrefix = repositoryPrefix
    }
}

struct ListRepositoriesInDomainInputBody: Swift.Equatable {
}

extension ListRepositoriesInDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRepositoriesInDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesInDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoriesInDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesInDomainOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositoriesInDomainOutputResponse(nextToken: \(Swift.String(describing: nextToken)), repositories: \(Swift.String(describing: repositories)))"}
}

extension ListRepositoriesInDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRepositoriesInDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesInDomainOutputResponse: Swift.Equatable {
    ///
    ///         If there are additional results, this is the token for the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///        The returned list of repositories.
    ///
    public var repositories: [CodeartifactClientTypes.RepositorySummary]?

    public init (
        nextToken: Swift.String? = nil,
        repositories: [CodeartifactClientTypes.RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesInDomainOutputResponseBody: Swift.Equatable {
    public let repositories: [CodeartifactClientTypes.RepositorySummary]?
    public let nextToken: Swift.String?
}

extension ListRepositoriesInDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeartifactClientTypes.RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeartifactClientTypes.RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRepositoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositoriesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), repositoryPrefix: \(Swift.String(describing: repositoryPrefix)))"}
}

extension ListRepositoriesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRepositoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let repositoryPrefix = input.operationInput.repositoryPrefix {
            let repositoryPrefixQueryItem = ClientRuntime.URLQueryItem(name: "repository-prefix".urlPercentEncoding(), value: Swift.String(repositoryPrefix).urlPercentEncoding())
            input.builder.withQueryItem(repositoryPrefixQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRepositoriesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListRepositoriesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repositories"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRepositoriesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInput: Swift.Equatable {
    ///
    ///         The maximum number of results to return per page.
    ///
    public var maxResults: Swift.Int?
    ///
    ///         The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    ///
    public var nextToken: Swift.String?
    ///  A prefix used to filter returned repositories. Only repositories with names that start
    ///       with repositoryPrefix are returned.
    public var repositoryPrefix: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryPrefix: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryPrefix = repositoryPrefix
    }
}

struct ListRepositoriesInputBody: Swift.Equatable {
}

extension ListRepositoriesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRepositoriesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), repositories: \(Swift.String(describing: repositories)))"}
}

extension ListRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesOutputResponse: Swift.Equatable {
    ///
    ///         If there are additional results, this is the token for the next set of results.
    ///
    public var nextToken: Swift.String?
    ///
    ///         The returned list of <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_RepositorySummary.html">RepositorySummary
    ///         objects.
    ///
    public var repositories: [CodeartifactClientTypes.RepositorySummary]?

    public init (
        nextToken: Swift.String? = nil,
        repositories: [CodeartifactClientTypes.RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesOutputResponseBody: Swift.Equatable {
    public let repositories: [CodeartifactClientTypes.RepositorySummary]?
    public let nextToken: Swift.String?
}

extension ListRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeartifactClientTypes.RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeartifactClientTypes.RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/tags"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to get tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tag key and value pairs associated with the specified resource.
    public var tags: [CodeartifactClientTypes.Tag]?

    public init (
        tags: [CodeartifactClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [CodeartifactClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeartifactClientTypes.PackageDependency: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencyType
        case namespace
        case package
        case versionRequirement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependencyType = dependencyType {
            try encodeContainer.encode(dependencyType, forKey: .dependencyType)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let package = package {
            try encodeContainer.encode(package, forKey: .package)
        }
        if let versionRequirement = versionRequirement {
            try encodeContainer.encode(versionRequirement, forKey: .versionRequirement)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let dependencyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dependencyType)
        dependencyType = dependencyTypeDecoded
        let versionRequirementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRequirement)
        versionRequirement = versionRequirementDecoded
    }
}

extension CodeartifactClientTypes.PackageDependency: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PackageDependency(dependencyType: \(Swift.String(describing: dependencyType)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)), versionRequirement: \(Swift.String(describing: versionRequirement)))"}
}

extension CodeartifactClientTypes {
    ///
    ///         Details about a package dependency.
    ///
    public struct PackageDependency: Swift.Equatable {
        ///  The type of a package dependency. The possible values depend on the package type.
        ///       Example types are compile, runtime, and test for Maven
        ///       packages, and dev, prod, and optional for npm packages.
        public var dependencyType: Swift.String?
        ///
        ///       The namespace of the package. The package component that specifies its
        ///       namespace depends on its type. For example:
        ///
        ///
        ///
        ///
        ///           The namespace of a Maven package is its groupId.
        ///
        ///
        ///
        ///
        ///           The namespace of an npm package is its scope.
        ///
        ///
        ///
        ///
        ///           A Python package does not contain a corresponding component, so
        ///           Python packages do not have a namespace.
        ///
        ///
        ///
        public var namespace: Swift.String?
        ///
        ///         The name of the package that this package depends on.
        ///
        public var package: Swift.String?
        ///
        ///         The required version, or version range, of the package that this package depends on. The version format
        ///         is specific to the package type. For example, the following are possible valid required versions: 1.2.3,
        ///         ^2.3.4, or 4.x.
        ///
        public var versionRequirement: Swift.String?

        public init (
            dependencyType: Swift.String? = nil,
            namespace: Swift.String? = nil,
            package: Swift.String? = nil,
            versionRequirement: Swift.String? = nil
        )
        {
            self.dependencyType = dependencyType
            self.namespace = namespace
            self.package = package
            self.versionRequirement = versionRequirement
        }
    }

}

extension CodeartifactClientTypes {
    public enum PackageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case maven
        case npm
        case nuget
        case pypi
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageFormat] {
            return [
                .maven,
                .npm,
                .nuget,
                .pypi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .maven: return "maven"
            case .npm: return "npm"
            case .nuget: return "nuget"
            case .pypi: return "pypi"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageFormat(rawValue: rawValue) ?? PackageFormat.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.PackageSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case namespace
        case package
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let package = package {
            try encodeContainer.encode(package, forKey: .package)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
    }
}

extension CodeartifactClientTypes.PackageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PackageSummary(format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)))"}
}

extension CodeartifactClientTypes {
    ///
    ///       Details about a package, including its format, namespace, and name. The
    ///       <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackages.html">ListPackages
    ///       operation returns a list of PackageSummary objects.
    ///
    public struct PackageSummary: Swift.Equatable {
        ///
        ///       The format of the package. Valid values are:
        ///
        ///
        ///
        ///
        ///                   npm
        ///
        ///
        ///
        ///
        ///                   pypi
        ///
        ///
        ///
        ///
        ///                   maven
        ///
        ///
        ///
        public var format: CodeartifactClientTypes.PackageFormat?
        ///
        ///       The namespace of the package. The package component that specifies its
        ///       namespace depends on its type. For example:
        ///
        ///
        ///
        ///
        ///           The namespace of a Maven package is its groupId.
        ///
        ///
        ///
        ///
        ///           The namespace of an npm package is its scope.
        ///
        ///
        ///
        ///
        ///           A Python package does not contain a corresponding component, so
        ///           Python packages do not have a namespace.
        ///
        ///
        ///
        public var namespace: Swift.String?
        ///
        ///       The name of the package.
        ///
        public var package: Swift.String?

        public init (
            format: CodeartifactClientTypes.PackageFormat? = nil,
            namespace: Swift.String? = nil,
            package: Swift.String? = nil
        )
        {
            self.format = format
            self.namespace = namespace
            self.package = package
        }
    }

}

extension CodeartifactClientTypes.PackageVersionDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case format
        case homePage
        case licenses
        case namespace
        case packageName
        case publishedTime
        case revision
        case sourceCodeRepository
        case status
        case summary
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let homePage = homePage {
            try encodeContainer.encode(homePage, forKey: .homePage)
        }
        if let licenses = licenses {
            var licensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenses)
            for licenseinfolist0 in licenses {
                try licensesContainer.encode(licenseinfolist0)
            }
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let publishedTime = publishedTime {
            try encodeContainer.encode(publishedTime.timeIntervalSince1970, forKey: .publishedTime)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let sourceCodeRepository = sourceCodeRepository {
            try encodeContainer.encode(sourceCodeRepository, forKey: .sourceCodeRepository)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let homePageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePage)
        homePage = homePageDecoded
        let sourceCodeRepositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeRepository)
        sourceCodeRepository = sourceCodeRepositoryDecoded
        let publishedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .publishedTime)
        publishedTime = publishedTimeDecoded
        let licensesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.LicenseInfo?].self, forKey: .licenses)
        var licensesDecoded0:[CodeartifactClientTypes.LicenseInfo]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [CodeartifactClientTypes.LicenseInfo]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes.PackageVersionDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PackageVersionDescription(displayName: \(Swift.String(describing: displayName)), format: \(Swift.String(describing: format)), homePage: \(Swift.String(describing: homePage)), licenses: \(Swift.String(describing: licenses)), namespace: \(Swift.String(describing: namespace)), packageName: \(Swift.String(describing: packageName)), publishedTime: \(Swift.String(describing: publishedTime)), revision: \(Swift.String(describing: revision)), sourceCodeRepository: \(Swift.String(describing: sourceCodeRepository)), status: \(Swift.String(describing: status)), summary: \(Swift.String(describing: summary)), version: \(Swift.String(describing: version)))"}
}

extension CodeartifactClientTypes {
    ///
    ///       Details about a package version.
    ///
    public struct PackageVersionDescription: Swift.Equatable {
        ///
        ///       The name of the package that is displayed. The displayName varies depending
        ///       on the package version's format. For example, if an npm package is named ui,
        ///       is in the namespace vue, and has the format npm, then
        ///       the displayName is @vue/ui.
        ///
        public var displayName: Swift.String?
        ///
        ///       The format of the package version. The valid package formats are:
        ///
        ///
        ///
        ///
        ///                   npm: A Node Package Manager (npm) package.
        ///
        ///
        ///
        ///
        ///                   pypi: A Python Package Index (PyPI) package.
        ///
        ///
        ///
        ///
        ///                   maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        ///
        ///
        ///
        public var format: CodeartifactClientTypes.PackageFormat?
        ///
        ///       The homepage associated with the package.
        ///
        public var homePage: Swift.String?
        ///
        ///       Information about licenses associated with the package version.
        ///
        public var licenses: [CodeartifactClientTypes.LicenseInfo]?
        ///
        ///       The namespace of the package. The package component that specifies its
        ///       namespace depends on its type. For example:
        ///
        ///
        ///
        ///
        ///           The namespace of a Maven package is its groupId.
        ///
        ///
        ///
        ///
        ///           The namespace of an npm package is its scope.
        ///
        ///
        ///
        ///
        ///           A Python package does not contain a corresponding component, so
        ///           Python packages do not have a namespace.
        ///
        ///
        ///
        public var namespace: Swift.String?
        ///
        ///       The name of the requested package.
        ///
        public var packageName: Swift.String?
        ///
        ///       A timestamp that contains the date and time the package version was published.
        ///
        public var publishedTime: ClientRuntime.Date?
        ///
        ///       The revision of the package version.
        ///
        public var revision: Swift.String?
        ///
        ///       The repository for the source code in the package version, or the source code used to build it.
        ///
        public var sourceCodeRepository: Swift.String?
        ///
        ///       A string that contains the status of the package version. It can be one of the following:
        ///
        ///
        ///
        ///
        ///                   Published
        ///
        ///
        ///
        ///
        ///                   Unfinished
        ///
        ///
        ///
        ///
        ///                   Unlisted
        ///
        ///
        ///
        ///
        ///                   Archived
        ///
        ///
        ///
        ///
        ///                   Disposed
        ///
        ///
        ///
        public var status: CodeartifactClientTypes.PackageVersionStatus?
        ///
        ///       A summary of the package version. The summary is extracted from the package. The information in and
        ///       detail level of the summary depends on the package version's format.
        ///
        public var summary: Swift.String?
        ///
        ///       The version of the package.
        ///
        public var version: Swift.String?

        public init (
            displayName: Swift.String? = nil,
            format: CodeartifactClientTypes.PackageFormat? = nil,
            homePage: Swift.String? = nil,
            licenses: [CodeartifactClientTypes.LicenseInfo]? = nil,
            namespace: Swift.String? = nil,
            packageName: Swift.String? = nil,
            publishedTime: ClientRuntime.Date? = nil,
            revision: Swift.String? = nil,
            sourceCodeRepository: Swift.String? = nil,
            status: CodeartifactClientTypes.PackageVersionStatus? = nil,
            summary: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.format = format
            self.homePage = homePage
            self.licenses = licenses
            self.namespace = namespace
            self.packageName = packageName
            self.publishedTime = publishedTime
            self.revision = revision
            self.sourceCodeRepository = sourceCodeRepository
            self.status = status
            self.summary = summary
            self.version = version
        }
    }

}

extension CodeartifactClientTypes.PackageVersionError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CodeartifactClientTypes.PackageVersionError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PackageVersionError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)))"}
}

extension CodeartifactClientTypes {
    ///
    ///        An error associated with package.
    ///
    public struct PackageVersionError: Swift.Equatable {
        ///  The error code associated with the error. Valid error codes are:
        ///
        ///
        ///
        ///                   ALREADY_EXISTS
        ///
        ///
        ///
        ///
        ///                   MISMATCHED_REVISION
        ///
        ///
        ///
        ///
        ///                   MISMATCHED_STATUS
        ///
        ///
        ///
        ///
        ///                   NOT_ALLOWED
        ///
        ///
        ///
        ///
        ///                   NOT_FOUND
        ///
        ///
        ///
        ///
        ///                   SKIPPED
        ///
        ///
        ///
        public var errorCode: CodeartifactClientTypes.PackageVersionErrorCode?
        ///
        ///          The error message associated with the error.
        ///
        public var errorMessage: Swift.String?

        public init (
            errorCode: CodeartifactClientTypes.PackageVersionErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension CodeartifactClientTypes {
    public enum PackageVersionErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alreadyExists
        case mismatchedRevision
        case mismatchedStatus
        case notAllowed
        case notFound
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionErrorCode] {
            return [
                .alreadyExists,
                .mismatchedRevision,
                .mismatchedStatus,
                .notAllowed,
                .notFound,
                .skipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alreadyExists: return "ALREADY_EXISTS"
            case .mismatchedRevision: return "MISMATCHED_REVISION"
            case .mismatchedStatus: return "MISMATCHED_STATUS"
            case .notAllowed: return "NOT_ALLOWED"
            case .notFound: return "NOT_FOUND"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionErrorCode(rawValue: rawValue) ?? PackageVersionErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes {
    public enum PackageVersionSortType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case publishedTime
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionSortType] {
            return [
                .publishedTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .publishedTime: return "PUBLISHED_TIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionSortType(rawValue: rawValue) ?? PackageVersionSortType.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes {
    public enum PackageVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archived
        case deleted
        case disposed
        case published
        case unfinished
        case unlisted
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionStatus] {
            return [
                .archived,
                .deleted,
                .disposed,
                .published,
                .unfinished,
                .unlisted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archived: return "Archived"
            case .deleted: return "Deleted"
            case .disposed: return "Disposed"
            case .published: return "Published"
            case .unfinished: return "Unfinished"
            case .unlisted: return "Unlisted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionStatus(rawValue: rawValue) ?? PackageVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.PackageVersionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revision
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes.PackageVersionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PackageVersionSummary(revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)))"}
}

extension CodeartifactClientTypes {
    ///
    ///        Details about a package version, including its status, version, and revision. The
    ///        <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html">ListPackageVersions
    ///        operation returns a list of PackageVersionSummary objects.
    ///
    public struct PackageVersionSummary: Swift.Equatable {
        ///
        ///       The revision associated with a package version.
        ///
        public var revision: Swift.String?
        ///
        ///       A string that contains the status of the package version. It can be one of the following:
        ///
        ///
        ///
        ///
        ///                   Published
        ///
        ///
        ///
        ///
        ///                   Unfinished
        ///
        ///
        ///
        ///
        ///                   Unlisted
        ///
        ///
        ///
        ///
        ///                   Archived
        ///
        ///
        ///
        ///
        ///                   Disposed
        ///
        ///
        ///
        /// This member is required.
        public var status: CodeartifactClientTypes.PackageVersionStatus?
        ///
        ///         Information about a package version.
        ///
        /// This member is required.
        public var version: Swift.String?

        public init (
            revision: Swift.String? = nil,
            status: CodeartifactClientTypes.PackageVersionStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.revision = revision
            self.status = status
            self.version = version
        }
    }

}

public struct PutDomainPermissionsPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDomainPermissionsPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDomainPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDomainPermissionsPolicyOutputError>
}

extension PutDomainPermissionsPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDomainPermissionsPolicyInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), policyDocument: \(Swift.String(describing: policyDocument)), policyRevision: \(Swift.String(describing: policyRevision)))"}
}

extension PutDomainPermissionsPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case domainOwner
        case policyDocument
        case policyRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let domainOwner = domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyRevision = policyRevision {
            try encodeContainer.encode(policyRevision, forKey: .policyRevision)
        }
    }
}

public struct PutDomainPermissionsPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDomainPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDomainPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDomainPermissionsPolicyOutputError>
}

public struct PutDomainPermissionsPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDomainPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDomainPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDomainPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDomainPermissionsPolicyOutputError>
}

public struct PutDomainPermissionsPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDomainPermissionsPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutDomainPermissionsPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDomainPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/domain/permissions/policy"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutDomainPermissionsPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutDomainPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDomainPermissionsPolicyOutputError>
}

public struct PutDomainPermissionsPolicyInput: Swift.Equatable {
    ///
    ///         The name of the domain on which to set the resource policy.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///  A valid displayable JSON Aspen policy string to be set as the access control resource
    ///       policy on the provided domain.
    /// This member is required.
    public var policyDocument: Swift.String?
    ///
    ///         The current revision of the resource policy to be set. This revision is used for optimistic locking, which
    ///         prevents others from overwriting your changes to the domain's resource policy.
    ///
    public var policyRevision: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyRevision: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyDocument = policyDocument
        self.policyRevision = policyRevision
    }
}

struct PutDomainPermissionsPolicyInputBody: Swift.Equatable {
    public let domain: Swift.String?
    public let domainOwner: Swift.String?
    public let policyRevision: Swift.String?
    public let policyDocument: Swift.String?
}

extension PutDomainPermissionsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case domainOwner
        case policyDocument
        case policyRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let policyRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRevision)
        policyRevision = policyRevisionDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutDomainPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDomainPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDomainPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDomainPermissionsPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDomainPermissionsPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension PutDomainPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutDomainPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutDomainPermissionsPolicyOutputResponse: Swift.Equatable {
    ///  The resource policy that was set after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct PutDomainPermissionsPolicyOutputResponseBody: Swift.Equatable {
    public let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension PutDomainPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct PutRepositoryPermissionsPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRepositoryPermissionsPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRepositoryPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRepositoryPermissionsPolicyOutputError>
}

extension PutRepositoryPermissionsPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRepositoryPermissionsPolicyInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), policyDocument: \(Swift.String(describing: policyDocument)), policyRevision: \(Swift.String(describing: policyRevision)), repository: \(Swift.String(describing: repository)))"}
}

extension PutRepositoryPermissionsPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
        case policyRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyRevision = policyRevision {
            try encodeContainer.encode(policyRevision, forKey: .policyRevision)
        }
    }
}

public struct PutRepositoryPermissionsPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRepositoryPermissionsPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRepositoryPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRepositoryPermissionsPolicyOutputError>
}

public struct PutRepositoryPermissionsPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRepositoryPermissionsPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRepositoryPermissionsPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRepositoryPermissionsPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRepositoryPermissionsPolicyOutputError>
}

public struct PutRepositoryPermissionsPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRepositoryPermissionsPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutRepositoryPermissionsPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository/permissions/policy"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRepositoryPermissionsPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRepositoryPermissionsPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRepositoryPermissionsPolicyOutputError>
}

public struct PutRepositoryPermissionsPolicyInput: Swift.Equatable {
    ///
    ///         The name of the domain containing the repository to set the resource policy on.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///  A valid displayable JSON Aspen policy string to be set as the access control resource
    ///       policy on the provided repository.
    /// This member is required.
    public var policyDocument: Swift.String?
    ///
    ///         Sets the revision of the resource policy that specifies permissions to access the repository.
    ///         This revision is used for optimistic locking, which prevents others from overwriting your
    ///         changes to the repository's resource policy.
    ///
    public var policyRevision: Swift.String?
    ///  The name of the repository to set the resource policy on.
    /// This member is required.
    public var repository: Swift.String?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyRevision: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyDocument = policyDocument
        self.policyRevision = policyRevision
        self.repository = repository
    }
}

struct PutRepositoryPermissionsPolicyInputBody: Swift.Equatable {
    public let policyRevision: Swift.String?
    public let policyDocument: Swift.String?
}

extension PutRepositoryPermissionsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
        case policyRevision
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRevision)
        policyRevision = policyRevisionDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutRepositoryPermissionsPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRepositoryPermissionsPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRepositoryPermissionsPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRepositoryPermissionsPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRepositoryPermissionsPolicyOutputResponse(policy: \(Swift.String(describing: policy)))"}
}

extension PutRepositoryPermissionsPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRepositoryPermissionsPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutRepositoryPermissionsPolicyOutputResponse: Swift.Equatable {
    ///  The resource policy that was set after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init (
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct PutRepositoryPermissionsPolicyOutputResponseBody: Swift.Equatable {
    public let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension PutRepositoryPermissionsPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CodeartifactClientTypes.RepositoryDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorAccount
        case arn
        case description
        case domainName
        case domainOwner
        case externalConnections
        case name
        case upstreams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccount = administratorAccount {
            try encodeContainer.encode(administratorAccount, forKey: .administratorAccount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainOwner = domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let externalConnections = externalConnections {
            var externalConnectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalConnections)
            for repositoryexternalconnectioninfolist0 in externalConnections {
                try externalConnectionsContainer.encode(repositoryexternalconnectioninfolist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositoryinfolist0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositoryinfolist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let administratorAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorAccount)
        administratorAccount = administratorAccountDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.UpstreamRepositoryInfo?].self, forKey: .upstreams)
        var upstreamsDecoded0:[CodeartifactClientTypes.UpstreamRepositoryInfo]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [CodeartifactClientTypes.UpstreamRepositoryInfo]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
        let externalConnectionsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.RepositoryExternalConnectionInfo?].self, forKey: .externalConnections)
        var externalConnectionsDecoded0:[CodeartifactClientTypes.RepositoryExternalConnectionInfo]? = nil
        if let externalConnectionsContainer = externalConnectionsContainer {
            externalConnectionsDecoded0 = [CodeartifactClientTypes.RepositoryExternalConnectionInfo]()
            for structure0 in externalConnectionsContainer {
                if let structure0 = structure0 {
                    externalConnectionsDecoded0?.append(structure0)
                }
            }
        }
        externalConnections = externalConnectionsDecoded0
    }
}

extension CodeartifactClientTypes.RepositoryDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryDescription(administratorAccount: \(Swift.String(describing: administratorAccount)), arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), domainName: \(Swift.String(describing: domainName)), domainOwner: \(Swift.String(describing: domainOwner)), externalConnections: \(Swift.String(describing: externalConnections)), name: \(Swift.String(describing: name)), upstreams: \(Swift.String(describing: upstreams)))"}
}

extension CodeartifactClientTypes {
    ///  The details of a repository stored in AWS CodeArtifact. A CodeArtifact repository contains a set of
    ///       package versions, each of which maps to a set of assets. Repositories are polyglot—a single
    ///       repository can contain packages of any supported type. Each repository exposes endpoints for
    ///       fetching and publishing packages using tools like the npm CLI, the Maven CLI
    ///         (mvn), and pip. You can create up to 100 repositories per AWS
    ///       account.
    public struct RepositoryDescription: Swift.Equatable {
        ///  The 12-digit account number of the AWS account that manages the repository.
        public var administratorAccount: Swift.String?
        ///  The Amazon Resource Name (ARN) of the repository.
        public var arn: Swift.String?
        ///
        ///       A text description of the repository.
        ///
        public var description: Swift.String?
        ///
        ///         The name of the domain that contains the repository.
        ///
        public var domainName: Swift.String?
        ///
        ///         The 12-digit account number of the AWS account that owns the domain that contains the repository. It does not include
        ///         dashes or spaces.
        ///
        public var domainOwner: Swift.String?
        ///
        ///       An array of external connections associated with the repository.
        ///
        public var externalConnections: [CodeartifactClientTypes.RepositoryExternalConnectionInfo]?
        ///
        ///         The name of the repository.
        ///
        public var name: Swift.String?
        ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories
        ///         in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more
        ///         information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories.
        public var upstreams: [CodeartifactClientTypes.UpstreamRepositoryInfo]?

        public init (
            administratorAccount: Swift.String? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainOwner: Swift.String? = nil,
            externalConnections: [CodeartifactClientTypes.RepositoryExternalConnectionInfo]? = nil,
            name: Swift.String? = nil,
            upstreams: [CodeartifactClientTypes.UpstreamRepositoryInfo]? = nil
        )
        {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.externalConnections = externalConnections
            self.name = name
            self.upstreams = upstreams
        }
    }

}

extension CodeartifactClientTypes.RepositoryExternalConnectionInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalConnectionName
        case packageFormat
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalConnectionName = externalConnectionName {
            try encodeContainer.encode(externalConnectionName, forKey: .externalConnectionName)
        }
        if let packageFormat = packageFormat {
            try encodeContainer.encode(packageFormat.rawValue, forKey: .packageFormat)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalConnectionName)
        externalConnectionName = externalConnectionNameDecoded
        let packageFormatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .packageFormat)
        packageFormat = packageFormatDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ExternalConnectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes.RepositoryExternalConnectionInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryExternalConnectionInfo(externalConnectionName: \(Swift.String(describing: externalConnectionName)), packageFormat: \(Swift.String(describing: packageFormat)), status: \(Swift.String(describing: status)))"}
}

extension CodeartifactClientTypes {
    ///
    ///         Contains information about the external connection of a repository.
    ///
    public struct RepositoryExternalConnectionInfo: Swift.Equatable {
        ///  The name of the external connection associated with a repository.
        public var externalConnectionName: Swift.String?
        ///
        ///         The package format associated with a repository's external connection. The valid package formats are:
        ///
        ///
        ///
        ///
        ///                   npm: A Node Package Manager (npm) package.
        ///
        ///
        ///
        ///
        ///                   pypi: A Python Package Index (PyPI) package.
        ///
        ///
        ///
        ///
        ///                   maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        ///
        ///
        ///
        public var packageFormat: CodeartifactClientTypes.PackageFormat?
        ///
        ///         The status of the external connection of a repository. There is one valid value, Available.
        ///
        public var status: CodeartifactClientTypes.ExternalConnectionStatus?

        public init (
            externalConnectionName: Swift.String? = nil,
            packageFormat: CodeartifactClientTypes.PackageFormat? = nil,
            status: CodeartifactClientTypes.ExternalConnectionStatus? = nil
        )
        {
            self.externalConnectionName = externalConnectionName
            self.packageFormat = packageFormat
            self.status = status
        }
    }

}

extension CodeartifactClientTypes.RepositorySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorAccount
        case arn
        case description
        case domainName
        case domainOwner
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccount = administratorAccount {
            try encodeContainer.encode(administratorAccount, forKey: .administratorAccount)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainOwner = domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let administratorAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorAccount)
        administratorAccount = administratorAccountDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CodeartifactClientTypes.RepositorySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositorySummary(administratorAccount: \(Swift.String(describing: administratorAccount)), arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), domainName: \(Swift.String(describing: domainName)), domainOwner: \(Swift.String(describing: domainOwner)), name: \(Swift.String(describing: name)))"}
}

extension CodeartifactClientTypes {
    ///  Details about a repository, including its Amazon Resource Name (ARN), description, and
    ///       domain information. The <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListRepositories.html">ListRepositories operation returns a list of
    ///         RepositorySummary objects.
    public struct RepositorySummary: Swift.Equatable {
        ///
        ///          The AWS account ID that manages the repository.
        ///
        public var administratorAccount: Swift.String?
        ///  The ARN of the repository.
        public var arn: Swift.String?
        ///
        ///       The description of the repository.
        ///
        public var description: Swift.String?
        ///
        ///          The name of the domain that contains the repository.
        ///
        public var domainName: Swift.String?
        ///
        ///         The 12-digit account number of the AWS account that owns the domain. It does not include
        ///         dashes or spaces.
        ///
        public var domainOwner: Swift.String?
        ///
        ///          The name of the repository.
        ///
        public var name: Swift.String?

        public init (
            administratorAccount: Swift.String? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainOwner: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.name = name
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///       The operation did not succeed because the resource requested is not found in the service.
///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    ///       The ID of the resource.
    ///
    public var resourceId: Swift.String?
    ///
    ///       The type of AWS resource.
    ///
    public var resourceType: CodeartifactClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CodeartifactClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: CodeartifactClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CodeartifactClientTypes.ResourcePolicy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document
        case resourceArn
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

extension CodeartifactClientTypes.ResourcePolicy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourcePolicy(document: \(Swift.String(describing: document)), resourceArn: \(Swift.String(describing: resourceArn)), revision: \(Swift.String(describing: revision)))"}
}

extension CodeartifactClientTypes {
    ///
    ///         An AWS CodeArtifact resource policy that contains a resource ARN, document details, and a revision.
    ///
    public struct ResourcePolicy: Swift.Equatable {
        ///
        ///       The resource policy formatted in JSON.
        ///
        public var document: Swift.String?
        ///
        ///         The ARN of the resource associated with the resource policy
        ///
        public var resourceArn: Swift.String?
        ///
        ///         The current revision of the resource policy.
        ///
        public var revision: Swift.String?

        public init (
            document: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.document = document
            self.resourceArn = resourceArn
            self.revision = revision
        }
    }

}

extension CodeartifactClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case domain
        case package
        case packageVersion
        case repository
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .asset,
                .domain,
                .package,
                .packageVersion,
                .repository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "asset"
            case .domain: return "domain"
            case .package: return "package"
            case .packageVersion: return "package-version"
            case .repository: return "repository"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///         The operation did not succeed because it would have exceeded a service limit for your account.
///
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    ///       The ID of the resource.
    ///
    public var resourceId: Swift.String?
    ///
    ///       The type of AWS resource.
    ///
    public var resourceType: CodeartifactClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CodeartifactClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: CodeartifactClientTypes.ResourceType?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CodeartifactClientTypes.SuccessfulPackageVersionInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revision
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes.SuccessfulPackageVersionInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuccessfulPackageVersionInfo(revision: \(Swift.String(describing: revision)), status: \(Swift.String(describing: status)))"}
}

extension CodeartifactClientTypes {
    ///
    ///       Contains the revision and status of a package version.
    ///
    public struct SuccessfulPackageVersionInfo: Swift.Equatable {
        ///
        ///       The revision of a package version.
        ///
        public var revision: Swift.String?
        ///
        ///       The status of a package version. Valid statuses are:
        ///
        ///
        ///
        ///
        ///                   Published
        ///
        ///
        ///
        ///
        ///                   Unfinished
        ///
        ///
        ///
        ///
        ///                   Unlisted
        ///
        ///
        ///
        ///
        ///                   Archived
        ///
        ///
        ///
        ///
        ///                   Disposed
        ///
        ///
        ///
        public var status: CodeartifactClientTypes.PackageVersionStatus?

        public init (
            revision: Swift.String? = nil,
            status: CodeartifactClientTypes.PackageVersionStatus? = nil
        )
        {
            self.revision = revision
            self.status = status
        }
    }

}

extension CodeartifactClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodeartifactClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CodeartifactClientTypes {
    /// A tag is a key-value pair that can be used to manage, search for, or filter resources in AWS CodeArtifact.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/tag"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags you want to modify or add to the resource.
    /// This member is required.
    public var tags: [CodeartifactClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [CodeartifactClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [CodeartifactClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///       The operation did not succeed because too many requests are sent to the service.
///
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    ///       The time period, in seconds, to wait before retrying the request.
    ///
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/untag"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key for each tag that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdatePackageVersionsStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePackageVersionsStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePackageVersionsStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePackageVersionsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePackageVersionsStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePackageVersionsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePackageVersionsStatusOutputError>
}

extension UpdatePackageVersionsStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePackageVersionsStatusInput(domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), expectedStatus: \(Swift.String(describing: expectedStatus)), format: \(Swift.String(describing: format)), namespace: \(Swift.String(describing: namespace)), package: \(Swift.String(describing: package)), repository: \(Swift.String(describing: repository)), targetStatus: \(Swift.String(describing: targetStatus)), versionRevisions: \(Swift.String(describing: versionRevisions)), versions: \(Swift.String(describing: versions)))"}
}

extension UpdatePackageVersionsStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case targetStatus
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let targetStatus = targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRevisions)
            for (dictKey0, packageversionrevisionmap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageversionrevisionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversionlist0 in versions {
                try versionsContainer.encode(packageversionlist0)
            }
        }
    }
}

public struct UpdatePackageVersionsStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePackageVersionsStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePackageVersionsStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePackageVersionsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePackageVersionsStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePackageVersionsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePackageVersionsStatusOutputError>
}

public struct UpdatePackageVersionsStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePackageVersionsStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePackageVersionsStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePackageVersionsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let package = input.operationInput.package {
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            input.builder.withQueryItem(packageQueryItem)
        }
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        if let namespace = input.operationInput.namespace {
            let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            input.builder.withQueryItem(namespaceQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePackageVersionsStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePackageVersionsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePackageVersionsStatusOutputError>
}

public struct UpdatePackageVersionsStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePackageVersionsStatusInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdatePackageVersionsStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePackageVersionsStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/package/versions/update_status"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePackageVersionsStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePackageVersionsStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePackageVersionsStatusOutputError>
}

public struct UpdatePackageVersionsStatusInput: Swift.Equatable {
    ///
    ///       The name of the domain that contains the repository that contains the package versions with a status to be updated.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///  The package version’s expected status before it is updated. If
    ///         expectedStatus is provided, the package version's status is updated only if its
    ///       status at the time UpdatePackageVersionsStatus is called matches
    ///         expectedStatus.
    public var expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    ///
    ///       A format that specifies the type of the package with the statuses to update. The valid values are:
    ///
    ///
    ///
    ///
    ///                   npm
    ///
    ///
    ///
    ///
    ///                   pypi
    ///
    ///
    ///
    ///
    ///                   maven
    ///
    ///
    ///
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    ///
    ///       The namespace of the package. The package component that specifies its
    ///       namespace depends on its type. For example:
    ///
    ///
    ///
    ///
    ///           The namespace of a Maven package is its groupId.
    ///
    ///
    ///
    ///
    ///           The namespace of an npm package is its scope.
    ///
    ///
    ///
    ///
    ///           A Python package does not contain a corresponding component, so
    ///           Python packages do not have a namespace.
    ///
    ///
    ///
    public var namespace: Swift.String?
    ///
    ///       The name of the package with the version statuses to update.
    ///
    /// This member is required.
    public var package: Swift.String?
    ///
    ///       The repository that contains the package versions with the status you want to update.
    ///
    /// This member is required.
    public var repository: Swift.String?
    ///
    ///       The status you want to change the package version status to.
    ///
    /// This member is required.
    public var targetStatus: CodeartifactClientTypes.PackageVersionStatus?
    ///  A map of package versions and package version revisions. The map key is the
    ///       package version (for example, 3.5.2), and the map value is the
    ///       package version revision.
    public var versionRevisions: [Swift.String:Swift.String]?
    ///
    ///       An array of strings that specify the versions of the package with the statuses to update.
    ///
    /// This member is required.
    public var versions: [Swift.String]?

    public init (
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        expectedStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        targetStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        versionRevisions: [Swift.String:Swift.String]? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.targetStatus = targetStatus
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct UpdatePackageVersionsStatusInputBody: Swift.Equatable {
    public let versions: [Swift.String]?
    public let versionRevisions: [Swift.String:Swift.String]?
    public let expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    public let targetStatus: CodeartifactClientTypes.PackageVersionStatus?
}

extension UpdatePackageVersionsStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case targetStatus
        case versionRevisions
        case versions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension UpdatePackageVersionsStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePackageVersionsStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePackageVersionsStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePackageVersionsStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePackageVersionsStatusOutputResponse(failedVersions: \(Swift.String(describing: failedVersions)), successfulVersions: \(Swift.String(describing: successfulVersions)))"}
}

extension UpdatePackageVersionsStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePackageVersionsStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct UpdatePackageVersionsStatusOutputResponse: Swift.Equatable {
    ///  A list of SuccessfulPackageVersionInfo objects, one for each package version
    ///       with a status that successfully updated.
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    ///
    ///       A list of PackageVersionError objects, one for each package version with
    ///       a status that failed to update.
    ///
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init (
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct UpdatePackageVersionsStatusOutputResponseBody: Swift.Equatable {
    public let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    public let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension UpdatePackageVersionsStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

public struct UpdateRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRepositoryOutputError>
}

extension UpdateRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRepositoryInput(description: \(Swift.String(describing: description)), domain: \(Swift.String(describing: domain)), domainOwner: \(Swift.String(describing: domainOwner)), repository: \(Swift.String(describing: repository)), upstreams: \(Swift.String(describing: upstreams)))"}
}

extension UpdateRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case upstreams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositorylist0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositorylist0)
            }
        }
    }
}

public struct UpdateRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRepositoryOutputError>
}

public struct UpdateRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let domain = input.operationInput.domain {
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            input.builder.withQueryItem(domainQueryItem)
        }
        if let domainOwner = input.operationInput.domainOwner {
            let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
            input.builder.withQueryItem(domainOwnerQueryItem)
        }
        if let repository = input.operationInput.repository {
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            input.builder.withQueryItem(repositoryQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRepositoryOutputError>
}

public struct UpdateRepositoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRepositoryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateRepositoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/v1/repository"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateRepositoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRepositoryOutputError>
}

public struct UpdateRepositoryInput: Swift.Equatable {
    ///
    ///          An updated repository description.
    ///
    public var description: Swift.String?
    ///
    ///          The name of the domain associated with the repository to update.
    ///
    /// This member is required.
    public var domain: Swift.String?
    ///
    ///         The 12-digit account number of the AWS account that owns the domain. It does not include
    ///         dashes or spaces.
    ///
    public var domainOwner: Swift.String?
    ///
    ///          The name of the repository to update.
    ///
    /// This member is required.
    public var repository: Swift.String?
    ///  A list of upstream repositories to associate with the repository. The order of the upstream repositories
    ///         in the list determines their priority order when AWS CodeArtifact looks for a requested package version. For more
    ///         information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories.
    public var upstreams: [CodeartifactClientTypes.UpstreamRepository]?

    public init (
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil,
        upstreams: [CodeartifactClientTypes.UpstreamRepository]? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
        self.upstreams = upstreams
    }
}

struct UpdateRepositoryInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let upstreams: [CodeartifactClientTypes.UpstreamRepository]?
}

extension UpdateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case upstreams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.UpstreamRepository?].self, forKey: .upstreams)
        var upstreamsDecoded0:[CodeartifactClientTypes.UpstreamRepository]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [CodeartifactClientTypes.UpstreamRepository]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
    }
}

extension UpdateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension UpdateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct UpdateRepositoryOutputResponse: Swift.Equatable {
    ///
    ///          The updated repository.
    ///
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init (
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct UpdateRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension UpdateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension CodeartifactClientTypes.UpstreamRepository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension CodeartifactClientTypes.UpstreamRepository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpstreamRepository(repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension CodeartifactClientTypes {
    ///
    ///        Information about an upstream repository. A list of UpstreamRepository objects is an input parameter to
    ///        <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_CreateRepository.html">CreateRepository
    ///        and <a href="https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_UpdateRepository.html">UpdateRepository.
    ///
    public struct UpstreamRepository: Swift.Equatable {
        ///  The name of an upstream repository.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init (
            repositoryName: Swift.String? = nil
        )
        {
            self.repositoryName = repositoryName
        }
    }

}

extension CodeartifactClientTypes.UpstreamRepositoryInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension CodeartifactClientTypes.UpstreamRepositoryInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpstreamRepositoryInfo(repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension CodeartifactClientTypes {
    ///
    ///         Information about an upstream repository.
    ///
    public struct UpstreamRepositoryInfo: Swift.Equatable {
        ///  The name of an upstream repository.
        public var repositoryName: Swift.String?

        public init (
            repositoryName: Swift.String? = nil
        )
        {
            self.repositoryName = repositoryName
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
///       The operation did not succeed because a parameter in the request was sent with an invalid value.
///
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    ///
    ///
    ///
    public var reason: CodeartifactClientTypes.ValidationExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: CodeartifactClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: CodeartifactClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CodeartifactClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case encryptionKeyError
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .encryptionKeyError,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .encryptionKeyError: return "ENCRYPTION_KEY_ERROR"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
