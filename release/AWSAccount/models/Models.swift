// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because the calling identity doesn't have the minimum required
///             permissions.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountClientTypes.AlternateContact: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateContactType = "AlternateContactType"
        case emailAddress = "EmailAddress"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateContactType = alternateContactType {
            try encodeContainer.encode(alternateContactType.rawValue, forKey: .alternateContactType)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let alternateContactTypeDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContactType.self, forKey: .alternateContactType)
        alternateContactType = alternateContactTypeDecoded
    }
}

extension AccountClientTypes.AlternateContact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlternateContact(alternateContactType: \(Swift.String(describing: alternateContactType)), emailAddress: \(Swift.String(describing: emailAddress)), name: \(Swift.String(describing: name)), phoneNumber: \(Swift.String(describing: phoneNumber)), title: \(Swift.String(describing: title)))"}
}

extension AccountClientTypes {
    /// A structure that contains the details of an alternate contact associated with an Amazon Web Services
    ///             account
    public struct AlternateContact: Swift.Equatable {
        /// The type of alternate contact.
        public var alternateContactType: AccountClientTypes.AlternateContactType?
        /// The email address associated with this alternate contact.
        public var emailAddress: Swift.String?
        /// The name associated with this alternate contact.
        public var name: Swift.String?
        /// The phone number associated with this alternate contact.
        public var phoneNumber: Swift.String?
        /// The title associated with this alternate contact.
        public var title: Swift.String?

        public init (
            alternateContactType: AccountClientTypes.AlternateContactType? = nil,
            emailAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.alternateContactType = alternateContactType
            self.emailAddress = emailAddress
            self.name = name
            self.phoneNumber = phoneNumber
            self.title = title
        }
    }

}

extension AccountClientTypes {
    public enum AlternateContactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case billing
        case operations
        case security
        case sdkUnknown(Swift.String)

        public static var allCases: [AlternateContactType] {
            return [
                .billing,
                .operations,
                .security,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .billing: return "BILLING"
            case .operations: return "OPERATIONS"
            case .security: return "SECURITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlternateContactType(rawValue: rawValue) ?? AlternateContactType.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteAlternateContactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAlternateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAlternateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAlternateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAlternateContactOutputError>
}

extension DeleteAlternateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAlternateContactInput(accountId: \(Swift.String(describing: accountId)), alternateContactType: \(Swift.String(describing: alternateContactType)))"}
}

extension DeleteAlternateContactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let alternateContactType = alternateContactType {
            try encodeContainer.encode(alternateContactType.rawValue, forKey: .alternateContactType)
        }
    }
}

public struct DeleteAlternateContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAlternateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAlternateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAlternateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAlternateContactOutputError>
}

public struct DeleteAlternateContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAlternateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAlternateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAlternateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAlternateContactOutputError>
}

public struct DeleteAlternateContactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAlternateContactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAlternateContactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/deleteAlternateContact"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAlternateContactInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAlternateContactOutputError>
}

public struct DeleteAlternateContactInput: Swift.Equatable {
    /// Specifies the 12 digit account ID number of the Amazon Web Services account that
    ///         you want to access or modify with this operation.
    ///          If you do not specify this parameter, it defaults to the Amazon Web Services account of the
    ///         identity used to call the operation.
    ///          To use this parameter, the caller must be an identity in the <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account">organization's management account or a delegated administrator account, and
    ///         the specified account ID must be a member account in the same organization. The
    ///         organization must have <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html">all features
    ///         enabled, and the organization must have <a href="https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html">trusted access enabled for the
    ///         Account Management service, and optionally a <a href="https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html">delegated admin account
    ///         assigned.
    ///
    ///             The management account can't specify its own AccountId; it must call
    ///             the operation in standalone context by not including the AccountId
    ///             parameter.
    ///
    ///          To call this operation on an account that is not a member of an organization, then
    ///         don't specify this parameter, and call the operation using an identity belonging to
    ///         the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Specifies which of the alternate contacts to delete.
    /// This member is required.
    public var alternateContactType: AccountClientTypes.AlternateContactType?

    public init (
        accountId: Swift.String? = nil,
        alternateContactType: AccountClientTypes.AlternateContactType? = nil
    )
    {
        self.accountId = accountId
        self.alternateContactType = alternateContactType
    }
}

struct DeleteAlternateContactInputBody: Swift.Equatable {
    public let alternateContactType: AccountClientTypes.AlternateContactType?
    public let accountId: Swift.String?
}

extension DeleteAlternateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alternateContactTypeDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContactType.self, forKey: .alternateContactType)
        alternateContactType = alternateContactTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DeleteAlternateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAlternateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAlternateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAlternateContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAlternateContactOutputResponse()"}
}

extension DeleteAlternateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAlternateContactOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAlternateContactOutputResponseBody: Swift.Equatable {
}

extension DeleteAlternateContactOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct GetAlternateContactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAlternateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAlternateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAlternateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAlternateContactOutputError>
}

extension GetAlternateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAlternateContactInput(accountId: \(Swift.String(describing: accountId)), alternateContactType: \(Swift.String(describing: alternateContactType)))"}
}

extension GetAlternateContactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let alternateContactType = alternateContactType {
            try encodeContainer.encode(alternateContactType.rawValue, forKey: .alternateContactType)
        }
    }
}

public struct GetAlternateContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAlternateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAlternateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAlternateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAlternateContactOutputError>
}

public struct GetAlternateContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAlternateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAlternateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAlternateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAlternateContactOutputError>
}

public struct GetAlternateContactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAlternateContactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAlternateContactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/getAlternateContact"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAlternateContactInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAlternateContactOutputError>
}

public struct GetAlternateContactInput: Swift.Equatable {
    /// Specifies the 12 digit account ID number of the Amazon Web Services account that
    ///         you want to access or modify with this operation.
    ///          If you do not specify this parameter, it defaults to the Amazon Web Services account of the
    ///         identity used to call the operation.
    ///          To use this parameter, the caller must be an identity in the <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account">organization's management account or a delegated administrator account, and
    ///         the specified account ID must be a member account in the same organization. The
    ///         organization must have <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html">all features
    ///         enabled, and the organization must have <a href="https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html">trusted access enabled for the
    ///         Account Management service, and optionally a <a href="https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html">delegated admin account
    ///         assigned.
    ///
    ///             The management account can't specify its own AccountId; it must call
    ///             the operation in standalone context by not including the AccountId
    ///             parameter.
    ///
    ///          To call this operation on an account that is not a member of an organization, then
    ///         don't specify this parameter, and call the operation using an identity belonging to
    ///         the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Specifies which alternate contact you want to retrieve.
    /// This member is required.
    public var alternateContactType: AccountClientTypes.AlternateContactType?

    public init (
        accountId: Swift.String? = nil,
        alternateContactType: AccountClientTypes.AlternateContactType? = nil
    )
    {
        self.accountId = accountId
        self.alternateContactType = alternateContactType
    }
}

struct GetAlternateContactInputBody: Swift.Equatable {
    public let alternateContactType: AccountClientTypes.AlternateContactType?
    public let accountId: Swift.String?
}

extension GetAlternateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alternateContactTypeDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContactType.self, forKey: .alternateContactType)
        alternateContactType = alternateContactTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension GetAlternateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAlternateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAlternateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAlternateContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAlternateContactOutputResponse(alternateContact: \(Swift.String(describing: alternateContact)))"}
}

extension GetAlternateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAlternateContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alternateContact = output.alternateContact
        } else {
            self.alternateContact = nil
        }
    }
}

public struct GetAlternateContactOutputResponse: Swift.Equatable {
    /// A structure that contains the details for the specified alternate contact.
    public var alternateContact: AccountClientTypes.AlternateContact?

    public init (
        alternateContact: AccountClientTypes.AlternateContact? = nil
    )
    {
        self.alternateContact = alternateContact
    }
}

struct GetAlternateContactOutputResponseBody: Swift.Equatable {
    public let alternateContact: AccountClientTypes.AlternateContact?
}

extension GetAlternateContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateContact = "AlternateContact"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alternateContactDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContact.self, forKey: .alternateContact)
        alternateContact = alternateContactDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because of an error internal to Amazon Web Services. Try your operation again
///             later.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutAlternateContactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAlternateContactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAlternateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAlternateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAlternateContactOutputError>
}

extension PutAlternateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAlternateContactInput(accountId: \(Swift.String(describing: accountId)), alternateContactType: \(Swift.String(describing: alternateContactType)), emailAddress: \(Swift.String(describing: emailAddress)), name: \(Swift.String(describing: name)), phoneNumber: \(Swift.String(describing: phoneNumber)), title: \(Swift.String(describing: title)))"}
}

extension PutAlternateContactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
        case emailAddress = "EmailAddress"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let alternateContactType = alternateContactType {
            try encodeContainer.encode(alternateContactType.rawValue, forKey: .alternateContactType)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct PutAlternateContactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAlternateContactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAlternateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAlternateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAlternateContactOutputError>
}

public struct PutAlternateContactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAlternateContactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAlternateContactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAlternateContactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAlternateContactOutputError>
}

public struct PutAlternateContactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAlternateContactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutAlternateContactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAlternateContactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/putAlternateContact"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAlternateContactInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAlternateContactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAlternateContactOutputError>
}

public struct PutAlternateContactInput: Swift.Equatable {
    /// Specifies the 12 digit account ID number of the Amazon Web Services account that
    ///         you want to access or modify with this operation.
    ///          If you do not specify this parameter, it defaults to the Amazon Web Services account of the
    ///         identity used to call the operation.
    ///          To use this parameter, the caller must be an identity in the <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account">organization's management account or a delegated administrator account, and
    ///         the specified account ID must be a member account in the same organization. The
    ///         organization must have <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html">all features
    ///         enabled, and the organization must have <a href="https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html">trusted access enabled for the
    ///         Account Management service, and optionally a <a href="https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html">delegated admin account
    ///         assigned.
    ///
    ///             The management account can't specify its own AccountId; it must call
    ///             the operation in standalone context by not including the AccountId
    ///             parameter.
    ///
    ///          To call this operation on an account that is not a member of an organization, then
    ///         don't specify this parameter, and call the operation using an identity belonging to
    ///         the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Specifies which alternate contact you want to create or update.
    /// This member is required.
    public var alternateContactType: AccountClientTypes.AlternateContactType?
    /// Specifies an email address for the alternate contact.
    /// This member is required.
    public var emailAddress: Swift.String?
    /// Specifies a name for the alternate contact.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies a phone number for the alternate contact.
    /// This member is required.
    public var phoneNumber: Swift.String?
    /// Specifies a title for the alternate contact.
    /// This member is required.
    public var title: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        alternateContactType: AccountClientTypes.AlternateContactType? = nil,
        emailAddress: Swift.String? = nil,
        name: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.alternateContactType = alternateContactType
        self.emailAddress = emailAddress
        self.name = name
        self.phoneNumber = phoneNumber
        self.title = title
    }
}

struct PutAlternateContactInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let title: Swift.String?
    public let emailAddress: Swift.String?
    public let phoneNumber: Swift.String?
    public let alternateContactType: AccountClientTypes.AlternateContactType?
    public let accountId: Swift.String?
}

extension PutAlternateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
        case emailAddress = "EmailAddress"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let alternateContactTypeDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContactType.self, forKey: .alternateContactType)
        alternateContactType = alternateContactTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension PutAlternateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAlternateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAlternateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAlternateContactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAlternateContactOutputResponse()"}
}

extension PutAlternateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutAlternateContactOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutAlternateContactOutputResponseBody: Swift.Equatable {
}

extension PutAlternateContactOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because it specified a resource that can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because it was called too frequently and exceeded a throttle
///             limit.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because one of the input parameters was invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
