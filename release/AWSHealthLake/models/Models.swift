// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access is denied. Your account is not authorized to perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    public enum CmkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aoCmk
        case cmCmk
        case sdkUnknown(Swift.String)

        public static var allCases: [CmkType] {
            return [
                .aoCmk,
                .cmCmk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aoCmk: return "AWS_OWNED_KMS_KEY"
            case .cmCmk: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CmkType(rawValue: rawValue) ?? CmkType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Data Store is in a transition state and the user requested action can not be performed.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateFHIRDatastoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFHIRDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFHIRDatastoreOutputError>
}

extension CreateFHIRDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFHIRDatastoreInput(clientToken: \(Swift.String(describing: clientToken)), datastoreName: \(Swift.String(describing: datastoreName)), datastoreTypeVersion: \(Swift.String(describing: datastoreTypeVersion)), preloadDataConfig: \(Swift.String(describing: preloadDataConfig)), sseConfiguration: \(Swift.String(describing: sseConfiguration)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateFHIRDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
        case sseConfiguration = "SseConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreTypeVersion = datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let preloadDataConfig = preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
        if let sseConfiguration = sseConfiguration {
            try encodeContainer.encode(sseConfiguration, forKey: .sseConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateFHIRDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFHIRDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFHIRDatastoreOutputError>
}

public struct CreateFHIRDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFHIRDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFHIRDatastoreOutputError>
}

public struct CreateFHIRDatastoreInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFHIRDatastoreInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateFHIRDatastoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateFHIRDatastoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateFHIRDatastoreOutputError>
}

public struct CreateFHIRDatastoreInput: Swift.Equatable {
    /// Optional user provided token used for ensuring idempotency.
    public var clientToken: Swift.String?
    /// The user generated name for the Data Store.
    public var datastoreName: Swift.String?
    /// The FHIR version of the Data Store. The only supported version is R4.
    /// This member is required.
    public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    /// Optional parameter to preload data upon creation of the Data Store. Currently, the only
    ///          supported preloaded data is synthetic data generated from Synthea.
    public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
    ///
    ///             The server-side encryption key configuration for a customer provided encryption key specified for creating a Data Store.
    ///
    public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?
    ///
    ///             Resource tags that are applied to a Data Store when it is created.
    ///
    public var tags: [HealthLakeClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        datastoreName: Swift.String? = nil,
        datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
        preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
        sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.datastoreName = datastoreName
        self.datastoreTypeVersion = datastoreTypeVersion
        self.preloadDataConfig = preloadDataConfig
        self.sseConfiguration = sseConfiguration
        self.tags = tags
    }
}

struct CreateFHIRDatastoreInputBody: Swift.Equatable {
    public let datastoreName: Swift.String?
    public let datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
    public let sseConfiguration: HealthLakeClientTypes.SseConfiguration?
    public let preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
    public let clientToken: Swift.String?
    public let tags: [HealthLakeClientTypes.Tag]?
}

extension CreateFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
        case sseConfiguration = "SseConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let sseConfigurationDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.SseConfiguration.self, forKey: .sseConfiguration)
        sseConfiguration = sseConfigurationDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[HealthLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [HealthLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFHIRDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFHIRDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFHIRDatastoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFHIRDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFHIRDatastoreOutputResponse(datastoreArn: \(Swift.String(describing: datastoreArn)), datastoreEndpoint: \(Swift.String(describing: datastoreEndpoint)), datastoreId: \(Swift.String(describing: datastoreId)), datastoreStatus: \(Swift.String(describing: datastoreStatus)))"}
}

extension CreateFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct CreateFHIRDatastoreOutputResponse: Swift.Equatable {
    /// The datastore ARN is generated during the creation of the Data Store and can be found in
    ///          the output from the initial Data Store creation call.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint for the created Data Store. For preview, only US-east-1 endpoints are
    ///          supported.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The AWS-generated Data Store id. This id is in the output from the initial Data Store
    ///          creation call.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The status of the FHIR Data Store. Possible statuses are ‘CREATING’, ‘ACTIVE’, ‘DELETING’,
    ///          ‘DELETED’.
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init (
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct CreateFHIRDatastoreOutputResponseBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let datastoreArn: Swift.String?
    public let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
    public let datastoreEndpoint: Swift.String?
}

extension CreateFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

extension HealthLakeClientTypes.DatastoreFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter = "CreatedAfter"
        case createdBefore = "CreatedBefore"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = createdAfter {
            try encodeContainer.encode(createdAfter.timeIntervalSince1970, forKey: .createdAfter)
        }
        if let createdBefore = createdBefore {
            try encodeContainer.encode(createdBefore.timeIntervalSince1970, forKey: .createdBefore)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
        let createdAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
    }
}

extension HealthLakeClientTypes.DatastoreFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatastoreFilter(createdAfter: \(Swift.String(describing: createdAfter)), createdBefore: \(Swift.String(describing: createdBefore)), datastoreName: \(Swift.String(describing: datastoreName)), datastoreStatus: \(Swift.String(describing: datastoreStatus)))"}
}

extension HealthLakeClientTypes {
    /// The filters applied to Data Store query.
    public struct DatastoreFilter: Swift.Equatable {
        /// A filter that allows the user to set cutoff dates for records. All Data Stores created
        ///          after the specified date will be included in the results.
        public var createdAfter: ClientRuntime.Date?
        /// A filter that allows the user to set cutoff dates for records. All Data Stores created
        ///          before the specified date will be included in the results.
        public var createdBefore: ClientRuntime.Date?
        /// Allows the user to filter Data Store results by name.
        public var datastoreName: Swift.String?
        /// Allows the user to filter Data Store results by status.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
        }
    }

}

extension HealthLakeClientTypes.DatastoreProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
        case sseConfiguration = "SseConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let datastoreArn = datastoreArn {
            try encodeContainer.encode(datastoreArn, forKey: .datastoreArn)
        }
        if let datastoreEndpoint = datastoreEndpoint {
            try encodeContainer.encode(datastoreEndpoint, forKey: .datastoreEndpoint)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
        if let datastoreTypeVersion = datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let preloadDataConfig = preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
        if let sseConfiguration = sseConfiguration {
            try encodeContainer.encode(sseConfiguration, forKey: .sseConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
        let sseConfigurationDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.SseConfiguration.self, forKey: .sseConfiguration)
        sseConfiguration = sseConfigurationDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
    }
}

extension HealthLakeClientTypes.DatastoreProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatastoreProperties(createdAt: \(Swift.String(describing: createdAt)), datastoreArn: \(Swift.String(describing: datastoreArn)), datastoreEndpoint: \(Swift.String(describing: datastoreEndpoint)), datastoreId: \(Swift.String(describing: datastoreId)), datastoreName: \(Swift.String(describing: datastoreName)), datastoreStatus: \(Swift.String(describing: datastoreStatus)), datastoreTypeVersion: \(Swift.String(describing: datastoreTypeVersion)), preloadDataConfig: \(Swift.String(describing: preloadDataConfig)), sseConfiguration: \(Swift.String(describing: sseConfiguration)))"}
}

extension HealthLakeClientTypes {
    /// Displays the properties of the Data Store, including the ID, Arn, name, and the status of the Data Store.
    public struct DatastoreProperties: Swift.Equatable {
        /// The time that a Data Store was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name used in the creation of the Data Store.
        /// This member is required.
        public var datastoreArn: Swift.String?
        /// The AWS endpoint for the Data Store. Each Data Store will have it's own endpoint with Data Store ID in the endpoint URL.
        /// This member is required.
        public var datastoreEndpoint: Swift.String?
        /// The AWS-generated ID number for the Data Store.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The user-generated name for the Data Store.
        public var datastoreName: Swift.String?
        /// The status of the Data Store. Possible statuses are 'CREATING', 'ACTIVE', 'DELETING', or 'DELETED'.
        /// This member is required.
        public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
        /// The FHIR version. Only R4 version data is supported.
        /// This member is required.
        public var datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion?
        /// The preloaded data configuration for the Data Store. Only data preloaded from Synthea is supported.
        public var preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig?
        ///
        ///             The server-side encryption key configuration for a customer provided encryption key (CMK).
        ///
        public var sseConfiguration: HealthLakeClientTypes.SseConfiguration?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            datastoreArn: Swift.String? = nil,
            datastoreEndpoint: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            datastoreName: Swift.String? = nil,
            datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil,
            datastoreTypeVersion: HealthLakeClientTypes.FHIRVersion? = nil,
            preloadDataConfig: HealthLakeClientTypes.PreloadDataConfig? = nil,
            sseConfiguration: HealthLakeClientTypes.SseConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.datastoreArn = datastoreArn
            self.datastoreEndpoint = datastoreEndpoint
            self.datastoreId = datastoreId
            self.datastoreName = datastoreName
            self.datastoreStatus = datastoreStatus
            self.datastoreTypeVersion = datastoreTypeVersion
            self.preloadDataConfig = preloadDataConfig
            self.sseConfiguration = sseConfiguration
        }
    }

}

extension HealthLakeClientTypes {
    public enum DatastoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DatastoreStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatastoreStatus(rawValue: rawValue) ?? DatastoreStatus.sdkUnknown(rawValue)
        }
    }
}

public struct DeleteFHIRDatastoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFHIRDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFHIRDatastoreOutputError>
}

extension DeleteFHIRDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFHIRDatastoreInput(datastoreId: \(Swift.String(describing: datastoreId)))"}
}

extension DeleteFHIRDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

public struct DeleteFHIRDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFHIRDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFHIRDatastoreOutputError>
}

public struct DeleteFHIRDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFHIRDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFHIRDatastoreOutputError>
}

public struct DeleteFHIRDatastoreInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteFHIRDatastoreInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteFHIRDatastoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteFHIRDatastoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteFHIRDatastoreOutputError>
}

public struct DeleteFHIRDatastoreInput: Swift.Equatable {
    ///  The AWS-generated ID for the Data Store to be deleted.
    public var datastoreId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DeleteFHIRDatastoreInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
}

extension DeleteFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension DeleteFHIRDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFHIRDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFHIRDatastoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFHIRDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFHIRDatastoreOutputResponse(datastoreArn: \(Swift.String(describing: datastoreArn)), datastoreEndpoint: \(Swift.String(describing: datastoreEndpoint)), datastoreId: \(Swift.String(describing: datastoreId)), datastoreStatus: \(Swift.String(describing: datastoreStatus)))"}
}

extension DeleteFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct DeleteFHIRDatastoreOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that gives Amazon HealthLake access permission.
    /// This member is required.
    public var datastoreArn: Swift.String?
    /// The AWS endpoint for the Data Store the user has requested to be deleted.
    /// This member is required.
    public var datastoreEndpoint: Swift.String?
    /// The AWS-generated ID for the Data Store to be deleted.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The status of the Data Store that the user has requested to be deleted.
    ///
    /// This member is required.
    public var datastoreStatus: HealthLakeClientTypes.DatastoreStatus?

    public init (
        datastoreArn: Swift.String? = nil,
        datastoreEndpoint: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        datastoreStatus: HealthLakeClientTypes.DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct DeleteFHIRDatastoreOutputResponseBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let datastoreArn: Swift.String?
    public let datastoreStatus: HealthLakeClientTypes.DatastoreStatus?
    public let datastoreEndpoint: Swift.String?
}

extension DeleteFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

public struct DescribeFHIRDatastoreInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRDatastoreOutputError>
}

extension DescribeFHIRDatastoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRDatastoreInput(datastoreId: \(Swift.String(describing: datastoreId)))"}
}

extension DescribeFHIRDatastoreInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

public struct DescribeFHIRDatastoreInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRDatastoreOutputError>
}

public struct DescribeFHIRDatastoreInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRDatastoreInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRDatastoreOutputError>
}

public struct DescribeFHIRDatastoreInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRDatastoreInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeFHIRDatastoreInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFHIRDatastoreInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRDatastoreOutputError>
}

public struct DescribeFHIRDatastoreInput: Swift.Equatable {
    /// The AWS-generated Data Store id. This is part of the ‘CreateFHIRDatastore’ output.
    public var datastoreId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DescribeFHIRDatastoreInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
}

extension DescribeFHIRDatastoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension DescribeFHIRDatastoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRDatastoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFHIRDatastoreOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRDatastoreOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRDatastoreOutputResponse(datastoreProperties: \(Swift.String(describing: datastoreProperties)))"}
}

extension DescribeFHIRDatastoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreProperties = output.datastoreProperties
        } else {
            self.datastoreProperties = nil
        }
    }
}

public struct DescribeFHIRDatastoreOutputResponse: Swift.Equatable {
    /// All properties associated with a Data Store, including the Data Store ID, Data Store ARN,
    ///          Data Store name, Data Store status, created at, Data Store type version, and Data Store
    ///          endpoint.
    /// This member is required.
    public var datastoreProperties: HealthLakeClientTypes.DatastoreProperties?

    public init (
        datastoreProperties: HealthLakeClientTypes.DatastoreProperties? = nil
    )
    {
        self.datastoreProperties = datastoreProperties
    }
}

struct DescribeFHIRDatastoreOutputResponseBody: Swift.Equatable {
    public let datastoreProperties: HealthLakeClientTypes.DatastoreProperties?
}

extension DescribeFHIRDatastoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreProperties = "DatastoreProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreProperties.self, forKey: .datastoreProperties)
        datastoreProperties = datastorePropertiesDecoded
    }
}

public struct DescribeFHIRExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRExportJobOutputError>
}

extension DescribeFHIRExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRExportJobInput(datastoreId: \(Swift.String(describing: datastoreId)), jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeFHIRExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeFHIRExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRExportJobOutputError>
}

public struct DescribeFHIRExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRExportJobOutputError>
}

public struct DescribeFHIRExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeFHIRExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFHIRExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRExportJobOutputError>
}

public struct DescribeFHIRExportJobInput: Swift.Equatable {
    /// The AWS generated ID for the Data Store from which files are being exported from for an export job.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The AWS generated ID for an export job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRExportJobInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let jobId: Swift.String?
}

extension DescribeFHIRExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFHIRExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFHIRExportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRExportJobOutputResponse(exportJobProperties: \(Swift.String(describing: exportJobProperties)))"}
}

extension DescribeFHIRExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportJobProperties = output.exportJobProperties
        } else {
            self.exportJobProperties = nil
        }
    }
}

public struct DescribeFHIRExportJobOutputResponse: Swift.Equatable {
    /// Displays the properties of the export job, including the ID, Arn, Name, and the status of the job.
    /// This member is required.
    public var exportJobProperties: HealthLakeClientTypes.ExportJobProperties?

    public init (
        exportJobProperties: HealthLakeClientTypes.ExportJobProperties? = nil
    )
    {
        self.exportJobProperties = exportJobProperties
    }
}

struct DescribeFHIRExportJobOutputResponseBody: Swift.Equatable {
    public let exportJobProperties: HealthLakeClientTypes.ExportJobProperties?
}

extension DescribeFHIRExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportJobProperties = "ExportJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobPropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.ExportJobProperties.self, forKey: .exportJobProperties)
        exportJobProperties = exportJobPropertiesDecoded
    }
}

public struct DescribeFHIRImportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRImportJobOutputError>
}

extension DescribeFHIRImportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRImportJobInput(datastoreId: \(Swift.String(describing: datastoreId)), jobId: \(Swift.String(describing: jobId)))"}
}

extension DescribeFHIRImportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeFHIRImportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRImportJobOutputError>
}

public struct DescribeFHIRImportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRImportJobOutputError>
}

public struct DescribeFHIRImportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeFHIRImportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeFHIRImportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeFHIRImportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeFHIRImportJobOutputError>
}

public struct DescribeFHIRImportJobInput: Swift.Equatable {
    /// The AWS-generated ID of the Data Store.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The AWS-generated job ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRImportJobInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let jobId: Swift.String?
}

extension DescribeFHIRImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFHIRImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFHIRImportJobOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRImportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFHIRImportJobOutputResponse(importJobProperties: \(Swift.String(describing: importJobProperties)))"}
}

extension DescribeFHIRImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importJobProperties = output.importJobProperties
        } else {
            self.importJobProperties = nil
        }
    }
}

public struct DescribeFHIRImportJobOutputResponse: Swift.Equatable {
    /// The properties of the Import job request, including the ID, ARN, name, and the status of the job.
    /// This member is required.
    public var importJobProperties: HealthLakeClientTypes.ImportJobProperties?

    public init (
        importJobProperties: HealthLakeClientTypes.ImportJobProperties? = nil
    )
    {
        self.importJobProperties = importJobProperties
    }
}

struct DescribeFHIRImportJobOutputResponseBody: Swift.Equatable {
    public let importJobProperties: HealthLakeClientTypes.ImportJobProperties?
}

extension DescribeFHIRImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobProperties = "ImportJobProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobPropertiesDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.ImportJobProperties.self, forKey: .importJobProperties)
        importJobProperties = importJobPropertiesDecoded
    }
}

extension HealthLakeClientTypes.ExportJobProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes.ExportJobProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportJobProperties(dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), datastoreId: \(Swift.String(describing: datastoreId)), endTime: \(Swift.String(describing: endTime)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobStatus: \(Swift.String(describing: jobStatus)), message: \(Swift.String(describing: message)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), submitTime: \(Swift.String(describing: submitTime)))"}
}

extension HealthLakeClientTypes {
    /// The properties of a FHIR export job, including the ID, ARN, name, and the status of the job.
    public struct ExportJobProperties: Swift.Equatable {
        /// The Amazon Resource Name used during the initiation of the job.
        public var dataAccessRoleArn: Swift.String?
        /// The AWS generated ID for the Data Store from which files are being exported for an export job.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time an export job completed.
        public var endTime: ClientRuntime.Date?
        /// The AWS generated ID for an export job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user generated name for an export job.
        public var jobName: Swift.String?
        /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that may have occurred during the export job.
        public var message: Swift.String?
        /// The output data configuration that was supplied when the export job was created.
        /// This member is required.
        public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// The time an export job was initiated.
        /// This member is required.
        public var submitTime: ClientRuntime.Date?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.message = message
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }
    }

}

extension HealthLakeClientTypes {
    public enum FHIRVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case r4
        case sdkUnknown(Swift.String)

        public static var allCases: [FHIRVersion] {
            return [
                .r4,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .r4: return "R4"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FHIRVersion(rawValue: rawValue) ?? FHIRVersion.sdkUnknown(rawValue)
        }
    }
}

extension HealthLakeClientTypes.ImportJobProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobOutputDataConfig = "JobOutputDataConfig"
        case jobStatus = "JobStatus"
        case message = "Message"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutputDataConfig = jobOutputDataConfig {
            try encodeContainer.encode(jobOutputDataConfig, forKey: .jobOutputDataConfig)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let jobOutputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .jobOutputDataConfig)
        jobOutputDataConfig = jobOutputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes.ImportJobProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportJobProperties(dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), datastoreId: \(Swift.String(describing: datastoreId)), endTime: \(Swift.String(describing: endTime)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobName: \(Swift.String(describing: jobName)), jobOutputDataConfig: \(Swift.String(describing: jobOutputDataConfig)), jobStatus: \(Swift.String(describing: jobStatus)), message: \(Swift.String(describing: message)), submitTime: \(Swift.String(describing: submitTime)))"}
}

extension HealthLakeClientTypes {
    /// Displays the properties of the import job, including the ID, Arn, Name, and the status of the Data Store.
    public struct ImportJobProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that gives Amazon HealthLake access to your input data.
        public var dataAccessRoleArn: Swift.String?
        /// The datastore id used when the Import job was created.
        /// This member is required.
        public var datastoreId: Swift.String?
        /// The time that the Import job was completed.
        public var endTime: ClientRuntime.Date?
        /// The input data configuration that was supplied when the Import job was created.
        /// This member is required.
        public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
        /// The AWS-generated id number for the Import job.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user-generated name for an Import job.
        public var jobName: Swift.String?
        /// The output data configuration that was supplied when the export job was created.
        public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?
        /// The job status for an Import job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, FAILED.
        /// This member is required.
        public var jobStatus: HealthLakeClientTypes.JobStatus?
        /// An explanation of any errors that may have occurred during the FHIR import job.
        public var message: Swift.String?
        /// The time that the Import job was submitted for processing.
        /// This member is required.
        public var submitTime: ClientRuntime.Date?

        public init (
            dataAccessRoleArn: Swift.String? = nil,
            datastoreId: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil,
            jobStatus: HealthLakeClientTypes.JobStatus? = nil,
            message: Swift.String? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.datastoreId = datastoreId
            self.endTime = endTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobOutputDataConfig = jobOutputDataConfig
            self.jobStatus = jobStatus
            self.message = message
            self.submitTime = submitTime
        }
    }

}

extension HealthLakeClientTypes.InputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3uri = "S3Uri"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3uri(s3uri):
                try container.encode(s3uri, forKey: .s3uri)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3uriDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .s3uri)
        if let s3uri = s3uriDecoded {
            self = .s3uri(s3uri)
            return
        }
        self = .sdkUnknown("")
    }
}

extension HealthLakeClientTypes {
    ///  The input properties for an import job.
    public enum InputDataConfig: Swift.Equatable, Swift.Hashable {
        /// The S3Uri is the user specified S3 location of the FHIR data to be imported into Amazon HealthLake.
        case s3uri(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unknown error occurs in the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension HealthLakeClientTypes.KmsEncryptionConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cmkType = "CmkType"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmkType = cmkType {
            try encodeContainer.encode(cmkType.rawValue, forKey: .cmkType)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cmkTypeDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.CmkType.self, forKey: .cmkType)
        cmkType = cmkTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension HealthLakeClientTypes.KmsEncryptionConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KmsEncryptionConfig(cmkType: \(Swift.String(describing: cmkType)), kmsKeyId: \(Swift.String(describing: kmsKeyId)))"}
}

extension HealthLakeClientTypes {
    ///
    ///             The customer-managed-key(CMK) used when creating a Data Store. If a customer owned key is not specified, an AWS owned key will be used for encryption.
    ///
    public struct KmsEncryptionConfig: Swift.Equatable {
        ///
        ///             The type of customer-managed-key(CMK) used for encyrption. The two types of supported CMKs are customer owned CMKs and AWS owned CMKs.
        ///
        /// This member is required.
        public var cmkType: HealthLakeClientTypes.CmkType?
        ///
        ///             The KMS encryption key id/alias used to encrypt the Data Store contents at rest.
        ///
        public var kmsKeyId: Swift.String?

        public init (
            cmkType: HealthLakeClientTypes.CmkType? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.cmkType = cmkType
            self.kmsKeyId = kmsKeyId
        }
    }

}

public struct ListFHIRDatastoresInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRDatastoresInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRDatastoresOutputError>
}

extension ListFHIRDatastoresInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFHIRDatastoresInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFHIRDatastoresInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFHIRDatastoresInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRDatastoresInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRDatastoresOutputError>
}

public struct ListFHIRDatastoresInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRDatastoresInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRDatastoresInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRDatastoresOutputError>
}

public struct ListFHIRDatastoresInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRDatastoresInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFHIRDatastoresInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFHIRDatastoresInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRDatastoresOutputError>
}

public struct ListFHIRDatastoresInput: Swift.Equatable {
    /// Lists all filters associated with a FHIR Data Store request.
    public var filter: HealthLakeClientTypes.DatastoreFilter?
    /// The maximum number of Data Stores returned in a single page of a
    ///          ListFHIRDatastoresRequest call.
    public var maxResults: Swift.Int?
    /// Fetches the next page of Data Stores when results are paginated.
    public var nextToken: Swift.String?

    public init (
        filter: HealthLakeClientTypes.DatastoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresInputBody: Swift.Equatable {
    public let filter: HealthLakeClientTypes.DatastoreFilter?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListFHIRDatastoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.DatastoreFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFHIRDatastoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFHIRDatastoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFHIRDatastoresOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFHIRDatastoresOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFHIRDatastoresOutputResponse(datastorePropertiesList: \(Swift.String(describing: datastorePropertiesList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFHIRDatastoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFHIRDatastoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastorePropertiesList = output.datastorePropertiesList
            self.nextToken = output.nextToken
        } else {
            self.datastorePropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRDatastoresOutputResponse: Swift.Equatable {
    /// All properties associated with the listed Data Stores.
    /// This member is required.
    public var datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    /// Pagination token that can be used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datastorePropertiesList = datastorePropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresOutputResponseBody: Swift.Equatable {
    public let datastorePropertiesList: [HealthLakeClientTypes.DatastoreProperties]?
    public let nextToken: Swift.String?
}

extension ListFHIRDatastoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastorePropertiesList = "DatastorePropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.DatastoreProperties?].self, forKey: .datastorePropertiesList)
        var datastorePropertiesListDecoded0:[HealthLakeClientTypes.DatastoreProperties]? = nil
        if let datastorePropertiesListContainer = datastorePropertiesListContainer {
            datastorePropertiesListDecoded0 = [HealthLakeClientTypes.DatastoreProperties]()
            for structure0 in datastorePropertiesListContainer {
                if let structure0 = structure0 {
                    datastorePropertiesListDecoded0?.append(structure0)
                }
            }
        }
        datastorePropertiesList = datastorePropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFHIRExportJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRExportJobsOutputError>
}

extension ListFHIRExportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFHIRExportJobsInput(datastoreId: \(Swift.String(describing: datastoreId)), jobName: \(Swift.String(describing: jobName)), jobStatus: \(Swift.String(describing: jobStatus)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), submittedAfter: \(Swift.String(describing: submittedAfter)), submittedBefore: \(Swift.String(describing: submittedBefore)))"}
}

extension ListFHIRExportJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let submittedAfter = submittedAfter {
            try encodeContainer.encode(submittedAfter.timeIntervalSince1970, forKey: .submittedAfter)
        }
        if let submittedBefore = submittedBefore {
            try encodeContainer.encode(submittedBefore.timeIntervalSince1970, forKey: .submittedBefore)
        }
    }
}

public struct ListFHIRExportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRExportJobsOutputError>
}

public struct ListFHIRExportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRExportJobsOutputError>
}

public struct ListFHIRExportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRExportJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFHIRExportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFHIRExportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRExportJobsOutputError>
}

public struct ListFHIRExportJobsInput: Swift.Equatable {
    ///
    ///             This parameter limits the response to the export job with the specified Data Store ID.
    ///
    /// This member is required.
    public var datastoreId: Swift.String?
    ///
    ///             This parameter limits the response to the export job with the specified job name.
    ///
    public var jobName: Swift.String?
    ///
    ///             This parameter limits the response to the export jobs with the specified job status.
    ///
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    ///
    ///             This parameter limits the number of results returned for a ListFHIRExportJobs to a maximum quantity specified by the user.
    ///
    public var maxResults: Swift.Int?
    ///
    ///             A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
    ///
    public var nextToken: Swift.String?
    ///
    ///             This parameter limits the response to FHIR export jobs submitted after a user specified date.
    ///
    public var submittedAfter: ClientRuntime.Date?
    ///
    ///             This parameter limits the response to FHIR export jobs submitted before a user specified date.
    ///
    public var submittedBefore: ClientRuntime.Date?

    public init (
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: ClientRuntime.Date? = nil,
        submittedBefore: ClientRuntime.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

struct ListFHIRExportJobsInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let jobName: Swift.String?
    public let jobStatus: HealthLakeClientTypes.JobStatus?
    public let submittedBefore: ClientRuntime.Date?
    public let submittedAfter: ClientRuntime.Date?
}

extension ListFHIRExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submittedBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submittedBefore)
        submittedBefore = submittedBeforeDecoded
        let submittedAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submittedAfter)
        submittedAfter = submittedAfterDecoded
    }
}

extension ListFHIRExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFHIRExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFHIRExportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFHIRExportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFHIRExportJobsOutputResponse(exportJobPropertiesList: \(Swift.String(describing: exportJobPropertiesList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFHIRExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFHIRExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportJobPropertiesList = output.exportJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.exportJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRExportJobsOutputResponse: Swift.Equatable {
    ///
    ///             The properties of listed FHIR export jobs, including the ID, ARN, name, and the status of the job.
    ///
    /// This member is required.
    public var exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]?
    ///
    ///             A pagination token used to identify the next page of results to return for a ListFHIRExportJobs query.
    ///
    public var nextToken: Swift.String?

    public init (
        exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportJobPropertiesList = exportJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRExportJobsOutputResponseBody: Swift.Equatable {
    public let exportJobPropertiesList: [HealthLakeClientTypes.ExportJobProperties]?
    public let nextToken: Swift.String?
}

extension ListFHIRExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportJobPropertiesList = "ExportJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobPropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.ExportJobProperties?].self, forKey: .exportJobPropertiesList)
        var exportJobPropertiesListDecoded0:[HealthLakeClientTypes.ExportJobProperties]? = nil
        if let exportJobPropertiesListContainer = exportJobPropertiesListContainer {
            exportJobPropertiesListDecoded0 = [HealthLakeClientTypes.ExportJobProperties]()
            for structure0 in exportJobPropertiesListContainer {
                if let structure0 = structure0 {
                    exportJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        exportJobPropertiesList = exportJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFHIRImportJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRImportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRImportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRImportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRImportJobsOutputError>
}

extension ListFHIRImportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFHIRImportJobsInput(datastoreId: \(Swift.String(describing: datastoreId)), jobName: \(Swift.String(describing: jobName)), jobStatus: \(Swift.String(describing: jobStatus)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), submittedAfter: \(Swift.String(describing: submittedAfter)), submittedBefore: \(Swift.String(describing: submittedBefore)))"}
}

extension ListFHIRImportJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let submittedAfter = submittedAfter {
            try encodeContainer.encode(submittedAfter.timeIntervalSince1970, forKey: .submittedAfter)
        }
        if let submittedBefore = submittedBefore {
            try encodeContainer.encode(submittedBefore.timeIntervalSince1970, forKey: .submittedBefore)
        }
    }
}

public struct ListFHIRImportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRImportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRImportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRImportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRImportJobsOutputError>
}

public struct ListFHIRImportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRImportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFHIRImportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFHIRImportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRImportJobsOutputError>
}

public struct ListFHIRImportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFHIRImportJobsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListFHIRImportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFHIRImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListFHIRImportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListFHIRImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFHIRImportJobsOutputError>
}

public struct ListFHIRImportJobsInput: Swift.Equatable {
    ///
    ///             This parameter limits the response to the import job with the specified Data Store ID.
    ///
    /// This member is required.
    public var datastoreId: Swift.String?
    ///
    ///             This parameter limits the response to the import job with the specified job name.
    ///
    public var jobName: Swift.String?
    ///
    ///             This parameter limits the response to the import job with the specified job status.
    ///
    public var jobStatus: HealthLakeClientTypes.JobStatus?
    ///
    ///             This parameter limits the number of results returned for a ListFHIRImportJobs to a maximum quantity specified by the user.
    ///
    public var maxResults: Swift.Int?
    ///
    ///             A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
    ///
    public var nextToken: Swift.String?
    ///
    ///             This parameter limits the response to FHIR import jobs submitted after a user specified date.
    ///
    public var submittedAfter: ClientRuntime.Date?
    ///
    ///             This parameter limits the response to FHIR import jobs submitted before a user specified date.
    ///
    public var submittedBefore: ClientRuntime.Date?

    public init (
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        submittedAfter: ClientRuntime.Date? = nil,
        submittedBefore: ClientRuntime.Date? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.submittedAfter = submittedAfter
        self.submittedBefore = submittedBefore
    }
}

struct ListFHIRImportJobsInputBody: Swift.Equatable {
    public let datastoreId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let jobName: Swift.String?
    public let jobStatus: HealthLakeClientTypes.JobStatus?
    public let submittedBefore: ClientRuntime.Date?
    public let submittedAfter: ClientRuntime.Date?
}

extension ListFHIRImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case submittedAfter = "SubmittedAfter"
        case submittedBefore = "SubmittedBefore"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submittedBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submittedBefore)
        submittedBefore = submittedBeforeDecoded
        let submittedAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .submittedAfter)
        submittedAfter = submittedAfterDecoded
    }
}

extension ListFHIRImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFHIRImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFHIRImportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFHIRImportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFHIRImportJobsOutputResponse(importJobPropertiesList: \(Swift.String(describing: importJobPropertiesList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFHIRImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFHIRImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importJobPropertiesList = output.importJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.importJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRImportJobsOutputResponse: Swift.Equatable {
    ///
    ///             The properties of a listed FHIR import jobs, including the ID, ARN, name, and the status of the job.
    ///
    /// This member is required.
    public var importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]?
    ///
    ///             A pagination token used to identify the next page of results to return for a ListFHIRImportJobs query.
    ///
    public var nextToken: Swift.String?

    public init (
        importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobPropertiesList = importJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRImportJobsOutputResponseBody: Swift.Equatable {
    public let importJobPropertiesList: [HealthLakeClientTypes.ImportJobProperties]?
    public let nextToken: Swift.String?
}

extension ListFHIRImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobPropertiesList = "ImportJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobPropertiesListContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.ImportJobProperties?].self, forKey: .importJobPropertiesList)
        var importJobPropertiesListDecoded0:[HealthLakeClientTypes.ImportJobProperties]? = nil
        if let importJobPropertiesListContainer = importJobPropertiesListContainer {
            importJobPropertiesListDecoded0 = [HealthLakeClientTypes.ImportJobProperties]()
            for structure0 in importJobPropertiesListContainer {
                if let structure0 = structure0 {
                    importJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        importJobPropertiesList = importJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    ///
    ///             The Amazon Resource Name(ARN) of the Data Store for which tags are being added.
    ///
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    ///
    ///             Returns a list of tags associated with a Data Store.
    ///
    public var tags: [HealthLakeClientTypes.Tag]?

    public init (
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [HealthLakeClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[HealthLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [HealthLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension HealthLakeClientTypes.OutputDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3configuration = "S3Configuration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3configuration(s3configuration):
                try container.encode(s3configuration, forKey: .s3configuration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3configurationDecoded = try values.decodeIfPresent(HealthLakeClientTypes.S3Configuration.self, forKey: .s3configuration)
        if let s3configuration = s3configurationDecoded {
            self = .s3configuration(s3configuration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension HealthLakeClientTypes {
    /// The output data configuration that was supplied when the export job was created.
    public enum OutputDataConfig: Swift.Equatable {
        ///
        ///             The output data configuration that was supplied when the export job was created.
        ///
        case s3configuration(HealthLakeClientTypes.S3Configuration)
        case sdkUnknown(Swift.String)
    }

}

extension HealthLakeClientTypes.PreloadDataConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preloadDataType = "PreloadDataType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preloadDataType = preloadDataType {
            try encodeContainer.encode(preloadDataType.rawValue, forKey: .preloadDataType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preloadDataTypeDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.PreloadDataType.self, forKey: .preloadDataType)
        preloadDataType = preloadDataTypeDecoded
    }
}

extension HealthLakeClientTypes.PreloadDataConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreloadDataConfig(preloadDataType: \(Swift.String(describing: preloadDataType)))"}
}

extension HealthLakeClientTypes {
    ///  The input properties for the preloaded Data Store. Only data preloaded from Synthea is supported.
    public struct PreloadDataConfig: Swift.Equatable {
        /// The type of preloaded data. Only Synthea preloaded data is supported.
        /// This member is required.
        public var preloadDataType: HealthLakeClientTypes.PreloadDataType?

        public init (
            preloadDataType: HealthLakeClientTypes.PreloadDataType? = nil
        )
        {
            self.preloadDataType = preloadDataType
        }
    }

}

extension HealthLakeClientTypes {
    public enum PreloadDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case synthea
        case sdkUnknown(Swift.String)

        public static var allCases: [PreloadDataType] {
            return [
                .synthea,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .synthea: return "SYNTHEA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PreloadDataType(rawValue: rawValue) ?? PreloadDataType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///  The requested Data Store was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthLakeClientTypes.S3Configuration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension HealthLakeClientTypes.S3Configuration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Configuration(kmsKeyId: \(Swift.String(describing: kmsKeyId)), s3Uri: \(Swift.String(describing: s3Uri)))"}
}

extension HealthLakeClientTypes {
    ///
    ///             The configuration of the S3 bucket for either an import or export job. This includes assigning permissions for access.
    ///
    public struct S3Configuration: Swift.Equatable {
        ///
        ///             The KMS key ID used to access the S3 bucket.
        ///
        /// This member is required.
        public var kmsKeyId: Swift.String?
        ///
        ///             The S3Uri is the user specified S3 location of the FHIR data to be imported into Amazon HealthLake.
        ///
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension HealthLakeClientTypes.SseConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsEncryptionConfig = "KmsEncryptionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsEncryptionConfig = kmsEncryptionConfig {
            try encodeContainer.encode(kmsEncryptionConfig, forKey: .kmsEncryptionConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsEncryptionConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.KmsEncryptionConfig.self, forKey: .kmsEncryptionConfig)
        kmsEncryptionConfig = kmsEncryptionConfigDecoded
    }
}

extension HealthLakeClientTypes.SseConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SseConfiguration(kmsEncryptionConfig: \(Swift.String(describing: kmsEncryptionConfig)))"}
}

extension HealthLakeClientTypes {
    ///
    ///             The server-side encryption key configuration for a customer provided encryption key.
    ///
    public struct SseConfiguration: Swift.Equatable {
        ///
        ///             The KMS encryption configuration used to provide details for data encryption.
        ///
        /// This member is required.
        public var kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig?

        public init (
            kmsEncryptionConfig: HealthLakeClientTypes.KmsEncryptionConfig? = nil
        )
        {
            self.kmsEncryptionConfig = kmsEncryptionConfig
        }
    }

}

public struct StartFHIRExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRExportJobOutputError>
}

extension StartFHIRExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFHIRExportJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), datastoreId: \(Swift.String(describing: datastoreId)), jobName: \(Swift.String(describing: jobName)), outputDataConfig: \(Swift.String(describing: outputDataConfig)))"}
}

extension StartFHIRExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartFHIRExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRExportJobOutputError>
}

public struct StartFHIRExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRExportJobOutputError>
}

public struct StartFHIRExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRExportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartFHIRExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartFHIRExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRExportJobOutputError>
}

public struct StartFHIRExportJobInput: Swift.Equatable {
    /// An optional user provided token used for ensuring idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name used during the initiation of the job.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The AWS generated ID for the Data Store from which files are being exported for an export job.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The user generated name for an export job.
    public var jobName: Swift.String?
    /// The output data configuration that was supplied when the export job was created.
    /// This member is required.
    public var outputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

struct StartFHIRExportJobInputBody: Swift.Equatable {
    public let jobName: Swift.String?
    public let outputDataConfig: HealthLakeClientTypes.OutputDataConfig?
    public let datastoreId: Swift.String?
    public let dataAccessRoleArn: Swift.String?
    public let clientToken: Swift.String?
}

extension StartFHIRExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartFHIRExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFHIRExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFHIRExportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFHIRExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFHIRExportJobOutputResponse(datastoreId: \(Swift.String(describing: datastoreId)), jobId: \(Swift.String(describing: jobId)), jobStatus: \(Swift.String(describing: jobStatus)))"}
}

extension StartFHIRExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRExportJobOutputResponse: Swift.Equatable {
    /// The AWS generated ID for the Data Store from which files are being exported for an export job.
    public var datastoreId: Swift.String?
    /// The AWS generated ID for an export job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRExportJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let jobStatus: HealthLakeClientTypes.JobStatus?
    public let datastoreId: Swift.String?
}

extension StartFHIRExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

public struct StartFHIRImportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRImportJobOutputError>
}

extension StartFHIRImportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFHIRImportJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), datastoreId: \(Swift.String(describing: datastoreId)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobName: \(Swift.String(describing: jobName)), jobOutputDataConfig: \(Swift.String(describing: jobOutputDataConfig)))"}
}

extension StartFHIRImportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case jobOutputDataConfig = "JobOutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobOutputDataConfig = jobOutputDataConfig {
            try encodeContainer.encode(jobOutputDataConfig, forKey: .jobOutputDataConfig)
        }
    }
}

public struct StartFHIRImportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRImportJobOutputError>
}

public struct StartFHIRImportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartFHIRImportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRImportJobOutputError>
}

public struct StartFHIRImportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartFHIRImportJobInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartFHIRImportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartFHIRImportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartFHIRImportJobOutputError>
}

public struct StartFHIRImportJobInput: Swift.Equatable {
    /// Optional user provided token used for ensuring idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) that gives Amazon HealthLake access permission.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The AWS-generated Data Store ID.
    /// This member is required.
    public var datastoreId: Swift.String?
    /// The input properties of the FHIR Import job in the StartFHIRImport job request.
    /// This member is required.
    public var inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    /// The name of the FHIR Import job in the StartFHIRImport job request.
    public var jobName: Swift.String?
    /// The output data configuration that was supplied when the export job was created.
    /// This member is required.
    public var jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        datastoreId: Swift.String? = nil,
        inputDataConfig: HealthLakeClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.jobOutputDataConfig = jobOutputDataConfig
    }
}

struct StartFHIRImportJobInputBody: Swift.Equatable {
    public let jobName: Swift.String?
    public let inputDataConfig: HealthLakeClientTypes.InputDataConfig?
    public let jobOutputDataConfig: HealthLakeClientTypes.OutputDataConfig?
    public let datastoreId: Swift.String?
    public let dataAccessRoleArn: Swift.String?
    public let clientToken: Swift.String?
}

extension StartFHIRImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case jobOutputDataConfig = "JobOutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let jobOutputDataConfigDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.OutputDataConfig.self, forKey: .jobOutputDataConfig)
        jobOutputDataConfig = jobOutputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartFHIRImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFHIRImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFHIRImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFHIRImportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFHIRImportJobOutputResponse(datastoreId: \(Swift.String(describing: datastoreId)), jobId: \(Swift.String(describing: jobId)), jobStatus: \(Swift.String(describing: jobStatus)))"}
}

extension StartFHIRImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRImportJobOutputResponse: Swift.Equatable {
    /// The AWS-generated Data Store ID.
    public var datastoreId: Swift.String?
    /// The AWS-generated job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of an import job.
    /// This member is required.
    public var jobStatus: HealthLakeClientTypes.JobStatus?

    public init (
        datastoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobStatus: HealthLakeClientTypes.JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRImportJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let jobStatus: HealthLakeClientTypes.JobStatus?
    public let datastoreId: Swift.String?
}

extension StartFHIRImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HealthLakeClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension HealthLakeClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension HealthLakeClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension HealthLakeClientTypes {
    ///
    ///             A tag is a label consisting of a user-defined key and value. The form for tags is {"Key", "Value"}
    ///
    public struct Tag: Swift.Equatable {
        ///
        ///             The key portion of a tag. Tag keys are case sensitive.
        ///
        /// This member is required.
        public var key: Swift.String?
        ///
        ///             The value portion of tag. Tag values are case sensitive.
        ///
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    ///
    ///             The Amazon Resource Name(ARN)that gives Amazon HealthLake access to the Data Store which tags are being added to.
    ///
    /// This member is required.
    public var resourceARN: Swift.String?
    ///
    ///             The user specified key and value pair tags being added to a Data Store.
    ///
    /// This member is required.
    public var tags: [HealthLakeClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [HealthLakeClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [HealthLakeClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([HealthLakeClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[HealthLakeClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [HealthLakeClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user has exceeded their maximum number of allowed calls to the given API.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    ///
    ///             "The Amazon Resource Name(ARN) of the Data Store for which tags are being removed
    ///
    /// This member is required.
    public var resourceARN: Swift.String?
    ///
    ///             The keys for the tags to be removed from the Healthlake Data Store.
    ///
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user input parameter was invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
