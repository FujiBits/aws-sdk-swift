// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension Route53RecoveryClusterClient {
    /// Get the state for a routing control. A routing control is a simple on/off switch
    /// 				that you can use to route traffic to cells. When the state is On, traffic flows to a cell. When it's off, traffic does not flow.
    /// 			      Before you can create a routing control, you first must create a cluster to host the control.
    /// 				For more information, see
    /// 				<a href="https://docs.aws.amazon.com/recovery-cluster/latest/api/cluster.html">CreateCluster.
    /// 				Access one of the endpoints for the cluster to get or update the routing control state to
    /// 				redirect traffic.
    /// 			      For more information about working with routing controls, see
    /// 				<a href="https://docs.aws.amazon.com/r53recovery/latest/dg/routing-control.html">Routing control
    /// 				in the Route 53 Application Recovery Controller Developer Guide.
    func getRoutingControlState(input: GetRoutingControlStateInput) async throws -> GetRoutingControlStateOutputResponse
    {
        typealias getRoutingControlStateContinuation = CheckedContinuation<GetRoutingControlStateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getRoutingControlStateContinuation) in
            getRoutingControlState(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Set the state of the routing control to reroute traffic. You can set the value to be On or Off.
    /// 				When the state is On, traffic flows to a cell. When it's off, traffic does not flow.
    /// 			      For more information about working with routing controls, see
    /// 				<a href="https://docs.aws.amazon.com/r53recovery/latest/dg/routing-control.html">Routing control
    /// 				in the Route 53 Application Recovery Controller Developer Guide.
    func updateRoutingControlState(input: UpdateRoutingControlStateInput) async throws -> UpdateRoutingControlStateOutputResponse
    {
        typealias updateRoutingControlStateContinuation = CheckedContinuation<UpdateRoutingControlStateOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateRoutingControlStateContinuation) in
            updateRoutingControlState(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Set multiple routing control states. You can set the value for each state to be On or Off.
    /// 			When the state is On, traffic flows to a cell. When it's off, traffic does not flow.
    /// 			      For more information about working with routing controls, see
    /// 				<a href="https://docs.aws.amazon.com/r53recovery/latest/dg/routing-control.html">Routing control
    /// 				in the Route 53 Application Recovery Controller Developer Guide.
    func updateRoutingControlStates(input: UpdateRoutingControlStatesInput) async throws -> UpdateRoutingControlStatesOutputResponse
    {
        typealias updateRoutingControlStatesContinuation = CheckedContinuation<UpdateRoutingControlStatesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateRoutingControlStatesContinuation) in
            updateRoutingControlStates(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
