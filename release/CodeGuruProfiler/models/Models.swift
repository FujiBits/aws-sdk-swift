// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CodeGuruProfilerClientTypes {
    public enum ActionGroup: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Permission group type for Agent APIs - ConfigureAgent, PostAgentProfile
        case agentPermissions
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroup] {
            return [
                .agentPermissions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentPermissions: return "agentPermissions"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionGroup(rawValue: rawValue) ?? ActionGroup.sdkUnknown(rawValue)
        }
    }
}

public struct AddNotificationChannelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddNotificationChannelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddNotificationChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddNotificationChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddNotificationChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddNotificationChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddNotificationChannelsOutputError>
}

extension AddNotificationChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddNotificationChannelsInput(channels: \(Swift.String(describing: channels)), profilingGroupName: \(Swift.String(describing: profilingGroupName)))"}
}

extension AddNotificationChannelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channels0 in channels {
                try channelsContainer.encode(channels0)
            }
        }
    }
}

public struct AddNotificationChannelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddNotificationChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddNotificationChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddNotificationChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddNotificationChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddNotificationChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddNotificationChannelsOutputError>
}

public struct AddNotificationChannelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AddNotificationChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AddNotificationChannelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AddNotificationChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AddNotificationChannelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AddNotificationChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AddNotificationChannelsOutputError>
}

/// <p>The structure representing the AddNotificationChannelsRequest.</p>
public struct AddNotificationChannelsInput: Swift.Equatable {
    /// <p>One or 2 channels to report to when anomalies are detected.</p>
    public let channels: Swift.Set<CodeGuruProfilerClientTypes.Channel>?
    /// <p>The name of the profiling group that we are setting up notifications for.</p>
    public let profilingGroupName: Swift.String?

    public init (
        channels: Swift.Set<CodeGuruProfilerClientTypes.Channel>? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.channels = channels
        self.profilingGroupName = profilingGroupName
    }
}

struct AddNotificationChannelsInputBody: Swift.Equatable {
    public let channels: Swift.Set<CodeGuruProfilerClientTypes.Channel>?
}

extension AddNotificationChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent(Swift.Set<CodeGuruProfilerClientTypes.Channel>.self, forKey: .channels)
        var channelsDecoded0:Swift.Set<CodeGuruProfilerClientTypes.Channel>? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = Swift.Set<CodeGuruProfilerClientTypes.Channel>()
            for structure0 in channelsContainer {
                channelsDecoded0?.insert(structure0)
            }
        }
        channels = channelsDecoded0
    }
}

extension AddNotificationChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddNotificationChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddNotificationChannelsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddNotificationChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddNotificationChannelsOutputResponse(notificationConfiguration: \(Swift.String(describing: notificationConfiguration)))"}
}

extension AddNotificationChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddNotificationChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

/// <p>The structure representing the AddNotificationChannelsResponse.</p>
public struct AddNotificationChannelsOutputResponse: Swift.Equatable {
    /// <p>The new notification configuration for this profiling group.</p>
    public let notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?

    public init (
        notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct AddNotificationChannelsOutputResponseBody: Swift.Equatable {
    public let notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?
}

extension AddNotificationChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension CodeGuruProfilerClientTypes.AgentConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentParameters
        case periodInSeconds
        case shouldProfile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentParameters = agentParameters {
            var agentParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .agentParameters)
            for (dictKey0, agentparameters0) in agentParameters {
                try agentParametersContainer.encode(agentparameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let periodInSeconds = periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let shouldProfile = shouldProfile {
            try encodeContainer.encode(shouldProfile, forKey: .shouldProfile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shouldProfileDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .shouldProfile)
        shouldProfile = shouldProfileDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let agentParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .agentParameters)
        var agentParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let agentParametersContainer = agentParametersContainer {
            agentParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in agentParametersContainer {
                if let string0 = string0 {
                    agentParametersDecoded0?[key0] = string0
                }
            }
        }
        agentParameters = agentParametersDecoded0
    }
}

extension CodeGuruProfilerClientTypes.AgentConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentConfiguration(agentParameters: \(Swift.String(describing: agentParameters)), periodInSeconds: \(Swift.String(describing: periodInSeconds)), shouldProfile: \(Swift.String(describing: shouldProfile)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///          The response of <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html">
    ///                <code>ConfigureAgent</code>
    ///             </a> that
    ///          specifies if an agent profiles or not and for how long to return profiling data.
    ///       </p>
    public struct AgentConfiguration: Swift.Equatable {
        /// <p>
        ///          Parameters used by the profiler. The valid parameters are:
        ///       </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>MaxStackDepth</code> - The maximum depth of the stacks in the code that is represented in
        ///                the profile. For example, if CodeGuru Profiler finds a method <code>A</code>,
        ///                which calls method <code>B</code>, which calls method <code>C</code>, which
        ///                calls method <code>D</code>, then the depth is 4. If the <code>maxDepth</code> is
        ///                set to 2, then the profiler evaluates <code>A</code> and <code>B</code>.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>MemoryUsageLimitPercent</code> - The percentage of memory that is used by the
        ///                profiler.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>MinimumTimeForReportingInMilliseconds</code> - The minimum time in milliseconds between
        ///                sending reports.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ReportingIntervalInMilliseconds</code> - The reporting interval in milliseconds used
        ///                to report profiles.
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>SamplingIntervalInMilliseconds</code> - The sampling interval in milliseconds that is used to
        ///                profile samples.
        ///             </p>
        ///             </li>
        ///          </ul>
        public let agentParameters: [Swift.String:Swift.String]?
        /// <p>
        ///          How long a profiling agent should send profiling data using
        ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html">
        ///                <code>ConfigureAgent</code>
        ///             </a>.
        ///          For example, if this is set to 300, the profiling agent calls <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html">
        ///                <code>ConfigureAgent</code>
        ///             </a>
        ///          every 5 minutes to submit the profiled data collected during that period.
        ///       </p>
        public let periodInSeconds: Swift.Int?
        /// <p>
        ///          A <code>Boolean</code> that specifies whether the profiling agent collects profiling data or not. Set to <code>true</code>
        ///         to enable profiling.
        ///       </p>
        public let shouldProfile: Swift.Bool?

        public init (
            agentParameters: [Swift.String:Swift.String]? = nil,
            periodInSeconds: Swift.Int? = nil,
            shouldProfile: Swift.Bool? = nil
        )
        {
            self.agentParameters = agentParameters
            self.periodInSeconds = periodInSeconds
            self.shouldProfile = shouldProfile
        }
    }

}

extension CodeGuruProfilerClientTypes.AgentOrchestrationConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profilingEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profilingEnabled = profilingEnabled {
            try encodeContainer.encode(profilingEnabled, forKey: .profilingEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .profilingEnabled)
        profilingEnabled = profilingEnabledDecoded
    }
}

extension CodeGuruProfilerClientTypes.AgentOrchestrationConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentOrchestrationConfig(profilingEnabled: \(Swift.String(describing: profilingEnabled)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///          Specifies whether profiling is enabled or disabled for a profiling group. It
    ///          is used by <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html">
    ///                <code>ConfigureAgent</code>
    ///             </a>
    ///          to enable or disable profiling for a profiling group.
    ///       </p>
    public struct AgentOrchestrationConfig: Swift.Equatable {
        /// <p>
        ///          A <code>Boolean</code> that specifies whether the profiling agent collects profiling data or not. Set to <code>true</code>
        ///          to enable profiling.
        ///       </p>
        public let profilingEnabled: Swift.Bool?

        public init (
            profilingEnabled: Swift.Bool? = nil
        )
        {
            self.profilingEnabled = profilingEnabled
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum AgentParameterField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Maximum stack depth to be captured by the CodeGuru Profiler.
        case maxStackDepth
        /// Percentage of memory to be used by CodeGuru profiler. Minimum of 30MB is required for the agent.
        case memoryUsageLimitPercent
        /// Minimum time in milliseconds between sending reports.
        case minimumTimeForReportingInMilliseconds
        /// Reporting interval in milliseconds used to report profiles.
        case reportingIntervalInMilliseconds
        /// Sampling interval in milliseconds used to sample profiles.
        case samplingIntervalInMilliseconds
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentParameterField] {
            return [
                .maxStackDepth,
                .memoryUsageLimitPercent,
                .minimumTimeForReportingInMilliseconds,
                .reportingIntervalInMilliseconds,
                .samplingIntervalInMilliseconds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .maxStackDepth: return "MaxStackDepth"
            case .memoryUsageLimitPercent: return "MemoryUsageLimitPercent"
            case .minimumTimeForReportingInMilliseconds: return "MinimumTimeForReportingInMilliseconds"
            case .reportingIntervalInMilliseconds: return "ReportingIntervalInMilliseconds"
            case .samplingIntervalInMilliseconds: return "SamplingIntervalInMilliseconds"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentParameterField(rawValue: rawValue) ?? AgentParameterField.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.AggregatedProfileTime: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case period
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let period = period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let start = start {
            try encodeContainer.encode(start.timeIntervalSince1970, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .start)
        start = startDecoded
        let periodDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AggregationPeriod.self, forKey: .period)
        period = periodDecoded
    }
}

extension CodeGuruProfilerClientTypes.AggregatedProfileTime: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AggregatedProfileTime(period: \(Swift.String(describing: period)), start: \(Swift.String(describing: start)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///          Specifies the aggregation period and aggregation start time for
    ///          an aggregated profile. An aggregated profile is used to collect posted agent profiles
    ///          during an aggregation period. There are three possible aggregation periods (1 day,
    ///          1 hour, or 5 minutes).
    ///       </p>
    public struct AggregatedProfileTime: Swift.Equatable {
        /// <p>
        ///          The aggregation period. This indicates the period during which an aggregation profile
        ///          collects posted agent profiles for a profiling group. Use one of three valid
        ///          durations that are specified using the ISO 8601 format.
        ///       </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>P1D</code> — 1 day
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>PT1H</code> — 1 hour
        ///             </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>PT5M</code> — 5 minutes
        ///             </p>
        ///             </li>
        ///          </ul>
        public let period: CodeGuruProfilerClientTypes.AggregationPeriod?
        /// <p>
        ///          The time that aggregation of posted agent profiles for a profiling group starts. The aggregation profile
        ///          contains profiles posted by the agent starting at this time for an aggregation period
        ///          specified by the <code>period</code> property of the <code>AggregatedProfileTime</code>
        ///          object.
        ///       </p>
        ///          <p>
        ///          Specify <code>start</code> using the ISO 8601 format. For example,
        ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        ///       </p>
        public let start: ClientRuntime.Date?

        public init (
            period: CodeGuruProfilerClientTypes.AggregationPeriod? = nil,
            start: ClientRuntime.Date? = nil
        )
        {
            self.period = period
            self.start = start
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum AggregationPeriod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Period of one day.
        case p1d
        /// Period of one hour.
        case pt1h
        /// Period of five minutes.
        case pt5m
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationPeriod] {
            return [
                .p1d,
                .pt1h,
                .pt5m,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .p1d: return "P1D"
            case .pt1h: return "PT1H"
            case .pt5m: return "PT5M"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationPeriod(rawValue: rawValue) ?? AggregationPeriod.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.Anomaly: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances
        case metric
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for anomalyinstances0 in instances {
                try instancesContainer.encode(anomalyinstances0)
            }
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.Metric.self, forKey: .metric)
        metric = metricDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let instancesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.AnomalyInstance?].self, forKey: .instances)
        var instancesDecoded0:[CodeGuruProfilerClientTypes.AnomalyInstance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [CodeGuruProfilerClientTypes.AnomalyInstance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

extension CodeGuruProfilerClientTypes.Anomaly: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Anomaly(instances: \(Swift.String(describing: instances)), metric: \(Swift.String(describing: metric)), reason: \(Swift.String(describing: reason)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///             Details about an anomaly in a specific metric of application profile. The anomaly is detected using
    ///             analysis of the metric data over a period of time.
    ///         </p>
    public struct Anomaly: Swift.Equatable {
        /// <p>
        ///             A list of the instances of the detected anomalies during the requested period.
        ///         </p>
        public let instances: [CodeGuruProfilerClientTypes.AnomalyInstance]?
        /// <p>
        ///             Details about the metric that the analysis used when it detected the anomaly.
        ///             The metric includes the name of the frame that was analyzed with the type and
        ///             thread states used to derive the metric value for that frame.
        ///         </p>
        public let metric: CodeGuruProfilerClientTypes.Metric?
        /// <p>The reason for which metric was flagged as anomalous.</p>
        public let reason: Swift.String?

        public init (
            instances: [CodeGuruProfilerClientTypes.AnomalyInstance]? = nil,
            metric: CodeGuruProfilerClientTypes.Metric? = nil,
            reason: Swift.String? = nil
        )
        {
            self.instances = instances
            self.metric = metric
            self.reason = reason
        }
    }

}

extension CodeGuruProfilerClientTypes.AnomalyInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case id
        case startTime
        case userFeedback
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let userFeedback = userFeedback {
            try encodeContainer.encode(userFeedback, forKey: .userFeedback)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let userFeedbackDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.UserFeedback.self, forKey: .userFeedback)
        userFeedback = userFeedbackDecoded
    }
}

extension CodeGuruProfilerClientTypes.AnomalyInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnomalyInstance(endTime: \(Swift.String(describing: endTime)), id: \(Swift.String(describing: id)), startTime: \(Swift.String(describing: startTime)), userFeedback: \(Swift.String(describing: userFeedback)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>The specific duration in which the metric is flagged as anomalous.</p>
    public struct AnomalyInstance: Swift.Equatable {
        /// <p>
        ///             The end time of the period during which the metric is flagged as anomalous.
        ///             This is specified
        ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        ///             millisecond past June 1, 2020 1:15:02 PM UTC.
        ///         </p>
        public let endTime: ClientRuntime.Date?
        /// <p>
        ///             The universally unique identifier (UUID) of an instance of an anomaly in a metric.
        ///         </p>
        public let id: Swift.String?
        /// <p>
        ///             The start time of the period during which the metric is flagged as anomalous.
        ///             This is specified
        ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        ///             millisecond past June 1, 2020 1:15:02 PM UTC.
        ///         </p>
        public let startTime: ClientRuntime.Date?
        /// <p>Feedback type on a specific instance of anomaly submitted by the user.</p>
        public let userFeedback: CodeGuruProfilerClientTypes.UserFeedback?

        public init (
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            userFeedback: CodeGuruProfilerClientTypes.UserFeedback? = nil
        )
        {
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.userFeedback = userFeedback
        }
    }

}

public struct BatchGetFrameMetricDataInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetFrameMetricDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetFrameMetricDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetFrameMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetFrameMetricDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetFrameMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetFrameMetricDataOutputError>
}

extension BatchGetFrameMetricDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetFrameMetricDataInput(endTime: \(Swift.String(describing: endTime)), frameMetrics: \(Swift.String(describing: frameMetrics)), period: \(Swift.String(describing: period)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), startTime: \(Swift.String(describing: startTime)), targetResolution: \(Swift.String(describing: targetResolution)))"}
}

extension BatchGetFrameMetricDataInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameMetrics = frameMetrics {
            var frameMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameMetrics)
            for framemetrics0 in frameMetrics {
                try frameMetricsContainer.encode(framemetrics0)
            }
        }
    }
}

public struct BatchGetFrameMetricDataInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetFrameMetricDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetFrameMetricDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetFrameMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetFrameMetricDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetFrameMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetFrameMetricDataOutputError>
}

public struct BatchGetFrameMetricDataInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetFrameMetricDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetFrameMetricDataInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetFrameMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let period = input.operationInput.period {
            let periodQueryItem = ClientRuntime.URLQueryItem(name: "period".urlPercentEncoding(), value: Swift.String(period).urlPercentEncoding())
            input.builder.withQueryItem(periodQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let targetResolution = input.operationInput.targetResolution {
            let targetResolutionQueryItem = ClientRuntime.URLQueryItem(name: "targetResolution".urlPercentEncoding(), value: Swift.String(targetResolution.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(targetResolutionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetFrameMetricDataInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetFrameMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetFrameMetricDataOutputError>
}

/// <p>The structure representing the BatchGetFrameMetricDataRequest.</p>
public struct BatchGetFrameMetricDataInput: Swift.Equatable {
    /// <p>
    ///          The end time of the time period for the returned time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let endTime: ClientRuntime.Date?
    /// <p>
    ///          The details of the metrics that are used to request a time series of values. The metric includes
    ///          the name of the frame, the aggregation type to calculate the metric value for the
    ///          frame, and the thread states to use to get the count for the metric value of the frame.</p>
    public let frameMetrics: [CodeGuruProfilerClientTypes.FrameMetric]?
    /// <p>
    ///          The duration of the frame metrics used to return the time series values.
    ///          Specify using the ISO 8601 format. The maximum period duration
    ///          is one day (<code>PT24H</code> or <code>P1D</code>).
    ///       </p>
    public let period: Swift.String?
    /// <p>
    ///          The name of the profiling group associated with the
    ///          the frame metrics used to return the time series values.
    ///       </p>
    public let profilingGroupName: Swift.String?
    /// <p>
    ///          The start time of the time period for the frame metrics used to return the time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let startTime: ClientRuntime.Date?
    /// <p>The requested resolution of time steps for the returned time series of values.
    ///          If the requested target resolution is not available due to data not being retained we provide a best effort
    ///          result by falling back to the most granular available resolution after the target resolution.
    ///          There are 3 valid values.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>P1D</code> — 1 day
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT1H</code> — 1 hour
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT5M</code> — 5 minutes
    ///             </p>
    ///             </li>
    ///          </ul>
    public let targetResolution: CodeGuruProfilerClientTypes.AggregationPeriod?

    public init (
        endTime: ClientRuntime.Date? = nil,
        frameMetrics: [CodeGuruProfilerClientTypes.FrameMetric]? = nil,
        period: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        targetResolution: CodeGuruProfilerClientTypes.AggregationPeriod? = nil
    )
    {
        self.endTime = endTime
        self.frameMetrics = frameMetrics
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
        self.targetResolution = targetResolution
    }
}

struct BatchGetFrameMetricDataInputBody: Swift.Equatable {
    public let frameMetrics: [CodeGuruProfilerClientTypes.FrameMetric]?
}

extension BatchGetFrameMetricDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameMetrics
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameMetricsContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.FrameMetric?].self, forKey: .frameMetrics)
        var frameMetricsDecoded0:[CodeGuruProfilerClientTypes.FrameMetric]? = nil
        if let frameMetricsContainer = frameMetricsContainer {
            frameMetricsDecoded0 = [CodeGuruProfilerClientTypes.FrameMetric]()
            for structure0 in frameMetricsContainer {
                if let structure0 = structure0 {
                    frameMetricsDecoded0?.append(structure0)
                }
            }
        }
        frameMetrics = frameMetricsDecoded0
    }
}

extension BatchGetFrameMetricDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetFrameMetricDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetFrameMetricDataOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetFrameMetricDataOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetFrameMetricDataOutputResponse(endTime: \(Swift.String(describing: endTime)), endTimes: \(Swift.String(describing: endTimes)), frameMetricData: \(Swift.String(describing: frameMetricData)), resolution: \(Swift.String(describing: resolution)), startTime: \(Swift.String(describing: startTime)), unprocessedEndTimes: \(Swift.String(describing: unprocessedEndTimes)))"}
}

extension BatchGetFrameMetricDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetFrameMetricDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.endTimes = output.endTimes
            self.frameMetricData = output.frameMetricData
            self.resolution = output.resolution
            self.startTime = output.startTime
            self.unprocessedEndTimes = output.unprocessedEndTimes
        } else {
            self.endTime = nil
            self.endTimes = nil
            self.frameMetricData = nil
            self.resolution = nil
            self.startTime = nil
            self.unprocessedEndTimes = nil
        }
    }
}

/// <p>The structure representing the BatchGetFrameMetricDataResponse.</p>
public struct BatchGetFrameMetricDataOutputResponse: Swift.Equatable {
    /// <p>
    ///          The end time of the time period for the returned time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let endTime: ClientRuntime.Date?
    /// <p>
    ///          List of instances, or time steps, in the time series. For example, if the
    ///          <code>period</code> is one day (<code>PT24H)</code>), and the <code>resolution</code>
    ///          is five minutes (<code>PT5M</code>), then there are 288 <code>endTimes</code> in the
    ///          list that are each five minutes appart.
    ///       </p>
    public let endTimes: [CodeGuruProfilerClientTypes.TimestampStructure]?
    /// <p>Details of the metrics to request a time series of values. The metric includes
    ///          the name of the frame, the aggregation type to calculate the metric value for the frame,
    ///          and the thread states to use to get the count for the metric value of the frame.</p>
    public let frameMetricData: [CodeGuruProfilerClientTypes.FrameMetricDatum]?
    /// <p>Resolution or granularity of the profile data used to generate the time series.
    ///          This is the value used to jump through time steps in a time series. There are 3 valid values.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>P1D</code> — 1 day
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT1H</code> — 1 hour
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT5M</code> — 5 minutes
    ///             </p>
    ///             </li>
    ///          </ul>
    public let resolution: CodeGuruProfilerClientTypes.AggregationPeriod?
    /// <p>
    ///          The start time of the time period for the returned time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let startTime: ClientRuntime.Date?
    /// <p>List of instances which remained unprocessed. This will create a missing time step in the list of end times.</p>
    public let unprocessedEndTimes: [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]?

    public init (
        endTime: ClientRuntime.Date? = nil,
        endTimes: [CodeGuruProfilerClientTypes.TimestampStructure]? = nil,
        frameMetricData: [CodeGuruProfilerClientTypes.FrameMetricDatum]? = nil,
        resolution: CodeGuruProfilerClientTypes.AggregationPeriod? = nil,
        startTime: ClientRuntime.Date? = nil,
        unprocessedEndTimes: [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]? = nil
    )
    {
        self.endTime = endTime
        self.endTimes = endTimes
        self.frameMetricData = frameMetricData
        self.resolution = resolution
        self.startTime = startTime
        self.unprocessedEndTimes = unprocessedEndTimes
    }
}

struct BatchGetFrameMetricDataOutputResponseBody: Swift.Equatable {
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
    public let resolution: CodeGuruProfilerClientTypes.AggregationPeriod?
    public let endTimes: [CodeGuruProfilerClientTypes.TimestampStructure]?
    public let unprocessedEndTimes: [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]?
    public let frameMetricData: [CodeGuruProfilerClientTypes.FrameMetricDatum]?
}

extension BatchGetFrameMetricDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case endTimes
        case frameMetricData
        case resolution
        case startTime
        case unprocessedEndTimes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AggregationPeriod.self, forKey: .resolution)
        resolution = resolutionDecoded
        let endTimesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.TimestampStructure?].self, forKey: .endTimes)
        var endTimesDecoded0:[CodeGuruProfilerClientTypes.TimestampStructure]? = nil
        if let endTimesContainer = endTimesContainer {
            endTimesDecoded0 = [CodeGuruProfilerClientTypes.TimestampStructure]()
            for structure0 in endTimesContainer {
                if let structure0 = structure0 {
                    endTimesDecoded0?.append(structure0)
                }
            }
        }
        endTimes = endTimesDecoded0
        let unprocessedEndTimesContainer = try containerValues.decodeIfPresent([Swift.String: [CodeGuruProfilerClientTypes.TimestampStructure?]?].self, forKey: .unprocessedEndTimes)
        var unprocessedEndTimesDecoded0: [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]? = nil
        if let unprocessedEndTimesContainer = unprocessedEndTimesContainer {
            unprocessedEndTimesDecoded0 = [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]()
            for (key0, listoftimestamps0) in unprocessedEndTimesContainer {
                var listoftimestamps0Decoded0: [CodeGuruProfilerClientTypes.TimestampStructure]? = nil
                if let listoftimestamps0 = listoftimestamps0 {
                    listoftimestamps0Decoded0 = [CodeGuruProfilerClientTypes.TimestampStructure]()
                    for structure1 in listoftimestamps0 {
                        if let structure1 = structure1 {
                            listoftimestamps0Decoded0?.append(structure1)
                        }
                    }
                }
                unprocessedEndTimesDecoded0?[key0] = listoftimestamps0Decoded0
            }
        }
        unprocessedEndTimes = unprocessedEndTimesDecoded0
        let frameMetricDataContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.FrameMetricDatum?].self, forKey: .frameMetricData)
        var frameMetricDataDecoded0:[CodeGuruProfilerClientTypes.FrameMetricDatum]? = nil
        if let frameMetricDataContainer = frameMetricDataContainer {
            frameMetricDataDecoded0 = [CodeGuruProfilerClientTypes.FrameMetricDatum]()
            for structure0 in frameMetricDataContainer {
                if let structure0 = structure0 {
                    frameMetricDataDecoded0?.append(structure0)
                }
            }
        }
        frameMetricData = frameMetricDataDecoded0
    }
}

extension CodeGuruProfilerClientTypes.Channel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventPublishers
        case id
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventPublishers = eventPublishers {
            var eventPublishersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventPublishers)
            for eventpublishers0 in eventPublishers {
                try eventPublishersContainer.encode(eventpublishers0.rawValue)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let eventPublishersContainer = try containerValues.decodeIfPresent(Swift.Set<CodeGuruProfilerClientTypes.EventPublisher>.self, forKey: .eventPublishers)
        var eventPublishersDecoded0:Swift.Set<CodeGuruProfilerClientTypes.EventPublisher>? = nil
        if let eventPublishersContainer = eventPublishersContainer {
            eventPublishersDecoded0 = Swift.Set<CodeGuruProfilerClientTypes.EventPublisher>()
            for string0 in eventPublishersContainer {
                eventPublishersDecoded0?.insert(string0)
            }
        }
        eventPublishers = eventPublishersDecoded0
    }
}

extension CodeGuruProfilerClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(eventPublishers: \(Swift.String(describing: eventPublishers)), id: \(Swift.String(describing: id)), uri: \(Swift.String(describing: uri)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>Notification medium for users to get alerted for events that occur in application profile. We support SNS topic as a notification channel.</p>
    public struct Channel: Swift.Equatable, Swift.Hashable {
        /// <p>List of publishers for different type of events that may be detected in an application from the profile. Anomaly detection is the only event publisher in Profiler.</p>
        public let eventPublishers: Swift.Set<CodeGuruProfilerClientTypes.EventPublisher>?
        /// <p>Unique identifier for each <code>Channel</code> in the notification configuration of a Profiling Group. A random UUID for channelId is used when adding a channel to the notification configuration if not specified in the request.</p>
        public let id: Swift.String?
        /// <p>Unique arn of the resource to be used for notifications. We support a valid SNS topic arn as a channel uri.</p>
        public let uri: Swift.String?

        public init (
            eventPublishers: Swift.Set<CodeGuruProfilerClientTypes.EventPublisher>? = nil,
            id: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.eventPublishers = eventPublishers
            self.id = id
            self.uri = uri
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum ComputePlatform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Compute platform meant to used for AWS Lambda.
        case awslambda
        /// Compute platform meant to used for all usecases (like EC2, Fargate, physical servers etc.) but AWS Lambda.
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputePlatform] {
            return [
                .awslambda,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awslambda: return "AWSLambda"
            case .default: return "Default"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComputePlatform(rawValue: rawValue) ?? ComputePlatform.sdkUnknown(rawValue)
        }
    }
}

public struct ConfigureAgentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureAgentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfigureAgentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfigureAgentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureAgentOutputError>
}

extension ConfigureAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigureAgentInput(fleetInstanceId: \(Swift.String(describing: fleetInstanceId)), metadata: \(Swift.String(describing: metadata)), profilingGroupName: \(Swift.String(describing: profilingGroupName)))"}
}

extension ConfigureAgentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetInstanceId
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetInstanceId = fleetInstanceId {
            try encodeContainer.encode(fleetInstanceId, forKey: .fleetInstanceId)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ConfigureAgentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureAgentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfigureAgentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfigureAgentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureAgentOutputError>
}

public struct ConfigureAgentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ConfigureAgentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ConfigureAgentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ConfigureAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ConfigureAgentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ConfigureAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ConfigureAgentOutputError>
}

/// <p>The structure representing the configureAgentRequest.</p>
public struct ConfigureAgentInput: Swift.Equatable {
    /// <p> A universally unique identifier (UUID) for a profiling instance. For example, if the
    ///          profiling instance is an Amazon EC2 instance, it is the instance ID. If it is an AWS
    ///          Fargate container, it is the container's task ID. </p>
    public let fleetInstanceId: Swift.String?
    /// <p> Metadata captured about the compute platform the agent is running on. It includes
    ///          information about sampling and reporting. The valid fields are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>COMPUTE_PLATFORM</code> - The compute platform on which the agent is running
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AGENT_ID</code> - The ID for an agent instance.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AWS_REQUEST_ID</code> - The AWS request ID of a Lambda invocation.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EXECUTION_ENVIRONMENT</code> - The execution environment a Lambda function is running on.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_FUNCTION_ARN</code> - The Amazon Resource Name (ARN) that is used to invoke a Lambda function.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_MEMORY_LIMIT_IN_MB</code> - The memory allocated to a Lambda function.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_REMAINING_TIME_IN_MILLISECONDS</code> - The time in milliseconds before execution of a Lambda function times out.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_TIME_GAP_BETWEEN_INVOKES_IN_MILLISECONDS</code> - The time in milliseconds between two invocations of a Lambda function.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_PREVIOUS_EXECUTION_TIME_IN_MILLISECONDS</code> - The time in milliseconds for the previous Lambda invocation.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let metadata: [Swift.String:Swift.String]?
    /// <p>
    ///          The name of the profiling group for which the configured agent is collecting profiling data.
    ///       </p>
    public let profilingGroupName: Swift.String?

    public init (
        fleetInstanceId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.fleetInstanceId = fleetInstanceId
        self.metadata = metadata
        self.profilingGroupName = profilingGroupName
    }
}

struct ConfigureAgentInputBody: Swift.Equatable {
    public let fleetInstanceId: Swift.String?
    public let metadata: [Swift.String:Swift.String]?
}

extension ConfigureAgentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetInstanceId
        case metadata
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetInstanceId)
        fleetInstanceId = fleetInstanceIdDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension ConfigureAgentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfigureAgentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfigureAgentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureAgentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigureAgentOutputResponse(configuration: \(Swift.String(describing: configuration)))"}
}

extension ConfigureAgentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CodeGuruProfilerClientTypes.AgentConfiguration = try responseDecoder.decode(responseBody: data)
                self.configuration = output
            } else {
                self.configuration = nil
            }
        } else {
            self.configuration = nil
        }
    }
}

/// <p>The structure representing the configureAgentResponse.</p>
public struct ConfigureAgentOutputResponse: Swift.Equatable {
    /// <p>
    ///          An <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AgentConfiguration.html">
    ///                <code>AgentConfiguration</code>
    ///             </a>
    ///          object that specifies if an agent profiles or not and for how long to return profiling data.
    ///       </p>
    public let configuration: CodeGuruProfilerClientTypes.AgentConfiguration?

    public init (
        configuration: CodeGuruProfilerClientTypes.AgentConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct ConfigureAgentOutputResponseBody: Swift.Equatable {
    public let configuration: CodeGuruProfilerClientTypes.AgentConfiguration?
}

extension ConfigureAgentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AgentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation would cause a conflict with the current state
///         of a service resource associated with the request. Resolve the conflict
///         before retrying this request.
///       </p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateProfilingGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProfilingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProfilingGroupOutputError>
}

extension CreateProfilingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfilingGroupInput(agentOrchestrationConfig: \(Swift.String(describing: agentOrchestrationConfig)), clientToken: \(Swift.String(describing: clientToken)), computePlatform: \(Swift.String(describing: computePlatform)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateProfilingGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
        case computePlatform
        case profilingGroupName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentOrchestrationConfig = agentOrchestrationConfig {
            try encodeContainer.encode(agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
        }
        if let computePlatform = computePlatform {
            try encodeContainer.encode(computePlatform.rawValue, forKey: .computePlatform)
        }
        if let profilingGroupName = profilingGroupName {
            try encodeContainer.encode(profilingGroupName, forKey: .profilingGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateProfilingGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProfilingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProfilingGroupOutputError>
}

public struct CreateProfilingGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProfilingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProfilingGroupOutputError>
}

/// <p>The structure representing the createProfiliingGroupRequest.</p>
public struct CreateProfilingGroupInput: Swift.Equatable {
    /// <p>
    ///          Specifies whether profiling is enabled or disabled for the created profiling group.
    ///       </p>
    public let agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
    /// <p> Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the
    ///          accidental creation of duplicate profiling groups if there are failures and retries. </p>
    public var clientToken: Swift.String?
    /// <p>
    ///          The compute platform of the profiling group. Use <code>AWSLambda</code> if your application
    ///          runs on AWS Lambda. Use <code>Default</code> if your application runs on a compute platform that
    ///          is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform.
    ///          If not specified, <code>Default</code> is used.
    ///       </p>
    public let computePlatform: CodeGuruProfilerClientTypes.ComputePlatform?
    /// <p>The name of the profiling group to create.</p>
    public let profilingGroupName: Swift.String?
    /// <p>
    ///          A list of tags to add to the created profiling group.
    ///       </p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig? = nil,
        clientToken: Swift.String? = nil,
        computePlatform: CodeGuruProfilerClientTypes.ComputePlatform? = nil,
        profilingGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentOrchestrationConfig = agentOrchestrationConfig
        self.clientToken = clientToken
        self.computePlatform = computePlatform
        self.profilingGroupName = profilingGroupName
        self.tags = tags
    }
}

struct CreateProfilingGroupInputBody: Swift.Equatable {
    public let profilingGroupName: Swift.String?
    public let computePlatform: CodeGuruProfilerClientTypes.ComputePlatform?
    public let agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateProfilingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
        case computePlatform
        case profilingGroupName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profilingGroupName)
        profilingGroupName = profilingGroupNameDecoded
        let computePlatformDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ComputePlatform.self, forKey: .computePlatform)
        computePlatform = computePlatformDecoded
        let agentOrchestrationConfigDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AgentOrchestrationConfig.self, forKey: .agentOrchestrationConfig)
        agentOrchestrationConfig = agentOrchestrationConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfilingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProfilingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProfilingGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProfilingGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfilingGroupOutputResponse(profilingGroup: \(Swift.String(describing: profilingGroup)))"}
}

extension CreateProfilingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CodeGuruProfilerClientTypes.ProfilingGroupDescription = try responseDecoder.decode(responseBody: data)
                self.profilingGroup = output
            } else {
                self.profilingGroup = nil
            }
        } else {
            self.profilingGroup = nil
        }
    }
}

/// <p>The structure representing the createProfilingGroupResponse.</p>
public struct CreateProfilingGroupOutputResponse: Swift.Equatable {
    /// <p> The returned <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a> object that contains information
    ///          about the created profiling group. </p>
    public let profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?

    public init (
        profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription? = nil
    )
    {
        self.profilingGroup = profilingGroup
    }
}

struct CreateProfilingGroupOutputResponseBody: Swift.Equatable {
    public let profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?
}

extension CreateProfilingGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profilingGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ProfilingGroupDescription.self, forKey: .profilingGroup)
        profilingGroup = profilingGroupDecoded
    }
}

extension DeleteProfilingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProfilingGroupInput(profilingGroupName: \(Swift.String(describing: profilingGroupName)))"}
}

extension DeleteProfilingGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteProfilingGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProfilingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProfilingGroupOutputError>
}

public struct DeleteProfilingGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProfilingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProfilingGroupOutputError>
}

/// <p>The structure representing the deleteProfilingGroupRequest.</p>
public struct DeleteProfilingGroupInput: Swift.Equatable {
    /// <p>The name of the profiling group to delete.</p>
    public let profilingGroupName: Swift.String?

    public init (
        profilingGroupName: Swift.String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct DeleteProfilingGroupInputBody: Swift.Equatable {
}

extension DeleteProfilingGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProfilingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfilingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProfilingGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfilingGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProfilingGroupOutputResponse()"}
}

extension DeleteProfilingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The structure representing the deleteProfilingGroupResponse.</p>
public struct DeleteProfilingGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProfilingGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteProfilingGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProfilingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProfilingGroupInput(profilingGroupName: \(Swift.String(describing: profilingGroupName)))"}
}

extension DescribeProfilingGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeProfilingGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProfilingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProfilingGroupOutputError>
}

public struct DescribeProfilingGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProfilingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProfilingGroupOutputError>
}

/// <p>The structure representing the describeProfilingGroupRequest.</p>
public struct DescribeProfilingGroupInput: Swift.Equatable {
    /// <p>
    ///          The name of the profiling group to get information about.
    ///       </p>
    public let profilingGroupName: Swift.String?

    public init (
        profilingGroupName: Swift.String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct DescribeProfilingGroupInputBody: Swift.Equatable {
}

extension DescribeProfilingGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProfilingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProfilingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProfilingGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProfilingGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProfilingGroupOutputResponse(profilingGroup: \(Swift.String(describing: profilingGroup)))"}
}

extension DescribeProfilingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CodeGuruProfilerClientTypes.ProfilingGroupDescription = try responseDecoder.decode(responseBody: data)
                self.profilingGroup = output
            } else {
                self.profilingGroup = nil
            }
        } else {
            self.profilingGroup = nil
        }
    }
}

/// <p>The structure representing the describeProfilingGroupResponse.</p>
public struct DescribeProfilingGroupOutputResponse: Swift.Equatable {
    /// <p>
    ///          The returned <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a>
    ///          object that contains information about the requested profiling group.
    ///       </p>
    public let profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?

    public init (
        profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription? = nil
    )
    {
        self.profilingGroup = profilingGroup
    }
}

struct DescribeProfilingGroupOutputResponseBody: Swift.Equatable {
    public let profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?
}

extension DescribeProfilingGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profilingGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ProfilingGroupDescription.self, forKey: .profilingGroup)
        profilingGroup = profilingGroupDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    public enum EventPublisher: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Notifications for Anomaly Detection
        case anomalyDetection
        case sdkUnknown(Swift.String)

        public static var allCases: [EventPublisher] {
            return [
                .anomalyDetection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anomalyDetection: return "AnomalyDetection"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventPublisher(rawValue: rawValue) ?? EventPublisher.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes {
    public enum FeedbackType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Profiler recommendation flagged as not useful.
        case negative
        /// Profiler recommendation flagged as useful.
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [FeedbackType] {
            return [
                .negative,
                .positive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .negative: return "Negative"
            case .positive: return "Positive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeedbackType(rawValue: rawValue) ?? FeedbackType.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.FindingsReportSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case profileEndTime
        case profileStartTime
        case profilingGroupName
        case totalNumberOfFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let profileEndTime = profileEndTime {
            try encodeContainer.encode(profileEndTime.timeIntervalSince1970, forKey: .profileEndTime)
        }
        if let profileStartTime = profileStartTime {
            try encodeContainer.encode(profileStartTime.timeIntervalSince1970, forKey: .profileStartTime)
        }
        if let profilingGroupName = profilingGroupName {
            try encodeContainer.encode(profilingGroupName, forKey: .profilingGroupName)
        }
        if let totalNumberOfFindings = totalNumberOfFindings {
            try encodeContainer.encode(totalNumberOfFindings, forKey: .totalNumberOfFindings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let profilingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profilingGroupName)
        profilingGroupName = profilingGroupNameDecoded
        let profileStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .profileStartTime)
        profileStartTime = profileStartTimeDecoded
        let profileEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .profileEndTime)
        profileEndTime = profileEndTimeDecoded
        let totalNumberOfFindingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumberOfFindings)
        totalNumberOfFindings = totalNumberOfFindingsDecoded
    }
}

extension CodeGuruProfilerClientTypes.FindingsReportSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FindingsReportSummary(id: \(Swift.String(describing: id)), profileEndTime: \(Swift.String(describing: profileEndTime)), profileStartTime: \(Swift.String(describing: profileStartTime)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), totalNumberOfFindings: \(Swift.String(describing: totalNumberOfFindings)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///             Information about potential recommendations that might be created from the
    ///             analysis of profiling data.
    ///         </p>
    public struct FindingsReportSummary: Swift.Equatable {
        /// <p>The universally unique identifier (UUID) of the recommendation report.</p>
        public let id: Swift.String?
        /// <p>
        ///             The end time of the period during which the metric is flagged as anomalous.
        ///             This is specified
        ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        ///             millisecond past June 1, 2020 1:15:02 PM UTC.
        ///         </p>
        public let profileEndTime: ClientRuntime.Date?
        /// <p>The start time of the profile the analysis data is about.
        ///             This is specified
        ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        ///             millisecond past June 1, 2020 1:15:02 PM UTC.</p>
        public let profileStartTime: ClientRuntime.Date?
        /// <p>The name of the profiling group that is associated with the analysis data.</p>
        public let profilingGroupName: Swift.String?
        /// <p>The total number of different recommendations that were found by the analysis.</p>
        public let totalNumberOfFindings: Swift.Int?

        public init (
            id: Swift.String? = nil,
            profileEndTime: ClientRuntime.Date? = nil,
            profileStartTime: ClientRuntime.Date? = nil,
            profilingGroupName: Swift.String? = nil,
            totalNumberOfFindings: Swift.Int? = nil
        )
        {
            self.id = id
            self.profileEndTime = profileEndTime
            self.profileStartTime = profileStartTime
            self.profilingGroupName = profilingGroupName
            self.totalNumberOfFindings = totalNumberOfFindings
        }
    }

}

extension CodeGuruProfilerClientTypes.FrameMetric: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameName
        case threadStates
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameName = frameName {
            try encodeContainer.encode(frameName, forKey: .frameName)
        }
        if let threadStates = threadStates {
            var threadStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threadStates)
            for threadstates0 in threadStates {
                try threadStatesContainer.encode(threadstates0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameName)
        frameName = frameNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.MetricType.self, forKey: .type)
        type = typeDecoded
        let threadStatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threadStates)
        var threadStatesDecoded0:[Swift.String]? = nil
        if let threadStatesContainer = threadStatesContainer {
            threadStatesDecoded0 = [Swift.String]()
            for string0 in threadStatesContainer {
                if let string0 = string0 {
                    threadStatesDecoded0?.append(string0)
                }
            }
        }
        threadStates = threadStatesDecoded0
    }
}

extension CodeGuruProfilerClientTypes.FrameMetric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FrameMetric(frameName: \(Swift.String(describing: frameName)), threadStates: \(Swift.String(describing: threadStates)), type: \(Swift.String(describing: type)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///          The frame name, metric type, and thread states. These are used
    ///          to derive the value of the metric for the frame.</p>
    public struct FrameMetric: Swift.Equatable {
        /// <p> Name of the method common across the multiple occurrences of a frame in an application
        ///          profile.</p>
        public let frameName: Swift.String?
        /// <p>List of application runtime thread states used to get the counts for a frame a derive a metric value.</p>
        public let threadStates: [Swift.String]?
        /// <p> A type of aggregation that specifies how a metric for a frame is analyzed. The
        ///          supported value <code>AggregatedRelativeTotalTime</code> is an aggregation of the metric
        ///          value for one frame that is calculated across the occurrences of all frames in a profile. </p>
        public let type: CodeGuruProfilerClientTypes.MetricType?

        public init (
            frameName: Swift.String? = nil,
            threadStates: [Swift.String]? = nil,
            type: CodeGuruProfilerClientTypes.MetricType? = nil
        )
        {
            self.frameName = frameName
            self.threadStates = threadStates
            self.type = type
        }
    }

}

extension CodeGuruProfilerClientTypes.FrameMetricDatum: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameMetric
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameMetric = frameMetric {
            try encodeContainer.encode(frameMetric, forKey: .frameMetric)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for framemetricvalues0 in values {
                try valuesContainer.encode(framemetricvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameMetricDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.FrameMetric.self, forKey: .frameMetric)
        frameMetric = frameMetricDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .values)
        var valuesDecoded0:[Swift.Double]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.Double]()
            for double0 in valuesContainer {
                if let double0 = double0 {
                    valuesDecoded0?.append(double0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CodeGuruProfilerClientTypes.FrameMetricDatum: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FrameMetricDatum(frameMetric: \(Swift.String(describing: frameMetric)), values: \(Swift.String(describing: values)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///          Information about a frame metric and its values.
    ///       </p>
    public struct FrameMetricDatum: Swift.Equatable {
        /// <p>
        ///          The frame name, metric type, and thread states. These are used
        ///          to derive the value of the metric for the frame.</p>
        public let frameMetric: CodeGuruProfilerClientTypes.FrameMetric?
        /// <p>
        ///          A list of values that are associated with a frame metric.
        ///       </p>
        public let values: [Swift.Double]?

        public init (
            frameMetric: CodeGuruProfilerClientTypes.FrameMetric? = nil,
            values: [Swift.Double]? = nil
        )
        {
            self.frameMetric = frameMetric
            self.values = values
        }
    }

}

extension GetFindingsReportAccountSummaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFindingsReportAccountSummaryInput(dailyReportsOnly: \(Swift.String(describing: dailyReportsOnly)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetFindingsReportAccountSummaryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetFindingsReportAccountSummaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFindingsReportAccountSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFindingsReportAccountSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFindingsReportAccountSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFindingsReportAccountSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFindingsReportAccountSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFindingsReportAccountSummaryOutputError>
}

public struct GetFindingsReportAccountSummaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetFindingsReportAccountSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetFindingsReportAccountSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetFindingsReportAccountSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let dailyReportsOnly = input.operationInput.dailyReportsOnly {
            let dailyReportsOnlyQueryItem = ClientRuntime.URLQueryItem(name: "dailyReportsOnly".urlPercentEncoding(), value: Swift.String(dailyReportsOnly).urlPercentEncoding())
            input.builder.withQueryItem(dailyReportsOnlyQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetFindingsReportAccountSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetFindingsReportAccountSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetFindingsReportAccountSummaryOutputError>
}

/// <p>The structure representing the GetFindingsReportAccountSummaryRequest.</p>
public struct GetFindingsReportAccountSummaryInput: Swift.Equatable {
    /// <p>A <code>Boolean</code> value indicating whether to only return reports from daily profiles. If set
    ///             to <code>True</code>, only analysis data from daily profiles is returned. If set to <code>False</code>,
    ///             analysis data is returned from smaller time windows (for example, one hour).</p>
    public let dailyReportsOnly: Swift.Bool?
    /// <p>The maximum number of results returned by <code> GetFindingsReportAccountSummary</code> in paginated output.
    ///             When this parameter is used, <code>GetFindingsReportAccountSummary</code> only returns <code>maxResults</code>
    ///             results in a single page along with a <code>nextToken</code> response element. The remaining results of the initial
    ///             request can be seen by sending another <code>GetFindingsReportAccountSummary</code> request with the returned
    ///             <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated <code>GetFindingsReportAccountSummary</code>
    ///          request where <code>maxResults</code> was used and the results exceeded the value of that parameter.
    ///          Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve
    ///          the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: Swift.String?

    public init (
        dailyReportsOnly: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dailyReportsOnly = dailyReportsOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFindingsReportAccountSummaryInputBody: Swift.Equatable {
}

extension GetFindingsReportAccountSummaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFindingsReportAccountSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsReportAccountSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsReportAccountSummaryOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsReportAccountSummaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFindingsReportAccountSummaryOutputResponse(nextToken: \(Swift.String(describing: nextToken)), reportSummaries: \(Swift.String(describing: reportSummaries)))"}
}

extension GetFindingsReportAccountSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFindingsReportAccountSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportSummaries = output.reportSummaries
        } else {
            self.nextToken = nil
            self.reportSummaries = nil
        }
    }
}

/// <p>The structure representing the GetFindingsReportAccountSummaryResponse.</p>
public struct GetFindingsReportAccountSummaryOutputResponse: Swift.Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>GetFindingsReportAccountSummary</code> request.
    ///          When the results of a <code>GetFindingsReportAccountSummary</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return.</p>
    public let nextToken: Swift.String?
    /// <p>The return list of
    ///             <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_FindingsReportSummary.html">
    ///                <code>FindingsReportSummary</code>
    ///             </a>
    ///             objects taht contain summaries of analysis results for all profiling groups in your AWS account.</p>
    public let reportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]?

    public init (
        nextToken: Swift.String? = nil,
        reportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportSummaries = reportSummaries
    }
}

struct GetFindingsReportAccountSummaryOutputResponseBody: Swift.Equatable {
    public let reportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]?
    public let nextToken: Swift.String?
}

extension GetFindingsReportAccountSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reportSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportSummariesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.FindingsReportSummary?].self, forKey: .reportSummaries)
        var reportSummariesDecoded0:[CodeGuruProfilerClientTypes.FindingsReportSummary]? = nil
        if let reportSummariesContainer = reportSummariesContainer {
            reportSummariesDecoded0 = [CodeGuruProfilerClientTypes.FindingsReportSummary]()
            for structure0 in reportSummariesContainer {
                if let structure0 = structure0 {
                    reportSummariesDecoded0?.append(structure0)
                }
            }
        }
        reportSummaries = reportSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNotificationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNotificationConfigurationInput(profilingGroupName: \(Swift.String(describing: profilingGroupName)))"}
}

extension GetNotificationConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetNotificationConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNotificationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNotificationConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNotificationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNotificationConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNotificationConfigurationOutputError>
}

public struct GetNotificationConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetNotificationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetNotificationConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetNotificationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetNotificationConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetNotificationConfigurationOutputError>
}

/// <p>The structure representing the GetNotificationConfigurationRequest.</p>
public struct GetNotificationConfigurationInput: Swift.Equatable {
    /// <p>The name of the profiling group we want to get the notification configuration for.</p>
    public let profilingGroupName: Swift.String?

    public init (
        profilingGroupName: Swift.String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct GetNotificationConfigurationInputBody: Swift.Equatable {
}

extension GetNotificationConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetNotificationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNotificationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNotificationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNotificationConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetNotificationConfigurationOutputResponse(notificationConfiguration: \(Swift.String(describing: notificationConfiguration)))"}
}

extension GetNotificationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNotificationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

/// <p>The structure representing the GetNotificationConfigurationResponse.</p>
public struct GetNotificationConfigurationOutputResponse: Swift.Equatable {
    /// <p>The current notification configuration for this profiling group.</p>
    public let notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?

    public init (
        notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct GetNotificationConfigurationOutputResponseBody: Swift.Equatable {
    public let notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?
}

extension GetNotificationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension GetPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPolicyInput(profilingGroupName: \(Swift.String(describing: profilingGroupName)))"}
}

extension GetPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPolicyOutputError>
}

/// <p>
///             The structure representing the <code>getPolicyRequest</code>.
///         </p>
public struct GetPolicyInput: Swift.Equatable {
    /// <p>The name of the profiling group.</p>
    public let profilingGroupName: Swift.String?

    public init (
        profilingGroupName: Swift.String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct GetPolicyInputBody: Swift.Equatable {
}

extension GetPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPolicyOutputResponse(policy: \(Swift.String(describing: policy)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension GetPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

/// <p>The structure representing the <code>getPolicyResponse</code>.</p>
public struct GetPolicyOutputResponse: Swift.Equatable {
    /// <p>The JSON-formatted resource-based policy attached to the <code>ProfilingGroup</code>.</p>
    public let policy: Swift.String?
    /// <p>A unique identifier for the current revision of the returned policy.</p>
    public let revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetPolicyOutputResponseBody: Swift.Equatable {
    public let policy: Swift.String?
    public let revisionId: Swift.String?
}

extension GetPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileInput(accept: \(Swift.String(describing: accept)), endTime: \(Swift.String(describing: endTime)), maxDepth: \(Swift.String(describing: maxDepth)), period: \(Swift.String(describing: period)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), startTime: \(Swift.String(describing: startTime)))"}
}

extension GetProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accept = input.operationInput.accept {
            input.builder.withHeader(name: "Accept", value: Swift.String(accept))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProfileOutputError>
}

public struct GetProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxDepth = input.operationInput.maxDepth {
            let maxDepthQueryItem = ClientRuntime.URLQueryItem(name: "maxDepth".urlPercentEncoding(), value: Swift.String(maxDepth).urlPercentEncoding())
            input.builder.withQueryItem(maxDepthQueryItem)
        }
        if let period = input.operationInput.period {
            let periodQueryItem = ClientRuntime.URLQueryItem(name: "period".urlPercentEncoding(), value: Swift.String(period).urlPercentEncoding())
            input.builder.withQueryItem(periodQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProfileOutputError>
}

/// <p>The structure representing the getProfileRequest.</p>
public struct GetProfileInput: Swift.Equatable {
    /// <p>
    ///          The format of the returned profiling data. The format maps to the
    ///          <code>Accept</code> and <code>Content-Type</code> headers of the
    ///          HTTP request. You can specify one of the following:
    ///         or the default .
    ///       </p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>application/json</code> — standard JSON format
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>application/x-amzn-ion</code> — the Amazon Ion data format. For more information,
    ///                see <a href="http://amzn.github.io/ion-docs/">Amazon Ion</a>.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let accept: Swift.String?
    /// <p>
    ///          The end time of the requested profile. Specify using
    ///          the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    ///          <p>
    ///          If you specify <code>endTime</code>, then you must also specify <code>period</code>
    ///          or <code>startTime</code>, but not both.
    ///       </p>
    public let endTime: ClientRuntime.Date?
    /// <p>
    ///          The maximum depth of the stacks in the code that is represented in
    ///          the aggregated profile. For example, if CodeGuru Profiler finds a method <code>A</code>,
    ///          which calls method <code>B</code>, which calls method <code>C</code>, which
    ///          calls method <code>D</code>, then the depth is 4. If the <code>maxDepth</code> is
    ///          set to 2, then the aggregated profile contains representations of methods <code>A</code>
    ///          and <code>B</code>.
    ///       </p>
    public let maxDepth: Swift.Int?
    /// <p>
    ///          Used with <code>startTime</code> or <code>endTime</code> to specify
    ///          the time range for the returned aggregated profile. Specify using
    ///          the ISO 8601 format. For example, <code>P1DT1H1M1S</code>.
    ///       </p>
    ///
    ///          <p>
    ///          To get the latest aggregated profile, specify only <code>period</code>.
    ///       </p>
    public let period: Swift.String?
    /// <p>The name of the profiling group to get.</p>
    public let profilingGroupName: Swift.String?
    /// <p>The start time of the profile to get. Specify using
    ///          the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p>
    ///
    ///          <p>
    ///          If you specify <code>startTime</code>, then you must also specify <code>period</code>
    ///          or <code>endTime</code>, but not both.
    ///       </p>
    public let startTime: ClientRuntime.Date?

    public init (
        accept: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxDepth: Swift.Int? = nil,
        period: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.accept = accept
        self.endTime = endTime
        self.maxDepth = maxDepth
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct GetProfileInputBody: Swift.Equatable {
}

extension GetProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileOutputResponse(contentEncoding: \(Swift.String(describing: contentEncoding)), contentType: \(Swift.String(describing: contentType)), profile: \(Swift.String(describing: profile)))"}
}

extension GetProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            self.contentEncoding = contentEncodingHeaderValue
        } else {
            self.contentEncoding = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.profile = data
        } else {
            self.profile = nil
        }
    }
}

/// <p>The structure representing the getProfileResponse.</p>
public struct GetProfileOutputResponse: Swift.Equatable {
    /// <p>The content encoding of the profile.</p>
    public let contentEncoding: Swift.String?
    /// <p>The content type of the profile in the payload. It is
    ///         either <code>application/json</code> or the default
    ///         <code>application/x-amzn-ion</code>.</p>
    public let contentType: Swift.String?
    /// <p>Information about the profile.</p>
    public let profile: ClientRuntime.Data?

    public init (
        contentEncoding: Swift.String? = nil,
        contentType: Swift.String? = nil,
        profile: ClientRuntime.Data? = nil
    )
    {
        self.contentEncoding = contentEncoding
        self.contentType = contentType
        self.profile = profile
    }
}

struct GetProfileOutputResponseBody: Swift.Equatable {
    public let profile: ClientRuntime.Data?
}

extension GetProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension GetRecommendationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecommendationsInput(endTime: \(Swift.String(describing: endTime)), locale: \(Swift.String(describing: locale)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), startTime: \(Swift.String(describing: startTime)))"}
}

extension GetRecommendationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRecommendationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecommendationsOutputError>
}

public struct GetRecommendationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let locale = input.operationInput.locale {
            let localeQueryItem = ClientRuntime.URLQueryItem(name: "locale".urlPercentEncoding(), value: Swift.String(locale).urlPercentEncoding())
            input.builder.withQueryItem(localeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecommendationsOutputError>
}

/// <p>The structure representing the GetRecommendationsRequest.</p>
public struct GetRecommendationsInput: Swift.Equatable {
    /// <p>
    ///             The start time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let endTime: ClientRuntime.Date?
    /// <p>
    ///             The language used to provide analysis. Specify using a string that is one
    ///             of the following <code>BCP 47</code> language codes.
    ///         </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>de-DE</code> - German, Germany
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>en-GB</code> - English, United Kingdom
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>en-US</code> - English, United States
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>es-ES</code> - Spanish, Spain
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>fr-FR</code> - French, France
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>it-IT</code> - Italian, Italy
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ja-JP</code> - Japanese, Japan
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ko-KR</code> - Korean, Republic of Korea
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>pt-BR</code> - Portugese, Brazil
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>zh-CN</code> - Chinese, China
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>zh-TW</code> - Chinese, Taiwan
    ///                 </p>
    ///             </li>
    ///          </ul>
    public let locale: Swift.String?
    /// <p>
    ///             The name of the profiling group to get analysis data about.
    ///         </p>
    public let profilingGroupName: Swift.String?
    /// <p>
    ///             The end time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        locale: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.locale = locale
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct GetRecommendationsInputBody: Swift.Equatable {
}

extension GetRecommendationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommendationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecommendationsOutputResponse(anomalies: \(Swift.String(describing: anomalies)), profileEndTime: \(Swift.String(describing: profileEndTime)), profileStartTime: \(Swift.String(describing: profileStartTime)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), recommendations: \(Swift.String(describing: recommendations)))"}
}

extension GetRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalies = output.anomalies
            self.profileEndTime = output.profileEndTime
            self.profileStartTime = output.profileStartTime
            self.profilingGroupName = output.profilingGroupName
            self.recommendations = output.recommendations
        } else {
            self.anomalies = nil
            self.profileEndTime = nil
            self.profileStartTime = nil
            self.profilingGroupName = nil
            self.recommendations = nil
        }
    }
}

/// <p>The structure representing the GetRecommendationsResponse.</p>
public struct GetRecommendationsOutputResponse: Swift.Equatable {
    /// <p>
    ///             The list of anomalies that the analysis has found for this profile.
    ///         </p>
    public let anomalies: [CodeGuruProfilerClientTypes.Anomaly]?
    /// <p>
    ///             The end time of the profile the analysis data is about. This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let profileEndTime: ClientRuntime.Date?
    /// <p>
    ///             The start time of the profile the analysis data is about. This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let profileStartTime: ClientRuntime.Date?
    /// <p>The name of the profiling group the analysis data is about.</p>
    public let profilingGroupName: Swift.String?
    /// <p>The list of recommendations that the analysis found for this profile.</p>
    public let recommendations: [CodeGuruProfilerClientTypes.Recommendation]?

    public init (
        anomalies: [CodeGuruProfilerClientTypes.Anomaly]? = nil,
        profileEndTime: ClientRuntime.Date? = nil,
        profileStartTime: ClientRuntime.Date? = nil,
        profilingGroupName: Swift.String? = nil,
        recommendations: [CodeGuruProfilerClientTypes.Recommendation]? = nil
    )
    {
        self.anomalies = anomalies
        self.profileEndTime = profileEndTime
        self.profileStartTime = profileStartTime
        self.profilingGroupName = profilingGroupName
        self.recommendations = recommendations
    }
}

struct GetRecommendationsOutputResponseBody: Swift.Equatable {
    public let profilingGroupName: Swift.String?
    public let profileStartTime: ClientRuntime.Date?
    public let profileEndTime: ClientRuntime.Date?
    public let recommendations: [CodeGuruProfilerClientTypes.Recommendation]?
    public let anomalies: [CodeGuruProfilerClientTypes.Anomaly]?
}

extension GetRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalies
        case profileEndTime
        case profileStartTime
        case profilingGroupName
        case recommendations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profilingGroupName)
        profilingGroupName = profilingGroupNameDecoded
        let profileStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .profileStartTime)
        profileStartTime = profileStartTimeDecoded
        let profileEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .profileEndTime)
        profileEndTime = profileEndTimeDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[CodeGuruProfilerClientTypes.Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [CodeGuruProfilerClientTypes.Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let anomaliesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.Anomaly?].self, forKey: .anomalies)
        var anomaliesDecoded0:[CodeGuruProfilerClientTypes.Anomaly]? = nil
        if let anomaliesContainer = anomaliesContainer {
            anomaliesDecoded0 = [CodeGuruProfilerClientTypes.Anomaly]()
            for structure0 in anomaliesContainer {
                if let structure0 = structure0 {
                    anomaliesDecoded0?.append(structure0)
                }
            }
        }
        anomalies = anomaliesDecoded0
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The server encountered an internal error and is unable to complete the request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListFindingsReportsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFindingsReportsInput(dailyReportsOnly: \(Swift.String(describing: dailyReportsOnly)), endTime: \(Swift.String(describing: endTime)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), startTime: \(Swift.String(describing: startTime)))"}
}

extension ListFindingsReportsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListFindingsReportsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFindingsReportsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFindingsReportsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsReportsOutputError>
}

public struct ListFindingsReportsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListFindingsReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListFindingsReportsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListFindingsReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let dailyReportsOnly = input.operationInput.dailyReportsOnly {
            let dailyReportsOnlyQueryItem = ClientRuntime.URLQueryItem(name: "dailyReportsOnly".urlPercentEncoding(), value: Swift.String(dailyReportsOnly).urlPercentEncoding())
            input.builder.withQueryItem(dailyReportsOnlyQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListFindingsReportsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListFindingsReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListFindingsReportsOutputError>
}

/// <p>The structure representing the ListFindingsReportsRequest.</p>
public struct ListFindingsReportsInput: Swift.Equatable {
    /// <p>A <code>Boolean</code> value indicating whether to only return reports from daily profiles. If set
    ///         to <code>True</code>, only analysis data from daily profiles is returned. If set to <code>False</code>,
    ///         analysis data is returned from smaller time windows (for example, one hour).</p>
    public let dailyReportsOnly: Swift.Bool?
    /// <p>
    ///             The end time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let endTime: ClientRuntime.Date?
    /// <p>The maximum number of report results returned by <code>ListFindingsReports</code>
    ///          in paginated output. When this parameter is used, <code>ListFindingsReports</code> only returns
    ///          <code>maxResults</code> results in a single page along with a <code>nextToken</code> response
    ///          element. The remaining results of the initial request
    ///          can be seen by sending another <code>ListFindingsReports</code> request with the returned
    ///          <code>nextToken</code> value.</p>
    public let maxResults: Swift.Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated <code>ListFindingsReportsRequest</code>
    ///          request where <code>maxResults</code> was used and the results exceeded the value of that parameter.
    ///          Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve
    ///       the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: Swift.String?
    /// <p>The name of the profiling group from which to search for analysis data.</p>
    public let profilingGroupName: Swift.String?
    /// <p>
    ///             The start time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let startTime: ClientRuntime.Date?

    public init (
        dailyReportsOnly: Swift.Bool? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.dailyReportsOnly = dailyReportsOnly
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct ListFindingsReportsInputBody: Swift.Equatable {
}

extension ListFindingsReportsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFindingsReportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsReportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsReportsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsReportsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListFindingsReportsOutputResponse(findingsReportSummaries: \(Swift.String(describing: findingsReportSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListFindingsReportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFindingsReportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingsReportSummaries = output.findingsReportSummaries
            self.nextToken = output.nextToken
        } else {
            self.findingsReportSummaries = nil
            self.nextToken = nil
        }
    }
}

/// <p>The structure representing the ListFindingsReportsResponse.</p>
public struct ListFindingsReportsOutputResponse: Swift.Equatable {
    /// <p>The list of analysis results summaries.</p>
    public let findingsReportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]?
    /// <p>The <code>nextToken</code> value to include in a future <code>ListFindingsReports</code> request.
    ///          When the results of a <code>ListFindingsReports</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return.</p>
    public let nextToken: Swift.String?

    public init (
        findingsReportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingsReportSummaries = findingsReportSummaries
        self.nextToken = nextToken
    }
}

struct ListFindingsReportsOutputResponseBody: Swift.Equatable {
    public let findingsReportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]?
    public let nextToken: Swift.String?
}

extension ListFindingsReportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingsReportSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsReportSummariesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.FindingsReportSummary?].self, forKey: .findingsReportSummaries)
        var findingsReportSummariesDecoded0:[CodeGuruProfilerClientTypes.FindingsReportSummary]? = nil
        if let findingsReportSummariesContainer = findingsReportSummariesContainer {
            findingsReportSummariesDecoded0 = [CodeGuruProfilerClientTypes.FindingsReportSummary]()
            for structure0 in findingsReportSummariesContainer {
                if let structure0 = structure0 {
                    findingsReportSummariesDecoded0?.append(structure0)
                }
            }
        }
        findingsReportSummaries = findingsReportSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProfileTimesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfileTimesInput(endTime: \(Swift.String(describing: endTime)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), orderBy: \(Swift.String(describing: orderBy)), period: \(Swift.String(describing: period)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), startTime: \(Swift.String(describing: startTime)))"}
}

extension ListProfileTimesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProfileTimesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProfileTimesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProfileTimesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProfileTimesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProfileTimesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProfileTimesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProfileTimesOutputError>
}

public struct ListProfileTimesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProfileTimesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProfileTimesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProfileTimesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let period = input.operationInput.period {
            let periodQueryItem = ClientRuntime.URLQueryItem(name: "period".urlPercentEncoding(), value: Swift.String(period.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(periodQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let orderBy = input.operationInput.orderBy {
            let orderByQueryItem = ClientRuntime.URLQueryItem(name: "orderBy".urlPercentEncoding(), value: Swift.String(orderBy.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(orderByQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProfileTimesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProfileTimesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProfileTimesOutputError>
}

/// <p>The structure representing the listProfileTimesRequest.</p>
public struct ListProfileTimesInput: Swift.Equatable {
    /// <p>The end time of the time range from which to list the profiles.</p>
    public let endTime: ClientRuntime.Date?
    /// <p>The maximum number of profile time results returned by <code>ListProfileTimes</code>
    ///          in paginated output. When this parameter is used, <code>ListProfileTimes</code> only returns
    ///          <code>maxResults</code> results in a single page with a <code>nextToken</code> response
    ///          element. The remaining results of the initial request
    ///          can be seen by sending another <code>ListProfileTimes</code> request with the returned
    ///          <code>nextToken</code> value.
    ///       </p>
    public let maxResults: Swift.Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///          <code>ListProfileTimes</code> request where <code>maxResults</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous results
    ///          that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve
    ///          the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: Swift.String?
    /// <p>The order (ascending or descending by start time of the profile) to
    ///         use when listing profiles. Defaults to <code>TIMESTAMP_DESCENDING</code>.
    ///       </p>
    public let orderBy: CodeGuruProfilerClientTypes.OrderBy?
    /// <p>
    ///          The aggregation period. This specifies the period during which an aggregation profile
    ///          collects posted agent profiles for a profiling group. There are 3 valid values.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>P1D</code> — 1 day
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT1H</code> — 1 hour
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT5M</code> — 5 minutes
    ///             </p>
    ///             </li>
    ///          </ul>
    public let period: CodeGuruProfilerClientTypes.AggregationPeriod?
    /// <p>The name of the profiling group.</p>
    public let profilingGroupName: Swift.String?
    /// <p>The start time of the time range from which to list the profiles.</p>
    public let startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        orderBy: CodeGuruProfilerClientTypes.OrderBy? = nil,
        period: CodeGuruProfilerClientTypes.AggregationPeriod? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderBy = orderBy
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct ListProfileTimesInputBody: Swift.Equatable {
}

extension ListProfileTimesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProfileTimesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfileTimesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProfileTimesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfileTimesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfileTimesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), profileTimes: \(Swift.String(describing: profileTimes)))"}
}

extension ListProfileTimesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProfileTimesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profileTimes = output.profileTimes
        } else {
            self.nextToken = nil
            self.profileTimes = nil
        }
    }
}

/// <p>The structure representing the listProfileTimesResponse.</p>
public struct ListProfileTimesOutputResponse: Swift.Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListProfileTimes</code> request.
    ///          When the results of a <code>ListProfileTimes</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return. </p>
    public let nextToken: Swift.String?
    /// <p>The list of start times of the available profiles for the aggregation
    ///         period in the specified time range.
    ///       </p>
    public let profileTimes: [CodeGuruProfilerClientTypes.ProfileTime]?

    public init (
        nextToken: Swift.String? = nil,
        profileTimes: [CodeGuruProfilerClientTypes.ProfileTime]? = nil
    )
    {
        self.nextToken = nextToken
        self.profileTimes = profileTimes
    }
}

struct ListProfileTimesOutputResponseBody: Swift.Equatable {
    public let profileTimes: [CodeGuruProfilerClientTypes.ProfileTime]?
    public let nextToken: Swift.String?
}

extension ListProfileTimesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case profileTimes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileTimesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.ProfileTime?].self, forKey: .profileTimes)
        var profileTimesDecoded0:[CodeGuruProfilerClientTypes.ProfileTime]? = nil
        if let profileTimesContainer = profileTimesContainer {
            profileTimesDecoded0 = [CodeGuruProfilerClientTypes.ProfileTime]()
            for structure0 in profileTimesContainer {
                if let structure0 = structure0 {
                    profileTimesDecoded0?.append(structure0)
                }
            }
        }
        profileTimes = profileTimesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProfilingGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfilingGroupsInput(includeDescription: \(Swift.String(describing: includeDescription)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListProfilingGroupsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProfilingGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProfilingGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProfilingGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProfilingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProfilingGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProfilingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProfilingGroupsOutputError>
}

public struct ListProfilingGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProfilingGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProfilingGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProfilingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let includeDescription = input.operationInput.includeDescription {
            let includeDescriptionQueryItem = ClientRuntime.URLQueryItem(name: "includeDescription".urlPercentEncoding(), value: Swift.String(includeDescription).urlPercentEncoding())
            input.builder.withQueryItem(includeDescriptionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProfilingGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProfilingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProfilingGroupsOutputError>
}

/// <p>The structure representing the listProfilingGroupsRequest.</p>
public struct ListProfilingGroupsInput: Swift.Equatable {
    /// <p>A <code>Boolean</code> value indicating whether to include a description. If <code>true</code>,
    ///       then a list of
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a> objects
    ///       that contain detailed information about profiling groups is returned. If <code>false</code>, then
    ///       a list of profiling group names is returned.</p>
    public let includeDescription: Swift.Bool?
    /// <p>The maximum number of profiling groups results returned by <code>ListProfilingGroups</code>
    ///          in paginated output. When this parameter is used, <code>ListProfilingGroups</code> only returns
    ///          <code>maxResults</code> results in a single page along with a <code>nextToken</code> response
    ///          element. The remaining results of the initial request
    ///          can be seen by sending another <code>ListProfilingGroups</code> request with the returned
    ///          <code>nextToken</code> value.
    ///       </p>
    public let maxResults: Swift.Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///          <code>ListProfilingGroups</code> request where <code>maxResults</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous results
    ///          that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve
    ///          the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: Swift.String?

    public init (
        includeDescription: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeDescription = includeDescription
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProfilingGroupsInputBody: Swift.Equatable {
}

extension ListProfilingGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProfilingGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfilingGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProfilingGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfilingGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProfilingGroupsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), profilingGroupNames: \(Swift.String(describing: profilingGroupNames)), profilingGroups: \(Swift.String(describing: profilingGroups)))"}
}

extension ListProfilingGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProfilingGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profilingGroupNames = output.profilingGroupNames
            self.profilingGroups = output.profilingGroups
        } else {
            self.nextToken = nil
            self.profilingGroupNames = nil
            self.profilingGroups = nil
        }
    }
}

/// <p>The structure representing the listProfilingGroupsResponse.</p>
public struct ListProfilingGroupsOutputResponse: Swift.Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListProfilingGroups</code> request.
    ///          When the results of a <code>ListProfilingGroups</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return. </p>
    public let nextToken: Swift.String?
    /// <p>
    ///          A returned list of profiling group names. A list of the names is returned only if
    ///          <code>includeDescription</code> is <code>false</code>, otherwise a list of
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a> objects
    ///          is returned.
    ///       </p>
    public let profilingGroupNames: [Swift.String]?
    /// <p>
    ///          A returned list
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a>
    ///          objects. A list of
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a>
    ///          objects is returned only if <code>includeDescription</code> is <code>true</code>, otherwise a list of profiling group names is returned.
    ///       </p>
    public let profilingGroups: [CodeGuruProfilerClientTypes.ProfilingGroupDescription]?

    public init (
        nextToken: Swift.String? = nil,
        profilingGroupNames: [Swift.String]? = nil,
        profilingGroups: [CodeGuruProfilerClientTypes.ProfilingGroupDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.profilingGroupNames = profilingGroupNames
        self.profilingGroups = profilingGroups
    }
}

struct ListProfilingGroupsOutputResponseBody: Swift.Equatable {
    public let profilingGroupNames: [Swift.String]?
    public let profilingGroups: [CodeGuruProfilerClientTypes.ProfilingGroupDescription]?
    public let nextToken: Swift.String?
}

extension ListProfilingGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case profilingGroupNames
        case profilingGroups
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .profilingGroupNames)
        var profilingGroupNamesDecoded0:[Swift.String]? = nil
        if let profilingGroupNamesContainer = profilingGroupNamesContainer {
            profilingGroupNamesDecoded0 = [Swift.String]()
            for string0 in profilingGroupNamesContainer {
                if let string0 = string0 {
                    profilingGroupNamesDecoded0?.append(string0)
                }
            }
        }
        profilingGroupNames = profilingGroupNamesDecoded0
        let profilingGroupsContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.ProfilingGroupDescription?].self, forKey: .profilingGroups)
        var profilingGroupsDecoded0:[CodeGuruProfilerClientTypes.ProfilingGroupDescription]? = nil
        if let profilingGroupsContainer = profilingGroupsContainer {
            profilingGroupsDecoded0 = [CodeGuruProfilerClientTypes.ProfilingGroupDescription]()
            for structure0 in profilingGroupsContainer {
                if let structure0 = structure0 {
                    profilingGroupsDecoded0?.append(structure0)
                }
            }
        }
        profilingGroups = profilingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the resource that contains the tags to return.
    ///       </p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>
    ///          The list of tags assigned to the specified resource. This is the list of tags
    ///          returned in the response.
    ///       </p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeGuruProfilerClientTypes.Match: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameAddress
        case targetFramesIndex
        case thresholdBreachValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameAddress = frameAddress {
            try encodeContainer.encode(frameAddress, forKey: .frameAddress)
        }
        if let targetFramesIndex = targetFramesIndex {
            try encodeContainer.encode(targetFramesIndex, forKey: .targetFramesIndex)
        }
        if let thresholdBreachValue = thresholdBreachValue {
            try encodeContainer.encode(thresholdBreachValue, forKey: .thresholdBreachValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetFramesIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetFramesIndex)
        targetFramesIndex = targetFramesIndexDecoded
        let frameAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameAddress)
        frameAddress = frameAddressDecoded
        let thresholdBreachValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .thresholdBreachValue)
        thresholdBreachValue = thresholdBreachValueDecoded
    }
}

extension CodeGuruProfilerClientTypes.Match: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Match(frameAddress: \(Swift.String(describing: frameAddress)), targetFramesIndex: \(Swift.String(describing: targetFramesIndex)), thresholdBreachValue: \(Swift.String(describing: thresholdBreachValue)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>The part of a profile that contains a recommendation found during analysis.</p>
    public struct Match: Swift.Equatable {
        /// <p>The location in the profiling graph that contains a recommendation found during analysis.</p>
        public let frameAddress: Swift.String?
        /// <p>The target frame that triggered a match.</p>
        public let targetFramesIndex: Swift.Int?
        /// <p>The value in the profile data that exceeded the recommendation threshold.</p>
        public let thresholdBreachValue: Swift.Double?

        public init (
            frameAddress: Swift.String? = nil,
            targetFramesIndex: Swift.Int? = nil,
            thresholdBreachValue: Swift.Double? = nil
        )
        {
            self.frameAddress = frameAddress
            self.targetFramesIndex = targetFramesIndex
            self.thresholdBreachValue = thresholdBreachValue
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum MetadataField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Unique identifier for the agent instance.
        case agentId
        /// AWS requestId of the Lambda invocation.
        case awsRequestId
        /// Compute platform on which agent is running.
        case computePlatform
        /// Execution environment on which Lambda function is running.
        case executionEnvironment
        /// Function ARN that's used to invoke the Lambda function.
        case lambdaFunctionArn
        /// Memory allocated for the Lambda function.
        case lambdaMemoryLimitInMb
        /// Time in milliseconds for the previous Lambda invocation.
        case lambdaPreviousExecutionTimeInMilliseconds
        /// Time in milliseconds left before the execution times out.
        case lambdaRemainingTimeInMilliseconds
        /// Time in milliseconds between two invocations of the Lambda function.
        case lambdaTimeGapBetweenInvokesInMilliseconds
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataField] {
            return [
                .agentId,
                .awsRequestId,
                .computePlatform,
                .executionEnvironment,
                .lambdaFunctionArn,
                .lambdaMemoryLimitInMb,
                .lambdaPreviousExecutionTimeInMilliseconds,
                .lambdaRemainingTimeInMilliseconds,
                .lambdaTimeGapBetweenInvokesInMilliseconds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentId: return "AgentId"
            case .awsRequestId: return "AwsRequestId"
            case .computePlatform: return "ComputePlatform"
            case .executionEnvironment: return "ExecutionEnvironment"
            case .lambdaFunctionArn: return "LambdaFunctionArn"
            case .lambdaMemoryLimitInMb: return "LambdaMemoryLimitInMB"
            case .lambdaPreviousExecutionTimeInMilliseconds: return "LambdaPreviousExecutionTimeInMilliseconds"
            case .lambdaRemainingTimeInMilliseconds: return "LambdaRemainingTimeInMilliseconds"
            case .lambdaTimeGapBetweenInvokesInMilliseconds: return "LambdaTimeGapBetweenInvokesInMilliseconds"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetadataField(rawValue: rawValue) ?? MetadataField.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.Metric: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameName
        case threadStates
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameName = frameName {
            try encodeContainer.encode(frameName, forKey: .frameName)
        }
        if let threadStates = threadStates {
            var threadStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threadStates)
            for strings0 in threadStates {
                try threadStatesContainer.encode(strings0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameName)
        frameName = frameNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.MetricType.self, forKey: .type)
        type = typeDecoded
        let threadStatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threadStates)
        var threadStatesDecoded0:[Swift.String]? = nil
        if let threadStatesContainer = threadStatesContainer {
            threadStatesDecoded0 = [Swift.String]()
            for string0 in threadStatesContainer {
                if let string0 = string0 {
                    threadStatesDecoded0?.append(string0)
                }
            }
        }
        threadStates = threadStatesDecoded0
    }
}

extension CodeGuruProfilerClientTypes.Metric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Metric(frameName: \(Swift.String(describing: frameName)), threadStates: \(Swift.String(describing: threadStates)), type: \(Swift.String(describing: type)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///             Details about the metric that the analysis used when it detected the anomaly.
    ///             The metric what is analyzed to create recommendations. It includes the name of the
    ///             frame that was analyzed and the type and thread states used to derive the metric
    ///             value for that frame.
    ///         </p>
    public struct Metric: Swift.Equatable {
        /// <p>
        ///             The name of the method that appears as a frame in any stack in a profile.
        ///         </p>
        public let frameName: Swift.String?
        /// <p>
        ///             The list of application runtime thread states that is used to calculate the
        ///             metric value for the frame.
        ///         </p>
        public let threadStates: [Swift.String]?
        /// <p>
        ///             A type that specifies how a metric for a frame is analyzed.
        ///             The supported value <code>AggregatedRelativeTotalTime</code> is an
        ///             aggregation of the metric value for one frame that is calculated across the
        ///             occurences of all frames in a profile.</p>
        public let type: CodeGuruProfilerClientTypes.MetricType?

        public init (
            frameName: Swift.String? = nil,
            threadStates: [Swift.String]? = nil,
            type: CodeGuruProfilerClientTypes.MetricType? = nil
        )
        {
            self.frameName = frameName
            self.threadStates = threadStates
            self.type = type
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum MetricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Metric value aggregated for all instances of a frame name in a profile relative to the root frame.
        case aggregatedrelativetotaltime
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricType] {
            return [
                .aggregatedrelativetotaltime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aggregatedrelativetotaltime: return "AggregatedRelativeTotalTime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetricType(rawValue: rawValue) ?? MetricType.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.NotificationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channels0 in channels {
                try channelsContainer.encode(channels0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent(Swift.Set<CodeGuruProfilerClientTypes.Channel>.self, forKey: .channels)
        var channelsDecoded0:Swift.Set<CodeGuruProfilerClientTypes.Channel>? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = Swift.Set<CodeGuruProfilerClientTypes.Channel>()
            for structure0 in channelsContainer {
                channelsDecoded0?.insert(structure0)
            }
        }
        channels = channelsDecoded0
    }
}

extension CodeGuruProfilerClientTypes.NotificationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationConfiguration(channels: \(Swift.String(describing: channels)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>The configuration for notifications stored for each profiling group. This includes up to
    ///          to two channels and a list of event publishers associated with each channel.</p>
    public struct NotificationConfiguration: Swift.Equatable {
        /// <p>List of up to two channels to be used for sending notifications for events detected from
        ///          the application profile.</p>
        public let channels: Swift.Set<CodeGuruProfilerClientTypes.Channel>?

        public init (
            channels: Swift.Set<CodeGuruProfilerClientTypes.Channel>? = nil
        )
        {
            self.channels = channels
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum OrderBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Order by timestamp in ascending order.
        case timestampAscending
        /// Order by timestamp in descending order.
        case timestampDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderBy] {
            return [
                .timestampAscending,
                .timestampDescending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .timestampAscending: return "TimestampAscending"
            case .timestampDescending: return "TimestampDescending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.Pattern: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countersToAggregate
        case description
        case id
        case name
        case resolutionSteps
        case targetFrames
        case thresholdPercent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countersToAggregate = countersToAggregate {
            var countersToAggregateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .countersToAggregate)
            for strings0 in countersToAggregate {
                try countersToAggregateContainer.encode(strings0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolutionSteps = resolutionSteps {
            try encodeContainer.encode(resolutionSteps, forKey: .resolutionSteps)
        }
        if let targetFrames = targetFrames {
            var targetFramesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetFrames)
            for targetframes0 in targetFrames {
                var targetframes0Container = targetFramesContainer.nestedUnkeyedContainer()
                for targetframe1 in targetframes0 {
                    try targetframes0Container.encode(targetframe1)
                }
            }
        }
        if thresholdPercent != 0.0 {
            try encodeContainer.encode(thresholdPercent, forKey: .thresholdPercent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resolutionStepsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionSteps)
        resolutionSteps = resolutionStepsDecoded
        let targetFramesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .targetFrames)
        var targetFramesDecoded0:[[Swift.String]]? = nil
        if let targetFramesContainer = targetFramesContainer {
            targetFramesDecoded0 = [[Swift.String]]()
            for list0 in targetFramesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    targetFramesDecoded0?.append(list0Decoded0)
                }
            }
        }
        targetFrames = targetFramesDecoded0
        let thresholdPercentDecoded = try containerValues.decode(Swift.Double.self, forKey: .thresholdPercent)
        thresholdPercent = thresholdPercentDecoded
        let countersToAggregateContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .countersToAggregate)
        var countersToAggregateDecoded0:[Swift.String]? = nil
        if let countersToAggregateContainer = countersToAggregateContainer {
            countersToAggregateDecoded0 = [Swift.String]()
            for string0 in countersToAggregateContainer {
                if let string0 = string0 {
                    countersToAggregateDecoded0?.append(string0)
                }
            }
        }
        countersToAggregate = countersToAggregateDecoded0
    }
}

extension CodeGuruProfilerClientTypes.Pattern: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Pattern(countersToAggregate: \(Swift.String(describing: countersToAggregate)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), resolutionSteps: \(Swift.String(describing: resolutionSteps)), targetFrames: \(Swift.String(describing: targetFrames)), thresholdPercent: \(Swift.String(describing: thresholdPercent)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///             A set of rules used to make a recommendation during an analysis.
    ///         </p>
    public struct Pattern: Swift.Equatable {
        /// <p>
        ///             A list of the different counters used to determine if there is a match.
        ///         </p>
        public let countersToAggregate: [Swift.String]?
        /// <p>The description of the recommendation. This explains a potential
        ///             inefficiency in a profiled application.</p>
        public let description: Swift.String?
        /// <p>The universally unique identifier (UUID) of this pattern.</p>
        public let id: Swift.String?
        /// <p>The name for this pattern.</p>
        public let name: Swift.String?
        /// <p>
        ///             A string that contains the steps recommended to address the potential inefficiency.
        ///         </p>
        public let resolutionSteps: Swift.String?
        /// <p>A list of frame names that were searched during the analysis that generated
        ///             a recommendation.</p>
        public let targetFrames: [[Swift.String]]?
        /// <p>
        ///             The percentage of time an application spends in one method that triggers
        ///             a recommendation. The percentage of time is the same as the percentage of
        ///             the total gathered sample counts during analysis.
        ///         </p>
        public let thresholdPercent: Swift.Double

        public init (
            countersToAggregate: [Swift.String]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resolutionSteps: Swift.String? = nil,
            targetFrames: [[Swift.String]]? = nil,
            thresholdPercent: Swift.Double = 0.0
        )
        {
            self.countersToAggregate = countersToAggregate
            self.description = description
            self.id = id
            self.name = name
            self.resolutionSteps = resolutionSteps
            self.targetFrames = targetFrames
            self.thresholdPercent = thresholdPercent
        }
    }

}

public struct PostAgentProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PostAgentProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PostAgentProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PostAgentProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let agentProfile = input.operationInput.agentProfile {
            let agentProfiledata = agentProfile
            let agentProfilebody = ClientRuntime.HttpBody.data(agentProfiledata)
            input.builder.withBody(agentProfilebody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PostAgentProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PostAgentProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PostAgentProfileOutputError>
}

extension PostAgentProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostAgentProfileInput(agentProfile: \(Swift.String(describing: agentProfile)), contentType: \(Swift.String(describing: contentType)), profileToken: \(Swift.String(describing: profileToken)), profilingGroupName: \(Swift.String(describing: profilingGroupName)))"}
}

extension PostAgentProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentProfile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentProfile = agentProfile {
            try encodeContainer.encode(agentProfile.base64EncodedString(), forKey: .agentProfile)
        }
    }
}

public struct PostAgentProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PostAgentProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PostAgentProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PostAgentProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: Swift.String(contentType))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PostAgentProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PostAgentProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PostAgentProfileOutputError>
}

public struct PostAgentProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PostAgentProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PostAgentProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PostAgentProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let profileToken = input.operationInput.profileToken {
            let profileTokenQueryItem = ClientRuntime.URLQueryItem(name: "profileToken".urlPercentEncoding(), value: Swift.String(profileToken).urlPercentEncoding())
            input.builder.withQueryItem(profileTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PostAgentProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PostAgentProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PostAgentProfileOutputError>
}

/// <p>The structure representing the postAgentProfileRequest.</p>
public struct PostAgentProfileInput: Swift.Equatable {
    /// <p>
    ///          The submitted profiling data.
    ///       </p>
    public let agentProfile: ClientRuntime.Data?
    /// <p>
    ///          The format of the submitted profiling data. The format maps to the
    ///          <code>Accept</code> and <code>Content-Type</code> headers of the
    ///          HTTP request. You can specify one of the following:
    ///          or the default .
    ///       </p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>application/json</code> — standard JSON format
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>application/x-amzn-ion</code> — the Amazon Ion data format. For more information,
    ///                see <a href="http://amzn.github.io/ion-docs/">Amazon Ion</a>.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let contentType: Swift.String?
    /// <p> Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the
    ///          accidental submission of duplicate profiling data if there are failures and retries. </p>
    public var profileToken: Swift.String?
    /// <p>
    ///          The name of the profiling group with the aggregated profile that receives the
    ///          submitted profiling data.
    ///       </p>
    public let profilingGroupName: Swift.String?

    public init (
        agentProfile: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        profileToken: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.agentProfile = agentProfile
        self.contentType = contentType
        self.profileToken = profileToken
        self.profilingGroupName = profilingGroupName
    }
}

struct PostAgentProfileInputBody: Swift.Equatable {
    public let agentProfile: ClientRuntime.Data?
}

extension PostAgentProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentProfileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .agentProfile)
        agentProfile = agentProfileDecoded
    }
}

extension PostAgentProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostAgentProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PostAgentProfileOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostAgentProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostAgentProfileOutputResponse()"}
}

extension PostAgentProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The structure representing the postAgentProfileResponse.</p>
public struct PostAgentProfileOutputResponse: Swift.Equatable {

    public init() {}
}

struct PostAgentProfileOutputResponseBody: Swift.Equatable {
}

extension PostAgentProfileOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CodeGuruProfilerClientTypes.ProfileTime: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let start = start {
            try encodeContainer.encode(start.timeIntervalSince1970, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .start)
        start = startDecoded
    }
}

extension CodeGuruProfilerClientTypes.ProfileTime: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProfileTime(start: \(Swift.String(describing: start)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///          Contains the start time of a profile.
    ///       </p>
    public struct ProfileTime: Swift.Equatable {
        /// <p>The start time of a profile. It is specified using
        ///          the ISO 8601 format. For example,
        ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p>
        public let start: ClientRuntime.Date?

        public init (
            start: ClientRuntime.Date? = nil
        )
        {
            self.start = start
        }
    }

}

extension CodeGuruProfilerClientTypes.ProfilingGroupDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
        case arn
        case computePlatform
        case createdAt
        case name
        case profilingStatus
        case tags
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentOrchestrationConfig = agentOrchestrationConfig {
            try encodeContainer.encode(agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computePlatform = computePlatform {
            try encodeContainer.encode(computePlatform.rawValue, forKey: .computePlatform)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let profilingStatus = profilingStatus {
            try encodeContainer.encode(profilingStatus, forKey: .profilingStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let agentOrchestrationConfigDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AgentOrchestrationConfig.self, forKey: .agentOrchestrationConfig)
        agentOrchestrationConfig = agentOrchestrationConfigDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let profilingStatusDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ProfilingStatus.self, forKey: .profilingStatus)
        profilingStatus = profilingStatusDecoded
        let computePlatformDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ComputePlatform.self, forKey: .computePlatform)
        computePlatform = computePlatformDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeGuruProfilerClientTypes.ProfilingGroupDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProfilingGroupDescription(agentOrchestrationConfig: \(Swift.String(describing: agentOrchestrationConfig)), arn: \(Swift.String(describing: arn)), computePlatform: \(Swift.String(describing: computePlatform)), createdAt: \(Swift.String(describing: createdAt)), name: \(Swift.String(describing: name)), profilingStatus: \(Swift.String(describing: profilingStatus)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///          Contains information about a profiling group.
    ///       </p>
    public struct ProfilingGroupDescription: Swift.Equatable {
        /// <p>
        ///          An <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AgentOrchestrationConfig.html">
        ///                <code>AgentOrchestrationConfig</code>
        ///             </a>
        ///          object that indicates if the profiling group is enabled for profiled or not.
        ///       </p>
        public let agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
        /// <p>The Amazon Resource Name (ARN) identifying the profiling group resource.</p>
        public let arn: Swift.String?
        /// <p>
        ///          The compute platform of the profiling group. If it is set to <code>AWSLambda</code>, then
        ///          the profiled application runs on AWS Lambda. If it is set to <code>Default</code>, then the
        ///          profiled application runs on a compute platform that is not AWS Lambda, such an Amazon EC2 instance,
        ///          an on-premises server, or a different platform. The default is <code>Default</code>.
        ///       </p>
        public let computePlatform: CodeGuruProfilerClientTypes.ComputePlatform?
        /// <p>The time when the profiling group was created. Specify using
        ///          the ISO 8601 format. For example,
        ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        ///       </p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The name of the profiling group.</p>
        public let name: Swift.String?
        /// <p>
        ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingStatus.html">
        ///                <code>ProfilingStatus</code>
        ///             </a> object
        ///          that includes information about the last time a profile agent pinged back,
        ///          the last time a profile was received, and the aggregation period and start time for the
        ///          most recent aggregated profile.
        ///       </p>
        public let profilingStatus: CodeGuruProfilerClientTypes.ProfilingStatus?
        /// <p>
        ///          A list of the tags that belong to this profiling group.
        ///       </p>
        public let tags: [Swift.String:Swift.String]?
        /// <p>
        ///          The date and time when the profiling group was last updated. Specify using
        ///          the ISO 8601 format. For example,
        ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        ///       </p>
        public let updatedAt: ClientRuntime.Date?

        public init (
            agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig? = nil,
            arn: Swift.String? = nil,
            computePlatform: CodeGuruProfilerClientTypes.ComputePlatform? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            profilingStatus: CodeGuruProfilerClientTypes.ProfilingStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentOrchestrationConfig = agentOrchestrationConfig
            self.arn = arn
            self.computePlatform = computePlatform
            self.createdAt = createdAt
            self.name = name
            self.profilingStatus = profilingStatus
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension CodeGuruProfilerClientTypes.ProfilingStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestAgentOrchestratedAt
        case latestAgentProfileReportedAt
        case latestAggregatedProfile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestAgentOrchestratedAt = latestAgentOrchestratedAt {
            try encodeContainer.encode(latestAgentOrchestratedAt.timeIntervalSince1970, forKey: .latestAgentOrchestratedAt)
        }
        if let latestAgentProfileReportedAt = latestAgentProfileReportedAt {
            try encodeContainer.encode(latestAgentProfileReportedAt.timeIntervalSince1970, forKey: .latestAgentProfileReportedAt)
        }
        if let latestAggregatedProfile = latestAggregatedProfile {
            try encodeContainer.encode(latestAggregatedProfile, forKey: .latestAggregatedProfile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestAgentProfileReportedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .latestAgentProfileReportedAt)
        latestAgentProfileReportedAt = latestAgentProfileReportedAtDecoded
        let latestAggregatedProfileDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AggregatedProfileTime.self, forKey: .latestAggregatedProfile)
        latestAggregatedProfile = latestAggregatedProfileDecoded
        let latestAgentOrchestratedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .latestAgentOrchestratedAt)
        latestAgentOrchestratedAt = latestAgentOrchestratedAtDecoded
    }
}

extension CodeGuruProfilerClientTypes.ProfilingStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProfilingStatus(latestAgentOrchestratedAt: \(Swift.String(describing: latestAgentOrchestratedAt)), latestAgentProfileReportedAt: \(Swift.String(describing: latestAgentProfileReportedAt)), latestAggregatedProfile: \(Swift.String(describing: latestAggregatedProfile)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///          Profiling status includes information about the last time a profile agent pinged back,
    ///          the last time a profile was received, and the aggregation period and start time for the
    ///          most recent aggregated profile.
    ///       </p>
    public struct ProfilingStatus: Swift.Equatable {
        /// <p>The date and time when the profiling agent most recently pinged back. Specify using
        ///          the ISO 8601 format. For example,
        ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p>
        public let latestAgentOrchestratedAt: ClientRuntime.Date?
        /// <p>The date and time when the most recent profile was received. Specify using
        ///          the ISO 8601 format. For example,
        ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p>
        public let latestAgentProfileReportedAt: ClientRuntime.Date?
        /// <p>
        ///          An <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AggregatedProfileTime.html">
        ///                <code>AggregatedProfileTime</code>
        ///             </a>
        ///          object that contains the aggregation period and start time for an aggregated profile.
        ///       </p>
        public let latestAggregatedProfile: CodeGuruProfilerClientTypes.AggregatedProfileTime?

        public init (
            latestAgentOrchestratedAt: ClientRuntime.Date? = nil,
            latestAgentProfileReportedAt: ClientRuntime.Date? = nil,
            latestAggregatedProfile: CodeGuruProfilerClientTypes.AggregatedProfileTime? = nil
        )
        {
            self.latestAgentOrchestratedAt = latestAgentOrchestratedAt
            self.latestAgentProfileReportedAt = latestAgentProfileReportedAt
            self.latestAggregatedProfile = latestAggregatedProfile
        }
    }

}

public struct PutPermissionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPermissionOutputError>
}

extension PutPermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPermissionInput(actionGroup: \(Swift.String(describing: actionGroup)), principals: \(Swift.String(describing: principals)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension PutPermissionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principals
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principals0 in principals {
                try principalsContainer.encode(principals0)
            }
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct PutPermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPermissionOutputError>
}

public struct PutPermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutPermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutPermissionOutputError>
}

/// <p>The structure representing the <code>putPermissionRequest</code>.</p>
public struct PutPermissionInput: Swift.Equatable {
    /// <p>
    ///             Specifies an action group that contains permissions to add to
    ///             a profiling group resource. One action group is supported, <code>agentPermissions</code>, which
    ///             grants permission to perform actions required by the profiling agent, <code>ConfigureAgent</code>
    ///             and <code>PostAgentProfile</code> permissions.
    ///         </p>
    public let actionGroup: CodeGuruProfilerClientTypes.ActionGroup?
    /// <p>
    ///             A list ARNs for the roles and users you want to grant access to the profiling group.
    ///             Wildcards are not are supported in the ARNs.
    ///         </p>
    public let principals: [Swift.String]?
    /// <p>The name of the profiling group to grant access to.</p>
    public let profilingGroupName: Swift.String?
    /// <p>
    ///             A universally unique identifier (UUID) for the revision of the policy you
    ///             are adding to the profiling group. Do not specify
    ///             this when you add permissions to a profiling group for the first time. If a policy already exists on the
    ///             profiling group, you must specify the <code>revisionId</code>.
    ///         </p>
    public let revisionId: Swift.String?

    public init (
        actionGroup: CodeGuruProfilerClientTypes.ActionGroup? = nil,
        principals: [Swift.String]? = nil,
        profilingGroupName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.actionGroup = actionGroup
        self.principals = principals
        self.profilingGroupName = profilingGroupName
        self.revisionId = revisionId
    }
}

struct PutPermissionInputBody: Swift.Equatable {
    public let principals: [Swift.String]?
    public let revisionId: Swift.String?
}

extension PutPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principals
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PutPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPermissionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutPermissionOutputResponse(policy: \(Swift.String(describing: policy)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension PutPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

/// <p>The structure representing the <code>putPermissionResponse</code>.</p>
public struct PutPermissionOutputResponse: Swift.Equatable {
    /// <p>
    ///             The JSON-formatted resource-based policy on the profiling group that includes the
    ///             added permissions.
    ///         </p>
    public let policy: Swift.String?
    /// <p> A universally unique identifier (UUID) for the revision of the resource-based policy
    ///             that includes the added permissions. The JSON-formatted policy is in the
    ///                 <code>policy</code> element of the response. </p>
    public let revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct PutPermissionOutputResponseBody: Swift.Equatable {
    public let policy: Swift.String?
    public let revisionId: Swift.String?
}

extension PutPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension CodeGuruProfilerClientTypes.Recommendation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allMatchesCount
        case allMatchesSum
        case endTime
        case pattern
        case startTime
        case topMatches
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allMatchesCount = allMatchesCount {
            try encodeContainer.encode(allMatchesCount, forKey: .allMatchesCount)
        }
        if let allMatchesSum = allMatchesSum {
            try encodeContainer.encode(allMatchesSum, forKey: .allMatchesSum)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let topMatches = topMatches {
            var topMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topMatches)
            for matches0 in topMatches {
                try topMatchesContainer.encode(matches0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allMatchesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allMatchesCount)
        allMatchesCount = allMatchesCountDecoded
        let allMatchesSumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .allMatchesSum)
        allMatchesSum = allMatchesSumDecoded
        let patternDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.Pattern.self, forKey: .pattern)
        pattern = patternDecoded
        let topMatchesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.Match?].self, forKey: .topMatches)
        var topMatchesDecoded0:[CodeGuruProfilerClientTypes.Match]? = nil
        if let topMatchesContainer = topMatchesContainer {
            topMatchesDecoded0 = [CodeGuruProfilerClientTypes.Match]()
            for structure0 in topMatchesContainer {
                if let structure0 = structure0 {
                    topMatchesDecoded0?.append(structure0)
                }
            }
        }
        topMatches = topMatchesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension CodeGuruProfilerClientTypes.Recommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Recommendation(allMatchesCount: \(Swift.String(describing: allMatchesCount)), allMatchesSum: \(Swift.String(describing: allMatchesSum)), endTime: \(Swift.String(describing: endTime)), pattern: \(Swift.String(describing: pattern)), startTime: \(Swift.String(describing: startTime)), topMatches: \(Swift.String(describing: topMatches)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>A potential improvement that was found from analyzing the profiling data.</p>
    public struct Recommendation: Swift.Equatable {
        /// <p>How many different places in the profile graph triggered a match.</p>
        public let allMatchesCount: Swift.Int?
        /// <p>How much of the total sample count is potentially affected.</p>
        public let allMatchesSum: Swift.Double?
        /// <p>End time of the profile that was used by this analysis.
        ///             This is specified
        ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        ///             millisecond past June 1, 2020 1:15:02 PM UTC.</p>
        public let endTime: ClientRuntime.Date?
        /// <p>The pattern that analysis recognized in the profile to make this recommendation.</p>
        public let pattern: CodeGuruProfilerClientTypes.Pattern?
        /// <p>The start time of the profile that was used by this analysis.
        ///         This is specified
        ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        ///             millisecond past June 1, 2020 1:15:02 PM UTC.</p>
        public let startTime: ClientRuntime.Date?
        /// <p>List of the matches with most impact. </p>
        public let topMatches: [CodeGuruProfilerClientTypes.Match]?

        public init (
            allMatchesCount: Swift.Int? = nil,
            allMatchesSum: Swift.Double? = nil,
            endTime: ClientRuntime.Date? = nil,
            pattern: CodeGuruProfilerClientTypes.Pattern? = nil,
            startTime: ClientRuntime.Date? = nil,
            topMatches: [CodeGuruProfilerClientTypes.Match]? = nil
        )
        {
            self.allMatchesCount = allMatchesCount
            self.allMatchesSum = allMatchesSum
            self.endTime = endTime
            self.pattern = pattern
            self.startTime = startTime
            self.topMatches = topMatches
        }
    }

}

extension RemoveNotificationChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveNotificationChannelInput(channelId: \(Swift.String(describing: channelId)), profilingGroupName: \(Swift.String(describing: profilingGroupName)))"}
}

extension RemoveNotificationChannelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RemoveNotificationChannelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveNotificationChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveNotificationChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveNotificationChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveNotificationChannelOutputError>
}

public struct RemoveNotificationChannelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveNotificationChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveNotificationChannelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveNotificationChannelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveNotificationChannelOutputError>
}

/// <p>The structure representing the RemoveNotificationChannelRequest.</p>
public struct RemoveNotificationChannelInput: Swift.Equatable {
    /// <p>The id of the channel that we want to stop receiving notifications.</p>
    public let channelId: Swift.String?
    /// <p>The name of the profiling group we want to change notification configuration for.</p>
    public let profilingGroupName: Swift.String?

    public init (
        channelId: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.profilingGroupName = profilingGroupName
    }
}

struct RemoveNotificationChannelInputBody: Swift.Equatable {
}

extension RemoveNotificationChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveNotificationChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveNotificationChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveNotificationChannelOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveNotificationChannelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveNotificationChannelOutputResponse(notificationConfiguration: \(Swift.String(describing: notificationConfiguration)))"}
}

extension RemoveNotificationChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveNotificationChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

/// <p>The structure representing the RemoveNotificationChannelResponse.</p>
public struct RemoveNotificationChannelOutputResponse: Swift.Equatable {
    /// <p>The new notification configuration for this profiling group.</p>
    public let notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?

    public init (
        notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct RemoveNotificationChannelOutputResponseBody: Swift.Equatable {
    public let notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?
}

extension RemoveNotificationChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension RemovePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemovePermissionInput(actionGroup: \(Swift.String(describing: actionGroup)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension RemovePermissionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RemovePermissionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemovePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "revisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemovePermissionOutputError>
}

/// <p>
///
///             The structure representing the <code>removePermissionRequest</code>.</p>
public struct RemovePermissionInput: Swift.Equatable {
    /// <p>
    ///             Specifies an action group that contains the permissions to remove from
    ///             a profiling group's resource-based policy. One action group is supported, <code>agentPermissions</code>, which
    ///             grants <code>ConfigureAgent</code> and <code>PostAgentProfile</code> permissions.
    ///         </p>
    public let actionGroup: CodeGuruProfilerClientTypes.ActionGroup?
    /// <p>The name of the profiling group.</p>
    public let profilingGroupName: Swift.String?
    /// <p>
    ///             A universally unique identifier (UUID) for the revision of the resource-based policy from which
    ///             you want to remove permissions.
    ///         </p>
    public let revisionId: Swift.String?

    public init (
        actionGroup: CodeGuruProfilerClientTypes.ActionGroup? = nil,
        profilingGroupName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.actionGroup = actionGroup
        self.profilingGroupName = profilingGroupName
        self.revisionId = revisionId
    }
}

struct RemovePermissionInputBody: Swift.Equatable {
}

extension RemovePermissionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemovePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemovePermissionOutputResponse(policy: \(Swift.String(describing: policy)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension RemovePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemovePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

/// <p>The structure representing the <code>removePermissionResponse</code>.</p>
public struct RemovePermissionOutputResponse: Swift.Equatable {
    /// <p>
    ///             The JSON-formatted resource-based policy on the profiling group after
    ///             the specified permissions were removed.
    ///         </p>
    public let policy: Swift.String?
    /// <p> A universally unique identifier (UUID) for the revision of the resource-based policy
    ///             after the specified permissions were removed. The updated JSON-formatted policy is in the
    ///                 <code>policy</code> element of the response. </p>
    public let revisionId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct RemovePermissionOutputResponseBody: Swift.Equatable {
    public let policy: Swift.String?
    public let revisionId: Swift.String?
}

extension RemovePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case revisionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in the request does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded your service quota. To perform the requested action,
///         remove some of the relevant resources, or use <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas</a> to request a
///         service quota increase.
///       </p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SubmitFeedbackInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubmitFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubmitFeedbackOutputError>
}

extension SubmitFeedbackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubmitFeedbackInput(anomalyInstanceId: \(Swift.String(describing: anomalyInstanceId)), comment: \(Swift.String(describing: comment)), profilingGroupName: \(Swift.String(describing: profilingGroupName)), type: \(Swift.String(describing: type)))"}
}

extension SubmitFeedbackInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct SubmitFeedbackInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubmitFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubmitFeedbackOutputError>
}

public struct SubmitFeedbackInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SubmitFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SubmitFeedbackOutputError>
}

/// <p>The structure representing the SubmitFeedbackRequest.</p>
public struct SubmitFeedbackInput: Swift.Equatable {
    /// <p>The universally unique identifier (UUID) of the
    ///             <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AnomalyInstance.html">
    ///                <code>AnomalyInstance</code>
    ///             </a> object
    ///             that is included in the analysis data.</p>
    public let anomalyInstanceId: Swift.String?
    /// <p>Optional feedback about this anomaly.</p>
    public let comment: Swift.String?
    /// <p>The name of the profiling group that is associated with the analysis data.</p>
    public let profilingGroupName: Swift.String?
    /// <p>
    ///             The feedback tpye. Thee are two valid values, <code>Positive</code> and <code>Negative</code>.
    ///         </p>
    public let type: CodeGuruProfilerClientTypes.FeedbackType?

    public init (
        anomalyInstanceId: Swift.String? = nil,
        comment: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        type: CodeGuruProfilerClientTypes.FeedbackType? = nil
    )
    {
        self.anomalyInstanceId = anomalyInstanceId
        self.comment = comment
        self.profilingGroupName = profilingGroupName
        self.type = type
    }
}

struct SubmitFeedbackInputBody: Swift.Equatable {
    public let type: CodeGuruProfilerClientTypes.FeedbackType?
    public let comment: Swift.String?
}

extension SubmitFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.FeedbackType.self, forKey: .type)
        type = typeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension SubmitFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubmitFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubmitFeedbackOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubmitFeedbackOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SubmitFeedbackOutputResponse()"}
}

extension SubmitFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The structure representing the SubmitFeedbackResponse.</p>
public struct SubmitFeedbackOutputResponse: Swift.Equatable {

    public init() {}
}

struct SubmitFeedbackOutputResponseBody: Swift.Equatable {
}

extension SubmitFeedbackOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the resource that the tags are added to.
    ///       </p>
    public let resourceArn: Swift.String?
    /// <p>
    ///          The list of tags that are added to the specified resource.
    ///       </p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeGuruProfilerClientTypes.TimestampStructure: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value.timeIntervalSince1970, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodeGuruProfilerClientTypes.TimestampStructure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimestampStructure(value: \(Swift.String(describing: value)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>
    ///          A data type that contains a <code>Timestamp</code> object. This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public struct TimestampStructure: Swift.Equatable {
        /// <p>
        ///          A <code>Timestamp</code>. This is specified
        ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
        ///          millisecond past June 1, 2020 1:15:02 PM UTC.
        ///       </p>
        public let value: ClientRuntime.Date?

        public init (
            value: ClientRuntime.Date? = nil
        )
        {
            self.value = value
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the resource that contains the tags to remove.
    ///       </p>
    public let resourceArn: Swift.String?
    /// <p>
    ///          A list of tag keys. Existing tags of resources with keys in this list are removed from
    ///          the specified resource.
    ///       </p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateProfilingGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProfilingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProfilingGroupOutputError>
}

extension UpdateProfilingGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfilingGroupInput(agentOrchestrationConfig: \(Swift.String(describing: agentOrchestrationConfig)), profilingGroupName: \(Swift.String(describing: profilingGroupName)))"}
}

extension UpdateProfilingGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentOrchestrationConfig = agentOrchestrationConfig {
            try encodeContainer.encode(agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
        }
    }
}

public struct UpdateProfilingGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProfilingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProfilingGroupOutputError>
}

public struct UpdateProfilingGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProfilingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProfilingGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProfilingGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProfilingGroupOutputError>
}

/// <p>The structure representing the updateProfilingGroupRequest.</p>
public struct UpdateProfilingGroupInput: Swift.Equatable {
    /// <p>
    ///          Specifies whether profiling is enabled or disabled for a profiling group.
    ///       </p>
    public let agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
    /// <p>The name of the profiling group to update.</p>
    public let profilingGroupName: Swift.String?

    public init (
        agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.agentOrchestrationConfig = agentOrchestrationConfig
        self.profilingGroupName = profilingGroupName
    }
}

struct UpdateProfilingGroupInputBody: Swift.Equatable {
    public let agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
}

extension UpdateProfilingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentOrchestrationConfigDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AgentOrchestrationConfig.self, forKey: .agentOrchestrationConfig)
        agentOrchestrationConfig = agentOrchestrationConfigDecoded
    }
}

extension UpdateProfilingGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProfilingGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProfilingGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProfilingGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfilingGroupOutputResponse(profilingGroup: \(Swift.String(describing: profilingGroup)))"}
}

extension UpdateProfilingGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: CodeGuruProfilerClientTypes.ProfilingGroupDescription = try responseDecoder.decode(responseBody: data)
                self.profilingGroup = output
            } else {
                self.profilingGroup = nil
            }
        } else {
            self.profilingGroup = nil
        }
    }
}

/// <p>The structure representing the updateProfilingGroupResponse.</p>
public struct UpdateProfilingGroupOutputResponse: Swift.Equatable {
    /// <p>
    ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a>
    ///          that contains information about the returned updated profiling group.
    ///       </p>
    public let profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?

    public init (
        profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription? = nil
    )
    {
        self.profilingGroup = profilingGroup
    }
}

struct UpdateProfilingGroupOutputResponseBody: Swift.Equatable {
    public let profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?
}

extension UpdateProfilingGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profilingGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ProfilingGroupDescription.self, forKey: .profilingGroup)
        profilingGroup = profilingGroupDecoded
    }
}

extension CodeGuruProfilerClientTypes.UserFeedback: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.FeedbackType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CodeGuruProfilerClientTypes.UserFeedback: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserFeedback(type: \(Swift.String(describing: type)))"}
}

extension CodeGuruProfilerClientTypes {
    /// <p>Feedback that can be submitted for each instance of an anomaly by the user.
    ///             Feedback is be used for improvements in generating recommendations for the application.</p>
    public struct UserFeedback: Swift.Equatable {
        /// <p>Optional <code>Positive</code> or <code>Negative</code> feedback submitted by
        ///             the user about whether the recommendation is useful or not.</p>
        public let type: CodeGuruProfilerClientTypes.FeedbackType?

        public init (
            type: CodeGuruProfilerClientTypes.FeedbackType? = nil
        )
        {
            self.type = type
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter is not valid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
