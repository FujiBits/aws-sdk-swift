// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

/// <p>The structure representing the BatchGetFrameMetricDataRequest.</p>
public struct BatchGetFrameMetricDataInput: Equatable {
    /// <p>
    ///          The end time of the time period for the returned time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let endTime: Date?
    /// <p>
    ///          The details of the metrics that are used to request a time series of values. The metric includes
    ///          the name of the frame, the aggregation type to calculate the metric value for the
    ///          frame, and the thread states to use to get the count for the metric value of the frame.</p>
    public let frameMetrics: [FrameMetric]?
    /// <p>
    ///          The duration of the frame metrics used to return the time series values.
    ///          Specify using the ISO 8601 format. The maximum period duration
    ///          is one day (<code>PT24H</code> or <code>P1D</code>).
    ///       </p>
    public let period: String?
    /// <p>
    ///          The name of the profiling group associated with the
    ///          the frame metrics used to return the time series values.
    ///       </p>
    public let profilingGroupName: String?
    /// <p>
    ///          The start time of the time period for the frame metrics used to return the time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let startTime: Date?
    /// <p>The requested resolution of time steps for the returned time series of values.
    ///          If the requested target resolution is not available due to data not being retained we provide a best effort
    ///          result by falling back to the most granular available resolution after the target resolution.
    ///          There are 3 valid values.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>P1D</code> — 1 day
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT1H</code> — 1 hour
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT5M</code> — 5 minutes
    ///             </p>
    ///             </li>
    ///          </ul>
    public let targetResolution: AggregationPeriod?

    public init (
        endTime: Date? = nil,
        frameMetrics: [FrameMetric]? = nil,
        period: String? = nil,
        profilingGroupName: String? = nil,
        startTime: Date? = nil,
        targetResolution: AggregationPeriod? = nil
    )
    {
        self.endTime = endTime
        self.frameMetrics = frameMetrics
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
        self.targetResolution = targetResolution
    }
}

extension BatchGetFrameMetricDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetFrameMetricDataInput(endTime: \(String(describing: endTime)), frameMetrics: \(String(describing: frameMetrics)), period: \(String(describing: period)), profilingGroupName: \(String(describing: profilingGroupName)), startTime: \(String(describing: startTime)), targetResolution: \(String(describing: targetResolution)))"}
}
