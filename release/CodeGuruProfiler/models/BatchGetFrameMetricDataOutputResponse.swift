// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

/// <p>The structure representing the BatchGetFrameMetricDataResponse.</p>
public struct BatchGetFrameMetricDataOutputResponse: Equatable {
    /// <p>
    ///          The end time of the time period for the returned time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let endTime: Date?
    /// <p>
    ///          List of instances, or time steps, in the time series. For example, if the
    ///          <code>period</code> is one day (<code>PT24H)</code>), and the <code>resolution</code>
    ///          is five minutes (<code>PT5M</code>), then there are 288 <code>endTimes</code> in the
    ///          list that are each five minutes appart.
    ///       </p>
    public let endTimes: [TimestampStructure]?
    /// <p>Details of the metrics to request a time series of values. The metric includes
    ///          the name of the frame, the aggregation type to calculate the metric value for the frame,
    ///          and the thread states to use to get the count for the metric value of the frame.</p>
    public let frameMetricData: [FrameMetricDatum]?
    /// <p>Resolution or granularity of the profile data used to generate the time series.
    ///          This is the value used to jump through time steps in a time series. There are 3 valid values.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>P1D</code> — 1 day
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT1H</code> — 1 hour
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT5M</code> — 5 minutes
    ///             </p>
    ///             </li>
    ///          </ul>
    public let resolution: AggregationPeriod?
    /// <p>
    ///          The start time of the time period for the returned time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let startTime: Date?
    /// <p>List of instances which remained unprocessed. This will create a missing time step in the list of end times.</p>
    public let unprocessedEndTimes: [String:[TimestampStructure]]?

    public init (
        endTime: Date? = nil,
        endTimes: [TimestampStructure]? = nil,
        frameMetricData: [FrameMetricDatum]? = nil,
        resolution: AggregationPeriod? = nil,
        startTime: Date? = nil,
        unprocessedEndTimes: [String:[TimestampStructure]]? = nil
    )
    {
        self.endTime = endTime
        self.endTimes = endTimes
        self.frameMetricData = frameMetricData
        self.resolution = resolution
        self.startTime = startTime
        self.unprocessedEndTimes = unprocessedEndTimes
    }
}

extension BatchGetFrameMetricDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetFrameMetricDataOutputResponse(endTime: \(String(describing: endTime)), endTimes: \(String(describing: endTimes)), frameMetricData: \(String(describing: frameMetricData)), resolution: \(String(describing: resolution)), startTime: \(String(describing: startTime)), unprocessedEndTimes: \(String(describing: unprocessedEndTimes)))"}
}
