// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension ImagebuilderClient {
    /// CancelImageCreation cancels the creation of Image. This operation can only be used on
    /// 			images in a non-terminal state.
    func cancelImageCreation(input: CancelImageCreationInput) async throws -> CancelImageCreationOutputResponse
    {
        typealias cancelImageCreationContinuation = CheckedContinuation<CancelImageCreationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelImageCreationContinuation) in
            cancelImageCreation(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new component that can be used to build, validate, test, and assess your
    /// 			image.
    func createComponent(input: CreateComponentInput) async throws -> CreateComponentOutputResponse
    {
        typealias createComponentContinuation = CheckedContinuation<CreateComponentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createComponentContinuation) in
            createComponent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new container recipe. Container recipes define how images are configured, tested, and assessed.
    func createContainerRecipe(input: CreateContainerRecipeInput) async throws -> CreateContainerRecipeOutputResponse
    {
        typealias createContainerRecipeContinuation = CheckedContinuation<CreateContainerRecipeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createContainerRecipeContinuation) in
            createContainerRecipe(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a new distribution configuration. Distribution configurations define and configure
    /// 			the outputs of your pipeline.
    func createDistributionConfiguration(input: CreateDistributionConfigurationInput) async throws -> CreateDistributionConfigurationOutputResponse
    {
        typealias createDistributionConfigurationContinuation = CheckedContinuation<CreateDistributionConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDistributionConfigurationContinuation) in
            createDistributionConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Creates a new image. This request will create a new image along with all of the
    /// 			configured output resources defined in the distribution configuration. You must specify
    /// 			exactly one recipe for your image, using either a ContainerRecipeArn or an ImageRecipeArn.
    func createImage(input: CreateImageInput) async throws -> CreateImageOutputResponse
    {
        typealias createImageContinuation = CheckedContinuation<CreateImageOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createImageContinuation) in
            createImage(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Creates a new image pipeline. Image pipelines enable you to automate the creation and
    /// 			distribution of images.
    func createImagePipeline(input: CreateImagePipelineInput) async throws -> CreateImagePipelineOutputResponse
    {
        typealias createImagePipelineContinuation = CheckedContinuation<CreateImagePipelineOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createImagePipelineContinuation) in
            createImagePipeline(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Creates a new image recipe. Image recipes define how images are configured, tested, and
    /// 			assessed.
    func createImageRecipe(input: CreateImageRecipeInput) async throws -> CreateImageRecipeOutputResponse
    {
        typealias createImageRecipeContinuation = CheckedContinuation<CreateImageRecipeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createImageRecipeContinuation) in
            createImageRecipe(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Creates a new infrastructure configuration. An infrastructure configuration defines the
    /// 			environment in which your image will be built and tested.
    func createInfrastructureConfiguration(input: CreateInfrastructureConfigurationInput) async throws -> CreateInfrastructureConfigurationOutputResponse
    {
        typealias createInfrastructureConfigurationContinuation = CheckedContinuation<CreateInfrastructureConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createInfrastructureConfigurationContinuation) in
            createInfrastructureConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Deletes a component build version.
    func deleteComponent(input: DeleteComponentInput) async throws -> DeleteComponentOutputResponse
    {
        typealias deleteComponentContinuation = CheckedContinuation<DeleteComponentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteComponentContinuation) in
            deleteComponent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a container recipe.
    func deleteContainerRecipe(input: DeleteContainerRecipeInput) async throws -> DeleteContainerRecipeOutputResponse
    {
        typealias deleteContainerRecipeContinuation = CheckedContinuation<DeleteContainerRecipeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteContainerRecipeContinuation) in
            deleteContainerRecipe(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Deletes a distribution configuration.
    func deleteDistributionConfiguration(input: DeleteDistributionConfigurationInput) async throws -> DeleteDistributionConfigurationOutputResponse
    {
        typealias deleteDistributionConfigurationContinuation = CheckedContinuation<DeleteDistributionConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDistributionConfigurationContinuation) in
            deleteDistributionConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes an Image Builder image resource. This does not delete any EC2 AMIs or ECR container images
    /// 			that are created during the image build process. You must clean those up separately,
    /// 			using the appropriate Amazon EC2 or Amazon ECR console actions, or API or CLI commands.
    /// 		
    ///
    /// 				           To deregister an EC2 Linux AMI, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/deregister-ami.html">Deregister
    /// 						your Linux AMI in the
    ///                      Amazon EC2 User Guide
    ///                   .
    /// 			
    ///
    /// 				           To deregister an EC2 Windows AMI, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/deregister-ami.html">Deregister
    /// 						your Windows AMI in the
    ///                      Amazon EC2 Windows Guide
    ///                   .
    /// 			
    ///
    /// 				           To delete a container image from Amazon ECR, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.comAmazonECR/latest/userguide/delete_image.html">Deleting
    /// 						an image in the Amazon ECR User Guide.
    /// 			
    ///
    func deleteImage(input: DeleteImageInput) async throws -> DeleteImageOutputResponse
    {
        typealias deleteImageContinuation = CheckedContinuation<DeleteImageOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteImageContinuation) in
            deleteImage(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Deletes an image pipeline.
    func deleteImagePipeline(input: DeleteImagePipelineInput) async throws -> DeleteImagePipelineOutputResponse
    {
        typealias deleteImagePipelineContinuation = CheckedContinuation<DeleteImagePipelineOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteImagePipelineContinuation) in
            deleteImagePipeline(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Deletes an image recipe.
    func deleteImageRecipe(input: DeleteImageRecipeInput) async throws -> DeleteImageRecipeOutputResponse
    {
        typealias deleteImageRecipeContinuation = CheckedContinuation<DeleteImageRecipeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteImageRecipeContinuation) in
            deleteImageRecipe(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Deletes an infrastructure configuration.
    func deleteInfrastructureConfiguration(input: DeleteInfrastructureConfigurationInput) async throws -> DeleteInfrastructureConfigurationOutputResponse
    {
        typealias deleteInfrastructureConfigurationContinuation = CheckedContinuation<DeleteInfrastructureConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteInfrastructureConfigurationContinuation) in
            deleteInfrastructureConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Gets a component object.
    func getComponent(input: GetComponentInput) async throws -> GetComponentOutputResponse
    {
        typealias getComponentContinuation = CheckedContinuation<GetComponentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getComponentContinuation) in
            getComponent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Gets a component policy.
    func getComponentPolicy(input: GetComponentPolicyInput) async throws -> GetComponentPolicyOutputResponse
    {
        typealias getComponentPolicyContinuation = CheckedContinuation<GetComponentPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getComponentPolicyContinuation) in
            getComponentPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves a container recipe.
    func getContainerRecipe(input: GetContainerRecipeInput) async throws -> GetContainerRecipeOutputResponse
    {
        typealias getContainerRecipeContinuation = CheckedContinuation<GetContainerRecipeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getContainerRecipeContinuation) in
            getContainerRecipe(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the policy for a container recipe.
    func getContainerRecipePolicy(input: GetContainerRecipePolicyInput) async throws -> GetContainerRecipePolicyOutputResponse
    {
        typealias getContainerRecipePolicyContinuation = CheckedContinuation<GetContainerRecipePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getContainerRecipePolicyContinuation) in
            getContainerRecipePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Gets a distribution configuration.
    func getDistributionConfiguration(input: GetDistributionConfigurationInput) async throws -> GetDistributionConfigurationOutputResponse
    {
        typealias getDistributionConfigurationContinuation = CheckedContinuation<GetDistributionConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDistributionConfigurationContinuation) in
            getDistributionConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Gets an image.
    func getImage(input: GetImageInput) async throws -> GetImageOutputResponse
    {
        typealias getImageContinuation = CheckedContinuation<GetImageOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getImageContinuation) in
            getImage(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Gets an image pipeline.
    func getImagePipeline(input: GetImagePipelineInput) async throws -> GetImagePipelineOutputResponse
    {
        typealias getImagePipelineContinuation = CheckedContinuation<GetImagePipelineOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getImagePipelineContinuation) in
            getImagePipeline(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Gets an image policy.
    func getImagePolicy(input: GetImagePolicyInput) async throws -> GetImagePolicyOutputResponse
    {
        typealias getImagePolicyContinuation = CheckedContinuation<GetImagePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getImagePolicyContinuation) in
            getImagePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Gets an image recipe.
    func getImageRecipe(input: GetImageRecipeInput) async throws -> GetImageRecipeOutputResponse
    {
        typealias getImageRecipeContinuation = CheckedContinuation<GetImageRecipeOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getImageRecipeContinuation) in
            getImageRecipe(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Gets an image recipe policy.
    func getImageRecipePolicy(input: GetImageRecipePolicyInput) async throws -> GetImageRecipePolicyOutputResponse
    {
        typealias getImageRecipePolicyContinuation = CheckedContinuation<GetImageRecipePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getImageRecipePolicyContinuation) in
            getImageRecipePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Gets an infrastructure configuration.
    func getInfrastructureConfiguration(input: GetInfrastructureConfigurationInput) async throws -> GetInfrastructureConfigurationOutputResponse
    {
        typealias getInfrastructureConfigurationContinuation = CheckedContinuation<GetInfrastructureConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getInfrastructureConfigurationContinuation) in
            getInfrastructureConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Imports a component and transforms its data into a component document.
    func importComponent(input: ImportComponentInput) async throws -> ImportComponentOutputResponse
    {
        typealias importComponentContinuation = CheckedContinuation<ImportComponentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: importComponentContinuation) in
            importComponent(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Returns the list of component build versions for the specified semantic version.
    /// 		
    /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
    /// 	You can assign values for the first three, and can filter on all of them.
    /// 			
    ///                Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    /// 		
    func listComponentBuildVersions(input: ListComponentBuildVersionsInput) async throws -> ListComponentBuildVersionsOutputResponse
    {
        typealias listComponentBuildVersionsContinuation = CheckedContinuation<ListComponentBuildVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listComponentBuildVersionsContinuation) in
            listComponentBuildVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the list of component build versions for the specified semantic version.
    /// 		
    /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
    /// 	You can assign values for the first three, and can filter on all of them.
    /// 			
    ///                Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    /// 		
    func listComponents(input: ListComponentsInput) async throws -> ListComponentsOutputResponse
    {
        typealias listComponentsContinuation = CheckedContinuation<ListComponentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listComponentsContinuation) in
            listComponents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of container recipes.
    func listContainerRecipes(input: ListContainerRecipesInput) async throws -> ListContainerRecipesOutputResponse
    {
        typealias listContainerRecipesContinuation = CheckedContinuation<ListContainerRecipesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listContainerRecipesContinuation) in
            listContainerRecipes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of distribution configurations.
    func listDistributionConfigurations(input: ListDistributionConfigurationsInput) async throws -> ListDistributionConfigurationsOutputResponse
    {
        typealias listDistributionConfigurationsContinuation = CheckedContinuation<ListDistributionConfigurationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDistributionConfigurationsContinuation) in
            listDistributionConfigurations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Returns a list of image build versions.
    func listImageBuildVersions(input: ListImageBuildVersionsInput) async throws -> ListImageBuildVersionsOutputResponse
    {
        typealias listImageBuildVersionsContinuation = CheckedContinuation<ListImageBuildVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listImageBuildVersionsContinuation) in
            listImageBuildVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the Packages that are associated with an Image Build Version, as determined by Amazon Web Services Systems Manager Inventory at build time.
    func listImagePackages(input: ListImagePackagesInput) async throws -> ListImagePackagesOutputResponse
    {
        typealias listImagePackagesContinuation = CheckedContinuation<ListImagePackagesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listImagePackagesContinuation) in
            listImagePackages(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Returns a list of images created by the specified pipeline.
    func listImagePipelineImages(input: ListImagePipelineImagesInput) async throws -> ListImagePipelineImagesOutputResponse
    {
        typealias listImagePipelineImagesContinuation = CheckedContinuation<ListImagePipelineImagesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listImagePipelineImagesContinuation) in
            listImagePipelineImages(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of image pipelines.
    func listImagePipelines(input: ListImagePipelinesInput) async throws -> ListImagePipelinesOutputResponse
    {
        typealias listImagePipelinesContinuation = CheckedContinuation<ListImagePipelinesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listImagePipelinesContinuation) in
            listImagePipelines(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Returns a list of image recipes.
    func listImageRecipes(input: ListImageRecipesInput) async throws -> ListImageRecipesOutputResponse
    {
        typealias listImageRecipesContinuation = CheckedContinuation<ListImageRecipesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listImageRecipesContinuation) in
            listImageRecipes(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Returns the list of images that you have access to.
    func listImages(input: ListImagesInput) async throws -> ListImagesOutputResponse
    {
        typealias listImagesContinuation = CheckedContinuation<ListImagesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listImagesContinuation) in
            listImages(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Returns a list of infrastructure configurations.
    func listInfrastructureConfigurations(input: ListInfrastructureConfigurationsInput) async throws -> ListInfrastructureConfigurationsOutputResponse
    {
        typealias listInfrastructureConfigurationsContinuation = CheckedContinuation<ListInfrastructureConfigurationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listInfrastructureConfigurationsContinuation) in
            listInfrastructureConfigurations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Returns the list of tags for the specified resource.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Applies a policy to a component. We recommend that you call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html">CreateResourceShare to share resources. If you call the Image Builder API
    /// 			PutComponentPolicy, you must also call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html">PromoteResourceShareCreatedFromPolicy in order for the resource to be visible to
    /// 			all principals with whom the resource is shared.
    func putComponentPolicy(input: PutComponentPolicyInput) async throws -> PutComponentPolicyOutputResponse
    {
        typealias putComponentPolicyContinuation = CheckedContinuation<PutComponentPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putComponentPolicyContinuation) in
            putComponentPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Applies a policy to a container image. We recommend that you call the RAM API CreateResourceShare (https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html) to share resources. If you call the Image Builder API PutContainerImagePolicy, you must also call the RAM API PromoteResourceShareCreatedFromPolicy (https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html) in order for the resource to be visible to all principals with whom the resource is shared.
    func putContainerRecipePolicy(input: PutContainerRecipePolicyInput) async throws -> PutContainerRecipePolicyOutputResponse
    {
        typealias putContainerRecipePolicyContinuation = CheckedContinuation<PutContainerRecipePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putContainerRecipePolicyContinuation) in
            putContainerRecipePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Applies a policy to an image. We recommend that you call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html">CreateResourceShare to share resources. If you call the Image Builder API
    /// 			PutImagePolicy, you must also call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html">PromoteResourceShareCreatedFromPolicy in order for the resource to be visible to
    /// 			all principals with whom the resource is shared.
    func putImagePolicy(input: PutImagePolicyInput) async throws -> PutImagePolicyOutputResponse
    {
        typealias putImagePolicyContinuation = CheckedContinuation<PutImagePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putImagePolicyContinuation) in
            putImagePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Applies a policy to an image recipe. We recommend that you call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_CreateResourceShare.html">CreateResourceShare to share resources. If you call the Image Builder API
    /// 			PutImageRecipePolicy, you must also call the RAM API <a href="https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html">PromoteResourceShareCreatedFromPolicy in order for the resource to be visible to
    /// 			all principals with whom the resource is shared.
    func putImageRecipePolicy(input: PutImageRecipePolicyInput) async throws -> PutImageRecipePolicyOutputResponse
    {
        typealias putImageRecipePolicyContinuation = CheckedContinuation<PutImageRecipePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putImageRecipePolicyContinuation) in
            putImageRecipePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Manually triggers a pipeline to create an image.
    func startImagePipelineExecution(input: StartImagePipelineExecutionInput) async throws -> StartImagePipelineExecutionOutputResponse
    {
        typealias startImagePipelineExecutionContinuation = CheckedContinuation<StartImagePipelineExecutionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startImagePipelineExecutionContinuation) in
            startImagePipelineExecution(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Adds a tag to a resource.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Removes a tag from a resource.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Updates a new distribution configuration. Distribution configurations define and
    /// 			configure the outputs of your pipeline.
    func updateDistributionConfiguration(input: UpdateDistributionConfigurationInput) async throws -> UpdateDistributionConfigurationOutputResponse
    {
        typealias updateDistributionConfigurationContinuation = CheckedContinuation<UpdateDistributionConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateDistributionConfigurationContinuation) in
            updateDistributionConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Updates an image pipeline. Image pipelines enable you to automate the creation and
    /// 			distribution of images.
    /// 		
    ///             UpdateImagePipeline does not support selective updates for the pipeline.
    /// 			You must specify all of the required properties in the update request, not just
    /// 			the properties that have changed.
    ///
    func updateImagePipeline(input: UpdateImagePipelineInput) async throws -> UpdateImagePipelineOutputResponse
    {
        typealias updateImagePipelineContinuation = CheckedContinuation<UpdateImagePipelineOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateImagePipelineContinuation) in
            updateImagePipeline(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    ///  Updates a new infrastructure configuration. An infrastructure configuration defines the
    /// 			environment in which your image will be built and tested.
    func updateInfrastructureConfiguration(input: UpdateInfrastructureConfigurationInput) async throws -> UpdateInfrastructureConfigurationOutputResponse
    {
        typealias updateInfrastructureConfigurationContinuation = CheckedContinuation<UpdateInfrastructureConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateInfrastructureConfigurationContinuation) in
            updateInfrastructureConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
