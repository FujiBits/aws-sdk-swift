// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Iot1ClickDevicesClientTypes.Attributes: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension Iot1ClickDevicesClientTypes.Attributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attributes()"}
}

extension Iot1ClickDevicesClientTypes {
    public struct Attributes: Swift.Equatable {

        public init() {}
    }

}

extension ClaimDevicesByClaimCodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClaimDevicesByClaimCodeInput(claimCode: \(Swift.String(describing: claimCode)))"}
}

extension ClaimDevicesByClaimCodeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ClaimDevicesByClaimCodeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ClaimDevicesByClaimCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ClaimDevicesByClaimCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ClaimDevicesByClaimCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ClaimDevicesByClaimCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ClaimDevicesByClaimCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ClaimDevicesByClaimCodeOutputError>
}

public struct ClaimDevicesByClaimCodeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ClaimDevicesByClaimCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ClaimDevicesByClaimCodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ClaimDevicesByClaimCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ClaimDevicesByClaimCodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ClaimDevicesByClaimCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ClaimDevicesByClaimCodeOutputError>
}

public struct ClaimDevicesByClaimCodeInput: Swift.Equatable {
    /// <p>The claim code, starting with "C-", as provided by the device manufacturer.</p>
    public let claimCode: Swift.String?

    public init (
        claimCode: Swift.String? = nil
    )
    {
        self.claimCode = claimCode
    }
}

struct ClaimDevicesByClaimCodeInputBody: Swift.Equatable {
}

extension ClaimDevicesByClaimCodeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ClaimDevicesByClaimCodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ClaimDevicesByClaimCodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ClaimDevicesByClaimCodeOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ClaimDevicesByClaimCodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClaimDevicesByClaimCodeOutputResponse(claimCode: \(Swift.String(describing: claimCode)), total: \(Swift.String(describing: total)))"}
}

extension ClaimDevicesByClaimCodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClaimDevicesByClaimCodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.claimCode = output.claimCode
            self.total = output.total
        } else {
            self.claimCode = nil
            self.total = 0
        }
    }
}

public struct ClaimDevicesByClaimCodeOutputResponse: Swift.Equatable {
    /// <p>The claim code provided by the device manufacturer.</p>
    public let claimCode: Swift.String?
    /// <p>The total number of devices associated with the claim code that has been processed in
    ///  the claim request.</p>
    public let total: Swift.Int

    public init (
        claimCode: Swift.String? = nil,
        total: Swift.Int = 0
    )
    {
        self.claimCode = claimCode
        self.total = total
    }
}

struct ClaimDevicesByClaimCodeOutputResponseBody: Swift.Equatable {
    public let claimCode: Swift.String?
    public let total: Swift.Int
}

extension ClaimDevicesByClaimCodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case claimCode = "claimCode"
        case total = "total"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let claimCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .claimCode)
        claimCode = claimCodeDecoded
        let totalDecoded = try containerValues.decode(Swift.Int.self, forKey: .total)
        total = totalDecoded
    }
}

extension DescribeDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDeviceInput(deviceId: \(Swift.String(describing: deviceId)))"}
}

extension DescribeDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeviceOutputError>
}

public struct DescribeDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDeviceOutputError>
}

public struct DescribeDeviceInput: Swift.Equatable {
    /// <p>The unique identifier of the device.</p>
    public let deviceId: Swift.String?

    public init (
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct DescribeDeviceInputBody: Swift.Equatable {
}

extension DescribeDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDeviceOutputResponse(deviceDescription: \(Swift.String(describing: deviceDescription)))"}
}

extension DescribeDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceDescription = output.deviceDescription
        } else {
            self.deviceDescription = nil
        }
    }
}

public struct DescribeDeviceOutputResponse: Swift.Equatable {
    /// <p>Device details.</p>
    public let deviceDescription: Iot1ClickDevicesClientTypes.DeviceDescription?

    public init (
        deviceDescription: Iot1ClickDevicesClientTypes.DeviceDescription? = nil
    )
    {
        self.deviceDescription = deviceDescription
    }
}

struct DescribeDeviceOutputResponseBody: Swift.Equatable {
    public let deviceDescription: Iot1ClickDevicesClientTypes.DeviceDescription?
}

extension DescribeDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceDescription = "deviceDescription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDescriptionDecoded = try containerValues.decodeIfPresent(Iot1ClickDevicesClientTypes.DeviceDescription.self, forKey: .deviceDescription)
        deviceDescription = deviceDescriptionDecoded
    }
}

extension Iot1ClickDevicesClientTypes.Device: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case deviceId = "deviceId"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(Iot1ClickDevicesClientTypes.Attributes.self, forKey: .attributes)
        attributes = attributesDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension Iot1ClickDevicesClientTypes.Device: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Device(attributes: \(Swift.String(describing: attributes)), deviceId: \(Swift.String(describing: deviceId)), type: \(Swift.String(describing: type)))"}
}

extension Iot1ClickDevicesClientTypes {
    public struct Device: Swift.Equatable {
        /// <p>The user specified attributes associated with the device for an event.</p>
        public let attributes: Iot1ClickDevicesClientTypes.Attributes?
        /// <p>The unique identifier of the device.</p>
        public let deviceId: Swift.String?
        /// <p>The device type, such as "button".</p>
        public let type: Swift.String?

        public init (
            attributes: Iot1ClickDevicesClientTypes.Attributes? = nil,
            deviceId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.deviceId = deviceId
            self.type = type
        }
    }

}

extension Iot1ClickDevicesClientTypes.DeviceDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case attributes = "attributes"
        case deviceId = "deviceId"
        case enabled = "enabled"
        case remainingLife = "remainingLife"
        case tags = "tags"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, deviceattributes0) in attributes {
                try attributesContainer.encode(deviceattributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if remainingLife != 0.0 {
            try encodeContainer.encode(remainingLife, forKey: .remainingLife)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in attributesContainer {
                if let __string0 = __string0 {
                    attributesDecoded0?[key0] = __string0
                }
            }
        }
        attributes = attributesDecoded0
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let remainingLifeDecoded = try containerValues.decode(Swift.Double.self, forKey: .remainingLife)
        remainingLife = remainingLifeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Iot1ClickDevicesClientTypes.DeviceDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceDescription(arn: \(Swift.String(describing: arn)), attributes: \(Swift.String(describing: attributes)), deviceId: \(Swift.String(describing: deviceId)), enabled: \(Swift.String(describing: enabled)), remainingLife: \(Swift.String(describing: remainingLife)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension Iot1ClickDevicesClientTypes {
    public struct DeviceDescription: Swift.Equatable {
        /// <p>The ARN of the device.</p>
        public let arn: Swift.String?
        /// <p>An array of zero or more elements of DeviceAttribute objects providing
        ///  user specified device attributes.</p>
        public let attributes: [Swift.String:Swift.String]?
        /// <p>The unique identifier of the device.</p>
        public let deviceId: Swift.String?
        /// <p>A Boolean value indicating whether or not the device is enabled.</p>
        public let enabled: Swift.Bool
        /// <p>A value between 0 and 1 inclusive, representing the fraction of life remaining for the
        ///  device.</p>
        public let remainingLife: Swift.Double
        /// <p>The tags currently associated with the AWS IoT 1-Click device.</p>
        public let tags: [Swift.String:Swift.String]?
        /// <p>The type of the device, such as "button".</p>
        public let type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            deviceId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            remainingLife: Swift.Double = 0.0,
            tags: [Swift.String:Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.deviceId = deviceId
            self.enabled = enabled
            self.remainingLife = remainingLife
            self.tags = tags
            self.type = type
        }
    }

}

extension Iot1ClickDevicesClientTypes.DeviceEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "device"
        case stdEvent = "stdEvent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let device = device {
            try encodeContainer.encode(device, forKey: .device)
        }
        if let stdEvent = stdEvent {
            try encodeContainer.encode(stdEvent, forKey: .stdEvent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(Iot1ClickDevicesClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
        let stdEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stdEvent)
        stdEvent = stdEventDecoded
    }
}

extension Iot1ClickDevicesClientTypes.DeviceEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceEvent(device: \(Swift.String(describing: device)), stdEvent: \(Swift.String(describing: stdEvent)))"}
}

extension Iot1ClickDevicesClientTypes {
    public struct DeviceEvent: Swift.Equatable {
        /// <p>An object representing the device associated with the event.</p>
        public let device: Iot1ClickDevicesClientTypes.Device?
        /// <p>A serialized JSON object representing the device-type specific event.</p>
        public let stdEvent: Swift.String?

        public init (
            device: Iot1ClickDevicesClientTypes.Device? = nil,
            stdEvent: Swift.String? = nil
        )
        {
            self.device = device
            self.stdEvent = stdEvent
        }
    }

}

extension Iot1ClickDevicesClientTypes.DeviceMethod: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceType = "deviceType"
        case methodName = "methodName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let methodName = methodName {
            try encodeContainer.encode(methodName, forKey: .methodName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let methodNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .methodName)
        methodName = methodNameDecoded
    }
}

extension Iot1ClickDevicesClientTypes.DeviceMethod: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceMethod(deviceType: \(Swift.String(describing: deviceType)), methodName: \(Swift.String(describing: methodName)))"}
}

extension Iot1ClickDevicesClientTypes {
    public struct DeviceMethod: Swift.Equatable {
        /// <p>The type of the device, such as "button".</p>
        public let deviceType: Swift.String?
        /// <p>The name of the method applicable to the deviceType.</p>
        public let methodName: Swift.String?

        public init (
            deviceType: Swift.String? = nil,
            methodName: Swift.String? = nil
        )
        {
            self.deviceType = deviceType
            self.methodName = methodName
        }
    }

}

public struct FinalizeDeviceClaimInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FinalizeDeviceClaimInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FinalizeDeviceClaimInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FinalizeDeviceClaimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FinalizeDeviceClaimInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FinalizeDeviceClaimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FinalizeDeviceClaimOutputError>
}

extension FinalizeDeviceClaimInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinalizeDeviceClaimInput(deviceId: \(Swift.String(describing: deviceId)), tags: \(Swift.String(describing: tags)))"}
}

extension FinalizeDeviceClaimInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct FinalizeDeviceClaimInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FinalizeDeviceClaimInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FinalizeDeviceClaimInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FinalizeDeviceClaimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FinalizeDeviceClaimInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FinalizeDeviceClaimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FinalizeDeviceClaimOutputError>
}

public struct FinalizeDeviceClaimInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "FinalizeDeviceClaimInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<FinalizeDeviceClaimInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<FinalizeDeviceClaimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<FinalizeDeviceClaimInput>
    public typealias MOutput = ClientRuntime.OperationOutput<FinalizeDeviceClaimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<FinalizeDeviceClaimOutputError>
}

public struct FinalizeDeviceClaimInput: Swift.Equatable {
    /// <p>The unique identifier of the device.</p>
    public let deviceId: Swift.String?
    /// <p>A collection of key/value pairs defining the resource tags. For example, {
    ///  "tags": {"key1": "value1", "key2": "value2"} }. For more information, see <a href="https://aws.amazon.com/answers/account-management/aws-tagging-strategies/">AWS
    ///  Tagging Strategies</a>.</p><p>
    ///
    ///  </p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        deviceId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deviceId = deviceId
        self.tags = tags
    }
}

struct FinalizeDeviceClaimInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension FinalizeDeviceClaimInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FinalizeDeviceClaimOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FinalizeDeviceClaimOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FinalizeDeviceClaimOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FinalizeDeviceClaimOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinalizeDeviceClaimOutputResponse(state: \(Swift.String(describing: state)))"}
}

extension FinalizeDeviceClaimOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FinalizeDeviceClaimOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct FinalizeDeviceClaimOutputResponse: Swift.Equatable {
    /// <p>The device's final claim state.</p>
    public let state: Swift.String?

    public init (
        state: Swift.String? = nil
    )
    {
        self.state = state
    }
}

struct FinalizeDeviceClaimOutputResponseBody: Swift.Equatable {
    public let state: Swift.String?
}

extension FinalizeDeviceClaimOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "state"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ForbiddenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>403</p>
    public var code: Swift.String?
    /// <p>The 403 error message returned by the web server.</p>
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetDeviceMethodsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceMethodsInput(deviceId: \(Swift.String(describing: deviceId)))"}
}

extension GetDeviceMethodsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDeviceMethodsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceMethodsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceMethodsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceMethodsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceMethodsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceMethodsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceMethodsOutputError>
}

public struct GetDeviceMethodsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDeviceMethodsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDeviceMethodsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDeviceMethodsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDeviceMethodsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDeviceMethodsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDeviceMethodsOutputError>
}

public struct GetDeviceMethodsInput: Swift.Equatable {
    /// <p>The unique identifier of the device.</p>
    public let deviceId: Swift.String?

    public init (
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct GetDeviceMethodsInputBody: Swift.Equatable {
}

extension GetDeviceMethodsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceMethodsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceMethodsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceMethodsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceMethodsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDeviceMethodsOutputResponse(deviceMethods: \(Swift.String(describing: deviceMethods)))"}
}

extension GetDeviceMethodsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeviceMethodsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceMethods = output.deviceMethods
        } else {
            self.deviceMethods = nil
        }
    }
}

public struct GetDeviceMethodsOutputResponse: Swift.Equatable {
    /// <p>List of available device APIs.</p>
    public let deviceMethods: [Iot1ClickDevicesClientTypes.DeviceMethod]?

    public init (
        deviceMethods: [Iot1ClickDevicesClientTypes.DeviceMethod]? = nil
    )
    {
        self.deviceMethods = deviceMethods
    }
}

struct GetDeviceMethodsOutputResponseBody: Swift.Equatable {
    public let deviceMethods: [Iot1ClickDevicesClientTypes.DeviceMethod]?
}

extension GetDeviceMethodsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceMethods = "deviceMethods"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceMethodsContainer = try containerValues.decodeIfPresent([Iot1ClickDevicesClientTypes.DeviceMethod?].self, forKey: .deviceMethods)
        var deviceMethodsDecoded0:[Iot1ClickDevicesClientTypes.DeviceMethod]? = nil
        if let deviceMethodsContainer = deviceMethodsContainer {
            deviceMethodsDecoded0 = [Iot1ClickDevicesClientTypes.DeviceMethod]()
            for structure0 in deviceMethodsContainer {
                if let structure0 = structure0 {
                    deviceMethodsDecoded0?.append(structure0)
                }
            }
        }
        deviceMethods = deviceMethodsDecoded0
    }
}

extension InitiateDeviceClaimInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateDeviceClaimInput(deviceId: \(Swift.String(describing: deviceId)))"}
}

extension InitiateDeviceClaimInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct InitiateDeviceClaimInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateDeviceClaimInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateDeviceClaimInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateDeviceClaimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateDeviceClaimInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateDeviceClaimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateDeviceClaimOutputError>
}

public struct InitiateDeviceClaimInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateDeviceClaimInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateDeviceClaimInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateDeviceClaimOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateDeviceClaimInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateDeviceClaimOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateDeviceClaimOutputError>
}

public struct InitiateDeviceClaimInput: Swift.Equatable {
    /// <p>The unique identifier of the device.</p>
    public let deviceId: Swift.String?

    public init (
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct InitiateDeviceClaimInputBody: Swift.Equatable {
}

extension InitiateDeviceClaimInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InitiateDeviceClaimOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateDeviceClaimOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateDeviceClaimOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateDeviceClaimOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateDeviceClaimOutputResponse(state: \(Swift.String(describing: state)))"}
}

extension InitiateDeviceClaimOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InitiateDeviceClaimOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct InitiateDeviceClaimOutputResponse: Swift.Equatable {
    /// <p>The device's final claim state.</p>
    public let state: Swift.String?

    public init (
        state: Swift.String? = nil
    )
    {
        self.state = state
    }
}

struct InitiateDeviceClaimOutputResponseBody: Swift.Equatable {
    public let state: Swift.String?
}

extension InitiateDeviceClaimOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "state"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InternalFailureException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InternalFailureException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// <p>500</p>
    public var code: Swift.String?
    /// <p>The 500 error message returned by the web server.</p>
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InvalidRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>400</p>
    public var code: Swift.String?
    /// <p>The 400 error message returned by the web server.</p>
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct InvokeDeviceMethodInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeDeviceMethodInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeDeviceMethodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeDeviceMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeDeviceMethodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeDeviceMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeDeviceMethodOutputError>
}

extension InvokeDeviceMethodInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeDeviceMethodInput(deviceId: \(Swift.String(describing: deviceId)), deviceMethod: \(Swift.String(describing: deviceMethod)), deviceMethodParameters: \(Swift.String(describing: deviceMethodParameters)))"}
}

extension InvokeDeviceMethodInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceMethod = "deviceMethod"
        case deviceMethodParameters = "deviceMethodParameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceMethod = deviceMethod {
            try encodeContainer.encode(deviceMethod, forKey: .deviceMethod)
        }
        if let deviceMethodParameters = deviceMethodParameters {
            try encodeContainer.encode(deviceMethodParameters, forKey: .deviceMethodParameters)
        }
    }
}

public struct InvokeDeviceMethodInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeDeviceMethodInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeDeviceMethodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeDeviceMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeDeviceMethodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeDeviceMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeDeviceMethodOutputError>
}

public struct InvokeDeviceMethodInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InvokeDeviceMethodInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InvokeDeviceMethodInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InvokeDeviceMethodOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InvokeDeviceMethodInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InvokeDeviceMethodOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InvokeDeviceMethodOutputError>
}

public struct InvokeDeviceMethodInput: Swift.Equatable {
    /// <p>The unique identifier of the device.</p>
    public let deviceId: Swift.String?
    /// <p>The device method to invoke.</p>
    public let deviceMethod: Iot1ClickDevicesClientTypes.DeviceMethod?
    /// <p>A JSON encoded string containing the device method request parameters.</p>
    public let deviceMethodParameters: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        deviceMethod: Iot1ClickDevicesClientTypes.DeviceMethod? = nil,
        deviceMethodParameters: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.deviceMethod = deviceMethod
        self.deviceMethodParameters = deviceMethodParameters
    }
}

struct InvokeDeviceMethodInputBody: Swift.Equatable {
    public let deviceMethod: Iot1ClickDevicesClientTypes.DeviceMethod?
    public let deviceMethodParameters: Swift.String?
}

extension InvokeDeviceMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceMethod = "deviceMethod"
        case deviceMethodParameters = "deviceMethodParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceMethodDecoded = try containerValues.decodeIfPresent(Iot1ClickDevicesClientTypes.DeviceMethod.self, forKey: .deviceMethod)
        deviceMethod = deviceMethodDecoded
        let deviceMethodParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceMethodParameters)
        deviceMethodParameters = deviceMethodParametersDecoded
    }
}

extension InvokeDeviceMethodOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvokeDeviceMethodOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RangeNotSatisfiableException" : self = .rangeNotSatisfiableException(try RangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvokeDeviceMethodOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case preconditionFailedException(PreconditionFailedException)
    case rangeNotSatisfiableException(RangeNotSatisfiableException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvokeDeviceMethodOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeDeviceMethodOutputResponse(deviceMethodResponse: \(Swift.String(describing: deviceMethodResponse)))"}
}

extension InvokeDeviceMethodOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvokeDeviceMethodOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceMethodResponse = output.deviceMethodResponse
        } else {
            self.deviceMethodResponse = nil
        }
    }
}

public struct InvokeDeviceMethodOutputResponse: Swift.Equatable {
    /// <p>A JSON encoded string containing the device method response.</p>
    public let deviceMethodResponse: Swift.String?

    public init (
        deviceMethodResponse: Swift.String? = nil
    )
    {
        self.deviceMethodResponse = deviceMethodResponse
    }
}

struct InvokeDeviceMethodOutputResponseBody: Swift.Equatable {
    public let deviceMethodResponse: Swift.String?
}

extension InvokeDeviceMethodOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceMethodResponse = "deviceMethodResponse"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceMethodResponseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceMethodResponse)
        deviceMethodResponse = deviceMethodResponseDecoded
    }
}

extension ListDeviceEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeviceEventsInput(deviceId: \(Swift.String(describing: deviceId)), fromTimeStamp: \(Swift.String(describing: fromTimeStamp)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), toTimeStamp: \(Swift.String(describing: toTimeStamp)))"}
}

extension ListDeviceEventsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDeviceEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeviceEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeviceEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceEventsOutputError>
}

public struct ListDeviceEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDeviceEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDeviceEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDeviceEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let toTimeStamp = input.operationInput.toTimeStamp {
            let toTimeStampQueryItem = ClientRuntime.URLQueryItem(name: "toTimeStamp".urlPercentEncoding(), value: Swift.String(toTimeStamp.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(toTimeStampQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let fromTimeStamp = input.operationInput.fromTimeStamp {
            let fromTimeStampQueryItem = ClientRuntime.URLQueryItem(name: "fromTimeStamp".urlPercentEncoding(), value: Swift.String(fromTimeStamp.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(fromTimeStampQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDeviceEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDeviceEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDeviceEventsOutputError>
}

public struct ListDeviceEventsInput: Swift.Equatable {
    /// <p>The unique identifier of the device.</p>
    public let deviceId: Swift.String?
    /// <p>The start date for the device event query, in ISO8061 format. For example,
    ///  2018-03-28T15:45:12.880Z
    ///  </p>
    public let fromTimeStamp: ClientRuntime.Date?
    /// <p>The maximum number of results to return per request. If not set, a default value of
    ///  100 is used.</p>
    public let maxResults: Swift.Int
    /// <p>The token to retrieve the next set of results.</p>
    public let nextToken: Swift.String?
    /// <p>The end date for the device event query, in ISO8061 format. For example,
    ///  2018-03-28T15:45:12.880Z
    ///  </p>
    public let toTimeStamp: ClientRuntime.Date?

    public init (
        deviceId: Swift.String? = nil,
        fromTimeStamp: ClientRuntime.Date? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        toTimeStamp: ClientRuntime.Date? = nil
    )
    {
        self.deviceId = deviceId
        self.fromTimeStamp = fromTimeStamp
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.toTimeStamp = toTimeStamp
    }
}

struct ListDeviceEventsInputBody: Swift.Equatable {
}

extension ListDeviceEventsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RangeNotSatisfiableException" : self = .rangeNotSatisfiableException(try RangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceEventsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case rangeNotSatisfiableException(RangeNotSatisfiableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDeviceEventsOutputResponse(events: \(Swift.String(describing: events)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDeviceEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeviceEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceEventsOutputResponse: Swift.Equatable {
    /// <p>An array of zero or more elements describing the event(s) associated with the
    ///  device.</p>
    public let events: [Iot1ClickDevicesClientTypes.DeviceEvent]?
    /// <p>The token to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        events: [Iot1ClickDevicesClientTypes.DeviceEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct ListDeviceEventsOutputResponseBody: Swift.Equatable {
    public let events: [Iot1ClickDevicesClientTypes.DeviceEvent]?
    public let nextToken: Swift.String?
}

extension ListDeviceEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events = "events"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Iot1ClickDevicesClientTypes.DeviceEvent?].self, forKey: .events)
        var eventsDecoded0:[Iot1ClickDevicesClientTypes.DeviceEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Iot1ClickDevicesClientTypes.DeviceEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicesInput(deviceType: \(Swift.String(describing: deviceType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDevicesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDevicesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

public struct ListDevicesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let deviceType = input.operationInput.deviceType {
            let deviceTypeQueryItem = ClientRuntime.URLQueryItem(name: "deviceType".urlPercentEncoding(), value: Swift.String(deviceType).urlPercentEncoding())
            input.builder.withQueryItem(deviceTypeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDevicesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDevicesOutputError>
}

public struct ListDevicesInput: Swift.Equatable {
    /// <p>The type of the device, such as "button".</p>
    public let deviceType: Swift.String?
    /// <p>The maximum number of results to return per request. If not set, a default value of
    ///  100 is used.</p>
    public let maxResults: Swift.Int
    /// <p>The token to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        deviceType: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceType = deviceType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Swift.Equatable {
}

extension ListDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RangeNotSatisfiableException" : self = .rangeNotSatisfiableException(try RangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevicesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case rangeNotSatisfiableException(RangeNotSatisfiableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDevicesOutputResponse(devices: \(Swift.String(describing: devices)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesOutputResponse: Swift.Equatable {
    /// <p>A list of devices.</p>
    public let devices: [Iot1ClickDevicesClientTypes.DeviceDescription]?
    /// <p>The token to retrieve the next set of results.</p>
    public let nextToken: Swift.String?

    public init (
        devices: [Iot1ClickDevicesClientTypes.DeviceDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputResponseBody: Swift.Equatable {
    public let devices: [Iot1ClickDevicesClientTypes.DeviceDescription]?
    public let nextToken: Swift.String?
}

extension ListDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "devices"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([Iot1ClickDevicesClientTypes.DeviceDescription?].self, forKey: .devices)
        var devicesDecoded0:[Iot1ClickDevicesClientTypes.DeviceDescription]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [Iot1ClickDevicesClientTypes.DeviceDescription]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>A collection of key/value pairs defining the resource tags. For example, {
    ///  "tags": {"key1": "value1", "key2": "value2"} }. For more information, see <a href="https://aws.amazon.com/answers/account-management/aws-tagging-strategies/">AWS
    ///  Tagging Strategies</a>.</p><p>
    ///
    ///  </p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PreconditionFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PreconditionFailedException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension PreconditionFailedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct PreconditionFailedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>412</p>
    public var code: Swift.String?
    /// <p>An error message explaining the error or its remedy.</p>
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct PreconditionFailedExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension PreconditionFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RangeNotSatisfiableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RangeNotSatisfiableException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension RangeNotSatisfiableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RangeNotSatisfiableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct RangeNotSatisfiableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>416</p>
    public var code: Swift.String?
    /// <p>The requested number of results specified by nextToken cannot be
    ///  satisfied.</p>
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct RangeNotSatisfiableExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension RangeNotSatisfiableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceConflictException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ResourceConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ResourceConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>409</p>
    public var code: Swift.String?
    /// <p>An error message explaining the error or its remedy.</p>
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>404</p>
    public var code: Swift.String?
    /// <p>The requested device could not be found.</p>
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: Swift.String?
    /// <p>A collection of key/value pairs defining the resource tags. For example, {
    ///  "tags": {"key1": "value1", "key2": "value2"} }. For more information, see <a href="https://aws.amazon.com/answers/account-management/aws-tagging-strategies/">AWS
    ///  Tagging Strategies</a>.</p><p>
    ///
    ///  </p>
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UnclaimDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnclaimDeviceInput(deviceId: \(Swift.String(describing: deviceId)))"}
}

extension UnclaimDeviceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UnclaimDeviceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnclaimDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnclaimDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnclaimDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnclaimDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnclaimDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnclaimDeviceOutputError>
}

public struct UnclaimDeviceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UnclaimDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UnclaimDeviceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UnclaimDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UnclaimDeviceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UnclaimDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UnclaimDeviceOutputError>
}

public struct UnclaimDeviceInput: Swift.Equatable {
    /// <p>The unique identifier of the device.</p>
    public let deviceId: Swift.String?

    public init (
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct UnclaimDeviceInputBody: Swift.Equatable {
}

extension UnclaimDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UnclaimDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnclaimDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnclaimDeviceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnclaimDeviceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnclaimDeviceOutputResponse(state: \(Swift.String(describing: state)))"}
}

extension UnclaimDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnclaimDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.state = output.state
        } else {
            self.state = nil
        }
    }
}

public struct UnclaimDeviceOutputResponse: Swift.Equatable {
    /// <p>The device's final claim state.</p>
    public let state: Swift.String?

    public init (
        state: Swift.String? = nil
    )
    {
        self.state = state
    }
}

struct UnclaimDeviceOutputResponseBody: Swift.Equatable {
    public let state: Swift.String?
}

extension UnclaimDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state = "state"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The ARN of the resource.</p>
    public let resourceArn: Swift.String?
    /// <p>A collections of tag keys. For example, {"key1","key2"}</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDeviceStateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceStateOutputError>
}

extension UpdateDeviceStateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceStateInput(deviceId: \(Swift.String(describing: deviceId)), enabled: \(Swift.String(describing: enabled)))"}
}

extension UpdateDeviceStateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }
}

public struct UpdateDeviceStateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceStateOutputError>
}

public struct UpdateDeviceStateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDeviceStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDeviceStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDeviceStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDeviceStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDeviceStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDeviceStateOutputError>
}

public struct UpdateDeviceStateInput: Swift.Equatable {
    /// <p>The unique identifier of the device.</p>
    public let deviceId: Swift.String?
    /// <p>If true, the device is enabled. If false, the device is
    ///  disabled.</p>
    public let enabled: Swift.Bool

    public init (
        deviceId: Swift.String? = nil,
        enabled: Swift.Bool = false
    )
    {
        self.deviceId = deviceId
        self.enabled = enabled
    }
}

struct UpdateDeviceStateInputBody: Swift.Equatable {
    public let enabled: Swift.Bool
}

extension UpdateDeviceStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "enabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension UpdateDeviceStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceStateOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceStateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceStateOutputResponse()"}
}

extension UpdateDeviceStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDeviceStateOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDeviceStateOutputResponseBody: Swift.Equatable {
}

extension UpdateDeviceStateOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}
