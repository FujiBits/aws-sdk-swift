// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AmplifyBackendClientTypes {
    public enum AdditionalConstraintsElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requireDigit
        case requireLowercase
        case requireSymbol
        case requireUppercase
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalConstraintsElement] {
            return [
                .requireDigit,
                .requireLowercase,
                .requireSymbol,
                .requireUppercase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requireDigit: return "REQUIRE_DIGIT"
            case .requireLowercase: return "REQUIRE_LOWERCASE"
            case .requireSymbol: return "REQUIRE_SYMBOL"
            case .requireUppercase: return "REQUIRE_UPPERCASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdditionalConstraintsElement(rawValue: rawValue) ?? AdditionalConstraintsElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum AuthResources: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case identityPoolAndUserPool
        case userPoolOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthResources] {
            return [
                .identityPoolAndUserPool,
                .userPoolOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .identityPoolAndUserPool: return "IDENTITY_POOL_AND_USER_POOL"
            case .userPoolOnly: return "USER_POOL_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthResources(rawValue: rawValue) ?? AuthResources.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cognitoUserPoolId = "cognitoUserPoolId"
        case description = "description"
        case expirationTime = "expirationTime"
        case openIDAuthTTL = "openIDAuthTTL"
        case openIDClientId = "openIDClientId"
        case openIDIatTTL = "openIDIatTTL"
        case openIDIssueURL = "openIDIssueURL"
        case openIDProviderName = "openIDProviderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cognitoUserPoolId = cognitoUserPoolId {
            try encodeContainer.encode(cognitoUserPoolId, forKey: .cognitoUserPoolId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime, forKey: .expirationTime)
        }
        if let openIDAuthTTL = openIDAuthTTL {
            try encodeContainer.encode(openIDAuthTTL, forKey: .openIDAuthTTL)
        }
        if let openIDClientId = openIDClientId {
            try encodeContainer.encode(openIDClientId, forKey: .openIDClientId)
        }
        if let openIDIatTTL = openIDIatTTL {
            try encodeContainer.encode(openIDIatTTL, forKey: .openIDIatTTL)
        }
        if let openIDIssueURL = openIDIssueURL {
            try encodeContainer.encode(openIDIssueURL, forKey: .openIDIssueURL)
        }
        if let openIDProviderName = openIDProviderName {
            try encodeContainer.encode(openIDProviderName, forKey: .openIDProviderName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cognitoUserPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cognitoUserPoolId)
        cognitoUserPoolId = cognitoUserPoolIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let openIDAuthTTLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDAuthTTL)
        openIDAuthTTL = openIDAuthTTLDecoded
        let openIDClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDClientId)
        openIDClientId = openIDClientIdDecoded
        let openIDIatTTLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDIatTTL)
        openIDIatTTL = openIDIatTTLDecoded
        let openIDIssueURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDIssueURL)
        openIDIssueURL = openIDIssueURLDecoded
        let openIDProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .openIDProviderName)
        openIDProviderName = openIDProviderNameDecoded
    }
}

extension AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackendAPIAppSyncAuthSettings(cognitoUserPoolId: \(Swift.String(describing: cognitoUserPoolId)), description: \(Swift.String(describing: description)), expirationTime: \(Swift.String(describing: expirationTime)), openIDAuthTTL: \(Swift.String(describing: openIDAuthTTL)), openIDClientId: \(Swift.String(describing: openIDClientId)), openIDIatTTL: \(Swift.String(describing: openIDIatTTL)), openIDIssueURL: \(Swift.String(describing: openIDIssueURL)), openIDProviderName: \(Swift.String(describing: openIDProviderName)))"}
}

extension AmplifyBackendClientTypes {
    /// The authentication settings for accessing provisioned data models in your Amplify project.
    public struct BackendAPIAppSyncAuthSettings: Swift.Equatable {
        /// The Amazon Cognito user pool ID, if Amazon Cognito was used as an authentication setting to access your data models.
        public let cognitoUserPoolId: Swift.String?
        /// The API key description for API_KEY, if it was used as an authentication mechanism to access your data models.
        public let description: Swift.String?
        /// The API key expiration time for API_KEY, if it was used as an authentication mechanism to access your data models.
        public let expirationTime: Swift.Double?
        /// The expiry time for the OpenID authentication mechanism.
        public let openIDAuthTTL: Swift.String?
        /// The clientID for openID, if openID was used as an authentication setting to access your data models.
        public let openIDClientId: Swift.String?
        /// The expiry time for the OpenID authentication mechanism.
        public let openIDIatTTL: Swift.String?
        /// The openID issuer URL, if openID was used as an authentication setting to access your data models.
        public let openIDIssueURL: Swift.String?
        /// The OpenID provider name, if OpenID was used as an authentication mechanism to access your data models.
        public let openIDProviderName: Swift.String?

        public init (
            cognitoUserPoolId: Swift.String? = nil,
            description: Swift.String? = nil,
            expirationTime: Swift.Double? = nil,
            openIDAuthTTL: Swift.String? = nil,
            openIDClientId: Swift.String? = nil,
            openIDIatTTL: Swift.String? = nil,
            openIDIssueURL: Swift.String? = nil,
            openIDProviderName: Swift.String? = nil
        )
        {
            self.cognitoUserPoolId = cognitoUserPoolId
            self.description = description
            self.expirationTime = expirationTime
            self.openIDAuthTTL = openIDAuthTTL
            self.openIDClientId = openIDClientId
            self.openIDIatTTL = openIDIatTTL
            self.openIDIssueURL = openIDIssueURL
            self.openIDProviderName = openIDProviderName
        }
    }

}

extension AmplifyBackendClientTypes.BackendAPIAuthType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "mode"
        case settings = "settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Mode.self, forKey: .mode)
        mode = modeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AmplifyBackendClientTypes.BackendAPIAuthType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackendAPIAuthType(mode: \(Swift.String(describing: mode)), settings: \(Swift.String(describing: settings)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes the auth types for your configured data models.
    public struct BackendAPIAuthType: Swift.Equatable {
        /// Describes the authentication mode.
        public let mode: AmplifyBackendClientTypes.Mode?
        /// Describes settings for the authentication mode.
        public let settings: AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings?

        public init (
            mode: AmplifyBackendClientTypes.Mode? = nil,
            settings: AmplifyBackendClientTypes.BackendAPIAppSyncAuthSettings? = nil
        )
        {
            self.mode = mode
            self.settings = settings
        }
    }

}

extension AmplifyBackendClientTypes.BackendAPIConflictResolution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resolutionStrategy = "resolutionStrategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resolutionStrategy = resolutionStrategy {
            try encodeContainer.encode(resolutionStrategy.rawValue, forKey: .resolutionStrategy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolutionStrategyDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ResolutionStrategy.self, forKey: .resolutionStrategy)
        resolutionStrategy = resolutionStrategyDecoded
    }
}

extension AmplifyBackendClientTypes.BackendAPIConflictResolution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackendAPIConflictResolution(resolutionStrategy: \(Swift.String(describing: resolutionStrategy)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes the conflict resolution configuration for your data model configured in your Amplify project.
    public struct BackendAPIConflictResolution: Swift.Equatable {
        /// The strategy for conflict resolution.
        public let resolutionStrategy: AmplifyBackendClientTypes.ResolutionStrategy?

        public init (
            resolutionStrategy: AmplifyBackendClientTypes.ResolutionStrategy? = nil
        )
        {
            self.resolutionStrategy = resolutionStrategy
        }
    }

}

extension AmplifyBackendClientTypes.BackendAPIResourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalAuthTypes = "additionalAuthTypes"
        case apiName = "apiName"
        case conflictResolution = "conflictResolution"
        case defaultAuthType = "defaultAuthType"
        case service = "service"
        case transformSchema = "transformSchema"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthTypes = additionalAuthTypes {
            var additionalAuthTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthTypes)
            for listofbackendapiauthtype0 in additionalAuthTypes {
                try additionalAuthTypesContainer.encode(listofbackendapiauthtype0)
            }
        }
        if let apiName = apiName {
            try encodeContainer.encode(apiName, forKey: .apiName)
        }
        if let conflictResolution = conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let defaultAuthType = defaultAuthType {
            try encodeContainer.encode(defaultAuthType, forKey: .defaultAuthType)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let transformSchema = transformSchema {
            try encodeContainer.encode(transformSchema, forKey: .transformSchema)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalAuthTypesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.BackendAPIAuthType?].self, forKey: .additionalAuthTypes)
        var additionalAuthTypesDecoded0:[AmplifyBackendClientTypes.BackendAPIAuthType]? = nil
        if let additionalAuthTypesContainer = additionalAuthTypesContainer {
            additionalAuthTypesDecoded0 = [AmplifyBackendClientTypes.BackendAPIAuthType]()
            for structure0 in additionalAuthTypesContainer {
                if let structure0 = structure0 {
                    additionalAuthTypesDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthTypes = additionalAuthTypesDecoded0
        let apiNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiName)
        apiName = apiNameDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
        let defaultAuthTypeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIAuthType.self, forKey: .defaultAuthType)
        defaultAuthType = defaultAuthTypeDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let transformSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformSchema)
        transformSchema = transformSchemaDecoded
    }
}

extension AmplifyBackendClientTypes.BackendAPIResourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackendAPIResourceConfig(additionalAuthTypes: \(Swift.String(describing: additionalAuthTypes)), apiName: \(Swift.String(describing: apiName)), conflictResolution: \(Swift.String(describing: conflictResolution)), defaultAuthType: \(Swift.String(describing: defaultAuthType)), service: \(Swift.String(describing: service)), transformSchema: \(Swift.String(describing: transformSchema)))"}
}

extension AmplifyBackendClientTypes {
    /// The resource config for the data model, configured as a part of the Amplify project.
    public struct BackendAPIResourceConfig: Swift.Equatable {
        /// Additional authentication methods used to interact with your data models.
        public let additionalAuthTypes: [AmplifyBackendClientTypes.BackendAPIAuthType]?
        /// The API name used to interact with the data model, configured as a part of your Amplify project.
        public let apiName: Swift.String?
        /// The conflict resolution strategy for your data stored in the data models.
        public let conflictResolution: AmplifyBackendClientTypes.BackendAPIConflictResolution?
        /// The default authentication type for interacting with the configured data models in your Amplify project.
        public let defaultAuthType: AmplifyBackendClientTypes.BackendAPIAuthType?
        /// The service used to provision and interact with the data model.
        public let service: Swift.String?
        /// The definition of the data model in the annotated transform of the GraphQL schema.
        public let transformSchema: Swift.String?

        public init (
            additionalAuthTypes: [AmplifyBackendClientTypes.BackendAPIAuthType]? = nil,
            apiName: Swift.String? = nil,
            conflictResolution: AmplifyBackendClientTypes.BackendAPIConflictResolution? = nil,
            defaultAuthType: AmplifyBackendClientTypes.BackendAPIAuthType? = nil,
            service: Swift.String? = nil,
            transformSchema: Swift.String? = nil
        )
        {
            self.additionalAuthTypes = additionalAuthTypes
            self.apiName = apiName
            self.conflictResolution = conflictResolution
            self.defaultAuthType = defaultAuthType
            self.service = service
            self.transformSchema = transformSchema
        }
    }

}

extension AmplifyBackendClientTypes.BackendAuthAppleProviderConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "client_id"
        case keyId = "key_id"
        case privateKey = "private_key"
        case teamId = "team_id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let teamId = teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
    }
}

extension AmplifyBackendClientTypes.BackendAuthAppleProviderConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackendAuthAppleProviderConfig(clientId: \(Swift.String(describing: clientId)), keyId: \(Swift.String(describing: keyId)), privateKey: \(Swift.String(describing: privateKey)), teamId: \(Swift.String(describing: teamId)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes Apple social federation configurations for allowing your app users to sign in using OAuth.
    public struct BackendAuthAppleProviderConfig: Swift.Equatable {
        /// Describes the client_id (also called Services ID) that comes from Apple.
        public let clientId: Swift.String?
        /// Describes the key_id that comes from Apple.
        public let keyId: Swift.String?
        /// Describes the private_key that comes from Apple.
        public let privateKey: Swift.String?
        /// Describes the team_id that comes from Apple.
        public let teamId: Swift.String?

        public init (
            clientId: Swift.String? = nil,
            keyId: Swift.String? = nil,
            privateKey: Swift.String? = nil,
            teamId: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.keyId = keyId
            self.privateKey = privateKey
            self.teamId = teamId
        }
    }

}

extension AmplifyBackendClientTypes.BackendAuthSocialProviderConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId = "client_id"
        case clientSecret = "client_secret"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension AmplifyBackendClientTypes.BackendAuthSocialProviderConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackendAuthSocialProviderConfig(clientId: \(Swift.String(describing: clientId)), clientSecret: \(Swift.String(describing: clientSecret)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
    public struct BackendAuthSocialProviderConfig: Swift.Equatable {
        /// Describes the client_id, which can be obtained from the third-party social federation provider.
        public let clientId: Swift.String?
        /// Describes the client_secret, which can be obtained from third-party social federation providers.
        public let clientSecret: Swift.String?

        public init (
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }

}

extension AmplifyBackendClientTypes.BackendJobRespObj: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let updateTime = updateTime {
            try encodeContainer.encode(updateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension AmplifyBackendClientTypes.BackendJobRespObj: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BackendJobRespObj(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), createTime: \(Swift.String(describing: createTime)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension AmplifyBackendClientTypes {
    /// The response object for this operation.
    public struct BackendJobRespObj: Swift.Equatable {
        /// The app ID.
        /// This member is required.
        public let appId: Swift.String?
        /// The name of the backend environment.
        /// This member is required.
        public let backendEnvironmentName: Swift.String?
        /// The time when the job was created.
        public let createTime: Swift.String?
        /// If the request fails, this error is returned.
        public let error: Swift.String?
        /// The ID for the job.
        public let jobId: Swift.String?
        /// The name of the operation.
        public let operation: Swift.String?
        /// The current status of the request.
        public let status: Swift.String?
        /// The time when the job was last updated.
        public let updateTime: Swift.String?

        public init (
            appId: Swift.String? = nil,
            backendEnvironmentName: Swift.String? = nil,
            createTime: Swift.String? = nil,
            error: Swift.String? = nil,
            jobId: Swift.String? = nil,
            operation: Swift.String? = nil,
            status: Swift.String? = nil,
            updateTime: Swift.String? = nil
        )
        {
            self.appId = appId
            self.backendEnvironmentName = backendEnvironmentName
            self.createTime = createTime
            self.error = error
            self.jobId = jobId
            self.operation = operation
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension BadRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BadRequestException(message: \(Swift.String(describing: message)))"}
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error returned if a request is not formed properly.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// An error message to inform that the request failed.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CloneBackendInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloneBackendInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CloneBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloneBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CloneBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CloneBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloneBackendOutputError>
}

extension CloneBackendInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloneBackendInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), targetEnvironmentName: \(Swift.String(describing: targetEnvironmentName)))"}
}

extension CloneBackendInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetEnvironmentName = "targetEnvironmentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetEnvironmentName = targetEnvironmentName {
            try encodeContainer.encode(targetEnvironmentName, forKey: .targetEnvironmentName)
        }
    }
}

public struct CloneBackendInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloneBackendInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CloneBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloneBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CloneBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CloneBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloneBackendOutputError>
}

public struct CloneBackendInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CloneBackendInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CloneBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CloneBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CloneBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CloneBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CloneBackendOutputError>
}

/// The request body for CloneBackend.
public struct CloneBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The name of the destination backend environment to be created.
    /// This member is required.
    public let targetEnvironmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        targetEnvironmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.targetEnvironmentName = targetEnvironmentName
    }
}

struct CloneBackendInputBody: Swift.Equatable {
    public let targetEnvironmentName: Swift.String?
}

extension CloneBackendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetEnvironmentName = "targetEnvironmentName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEnvironmentName)
        targetEnvironmentName = targetEnvironmentNameDecoded
    }
}

extension CloneBackendOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CloneBackendOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CloneBackendOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CloneBackendOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloneBackendOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension CloneBackendOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CloneBackendOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CloneBackendOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CloneBackendOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension CloneBackendOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateBackendAPIInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendAPIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendAPIOutputError>
}

extension CreateBackendAPIInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAPIInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceConfig: \(Swift.String(describing: resourceConfig)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension CreateBackendAPIInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct CreateBackendAPIInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendAPIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendAPIOutputError>
}

public struct CreateBackendAPIInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendAPIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendAPIOutputError>
}

/// The request body for CreateBackendAPI.
public struct CreateBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The resource configuration for this request.
    /// This member is required.
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendAPIInputBody: Swift.Equatable {
    public let backendEnvironmentName: Swift.String?
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    public let resourceName: Swift.String?
}

extension CreateBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendAPIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendAPIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackendAPIOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendAPIOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAPIOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension CreateBackendAPIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendAPIOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendAPIOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension CreateBackendAPIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthForgotPasswordConfig(deliveryMethod: \(Swift.String(describing: deliveryMethod)), emailSettings: \(Swift.String(describing: emailSettings)), smsSettings: \(Swift.String(describing: smsSettings)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes the forgot password policy for authenticating into the Amplify app.
    public struct CreateBackendAuthForgotPasswordConfig: Swift.Equatable {
        /// Describes which mode to use (either SMS or email) to deliver messages to app users who want to recover their password.
        /// This member is required.
        public let deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// The configuration for the email sent when an app user forgets their password.
        public let emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// The configuration for the SMS message sent when an app user forgets their password.
        public let smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init (
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolName = "identityPoolName"
        case unauthenticatedLogin = "unauthenticatedLogin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let unauthenticatedLogin = unauthenticatedLogin {
            try encodeContainer.encode(unauthenticatedLogin, forKey: .unauthenticatedLogin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let unauthenticatedLoginDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unauthenticatedLogin)
        unauthenticatedLogin = unauthenticatedLoginDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthIdentityPoolConfig(identityPoolName: \(Swift.String(describing: identityPoolName)), unauthenticatedLogin: \(Swift.String(describing: unauthenticatedLogin)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes authorization configurations for the auth resources, configured as a part of your Amplify project.
    public struct CreateBackendAuthIdentityPoolConfig: Swift.Equatable {
        /// Name of the Amazon Cognito identity pool used for authorization.
        /// This member is required.
        public let identityPoolName: Swift.String?
        /// Set to true or false based on whether you want to enable guest authorization to your Amplify app.
        /// This member is required.
        public let unauthenticatedLogin: Swift.Bool?

        public init (
            identityPoolName: Swift.String? = nil,
            unauthenticatedLogin: Swift.Bool? = nil
        )
        {
            self.identityPoolName = identityPoolName
            self.unauthenticatedLogin = unauthenticatedLogin
        }
    }

}

public struct CreateBackendAuthInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendAuthOutputError>
}

extension CreateBackendAuthInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceConfig: \(Swift.String(describing: resourceConfig)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension CreateBackendAuthInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct CreateBackendAuthInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendAuthOutputError>
}

public struct CreateBackendAuthInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendAuthOutputError>
}

/// The request body for CreateBackendAuth.
public struct CreateBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The resource configuration for this request object.
    /// This member is required.
    public let resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendAuthInputBody: Swift.Equatable {
    public let backendEnvironmentName: Swift.String?
    public let resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    public let resourceName: Swift.String?
}

extension CreateBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthMFAConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mFAMode = "MFAMode"
        case settings = "settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mFAMode = mFAMode {
            try encodeContainer.encode(mFAMode.rawValue, forKey: .mFAMode)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mFAModeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.MFAMode.self, forKey: .mFAMode)
        mFAMode = mFAModeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthMFAConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthMFAConfig(mFAMode: \(Swift.String(describing: mFAMode)), settings: \(Swift.String(describing: settings)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
    public struct CreateBackendAuthMFAConfig: Swift.Equatable {
        /// Describes whether MFA should be [ON, OFF, or OPTIONAL] for authentication in your Amplify project.
        /// This member is required.
        public let mFAMode: AmplifyBackendClientTypes.MFAMode?
        /// Describes the configuration settings and methods for your Amplify app users to use MFA.
        public let settings: AmplifyBackendClientTypes.Settings?

        public init (
            mFAMode: AmplifyBackendClientTypes.MFAMode? = nil,
            settings: AmplifyBackendClientTypes.Settings? = nil
        )
        {
            self.mFAMode = mFAMode
            self.settings = settings
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPrefix = "domainPrefix"
        case oAuthGrantType = "oAuthGrantType"
        case oAuthScopes = "oAuthScopes"
        case redirectSignInURIs = "redirectSignInURIs"
        case redirectSignOutURIs = "redirectSignOutURIs"
        case socialProviderSettings = "socialProviderSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainPrefix = domainPrefix {
            try encodeContainer.encode(domainPrefix, forKey: .domainPrefix)
        }
        if let oAuthGrantType = oAuthGrantType {
            try encodeContainer.encode(oAuthGrantType.rawValue, forKey: .oAuthGrantType)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for listofoauthscopeselement0 in oAuthScopes {
                try oAuthScopesContainer.encode(listofoauthscopeselement0.rawValue)
            }
        }
        if let redirectSignInURIs = redirectSignInURIs {
            var redirectSignInURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignInURIs)
            for listof__string0 in redirectSignInURIs {
                try redirectSignInURIsContainer.encode(listof__string0)
            }
        }
        if let redirectSignOutURIs = redirectSignOutURIs {
            var redirectSignOutURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignOutURIs)
            for listof__string0 in redirectSignOutURIs {
                try redirectSignOutURIsContainer.encode(listof__string0)
            }
        }
        if let socialProviderSettings = socialProviderSettings {
            try encodeContainer.encode(socialProviderSettings, forKey: .socialProviderSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainPrefix)
        domainPrefix = domainPrefixDecoded
        let oAuthGrantTypeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.OAuthGrantType.self, forKey: .oAuthGrantType)
        oAuthGrantType = oAuthGrantTypeDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.OAuthScopesElement?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[AmplifyBackendClientTypes.OAuthScopesElement]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [AmplifyBackendClientTypes.OAuthScopesElement]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
        let redirectSignInURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignInURIs)
        var redirectSignInURIsDecoded0:[Swift.String]? = nil
        if let redirectSignInURIsContainer = redirectSignInURIsContainer {
            redirectSignInURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignInURIsContainer {
                if let string0 = string0 {
                    redirectSignInURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignInURIs = redirectSignInURIsDecoded0
        let redirectSignOutURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignOutURIs)
        var redirectSignOutURIsDecoded0:[Swift.String]? = nil
        if let redirectSignOutURIsContainer = redirectSignOutURIsContainer {
            redirectSignOutURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignOutURIsContainer {
                if let string0 = string0 {
                    redirectSignOutURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignOutURIs = redirectSignOutURIsDecoded0
        let socialProviderSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SocialProviderSettings.self, forKey: .socialProviderSettings)
        socialProviderSettings = socialProviderSettingsDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthOAuthConfig(domainPrefix: \(Swift.String(describing: domainPrefix)), oAuthGrantType: \(Swift.String(describing: oAuthGrantType)), oAuthScopes: \(Swift.String(describing: oAuthScopes)), redirectSignInURIs: \(Swift.String(describing: redirectSignInURIs)), redirectSignOutURIs: \(Swift.String(describing: redirectSignOutURIs)), socialProviderSettings: \(Swift.String(describing: socialProviderSettings)))"}
}

extension AmplifyBackendClientTypes {
    /// Creates the OAuth configuration for your Amplify project.
    public struct CreateBackendAuthOAuthConfig: Swift.Equatable {
        /// The domain prefix for your Amplify app.
        public let domainPrefix: Swift.String?
        /// The OAuth grant type that you use to allow app users to authenticate from your Amplify app.
        /// This member is required.
        public let oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType?
        /// List of OAuth-related flows used to allow your app users to authenticate from your Amplify app.
        /// This member is required.
        public let oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]?
        /// The redirected URI for signing in to your Amplify app.
        /// This member is required.
        public let redirectSignInURIs: [Swift.String]?
        /// Redirect URLs that OAuth uses when a user signs out of an Amplify app.
        /// This member is required.
        public let redirectSignOutURIs: [Swift.String]?
        /// The settings for using social providers to access your Amplify app.
        public let socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings?

        public init (
            domainPrefix: Swift.String? = nil,
            oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType? = nil,
            oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]? = nil,
            redirectSignInURIs: [Swift.String]? = nil,
            redirectSignOutURIs: [Swift.String]? = nil,
            socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings? = nil
        )
        {
            self.domainPrefix = domainPrefix
            self.oAuthGrantType = oAuthGrantType
            self.oAuthScopes = oAuthScopes
            self.redirectSignInURIs = redirectSignInURIs
            self.redirectSignOutURIs = redirectSignOutURIs
            self.socialProviderSettings = socialProviderSettings
        }
    }

}

extension CreateBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendAuthOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension CreateBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendAuthOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension CreateBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConstraints = "additionalConstraints"
        case minimumLength = "minimumLength"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConstraints = additionalConstraints {
            var additionalConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConstraints)
            for listofadditionalconstraintselement0 in additionalConstraints {
                try additionalConstraintsContainer.encode(listofadditionalconstraintselement0.rawValue)
            }
        }
        if let minimumLength = minimumLength {
            try encodeContainer.encode(minimumLength, forKey: .minimumLength)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalConstraintsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.AdditionalConstraintsElement?].self, forKey: .additionalConstraints)
        var additionalConstraintsDecoded0:[AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil
        if let additionalConstraintsContainer = additionalConstraintsContainer {
            additionalConstraintsDecoded0 = [AmplifyBackendClientTypes.AdditionalConstraintsElement]()
            for string0 in additionalConstraintsContainer {
                if let string0 = string0 {
                    additionalConstraintsDecoded0?.append(string0)
                }
            }
        }
        additionalConstraints = additionalConstraintsDecoded0
        let minimumLengthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimumLength)
        minimumLength = minimumLengthDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthPasswordPolicyConfig(additionalConstraints: \(Swift.String(describing: additionalConstraints)), minimumLength: \(Swift.String(describing: minimumLength)))"}
}

extension AmplifyBackendClientTypes {
    /// The password policy configuration for the backend to your Amplify project.
    public struct CreateBackendAuthPasswordPolicyConfig: Swift.Equatable {
        /// Additional constraints for the password used to access the backend of your Amplify project.
        public let additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]?
        /// The minimum length of the password used to access the backend of your Amplify project.
        /// This member is required.
        public let minimumLength: Swift.Double?

        public init (
            additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil,
            minimumLength: Swift.Double? = nil
        )
        {
            self.additionalConstraints = additionalConstraints
            self.minimumLength = minimumLength
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthResourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authResources = "authResources"
        case identityPoolConfigs = "identityPoolConfigs"
        case service = "service"
        case userPoolConfigs = "userPoolConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authResources = authResources {
            try encodeContainer.encode(authResources.rawValue, forKey: .authResources)
        }
        if let identityPoolConfigs = identityPoolConfigs {
            try encodeContainer.encode(identityPoolConfigs, forKey: .identityPoolConfigs)
        }
        if let service = service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
        if let userPoolConfigs = userPoolConfigs {
            try encodeContainer.encode(userPoolConfigs, forKey: .userPoolConfigs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResourcesDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.AuthResources.self, forKey: .authResources)
        authResources = authResourcesDecoded
        let identityPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig.self, forKey: .identityPoolConfigs)
        identityPoolConfigs = identityPoolConfigsDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let userPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig.self, forKey: .userPoolConfigs)
        userPoolConfigs = userPoolConfigsDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthResourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthResourceConfig(authResources: \(Swift.String(describing: authResources)), identityPoolConfigs: \(Swift.String(describing: identityPoolConfigs)), service: \(Swift.String(describing: service)), userPoolConfigs: \(Swift.String(describing: userPoolConfigs)))"}
}

extension AmplifyBackendClientTypes {
    /// Defines the resource configuration when creating an auth resource in your Amplify project.
    public struct CreateBackendAuthResourceConfig: Swift.Equatable {
        /// Defines whether you want to configure only authentication or both authentication and authorization settings.
        /// This member is required.
        public let authResources: AmplifyBackendClientTypes.AuthResources?
        /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
        public let identityPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig?
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        /// This member is required.
        public let service: AmplifyBackendClientTypes.Service?
        /// Describes authentication configuration for the Amazon Cognito user pool, provisioned as a part of your auth resource in the Amplify project.
        /// This member is required.
        public let userPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig?

        public init (
            authResources: AmplifyBackendClientTypes.AuthResources? = nil,
            identityPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthIdentityPoolConfig? = nil,
            service: AmplifyBackendClientTypes.Service? = nil,
            userPoolConfigs: AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig? = nil
        )
        {
            self.authResources = authResources
            self.identityPoolConfigs = identityPoolConfigs
            self.service = service
            self.userPoolConfigs = userPoolConfigs
        }
    }

}

extension AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPassword = "forgotPassword"
        case mfa = "mfa"
        case oAuth = "oAuth"
        case passwordPolicy = "passwordPolicy"
        case requiredSignUpAttributes = "requiredSignUpAttributes"
        case signInMethod = "signInMethod"
        case userPoolName = "userPoolName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPassword = forgotPassword {
            try encodeContainer.encode(forgotPassword, forKey: .forgotPassword)
        }
        if let mfa = mfa {
            try encodeContainer.encode(mfa, forKey: .mfa)
        }
        if let oAuth = oAuth {
            try encodeContainer.encode(oAuth, forKey: .oAuth)
        }
        if let passwordPolicy = passwordPolicy {
            try encodeContainer.encode(passwordPolicy, forKey: .passwordPolicy)
        }
        if let requiredSignUpAttributes = requiredSignUpAttributes {
            var requiredSignUpAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredSignUpAttributes)
            for listofrequiredsignupattributeselement0 in requiredSignUpAttributes {
                try requiredSignUpAttributesContainer.encode(listofrequiredsignupattributeselement0.rawValue)
            }
        }
        if let signInMethod = signInMethod {
            try encodeContainer.encode(signInMethod.rawValue, forKey: .signInMethod)
        }
        if let userPoolName = userPoolName {
            try encodeContainer.encode(userPoolName, forKey: .userPoolName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forgotPasswordDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig.self, forKey: .forgotPassword)
        forgotPassword = forgotPasswordDecoded
        let mfaDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthMFAConfig.self, forKey: .mfa)
        mfa = mfaDecoded
        let oAuthDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig.self, forKey: .oAuth)
        oAuth = oAuthDecoded
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
        let requiredSignUpAttributesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.RequiredSignUpAttributesElement?].self, forKey: .requiredSignUpAttributes)
        var requiredSignUpAttributesDecoded0:[AmplifyBackendClientTypes.RequiredSignUpAttributesElement]? = nil
        if let requiredSignUpAttributesContainer = requiredSignUpAttributesContainer {
            requiredSignUpAttributesDecoded0 = [AmplifyBackendClientTypes.RequiredSignUpAttributesElement]()
            for string0 in requiredSignUpAttributesContainer {
                if let string0 = string0 {
                    requiredSignUpAttributesDecoded0?.append(string0)
                }
            }
        }
        requiredSignUpAttributes = requiredSignUpAttributesDecoded0
        let signInMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SignInMethod.self, forKey: .signInMethod)
        signInMethod = signInMethodDecoded
        let userPoolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolName)
        userPoolName = userPoolNameDecoded
    }
}

extension AmplifyBackendClientTypes.CreateBackendAuthUserPoolConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendAuthUserPoolConfig(forgotPassword: \(Swift.String(describing: forgotPassword)), mfa: \(Swift.String(describing: mfa)), oAuth: \(Swift.String(describing: oAuth)), passwordPolicy: \(Swift.String(describing: passwordPolicy)), requiredSignUpAttributes: \(Swift.String(describing: requiredSignUpAttributes)), signInMethod: \(Swift.String(describing: signInMethod)), userPoolName: \(Swift.String(describing: userPoolName)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes the Amazon Cognito user pool configuration for the auth resource to be configured for your Amplify project.
    public struct CreateBackendAuthUserPoolConfig: Swift.Equatable {
        /// Describes the forgotten password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let forgotPassword: AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig?
        /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
        public let mfa: AmplifyBackendClientTypes.CreateBackendAuthMFAConfig?
        /// Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let oAuth: AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig?
        /// Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let passwordPolicy: AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig?
        /// The required attributes to sign up new users in the user pool.
        /// This member is required.
        public let requiredSignUpAttributes: [AmplifyBackendClientTypes.RequiredSignUpAttributesElement]?
        /// Describes the sign-in methods that your Amplify app users use to log in using the Amazon Cognito user pool, configured as a part of your Amplify project.
        /// This member is required.
        public let signInMethod: AmplifyBackendClientTypes.SignInMethod?
        /// The Amazon Cognito user pool name.
        /// This member is required.
        public let userPoolName: Swift.String?

        public init (
            forgotPassword: AmplifyBackendClientTypes.CreateBackendAuthForgotPasswordConfig? = nil,
            mfa: AmplifyBackendClientTypes.CreateBackendAuthMFAConfig? = nil,
            oAuth: AmplifyBackendClientTypes.CreateBackendAuthOAuthConfig? = nil,
            passwordPolicy: AmplifyBackendClientTypes.CreateBackendAuthPasswordPolicyConfig? = nil,
            requiredSignUpAttributes: [AmplifyBackendClientTypes.RequiredSignUpAttributesElement]? = nil,
            signInMethod: AmplifyBackendClientTypes.SignInMethod? = nil,
            userPoolName: Swift.String? = nil
        )
        {
            self.forgotPassword = forgotPassword
            self.mfa = mfa
            self.oAuth = oAuth
            self.passwordPolicy = passwordPolicy
            self.requiredSignUpAttributes = requiredSignUpAttributes
            self.signInMethod = signInMethod
            self.userPoolName = userPoolName
        }
    }

}

public struct CreateBackendConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendConfigOutputError>
}

extension CreateBackendConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendConfigInput(appId: \(Swift.String(describing: appId)), backendManagerAppId: \(Swift.String(describing: backendManagerAppId)))"}
}

extension CreateBackendConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendManagerAppId = "backendManagerAppId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendManagerAppId = backendManagerAppId {
            try encodeContainer.encode(backendManagerAppId, forKey: .backendManagerAppId)
        }
    }
}

public struct CreateBackendConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendConfigOutputError>
}

public struct CreateBackendConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendConfigOutputError>
}

/// The request body for CreateBackendConfig.
public struct CreateBackendConfigInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The app ID for the backend manager.
    public let backendManagerAppId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendManagerAppId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendManagerAppId = backendManagerAppId
    }
}

struct CreateBackendConfigInputBody: Swift.Equatable {
    public let backendManagerAppId: Swift.String?
}

extension CreateBackendConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendManagerAppId = "backendManagerAppId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendManagerAppIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendManagerAppId)
        backendManagerAppId = backendManagerAppIdDecoded
    }
}

extension CreateBackendConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackendConfigOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendConfigOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), jobId: \(Swift.String(describing: jobId)), status: \(Swift.String(describing: status)))"}
}

extension CreateBackendConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBackendConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct CreateBackendConfigOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.status = status
    }
}

struct CreateBackendConfigOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let jobId: Swift.String?
    public let status: Swift.String?
}

extension CreateBackendConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case jobId = "jobId"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateBackendInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendOutputError>
}

extension CreateBackendInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendInput(appId: \(Swift.String(describing: appId)), appName: \(Swift.String(describing: appName)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceConfig: \(Swift.String(describing: resourceConfig)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension CreateBackendInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appName = appName {
            try encodeContainer.encode(appName, forKey: .appName)
        }
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct CreateBackendInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendOutputError>
}

public struct CreateBackendInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackendInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackendOutputError>
}

/// The request body for CreateBackend.
public struct CreateBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the app.
    /// This member is required.
    public let appName: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The resource configuration for the create backend request.
    public let resourceConfig: AmplifyBackendClientTypes.ResourceConfig?
    /// The name of the resource.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        appName: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.ResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.appName = appName
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct CreateBackendInputBody: Swift.Equatable {
    public let appId: Swift.String?
    public let appName: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let resourceConfig: AmplifyBackendClientTypes.ResourceConfig?
    public let resourceName: Swift.String?
}

extension CreateBackendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentName = "backendEnvironmentName"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let appNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appName)
        appName = appNameDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.ResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CreateBackendOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackendOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackendOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackendOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackendOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension CreateBackendOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBackendOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct CreateBackendOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct CreateBackendOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension CreateBackendOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension CreateTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenInput(appId: \(Swift.String(describing: appId)))"}
}

extension CreateTokenInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CreateTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTokenOutputError>
}

public struct CreateTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTokenOutputError>
}

public struct CreateTokenInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?

    public init (
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct CreateTokenInputBody: Swift.Equatable {
}

extension CreateTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTokenOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTokenOutputResponse(appId: \(Swift.String(describing: appId)), challengeCode: \(Swift.String(describing: challengeCode)), sessionId: \(Swift.String(describing: sessionId)), ttl: \(Swift.String(describing: ttl)))"}
}

extension CreateTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.challengeCode = output.challengeCode
            self.sessionId = output.sessionId
            self.ttl = output.ttl
        } else {
            self.appId = nil
            self.challengeCode = nil
            self.sessionId = nil
            self.ttl = nil
        }
    }
}

public struct CreateTokenOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// One-time challenge code for authenticating into the Amplify Admin UI.
    public let challengeCode: Swift.String?
    /// A unique ID provided when creating a new challenge token.
    public let sessionId: Swift.String?
    /// The expiry time for the one-time generated token code.
    public let ttl: Swift.String?

    public init (
        appId: Swift.String? = nil,
        challengeCode: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.challengeCode = challengeCode
        self.sessionId = sessionId
        self.ttl = ttl
    }
}

struct CreateTokenOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let challengeCode: Swift.String?
    public let sessionId: Swift.String?
    public let ttl: Swift.String?
}

extension CreateTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case challengeCode = "challengeCode"
        case sessionId = "sessionId"
        case ttl = "ttl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let challengeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .challengeCode)
        challengeCode = challengeCodeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

public struct DeleteBackendAPIInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackendAPIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackendAPIOutputError>
}

extension DeleteBackendAPIInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackendAPIInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceConfig: \(Swift.String(describing: resourceConfig)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension DeleteBackendAPIInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct DeleteBackendAPIInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackendAPIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackendAPIOutputError>
}

public struct DeleteBackendAPIInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackendAPIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackendAPIOutputError>
}

/// The request body for DeleteBackendAPI.
public struct DeleteBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// Defines the resource configuration for the data model in your Amplify project.
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct DeleteBackendAPIInputBody: Swift.Equatable {
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    public let resourceName: Swift.String?
}

extension DeleteBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeleteBackendAPIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendAPIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackendAPIOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendAPIOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackendAPIOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension DeleteBackendAPIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendAPIOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendAPIOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension DeleteBackendAPIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeleteBackendAuthInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackendAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackendAuthOutputError>
}

extension DeleteBackendAuthInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackendAuthInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension DeleteBackendAuthInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct DeleteBackendAuthInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackendAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackendAuthOutputError>
}

public struct DeleteBackendAuthInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackendAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackendAuthOutputError>
}

/// The request body for DeleteBackendAuth.
public struct DeleteBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct DeleteBackendAuthInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
}

extension DeleteBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension DeleteBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendAuthOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackendAuthOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension DeleteBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendAuthOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension DeleteBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteBackendInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackendInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)))"}
}

extension DeleteBackendInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteBackendInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackendInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackendOutputError>
}

public struct DeleteBackendInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackendInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackendOutputError>
}

public struct DeleteBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
    }
}

struct DeleteBackendInputBody: Swift.Equatable {
}

extension DeleteBackendInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBackendOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackendOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackendOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackendOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackendOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension DeleteBackendOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteBackendOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct DeleteBackendOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct DeleteBackendOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension DeleteBackendOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTokenInput(appId: \(Swift.String(describing: appId)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension DeleteTokenInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTokenOutputError>
}

public struct DeleteTokenInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The session ID.
    /// This member is required.
    public let sessionId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.sessionId = sessionId
    }
}

struct DeleteTokenInputBody: Swift.Equatable {
}

extension DeleteTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTokenOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTokenOutputResponse(isSuccess: \(Swift.String(describing: isSuccess)))"}
}

extension DeleteTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.isSuccess = output.isSuccess
        } else {
            self.isSuccess = nil
        }
    }
}

public struct DeleteTokenOutputResponse: Swift.Equatable {
    /// Indicates whether the request succeeded or failed.
    public let isSuccess: Swift.Bool?

    public init (
        isSuccess: Swift.Bool? = nil
    )
    {
        self.isSuccess = isSuccess
    }
}

struct DeleteTokenOutputResponseBody: Swift.Equatable {
    public let isSuccess: Swift.Bool?
}

extension DeleteTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isSuccess = "isSuccess"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isSuccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSuccess)
        isSuccess = isSuccessDecoded
    }
}

extension AmplifyBackendClientTypes {
    public enum DeliveryMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sms
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryMethod] {
            return [
                .email,
                .sms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sms: return "SMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeliveryMethod(rawValue: rawValue) ?? DeliveryMethod.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.EmailSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailMessage = "emailMessage"
        case emailSubject = "emailSubject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailMessage = emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if let emailSubject = emailSubject {
            try encodeContainer.encode(emailSubject, forKey: .emailSubject)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
        let emailSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailSubject)
        emailSubject = emailSubjectDecoded
    }
}

extension AmplifyBackendClientTypes.EmailSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmailSettings(emailMessage: \(Swift.String(describing: emailMessage)), emailSubject: \(Swift.String(describing: emailSubject)))"}
}

extension AmplifyBackendClientTypes {
    /// The configuration for the email sent when an app user forgets their password.
    public struct EmailSettings: Swift.Equatable {
        /// The body of the email.
        public let emailMessage: Swift.String?
        /// The subject of the email.
        public let emailSubject: Swift.String?

        public init (
            emailMessage: Swift.String? = nil,
            emailSubject: Swift.String? = nil
        )
        {
            self.emailMessage = emailMessage
            self.emailSubject = emailSubject
        }
    }

}

extension GatewayTimeoutException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GatewayTimeoutException(message: \(Swift.String(describing: message)))"}
}

extension GatewayTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GatewayTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error returned if there's a temporary issue with the service.
public struct GatewayTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// An error message to inform that the request failed.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GatewayTimeoutExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension GatewayTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GenerateBackendAPIModelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GenerateBackendAPIModelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GenerateBackendAPIModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GenerateBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GenerateBackendAPIModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GenerateBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GenerateBackendAPIModelsOutputError>
}

extension GenerateBackendAPIModelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateBackendAPIModelsInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension GenerateBackendAPIModelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct GenerateBackendAPIModelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GenerateBackendAPIModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GenerateBackendAPIModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GenerateBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GenerateBackendAPIModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GenerateBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GenerateBackendAPIModelsOutputError>
}

public struct GenerateBackendAPIModelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GenerateBackendAPIModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GenerateBackendAPIModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GenerateBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GenerateBackendAPIModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GenerateBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GenerateBackendAPIModelsOutputError>
}

/// The request body for GenerateBackendAPIModels.
public struct GenerateBackendAPIModelsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GenerateBackendAPIModelsInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
}

extension GenerateBackendAPIModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GenerateBackendAPIModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateBackendAPIModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateBackendAPIModelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateBackendAPIModelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateBackendAPIModelsOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension GenerateBackendAPIModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GenerateBackendAPIModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct GenerateBackendAPIModelsOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct GenerateBackendAPIModelsOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension GenerateBackendAPIModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct GetBackendAPIInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendAPIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendAPIOutputError>
}

extension GetBackendAPIInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendAPIInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceConfig: \(Swift.String(describing: resourceConfig)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension GetBackendAPIInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct GetBackendAPIInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendAPIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendAPIOutputError>
}

public struct GetBackendAPIInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendAPIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendAPIOutputError>
}

/// The request body for GetBackendAPI.
public struct GetBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// Defines the resource configuration for the data model in your Amplify project.
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAPIInputBody: Swift.Equatable {
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    public let resourceName: Swift.String?
}

extension GetBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct GetBackendAPIModelsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendAPIModelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendAPIModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendAPIModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendAPIModelsOutputError>
}

extension GetBackendAPIModelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendAPIModelsInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension GetBackendAPIModelsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct GetBackendAPIModelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendAPIModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendAPIModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendAPIModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendAPIModelsOutputError>
}

public struct GetBackendAPIModelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendAPIModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendAPIModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendAPIModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendAPIModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendAPIModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendAPIModelsOutputError>
}

/// The request body for GetBackendAPIModels.
public struct GetBackendAPIModelsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendAPIModelsInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
}

extension GetBackendAPIModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAPIModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendAPIModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendAPIModelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendAPIModelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendAPIModelsOutputResponse(models: \(Swift.String(describing: models)), status: \(Swift.String(describing: status)))"}
}

extension GetBackendAPIModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackendAPIModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.models = output.models
            self.status = output.status
        } else {
            self.models = nil
            self.status = nil
        }
    }
}

public struct GetBackendAPIModelsOutputResponse: Swift.Equatable {
    /// Stringified JSON of the datastore model.
    public let models: Swift.String?
    /// The current status of the request.
    public let status: AmplifyBackendClientTypes.Status?

    public init (
        models: Swift.String? = nil,
        status: AmplifyBackendClientTypes.Status? = nil
    )
    {
        self.models = models
        self.status = status
    }
}

struct GetBackendAPIModelsOutputResponseBody: Swift.Equatable {
    public let models: Swift.String?
    public let status: AmplifyBackendClientTypes.Status?
}

extension GetBackendAPIModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case models = "models"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .models)
        models = modelsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetBackendAPIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendAPIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendAPIOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendAPIOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendAPIOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), resourceConfig: \(Swift.String(describing: resourceConfig)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension GetBackendAPIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendAPIOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The resource configuration for this response object.
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAPIOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    public let resourceName: Swift.String?
}

extension GetBackendAPIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct GetBackendAuthInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendAuthOutputError>
}

extension GetBackendAuthInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendAuthInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension GetBackendAuthInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct GetBackendAuthInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendAuthOutputError>
}

public struct GetBackendAuthInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendAuthOutputError>
}

/// The request body for GetBackendAuth.
public struct GetBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceName = resourceName
    }
}

struct GetBackendAuthInputBody: Swift.Equatable {
    public let resourceName: Swift.String?
}

extension GetBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension GetBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendAuthOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendAuthOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), resourceConfig: \(Swift.String(describing: resourceConfig)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension GetBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.resourceConfig = output.resourceConfig
            self.resourceName = output.resourceName
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.resourceConfig = nil
            self.resourceName = nil
        }
    }
}

public struct GetBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The resource configuration for authorization requests to the backend of your Amplify project.
    public let resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    /// The name of this resource.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct GetBackendAuthOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let resourceConfig: AmplifyBackendClientTypes.CreateBackendAuthResourceConfig?
    public let resourceName: Swift.String?
}

extension GetBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.CreateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct GetBackendInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendOutputError>
}

extension GetBackendInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)))"}
}

extension GetBackendInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendEnvironmentName = backendEnvironmentName {
            try encodeContainer.encode(backendEnvironmentName, forKey: .backendEnvironmentName)
        }
    }
}

public struct GetBackendInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendOutputError>
}

public struct GetBackendInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendOutputError>
}

/// The request body for GetBackend.
public struct GetBackendInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
    }
}

struct GetBackendInputBody: Swift.Equatable {
    public let backendEnvironmentName: Swift.String?
}

extension GetBackendInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backendEnvironmentName = "backendEnvironmentName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
    }
}

extension GetBackendJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendJobInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), jobId: \(Swift.String(describing: jobId)))"}
}

extension GetBackendJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetBackendJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendJobOutputError>
}

public struct GetBackendJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetBackendJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetBackendJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetBackendJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetBackendJobOutputError>
}

public struct GetBackendJobInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The ID for the job.
    /// This member is required.
    public let jobId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
    }
}

struct GetBackendJobInputBody: Swift.Equatable {
}

extension GetBackendJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBackendJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendJobOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendJobOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), createTime: \(Swift.String(describing: createTime)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension GetBackendJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackendJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.createTime = output.createTime
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.createTime = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct GetBackendJobOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// The time when the job was created.
    public let createTime: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?
    /// The time when the job was last updated.
    public let updateTime: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        createTime: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil,
        updateTime: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.createTime = createTime
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
        self.updateTime = updateTime
    }
}

struct GetBackendJobOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let createTime: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
    public let updateTime: Swift.String?
}

extension GetBackendJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension GetBackendOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBackendOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBackendOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBackendOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBackendOutputResponse(amplifyMetaConfig: \(Swift.String(describing: amplifyMetaConfig)), appId: \(Swift.String(describing: appId)), appName: \(Swift.String(describing: appName)), backendEnvironmentList: \(Swift.String(describing: backendEnvironmentList)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)))"}
}

extension GetBackendOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBackendOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.amplifyMetaConfig = output.amplifyMetaConfig
            self.appId = output.appId
            self.appName = output.appName
            self.backendEnvironmentList = output.backendEnvironmentList
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
        } else {
            self.amplifyMetaConfig = nil
            self.appId = nil
            self.appName = nil
            self.backendEnvironmentList = nil
            self.backendEnvironmentName = nil
            self.error = nil
        }
    }
}

public struct GetBackendOutputResponse: Swift.Equatable {
    /// A stringified version of the current configs for your Amplify project.
    public let amplifyMetaConfig: Swift.String?
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the app.
    public let appName: Swift.String?
    /// A list of backend environments in an array.
    public let backendEnvironmentList: [Swift.String]?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request failed, this is the returned error.
    public let error: Swift.String?

    public init (
        amplifyMetaConfig: Swift.String? = nil,
        appId: Swift.String? = nil,
        appName: Swift.String? = nil,
        backendEnvironmentList: [Swift.String]? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil
    )
    {
        self.amplifyMetaConfig = amplifyMetaConfig
        self.appId = appId
        self.appName = appName
        self.backendEnvironmentList = backendEnvironmentList
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
    }
}

struct GetBackendOutputResponseBody: Swift.Equatable {
    public let amplifyMetaConfig: Swift.String?
    public let appId: Swift.String?
    public let appName: Swift.String?
    public let backendEnvironmentList: [Swift.String]?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
}

extension GetBackendOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplifyMetaConfig = "amplifyMetaConfig"
        case appId = "appId"
        case appName = "appName"
        case backendEnvironmentList = "backendEnvironmentList"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplifyMetaConfigDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amplifyMetaConfig)
        amplifyMetaConfig = amplifyMetaConfigDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let appNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appName)
        appName = appNameDecoded
        let backendEnvironmentListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .backendEnvironmentList)
        var backendEnvironmentListDecoded0:[Swift.String]? = nil
        if let backendEnvironmentListContainer = backendEnvironmentListContainer {
            backendEnvironmentListDecoded0 = [Swift.String]()
            for string0 in backendEnvironmentListContainer {
                if let string0 = string0 {
                    backendEnvironmentListDecoded0?.append(string0)
                }
            }
        }
        backendEnvironmentList = backendEnvironmentListDecoded0
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension GetTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTokenInput(appId: \(Swift.String(describing: appId)), sessionId: \(Swift.String(describing: sessionId)))"}
}

extension GetTokenInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTokenOutputError>
}

public struct GetTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTokenOutputError>
}

public struct GetTokenInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The session ID.
    /// This member is required.
    public let sessionId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.sessionId = sessionId
    }
}

struct GetTokenInputBody: Swift.Equatable {
}

extension GetTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTokenOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTokenOutputResponse(appId: \(Swift.String(describing: appId)), challengeCode: \(Swift.String(describing: challengeCode)), sessionId: \(Swift.String(describing: sessionId)), ttl: \(Swift.String(describing: ttl)))"}
}

extension GetTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.challengeCode = output.challengeCode
            self.sessionId = output.sessionId
            self.ttl = output.ttl
        } else {
            self.appId = nil
            self.challengeCode = nil
            self.sessionId = nil
            self.ttl = nil
        }
    }
}

public struct GetTokenOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The one-time challenge code for authenticating into the Amplify Admin UI.
    public let challengeCode: Swift.String?
    /// A unique ID provided when creating a new challenge token.
    public let sessionId: Swift.String?
    /// The expiry time for the one-time generated token code.
    public let ttl: Swift.String?

    public init (
        appId: Swift.String? = nil,
        challengeCode: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        ttl: Swift.String? = nil
    )
    {
        self.appId = appId
        self.challengeCode = challengeCode
        self.sessionId = sessionId
        self.ttl = ttl
    }
}

struct GetTokenOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let challengeCode: Swift.String?
    public let sessionId: Swift.String?
    public let ttl: Swift.String?
}

extension GetTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case challengeCode = "challengeCode"
        case sessionId = "sessionId"
        case ttl = "ttl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let challengeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .challengeCode)
        challengeCode = challengeCodeDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let ttlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ttl)
        ttl = ttlDecoded
    }
}

public struct ImportBackendAuthInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportBackendAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportBackendAuthOutputError>
}

extension ImportBackendAuthInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportBackendAuthInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), identityPoolId: \(Swift.String(describing: identityPoolId)), nativeClientId: \(Swift.String(describing: nativeClientId)), userPoolId: \(Swift.String(describing: userPoolId)), webClientId: \(Swift.String(describing: webClientId)))"}
}

extension ImportBackendAuthInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "identityPoolId"
        case nativeClientId = "nativeClientId"
        case userPoolId = "userPoolId"
        case webClientId = "webClientId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let nativeClientId = nativeClientId {
            try encodeContainer.encode(nativeClientId, forKey: .nativeClientId)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
        if let webClientId = webClientId {
            try encodeContainer.encode(webClientId, forKey: .webClientId)
        }
    }
}

public struct ImportBackendAuthInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportBackendAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportBackendAuthOutputError>
}

public struct ImportBackendAuthInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportBackendAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportBackendAuthOutputError>
}

/// The request body for ImportBackendAuth.
public struct ImportBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The ID of the Amazon Cognito identity pool.
    public let identityPoolId: Swift.String?
    /// The ID of the Amazon Cognito native client.
    /// This member is required.
    public let nativeClientId: Swift.String?
    /// The ID of the Amazon Cognito user pool.
    /// This member is required.
    public let userPoolId: Swift.String?
    /// The ID of the Amazon Cognito web client.
    /// This member is required.
    public let webClientId: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        identityPoolId: Swift.String? = nil,
        nativeClientId: Swift.String? = nil,
        userPoolId: Swift.String? = nil,
        webClientId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.identityPoolId = identityPoolId
        self.nativeClientId = nativeClientId
        self.userPoolId = userPoolId
        self.webClientId = webClientId
    }
}

struct ImportBackendAuthInputBody: Swift.Equatable {
    public let identityPoolId: Swift.String?
    public let nativeClientId: Swift.String?
    public let userPoolId: Swift.String?
    public let webClientId: Swift.String?
}

extension ImportBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityPoolId = "identityPoolId"
        case nativeClientId = "nativeClientId"
        case userPoolId = "userPoolId"
        case webClientId = "webClientId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let nativeClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nativeClientId)
        nativeClientId = nativeClientIdDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let webClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webClientId)
        webClientId = webClientIdDecoded
    }
}

extension ImportBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportBackendAuthOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportBackendAuthOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension ImportBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct ImportBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct ImportBackendAuthOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension ImportBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

public struct ListBackendJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackendJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackendJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackendJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackendJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackendJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackendJobsOutputError>
}

extension ListBackendJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackendJobsInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), jobId: \(Swift.String(describing: jobId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension ListBackendJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "jobId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case operation = "operation"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

public struct ListBackendJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackendJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackendJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackendJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackendJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackendJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackendJobsOutputError>
}

public struct ListBackendJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBackendJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBackendJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBackendJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBackendJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBackendJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBackendJobsOutputError>
}

/// The request body for ListBackendJobs.
public struct ListBackendJobsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The maximum number of results that you want in the response.
    public let maxResults: Swift.Int?
    /// The token for the next set of results.
    public let nextToken: Swift.String?
    /// Filters the list of response objects to include only those with the specified operation name.
    public let operation: Swift.String?
    /// Filters the list of response objects to include only those with the specified status.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operation = operation
        self.status = status
    }
}

struct ListBackendJobsInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension ListBackendJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "jobId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListBackendJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBackendJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBackendJobsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBackendJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBackendJobsOutputResponse(jobs: \(Swift.String(describing: jobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListBackendJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBackendJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListBackendJobsOutputResponse: Swift.Equatable {
    /// An array of jobs and their properties.
    public let jobs: [AmplifyBackendClientTypes.BackendJobRespObj]?
    /// The token for the next set of results.
    public let nextToken: Swift.String?

    public init (
        jobs: [AmplifyBackendClientTypes.BackendJobRespObj]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListBackendJobsOutputResponseBody: Swift.Equatable {
    public let jobs: [AmplifyBackendClientTypes.BackendJobRespObj]?
    public let nextToken: Swift.String?
}

extension ListBackendJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "jobs"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.BackendJobRespObj?].self, forKey: .jobs)
        var jobsDecoded0:[AmplifyBackendClientTypes.BackendJobRespObj]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [AmplifyBackendClientTypes.BackendJobRespObj]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AmplifyBackendClientTypes.LoginAuthConfigReqObj: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsCognitoIdentityPoolId = "aws_cognito_identity_pool_id"
        case awsCognitoRegion = "aws_cognito_region"
        case awsUserPoolsId = "aws_user_pools_id"
        case awsUserPoolsWebClientId = "aws_user_pools_web_client_id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsCognitoIdentityPoolId = awsCognitoIdentityPoolId {
            try encodeContainer.encode(awsCognitoIdentityPoolId, forKey: .awsCognitoIdentityPoolId)
        }
        if let awsCognitoRegion = awsCognitoRegion {
            try encodeContainer.encode(awsCognitoRegion, forKey: .awsCognitoRegion)
        }
        if let awsUserPoolsId = awsUserPoolsId {
            try encodeContainer.encode(awsUserPoolsId, forKey: .awsUserPoolsId)
        }
        if let awsUserPoolsWebClientId = awsUserPoolsWebClientId {
            try encodeContainer.encode(awsUserPoolsWebClientId, forKey: .awsUserPoolsWebClientId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsCognitoIdentityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsCognitoIdentityPoolId)
        awsCognitoIdentityPoolId = awsCognitoIdentityPoolIdDecoded
        let awsCognitoRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsCognitoRegion)
        awsCognitoRegion = awsCognitoRegionDecoded
        let awsUserPoolsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsUserPoolsId)
        awsUserPoolsId = awsUserPoolsIdDecoded
        let awsUserPoolsWebClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsUserPoolsWebClientId)
        awsUserPoolsWebClientId = awsUserPoolsWebClientIdDecoded
    }
}

extension AmplifyBackendClientTypes.LoginAuthConfigReqObj: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoginAuthConfigReqObj(awsCognitoIdentityPoolId: \(Swift.String(describing: awsCognitoIdentityPoolId)), awsCognitoRegion: \(Swift.String(describing: awsCognitoRegion)), awsUserPoolsId: \(Swift.String(describing: awsUserPoolsId)), awsUserPoolsWebClientId: \(Swift.String(describing: awsUserPoolsWebClientId)))"}
}

extension AmplifyBackendClientTypes {
    /// The request object for this operation.
    public struct LoginAuthConfigReqObj: Swift.Equatable {
        /// The Amazon Cognito identity pool ID used for the Amplify Admin UI login authorization.
        public let awsCognitoIdentityPoolId: Swift.String?
        /// The AWS Region for the Amplify Admin UI login.
        public let awsCognitoRegion: Swift.String?
        /// The Amazon Cognito user pool ID used for Amplify Admin UI login authentication.
        public let awsUserPoolsId: Swift.String?
        /// The web client ID for the Amazon Cognito user pools.
        public let awsUserPoolsWebClientId: Swift.String?

        public init (
            awsCognitoIdentityPoolId: Swift.String? = nil,
            awsCognitoRegion: Swift.String? = nil,
            awsUserPoolsId: Swift.String? = nil,
            awsUserPoolsWebClientId: Swift.String? = nil
        )
        {
            self.awsCognitoIdentityPoolId = awsCognitoIdentityPoolId
            self.awsCognitoRegion = awsCognitoRegion
            self.awsUserPoolsId = awsUserPoolsId
            self.awsUserPoolsWebClientId = awsUserPoolsWebClientId
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum MFAMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case `optional`
        case sdkUnknown(Swift.String)

        public static var allCases: [MFAMode] {
            return [
                .off,
                .on,
                .optional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .on: return "ON"
            case .optional: return "OPTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MFAMode(rawValue: rawValue) ?? MFAMode.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum MfaTypesElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case totp
        case sdkUnknown(Swift.String)

        public static var allCases: [MfaTypesElement] {
            return [
                .sms,
                .totp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .totp: return "TOTP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MfaTypesElement(rawValue: rawValue) ?? MfaTypesElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum Mode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonCognitoUserPools
        case apiKey
        case awsIam
        case openidConnect
        case sdkUnknown(Swift.String)

        public static var allCases: [Mode] {
            return [
                .amazonCognitoUserPools,
                .apiKey,
                .awsIam,
                .openidConnect,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonCognitoUserPools: return "AMAZON_COGNITO_USER_POOLS"
            case .apiKey: return "API_KEY"
            case .awsIam: return "AWS_IAM"
            case .openidConnect: return "OPENID_CONNECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotFoundException(message: \(Swift.String(describing: message)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error returned when a specific resource type is not found.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// An error message to inform that the request has failed.
    public var message: Swift.String?
    /// The type of resource that is not found.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceType: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case resourceType = "resourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AmplifyBackendClientTypes {
    public enum OAuthGrantType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case code
        case implicit
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuthGrantType] {
            return [
                .code,
                .implicit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .code: return "CODE"
            case .implicit: return "IMPLICIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OAuthGrantType(rawValue: rawValue) ?? OAuthGrantType.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum OAuthScopesElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsCognitoSigninUserAdmin
        case email
        case openid
        case phone
        case profile
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuthScopesElement] {
            return [
                .awsCognitoSigninUserAdmin,
                .email,
                .openid,
                .phone,
                .profile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsCognitoSigninUserAdmin: return "AWS_COGNITO_SIGNIN_USER_ADMIN"
            case .email: return "EMAIL"
            case .openid: return "OPENID"
            case .phone: return "PHONE"
            case .profile: return "PROFILE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OAuthScopesElement(rawValue: rawValue) ?? OAuthScopesElement.sdkUnknown(rawValue)
        }
    }
}

public struct RemoveAllBackendsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveAllBackendsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveAllBackendsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveAllBackendsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveAllBackendsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveAllBackendsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveAllBackendsOutputError>
}

extension RemoveAllBackendsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveAllBackendsInput(appId: \(Swift.String(describing: appId)), cleanAmplifyApp: \(Swift.String(describing: cleanAmplifyApp)))"}
}

extension RemoveAllBackendsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cleanAmplifyApp = "cleanAmplifyApp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cleanAmplifyApp = cleanAmplifyApp {
            try encodeContainer.encode(cleanAmplifyApp, forKey: .cleanAmplifyApp)
        }
    }
}

public struct RemoveAllBackendsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveAllBackendsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveAllBackendsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveAllBackendsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveAllBackendsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveAllBackendsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveAllBackendsOutputError>
}

public struct RemoveAllBackendsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveAllBackendsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveAllBackendsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveAllBackendsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveAllBackendsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveAllBackendsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveAllBackendsOutputError>
}

/// The request body for RemoveAllBackends.
public struct RemoveAllBackendsInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// Cleans up the Amplify Console app if this value is set to true.
    public let cleanAmplifyApp: Swift.Bool?

    public init (
        appId: Swift.String? = nil,
        cleanAmplifyApp: Swift.Bool? = nil
    )
    {
        self.appId = appId
        self.cleanAmplifyApp = cleanAmplifyApp
    }
}

struct RemoveAllBackendsInputBody: Swift.Equatable {
    public let cleanAmplifyApp: Swift.Bool?
}

extension RemoveAllBackendsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cleanAmplifyApp = "cleanAmplifyApp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cleanAmplifyAppDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cleanAmplifyApp)
        cleanAmplifyApp = cleanAmplifyAppDecoded
    }
}

extension RemoveAllBackendsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveAllBackendsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveAllBackendsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveAllBackendsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveAllBackendsOutputResponse(appId: \(Swift.String(describing: appId)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension RemoveAllBackendsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveAllBackendsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct RemoveAllBackendsOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct RemoveAllBackendsOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension RemoveAllBackendsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension RemoveBackendConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveBackendConfigInput(appId: \(Swift.String(describing: appId)))"}
}

extension RemoveBackendConfigInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct RemoveBackendConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveBackendConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveBackendConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveBackendConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveBackendConfigOutputError>
}

public struct RemoveBackendConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RemoveBackendConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RemoveBackendConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RemoveBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RemoveBackendConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RemoveBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RemoveBackendConfigOutputError>
}

public struct RemoveBackendConfigInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?

    public init (
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct RemoveBackendConfigInputBody: Swift.Equatable {
}

extension RemoveBackendConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveBackendConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveBackendConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveBackendConfigOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveBackendConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveBackendConfigOutputResponse(error: \(Swift.String(describing: error)))"}
}

extension RemoveBackendConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveBackendConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.error = output.error
        } else {
            self.error = nil
        }
    }
}

public struct RemoveBackendConfigOutputResponse: Swift.Equatable {
    /// If the request fails, this error is returned.
    public let error: Swift.String?

    public init (
        error: Swift.String? = nil
    )
    {
        self.error = error
    }
}

struct RemoveBackendConfigOutputResponseBody: Swift.Equatable {
    public let error: Swift.String?
}

extension RemoveBackendConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "error"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension AmplifyBackendClientTypes {
    public enum RequiredSignUpAttributesElement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case address
        case birthdate
        case email
        case familyName
        case gender
        case givenName
        case locale
        case middleName
        case name
        case nickname
        case phoneNumber
        case picture
        case preferredUsername
        case profile
        case updatedAt
        case website
        case zoneInfo
        case sdkUnknown(Swift.String)

        public static var allCases: [RequiredSignUpAttributesElement] {
            return [
                .address,
                .birthdate,
                .email,
                .familyName,
                .gender,
                .givenName,
                .locale,
                .middleName,
                .name,
                .nickname,
                .phoneNumber,
                .picture,
                .preferredUsername,
                .profile,
                .updatedAt,
                .website,
                .zoneInfo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .birthdate: return "BIRTHDATE"
            case .email: return "EMAIL"
            case .familyName: return "FAMILY_NAME"
            case .gender: return "GENDER"
            case .givenName: return "GIVEN_NAME"
            case .locale: return "LOCALE"
            case .middleName: return "MIDDLE_NAME"
            case .name: return "NAME"
            case .nickname: return "NICKNAME"
            case .phoneNumber: return "PHONE_NUMBER"
            case .picture: return "PICTURE"
            case .preferredUsername: return "PREFERRED_USERNAME"
            case .profile: return "PROFILE"
            case .updatedAt: return "UPDATED_AT"
            case .website: return "WEBSITE"
            case .zoneInfo: return "ZONE_INFO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequiredSignUpAttributesElement(rawValue: rawValue) ?? RequiredSignUpAttributesElement.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes {
    public enum ResolutionStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automerge
        case lambda
        case `none`
        case optimisticConcurrency
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionStrategy] {
            return [
                .automerge,
                .lambda,
                .none,
                .optimisticConcurrency,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automerge: return "AUTOMERGE"
            case .lambda: return "LAMBDA"
            case .none: return "NONE"
            case .optimisticConcurrency: return "OPTIMISTIC_CONCURRENCY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResolutionStrategy(rawValue: rawValue) ?? ResolutionStrategy.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.ResourceConfig: Swift.Codable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AmplifyBackendClientTypes.ResourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceConfig()"}
}

extension AmplifyBackendClientTypes {
    /// Defines the resource configuration for the data model in your Amplify project.
    public struct ResourceConfig: Swift.Equatable {

        public init() {}
    }

}

extension AmplifyBackendClientTypes {
    public enum Service: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cognito
        case sdkUnknown(Swift.String)

        public static var allCases: [Service] {
            return [
                .cognito,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cognito: return "COGNITO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Service(rawValue: rawValue) ?? Service.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.Settings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mfaTypes = "mfaTypes"
        case smsMessage = "smsMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mfaTypes = mfaTypes {
            var mfaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mfaTypes)
            for listofmfatypeselement0 in mfaTypes {
                try mfaTypesContainer.encode(listofmfatypeselement0.rawValue)
            }
        }
        if let smsMessage = smsMessage {
            try encodeContainer.encode(smsMessage, forKey: .smsMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaTypesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.MfaTypesElement?].self, forKey: .mfaTypes)
        var mfaTypesDecoded0:[AmplifyBackendClientTypes.MfaTypesElement]? = nil
        if let mfaTypesContainer = mfaTypesContainer {
            mfaTypesDecoded0 = [AmplifyBackendClientTypes.MfaTypesElement]()
            for string0 in mfaTypesContainer {
                if let string0 = string0 {
                    mfaTypesDecoded0?.append(string0)
                }
            }
        }
        mfaTypes = mfaTypesDecoded0
        let smsMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .smsMessage)
        smsMessage = smsMessageDecoded
    }
}

extension AmplifyBackendClientTypes.Settings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Settings(mfaTypes: \(Swift.String(describing: mfaTypes)), smsMessage: \(Swift.String(describing: smsMessage)))"}
}

extension AmplifyBackendClientTypes {
    /// The settings of your MFA configuration for the backend of your Amplify project.
    public struct Settings: Swift.Equatable {
        /// The supported MFA types.
        public let mfaTypes: [AmplifyBackendClientTypes.MfaTypesElement]?
        /// The body of the SMS message.
        public let smsMessage: Swift.String?

        public init (
            mfaTypes: [AmplifyBackendClientTypes.MfaTypesElement]? = nil,
            smsMessage: Swift.String? = nil
        )
        {
            self.mfaTypes = mfaTypes
            self.smsMessage = smsMessage
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum SignInMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case emailAndPhoneNumber
        case phoneNumber
        case username
        case sdkUnknown(Swift.String)

        public static var allCases: [SignInMethod] {
            return [
                .email,
                .emailAndPhoneNumber,
                .phoneNumber,
                .username,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .emailAndPhoneNumber: return "EMAIL_AND_PHONE_NUMBER"
            case .phoneNumber: return "PHONE_NUMBER"
            case .username: return "USERNAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignInMethod(rawValue: rawValue) ?? SignInMethod.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyBackendClientTypes.SmsSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case smsMessage = "smsMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let smsMessage = smsMessage {
            try encodeContainer.encode(smsMessage, forKey: .smsMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smsMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .smsMessage)
        smsMessage = smsMessageDecoded
    }
}

extension AmplifyBackendClientTypes.SmsSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SmsSettings(smsMessage: \(Swift.String(describing: smsMessage)))"}
}

extension AmplifyBackendClientTypes {
    /// SMS settings for authentication.
    public struct SmsSettings: Swift.Equatable {
        /// The body of the SMS message.
        public let smsMessage: Swift.String?

        public init (
            smsMessage: Swift.String? = nil
        )
        {
            self.smsMessage = smsMessage
        }
    }

}

extension AmplifyBackendClientTypes.SocialProviderSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case facebook = "Facebook"
        case google = "Google"
        case loginWithAmazon = "LoginWithAmazon"
        case signInWithApple = "SignInWithApple"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let facebook = facebook {
            try encodeContainer.encode(facebook, forKey: .facebook)
        }
        if let google = google {
            try encodeContainer.encode(google, forKey: .google)
        }
        if let loginWithAmazon = loginWithAmazon {
            try encodeContainer.encode(loginWithAmazon, forKey: .loginWithAmazon)
        }
        if let signInWithApple = signInWithApple {
            try encodeContainer.encode(signInWithApple, forKey: .signInWithApple)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let facebookDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthSocialProviderConfig.self, forKey: .facebook)
        facebook = facebookDecoded
        let googleDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthSocialProviderConfig.self, forKey: .google)
        google = googleDecoded
        let loginWithAmazonDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthSocialProviderConfig.self, forKey: .loginWithAmazon)
        loginWithAmazon = loginWithAmazonDecoded
        let signInWithAppleDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAuthAppleProviderConfig.self, forKey: .signInWithApple)
        signInWithApple = signInWithAppleDecoded
    }
}

extension AmplifyBackendClientTypes.SocialProviderSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SocialProviderSettings(facebook: \(Swift.String(describing: facebook)), google: \(Swift.String(describing: google)), loginWithAmazon: \(Swift.String(describing: loginWithAmazon)), signInWithApple: \(Swift.String(describing: signInWithApple)))"}
}

extension AmplifyBackendClientTypes {
    /// The settings for using the social identity providers for access to your Amplify app.
    public struct SocialProviderSettings: Swift.Equatable {
        /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
        public let facebook: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig?
        /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
        public let google: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig?
        /// Describes third-party social federation configurations for allowing your app users to sign in using OAuth.
        public let loginWithAmazon: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig?
        /// Describes Apple social federation configurations for allowing your app users to sign in using OAuth.
        public let signInWithApple: AmplifyBackendClientTypes.BackendAuthAppleProviderConfig?

        public init (
            facebook: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig? = nil,
            google: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig? = nil,
            loginWithAmazon: AmplifyBackendClientTypes.BackendAuthSocialProviderConfig? = nil,
            signInWithApple: AmplifyBackendClientTypes.BackendAuthAppleProviderConfig? = nil
        )
        {
            self.facebook = facebook
            self.google = google
            self.loginWithAmazon = loginWithAmazon
            self.signInWithApple = signInWithApple
        }
    }

}

extension AmplifyBackendClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latest
        case stale
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .latest,
                .stale,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latest: return "LATEST"
            case .stale: return "STALE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyRequestsException(limitType: \(Swift.String(describing: limitType)), message: \(Swift.String(describing: message)))"}
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limitType = output.limitType
            self.message = output.message
        } else {
            self.limitType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error that is returned when a limit of a specific type has been exceeded.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The type of limit that was exceeded.
    public var limitType: Swift.String?
    /// An error message to inform that the request has failed.
    public var message: Swift.String?

    public init (
        limitType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.limitType = limitType
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    public let limitType: Swift.String?
    public let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitType = "limitType"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitType)
        limitType = limitTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateBackendAPIInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendAPIInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendAPIOutputError>
}

extension UpdateBackendAPIInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAPIInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceConfig: \(Swift.String(describing: resourceConfig)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension UpdateBackendAPIInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct UpdateBackendAPIInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendAPIInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendAPIOutputError>
}

public struct UpdateBackendAPIInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendAPIInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendAPIInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendAPIOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendAPIInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendAPIOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendAPIOutputError>
}

/// The request body for UpdateBackendAPI.
public struct UpdateBackendAPIInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// Defines the resource configuration for the data model in your Amplify project.
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendAPIInputBody: Swift.Equatable {
    public let resourceConfig: AmplifyBackendClientTypes.BackendAPIResourceConfig?
    public let resourceName: Swift.String?
}

extension UpdateBackendAPIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.BackendAPIResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UpdateBackendAPIOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendAPIOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackendAPIOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendAPIOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAPIOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension UpdateBackendAPIOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBackendAPIOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendAPIOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendAPIOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension UpdateBackendAPIOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryMethod = "deliveryMethod"
        case emailSettings = "emailSettings"
        case smsSettings = "smsSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryMethod = deliveryMethod {
            try encodeContainer.encode(deliveryMethod.rawValue, forKey: .deliveryMethod)
        }
        if let emailSettings = emailSettings {
            try encodeContainer.encode(emailSettings, forKey: .emailSettings)
        }
        if let smsSettings = smsSettings {
            try encodeContainer.encode(smsSettings, forKey: .smsSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryMethodDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.DeliveryMethod.self, forKey: .deliveryMethod)
        deliveryMethod = deliveryMethodDecoded
        let emailSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.EmailSettings.self, forKey: .emailSettings)
        emailSettings = emailSettingsDecoded
        let smsSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SmsSettings.self, forKey: .smsSettings)
        smsSettings = smsSettingsDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthForgotPasswordConfig(deliveryMethod: \(Swift.String(describing: deliveryMethod)), emailSettings: \(Swift.String(describing: emailSettings)), smsSettings: \(Swift.String(describing: smsSettings)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes the forgot password policy for authenticating into the Amplify app.
    public struct UpdateBackendAuthForgotPasswordConfig: Swift.Equatable {
        /// Describes which mode to use (either SMS or email) to deliver messages to app users that want to recover their password.
        public let deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod?
        /// The configuration for the email sent when an app user forgets their password.
        public let emailSettings: AmplifyBackendClientTypes.EmailSettings?
        /// The configuration for the SMS message sent when an Amplify app user forgets their password.
        public let smsSettings: AmplifyBackendClientTypes.SmsSettings?

        public init (
            deliveryMethod: AmplifyBackendClientTypes.DeliveryMethod? = nil,
            emailSettings: AmplifyBackendClientTypes.EmailSettings? = nil,
            smsSettings: AmplifyBackendClientTypes.SmsSettings? = nil
        )
        {
            self.deliveryMethod = deliveryMethod
            self.emailSettings = emailSettings
            self.smsSettings = smsSettings
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unauthenticatedLogin = "unauthenticatedLogin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unauthenticatedLogin = unauthenticatedLogin {
            try encodeContainer.encode(unauthenticatedLogin, forKey: .unauthenticatedLogin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unauthenticatedLoginDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unauthenticatedLogin)
        unauthenticatedLogin = unauthenticatedLoginDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthIdentityPoolConfig(unauthenticatedLogin: \(Swift.String(describing: unauthenticatedLogin)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
    public struct UpdateBackendAuthIdentityPoolConfig: Swift.Equatable {
        /// A boolean value that can be set to allow or disallow guest-level authorization into your Amplify app.
        public let unauthenticatedLogin: Swift.Bool?

        public init (
            unauthenticatedLogin: Swift.Bool? = nil
        )
        {
            self.unauthenticatedLogin = unauthenticatedLogin
        }
    }

}

public struct UpdateBackendAuthInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendAuthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendAuthOutputError>
}

extension UpdateBackendAuthInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), resourceConfig: \(Swift.String(describing: resourceConfig)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension UpdateBackendAuthInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceConfig = resourceConfig {
            try encodeContainer.encode(resourceConfig, forKey: .resourceConfig)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct UpdateBackendAuthInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendAuthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendAuthOutputError>
}

public struct UpdateBackendAuthInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendAuthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendAuthInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendAuthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendAuthInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendAuthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendAuthOutputError>
}

/// The request body for UpdateBackendAuth.
public struct UpdateBackendAuthInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The resource configuration for this request object.
    /// This member is required.
    public let resourceConfig: AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig?
    /// The name of this resource.
    /// This member is required.
    public let resourceName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        resourceConfig: AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.resourceConfig = resourceConfig
        self.resourceName = resourceName
    }
}

struct UpdateBackendAuthInputBody: Swift.Equatable {
    public let resourceConfig: AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig?
    public let resourceName: Swift.String?
}

extension UpdateBackendAuthInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceConfig = "resourceConfig"
        case resourceName = "resourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig.self, forKey: .resourceConfig)
        resourceConfig = resourceConfigDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mFAMode = "MFAMode"
        case settings = "settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mFAMode = mFAMode {
            try encodeContainer.encode(mFAMode.rawValue, forKey: .mFAMode)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mFAModeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.MFAMode.self, forKey: .mFAMode)
        mFAMode = mFAModeDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthMFAConfig(mFAMode: \(Swift.String(describing: mFAMode)), settings: \(Swift.String(describing: settings)))"}
}

extension AmplifyBackendClientTypes {
    /// Updates the multi-factor authentication (MFA) configuration for the backend of your Amplify project.
    public struct UpdateBackendAuthMFAConfig: Swift.Equatable {
        /// The MFA mode for the backend of your Amplify project.
        public let mFAMode: AmplifyBackendClientTypes.MFAMode?
        /// The settings of your MFA configuration for the backend of your Amplify project.
        public let settings: AmplifyBackendClientTypes.Settings?

        public init (
            mFAMode: AmplifyBackendClientTypes.MFAMode? = nil,
            settings: AmplifyBackendClientTypes.Settings? = nil
        )
        {
            self.mFAMode = mFAMode
            self.settings = settings
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPrefix = "domainPrefix"
        case oAuthGrantType = "oAuthGrantType"
        case oAuthScopes = "oAuthScopes"
        case redirectSignInURIs = "redirectSignInURIs"
        case redirectSignOutURIs = "redirectSignOutURIs"
        case socialProviderSettings = "socialProviderSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainPrefix = domainPrefix {
            try encodeContainer.encode(domainPrefix, forKey: .domainPrefix)
        }
        if let oAuthGrantType = oAuthGrantType {
            try encodeContainer.encode(oAuthGrantType.rawValue, forKey: .oAuthGrantType)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for listofoauthscopeselement0 in oAuthScopes {
                try oAuthScopesContainer.encode(listofoauthscopeselement0.rawValue)
            }
        }
        if let redirectSignInURIs = redirectSignInURIs {
            var redirectSignInURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignInURIs)
            for listof__string0 in redirectSignInURIs {
                try redirectSignInURIsContainer.encode(listof__string0)
            }
        }
        if let redirectSignOutURIs = redirectSignOutURIs {
            var redirectSignOutURIsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectSignOutURIs)
            for listof__string0 in redirectSignOutURIs {
                try redirectSignOutURIsContainer.encode(listof__string0)
            }
        }
        if let socialProviderSettings = socialProviderSettings {
            try encodeContainer.encode(socialProviderSettings, forKey: .socialProviderSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainPrefix)
        domainPrefix = domainPrefixDecoded
        let oAuthGrantTypeDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.OAuthGrantType.self, forKey: .oAuthGrantType)
        oAuthGrantType = oAuthGrantTypeDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.OAuthScopesElement?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[AmplifyBackendClientTypes.OAuthScopesElement]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [AmplifyBackendClientTypes.OAuthScopesElement]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
        let redirectSignInURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignInURIs)
        var redirectSignInURIsDecoded0:[Swift.String]? = nil
        if let redirectSignInURIsContainer = redirectSignInURIsContainer {
            redirectSignInURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignInURIsContainer {
                if let string0 = string0 {
                    redirectSignInURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignInURIs = redirectSignInURIsDecoded0
        let redirectSignOutURIsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectSignOutURIs)
        var redirectSignOutURIsDecoded0:[Swift.String]? = nil
        if let redirectSignOutURIsContainer = redirectSignOutURIsContainer {
            redirectSignOutURIsDecoded0 = [Swift.String]()
            for string0 in redirectSignOutURIsContainer {
                if let string0 = string0 {
                    redirectSignOutURIsDecoded0?.append(string0)
                }
            }
        }
        redirectSignOutURIs = redirectSignOutURIsDecoded0
        let socialProviderSettingsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.SocialProviderSettings.self, forKey: .socialProviderSettings)
        socialProviderSettings = socialProviderSettingsDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthOAuthConfig(domainPrefix: \(Swift.String(describing: domainPrefix)), oAuthGrantType: \(Swift.String(describing: oAuthGrantType)), oAuthScopes: \(Swift.String(describing: oAuthScopes)), redirectSignInURIs: \(Swift.String(describing: redirectSignInURIs)), redirectSignOutURIs: \(Swift.String(describing: redirectSignOutURIs)), socialProviderSettings: \(Swift.String(describing: socialProviderSettings)))"}
}

extension AmplifyBackendClientTypes {
    /// The OAuth configurations for authenticating users into your Amplify app.
    public struct UpdateBackendAuthOAuthConfig: Swift.Equatable {
        /// The Amazon Cognito domain prefix used to create a hosted UI for authentication.
        public let domainPrefix: Swift.String?
        /// The OAuth grant type to allow app users to authenticate from your Amplify app.
        public let oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType?
        /// The list of OAuth-related flows that can allow users to authenticate from your Amplify app.
        public let oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]?
        /// Redirect URLs that OAuth uses when a user signs in to an Amplify app.
        public let redirectSignInURIs: [Swift.String]?
        /// Redirect URLs that OAuth uses when a user signs out of an Amplify app.
        public let redirectSignOutURIs: [Swift.String]?
        /// Describes third-party social federation configurations for allowing your users to sign in with OAuth.
        public let socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings?

        public init (
            domainPrefix: Swift.String? = nil,
            oAuthGrantType: AmplifyBackendClientTypes.OAuthGrantType? = nil,
            oAuthScopes: [AmplifyBackendClientTypes.OAuthScopesElement]? = nil,
            redirectSignInURIs: [Swift.String]? = nil,
            redirectSignOutURIs: [Swift.String]? = nil,
            socialProviderSettings: AmplifyBackendClientTypes.SocialProviderSettings? = nil
        )
        {
            self.domainPrefix = domainPrefix
            self.oAuthGrantType = oAuthGrantType
            self.oAuthScopes = oAuthScopes
            self.redirectSignInURIs = redirectSignInURIs
            self.redirectSignOutURIs = redirectSignOutURIs
            self.socialProviderSettings = socialProviderSettings
        }
    }

}

extension UpdateBackendAuthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendAuthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackendAuthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendAuthOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension UpdateBackendAuthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBackendAuthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
        }
    }
}

public struct UpdateBackendAuthOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendAuthOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension UpdateBackendAuthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConstraints = "additionalConstraints"
        case minimumLength = "minimumLength"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConstraints = additionalConstraints {
            var additionalConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConstraints)
            for listofadditionalconstraintselement0 in additionalConstraints {
                try additionalConstraintsContainer.encode(listofadditionalconstraintselement0.rawValue)
            }
        }
        if let minimumLength = minimumLength {
            try encodeContainer.encode(minimumLength, forKey: .minimumLength)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalConstraintsContainer = try containerValues.decodeIfPresent([AmplifyBackendClientTypes.AdditionalConstraintsElement?].self, forKey: .additionalConstraints)
        var additionalConstraintsDecoded0:[AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil
        if let additionalConstraintsContainer = additionalConstraintsContainer {
            additionalConstraintsDecoded0 = [AmplifyBackendClientTypes.AdditionalConstraintsElement]()
            for string0 in additionalConstraintsContainer {
                if let string0 = string0 {
                    additionalConstraintsDecoded0?.append(string0)
                }
            }
        }
        additionalConstraints = additionalConstraintsDecoded0
        let minimumLengthDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimumLength)
        minimumLength = minimumLengthDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthPasswordPolicyConfig(additionalConstraints: \(Swift.String(describing: additionalConstraints)), minimumLength: \(Swift.String(describing: minimumLength)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes the password policy for your Amazon Cognito user pool configured as a part of your Amplify project.
    public struct UpdateBackendAuthPasswordPolicyConfig: Swift.Equatable {
        /// Describes additional constraints on password requirements to sign in to the auth resource, configured as a part of your Amplify project.
        public let additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]?
        /// Describes the minimum length of the password required to sign in to the auth resource, configured as a part of your Amplify project.
        public let minimumLength: Swift.Double?

        public init (
            additionalConstraints: [AmplifyBackendClientTypes.AdditionalConstraintsElement]? = nil,
            minimumLength: Swift.Double? = nil
        )
        {
            self.additionalConstraints = additionalConstraints
            self.minimumLength = minimumLength
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authResources = "authResources"
        case identityPoolConfigs = "identityPoolConfigs"
        case service = "service"
        case userPoolConfigs = "userPoolConfigs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authResources = authResources {
            try encodeContainer.encode(authResources.rawValue, forKey: .authResources)
        }
        if let identityPoolConfigs = identityPoolConfigs {
            try encodeContainer.encode(identityPoolConfigs, forKey: .identityPoolConfigs)
        }
        if let service = service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
        if let userPoolConfigs = userPoolConfigs {
            try encodeContainer.encode(userPoolConfigs, forKey: .userPoolConfigs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authResourcesDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.AuthResources.self, forKey: .authResources)
        authResources = authResourcesDecoded
        let identityPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig.self, forKey: .identityPoolConfigs)
        identityPoolConfigs = identityPoolConfigsDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let userPoolConfigsDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig.self, forKey: .userPoolConfigs)
        userPoolConfigs = userPoolConfigsDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthResourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthResourceConfig(authResources: \(Swift.String(describing: authResources)), identityPoolConfigs: \(Swift.String(describing: identityPoolConfigs)), service: \(Swift.String(describing: service)), userPoolConfigs: \(Swift.String(describing: userPoolConfigs)))"}
}

extension AmplifyBackendClientTypes {
    /// Defines the resource configuration when updating an authentication resource in your Amplify project.
    public struct UpdateBackendAuthResourceConfig: Swift.Equatable {
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        /// This member is required.
        public let authResources: AmplifyBackendClientTypes.AuthResources?
        /// Describes the authorization configuration for the Amazon Cognito identity pool, provisioned as a part of your auth resource in the Amplify project.
        public let identityPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig?
        /// Defines the service name to use when configuring an authentication resource in your Amplify project.
        /// This member is required.
        public let service: AmplifyBackendClientTypes.Service?
        /// Describes the authentication configuration for the Amazon Cognito user pool, provisioned as a part of your auth resource in the Amplify project.
        /// This member is required.
        public let userPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig?

        public init (
            authResources: AmplifyBackendClientTypes.AuthResources? = nil,
            identityPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthIdentityPoolConfig? = nil,
            service: AmplifyBackendClientTypes.Service? = nil,
            userPoolConfigs: AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig? = nil
        )
        {
            self.authResources = authResources
            self.identityPoolConfigs = identityPoolConfigs
            self.service = service
            self.userPoolConfigs = userPoolConfigs
        }
    }

}

extension AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forgotPassword = "forgotPassword"
        case mfa = "mfa"
        case oAuth = "oAuth"
        case passwordPolicy = "passwordPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forgotPassword = forgotPassword {
            try encodeContainer.encode(forgotPassword, forKey: .forgotPassword)
        }
        if let mfa = mfa {
            try encodeContainer.encode(mfa, forKey: .mfa)
        }
        if let oAuth = oAuth {
            try encodeContainer.encode(oAuth, forKey: .oAuth)
        }
        if let passwordPolicy = passwordPolicy {
            try encodeContainer.encode(passwordPolicy, forKey: .passwordPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forgotPasswordDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig.self, forKey: .forgotPassword)
        forgotPassword = forgotPasswordDecoded
        let mfaDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig.self, forKey: .mfa)
        mfa = mfaDecoded
        let oAuthDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig.self, forKey: .oAuth)
        oAuth = oAuthDecoded
        let passwordPolicyDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig.self, forKey: .passwordPolicy)
        passwordPolicy = passwordPolicyDecoded
    }
}

extension AmplifyBackendClientTypes.UpdateBackendAuthUserPoolConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendAuthUserPoolConfig(forgotPassword: \(Swift.String(describing: forgotPassword)), mfa: \(Swift.String(describing: mfa)), oAuth: \(Swift.String(describing: oAuth)), passwordPolicy: \(Swift.String(describing: passwordPolicy)))"}
}

extension AmplifyBackendClientTypes {
    /// Describes the Amazon Cognito user pool configuration for the authorization resource to be configured for your Amplify project on an update.
    public struct UpdateBackendAuthUserPoolConfig: Swift.Equatable {
        /// Describes the forgot password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let forgotPassword: AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig?
        /// Describes whether to apply multi-factor authentication policies for your Amazon Cognito user pool configured as a part of your Amplify project.
        public let mfa: AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig?
        /// Describes the OAuth policy and rules for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let oAuth: AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig?
        /// Describes the password policy for your Amazon Cognito user pool, configured as a part of your Amplify project.
        public let passwordPolicy: AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig?

        public init (
            forgotPassword: AmplifyBackendClientTypes.UpdateBackendAuthForgotPasswordConfig? = nil,
            mfa: AmplifyBackendClientTypes.UpdateBackendAuthMFAConfig? = nil,
            oAuth: AmplifyBackendClientTypes.UpdateBackendAuthOAuthConfig? = nil,
            passwordPolicy: AmplifyBackendClientTypes.UpdateBackendAuthPasswordPolicyConfig? = nil
        )
        {
            self.forgotPassword = forgotPassword
            self.mfa = mfa
            self.oAuth = oAuth
            self.passwordPolicy = passwordPolicy
        }
    }

}

public struct UpdateBackendConfigInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendConfigOutputError>
}

extension UpdateBackendConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendConfigInput(appId: \(Swift.String(describing: appId)), loginAuthConfig: \(Swift.String(describing: loginAuthConfig)))"}
}

extension UpdateBackendConfigInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginAuthConfig = "loginAuthConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loginAuthConfig = loginAuthConfig {
            try encodeContainer.encode(loginAuthConfig, forKey: .loginAuthConfig)
        }
    }
}

public struct UpdateBackendConfigInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendConfigOutputError>
}

public struct UpdateBackendConfigInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendConfigInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendConfigInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendConfigOutputError>
}

/// The request body for UpdateBackendConfig.
public struct UpdateBackendConfigInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// Describes the Amazon Cognito configuration for Admin UI access.
    public let loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?

    public init (
        appId: Swift.String? = nil,
        loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj? = nil
    )
    {
        self.appId = appId
        self.loginAuthConfig = loginAuthConfig
    }
}

struct UpdateBackendConfigInputBody: Swift.Equatable {
    public let loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?
}

extension UpdateBackendConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginAuthConfig = "loginAuthConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loginAuthConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.LoginAuthConfigReqObj.self, forKey: .loginAuthConfig)
        loginAuthConfig = loginAuthConfigDecoded
    }
}

extension UpdateBackendConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackendConfigOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendConfigOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendConfigOutputResponse(appId: \(Swift.String(describing: appId)), backendManagerAppId: \(Swift.String(describing: backendManagerAppId)), error: \(Swift.String(describing: error)), loginAuthConfig: \(Swift.String(describing: loginAuthConfig)))"}
}

extension UpdateBackendConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBackendConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendManagerAppId = output.backendManagerAppId
            self.error = output.error
            self.loginAuthConfig = output.loginAuthConfig
        } else {
            self.appId = nil
            self.backendManagerAppId = nil
            self.error = nil
            self.loginAuthConfig = nil
        }
    }
}

public struct UpdateBackendConfigOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The app ID for the backend manager.
    public let backendManagerAppId: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// Describes the Amazon Cognito configurations for the Admin UI auth resource to log in with.
    public let loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?

    public init (
        appId: Swift.String? = nil,
        backendManagerAppId: Swift.String? = nil,
        error: Swift.String? = nil,
        loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj? = nil
    )
    {
        self.appId = appId
        self.backendManagerAppId = backendManagerAppId
        self.error = error
        self.loginAuthConfig = loginAuthConfig
    }
}

struct UpdateBackendConfigOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendManagerAppId: Swift.String?
    public let error: Swift.String?
    public let loginAuthConfig: AmplifyBackendClientTypes.LoginAuthConfigReqObj?
}

extension UpdateBackendConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendManagerAppId = "backendManagerAppId"
        case error = "error"
        case loginAuthConfig = "loginAuthConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendManagerAppIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendManagerAppId)
        backendManagerAppId = backendManagerAppIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let loginAuthConfigDecoded = try containerValues.decodeIfPresent(AmplifyBackendClientTypes.LoginAuthConfigReqObj.self, forKey: .loginAuthConfig)
        loginAuthConfig = loginAuthConfigDecoded
    }
}

public struct UpdateBackendJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendJobOutputError>
}

extension UpdateBackendJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendJobInput(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)))"}
}

extension UpdateBackendJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "operation"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

public struct UpdateBackendJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendJobOutputError>
}

public struct UpdateBackendJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateBackendJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateBackendJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateBackendJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateBackendJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateBackendJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateBackendJobOutputError>
}

/// The request body for GetBackendJob.
public struct UpdateBackendJobInput: Swift.Equatable {
    /// The app ID.
    /// This member is required.
    public let appId: Swift.String?
    /// The name of the backend environment.
    /// This member is required.
    public let backendEnvironmentName: Swift.String?
    /// The ID for the job.
    /// This member is required.
    public let jobId: Swift.String?
    /// Filters the list of response objects to include only those with the specified operation name.
    public let operation: Swift.String?
    /// Filters the list of response objects to include only those with the specified status.
    public let status: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.jobId = jobId
        self.operation = operation
        self.status = status
    }
}

struct UpdateBackendJobInputBody: Swift.Equatable {
    public let operation: Swift.String?
    public let status: Swift.String?
}

extension UpdateBackendJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation = "operation"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateBackendJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBackendJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GatewayTimeoutException" : self = .gatewayTimeoutException(try GatewayTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBackendJobOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case gatewayTimeoutException(GatewayTimeoutException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBackendJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBackendJobOutputResponse(appId: \(Swift.String(describing: appId)), backendEnvironmentName: \(Swift.String(describing: backendEnvironmentName)), createTime: \(Swift.String(describing: createTime)), error: \(Swift.String(describing: error)), jobId: \(Swift.String(describing: jobId)), operation: \(Swift.String(describing: operation)), status: \(Swift.String(describing: status)), updateTime: \(Swift.String(describing: updateTime)))"}
}

extension UpdateBackendJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBackendJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.backendEnvironmentName = output.backendEnvironmentName
            self.createTime = output.createTime
            self.error = output.error
            self.jobId = output.jobId
            self.operation = output.operation
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.appId = nil
            self.backendEnvironmentName = nil
            self.createTime = nil
            self.error = nil
            self.jobId = nil
            self.operation = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateBackendJobOutputResponse: Swift.Equatable {
    /// The app ID.
    public let appId: Swift.String?
    /// The name of the backend environment.
    public let backendEnvironmentName: Swift.String?
    /// The time when the job was created.
    public let createTime: Swift.String?
    /// If the request fails, this error is returned.
    public let error: Swift.String?
    /// The ID for the job.
    public let jobId: Swift.String?
    /// The name of the operation.
    public let operation: Swift.String?
    /// The current status of the request.
    public let status: Swift.String?
    /// The time when the job was last updated.
    public let updateTime: Swift.String?

    public init (
        appId: Swift.String? = nil,
        backendEnvironmentName: Swift.String? = nil,
        createTime: Swift.String? = nil,
        error: Swift.String? = nil,
        jobId: Swift.String? = nil,
        operation: Swift.String? = nil,
        status: Swift.String? = nil,
        updateTime: Swift.String? = nil
    )
    {
        self.appId = appId
        self.backendEnvironmentName = backendEnvironmentName
        self.createTime = createTime
        self.error = error
        self.jobId = jobId
        self.operation = operation
        self.status = status
        self.updateTime = updateTime
    }
}

struct UpdateBackendJobOutputResponseBody: Swift.Equatable {
    public let appId: Swift.String?
    public let backendEnvironmentName: Swift.String?
    public let createTime: Swift.String?
    public let error: Swift.String?
    public let jobId: Swift.String?
    public let operation: Swift.String?
    public let status: Swift.String?
    public let updateTime: Swift.String?
}

extension UpdateBackendJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId = "appId"
        case backendEnvironmentName = "backendEnvironmentName"
        case createTime = "createTime"
        case error = "error"
        case jobId = "jobId"
        case operation = "operation"
        case status = "status"
        case updateTime = "updateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let backendEnvironmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backendEnvironmentName)
        backendEnvironmentName = backendEnvironmentNameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let updateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}
