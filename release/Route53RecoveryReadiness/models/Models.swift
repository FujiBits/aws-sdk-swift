// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.CellOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellArn = cellArn {
            try encodeContainer.encode(cellArn, forKey: .cellArn)
        }
        if let cellName = cellName {
            try encodeContainer.encode(cellName, forKey: .cellName)
        }
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __listof__string0 in cells {
                try cellsContainer.encode(__listof__string0)
            }
        }
        if let parentReadinessScopes = parentReadinessScopes {
            var parentReadinessScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parentReadinessScopes)
            for __listof__string0 in parentReadinessScopes {
                try parentReadinessScopesContainer.encode(__listof__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes.CellOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CellOutput(cellArn: \(Swift.String(describing: cellArn)), cellName: \(Swift.String(describing: cellName)), cells: \(Swift.String(describing: cells)), parentReadinessScopes: \(Swift.String(describing: parentReadinessScopes)), tags: \(Swift.String(describing: tags)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// A Cell and its properties
    public struct CellOutput: Swift.Equatable {
        /// The arn for the Cell
        /// This member is required.
        public let cellArn: Swift.String?
        /// The name of the Cell
        /// This member is required.
        public let cellName: Swift.String?
        /// A list of Cell arns
        /// This member is required.
        public let cells: [Swift.String]?
        /// A list of Cell ARNs and/or RecoveryGroup ARNs
        /// This member is required.
        public let parentReadinessScopes: [Swift.String]?
        /// A collection of tags associated with a resource
        public let tags: [Swift.String:Swift.String]?

        public init (
            cellArn: Swift.String? = nil,
            cellName: Swift.String? = nil,
            cells: [Swift.String]? = nil,
            parentReadinessScopes: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.cellArn = cellArn
            self.cellName = cellName
            self.cells = cells
            self.parentReadinessScopes = parentReadinessScopes
            self.tags = tags
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCellInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCellInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCellOutputError>
}

extension CreateCellInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCellInput(cellName: \(Swift.String(describing: cellName)), cells: \(Swift.String(describing: cells)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateCellInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellName = "cellName"
        case cells = "cells"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellName = cellName {
            try encodeContainer.encode(cellName, forKey: .cellName)
        }
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __listof__string0 in cells {
                try cellsContainer.encode(__listof__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateCellInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCellInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCellOutputError>
}

public struct CreateCellInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCellInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCellOutputError>
}

/// The Cell to create
public struct CreateCellInput: Swift.Equatable {
    /// The name of the Cell to create
    /// This member is required.
    public let cellName: Swift.String?
    /// A list of Cell arns contained within this Cell (for use in nested Cells, e.g. regions within which AZs)
    public let cells: [Swift.String]?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellName = cellName
        self.cells = cells
        self.tags = tags
    }
}

struct CreateCellInputBody: Swift.Equatable {
    public let cellName: Swift.String?
    public let cells: [Swift.String]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateCellInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellName = "cellName"
        case cells = "cells"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCellOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCellOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCellOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCellOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCellOutputResponse(cellArn: \(Swift.String(describing: cellArn)), cellName: \(Swift.String(describing: cellName)), cells: \(Swift.String(describing: cells)), parentReadinessScopes: \(Swift.String(describing: parentReadinessScopes)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateCellOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCellOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cellArn = output.cellArn
            self.cellName = output.cellName
            self.cells = output.cells
            self.parentReadinessScopes = output.parentReadinessScopes
            self.tags = output.tags
        } else {
            self.cellArn = nil
            self.cellName = nil
            self.cells = nil
            self.parentReadinessScopes = nil
            self.tags = nil
        }
    }
}

public struct CreateCellOutputResponse: Swift.Equatable {
    /// The arn for the Cell
    public let cellArn: Swift.String?
    /// The name of the Cell
    public let cellName: Swift.String?
    /// A list of Cell arns
    public let cells: [Swift.String]?
    /// A list of Cell ARNs and/or RecoveryGroup ARNs
    public let parentReadinessScopes: [Swift.String]?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        cellArn: Swift.String? = nil,
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        parentReadinessScopes: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellArn = cellArn
        self.cellName = cellName
        self.cells = cells
        self.parentReadinessScopes = parentReadinessScopes
        self.tags = tags
    }
}

struct CreateCellOutputResponseBody: Swift.Equatable {
    public let cellArn: Swift.String?
    public let cellName: Swift.String?
    public let cells: [Swift.String]?
    public let parentReadinessScopes: [Swift.String]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateCellOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateCrossAccountAuthorizationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCrossAccountAuthorizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCrossAccountAuthorizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCrossAccountAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCrossAccountAuthorizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCrossAccountAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCrossAccountAuthorizationOutputError>
}

extension CreateCrossAccountAuthorizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCrossAccountAuthorizationInput(crossAccountAuthorization: \(Swift.String(describing: crossAccountAuthorization)))"}
}

extension CreateCrossAccountAuthorizationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorization = "crossAccountAuthorization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let crossAccountAuthorization = crossAccountAuthorization {
            try encodeContainer.encode(crossAccountAuthorization, forKey: .crossAccountAuthorization)
        }
    }
}

public struct CreateCrossAccountAuthorizationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCrossAccountAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCrossAccountAuthorizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCrossAccountAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCrossAccountAuthorizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCrossAccountAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCrossAccountAuthorizationOutputError>
}

public struct CreateCrossAccountAuthorizationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCrossAccountAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCrossAccountAuthorizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCrossAccountAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCrossAccountAuthorizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCrossAccountAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCrossAccountAuthorizationOutputError>
}

/// The cross account authorization
public struct CreateCrossAccountAuthorizationInput: Swift.Equatable {
    /// The cross account authorization
    /// This member is required.
    public let crossAccountAuthorization: Swift.String?

    public init (
        crossAccountAuthorization: Swift.String? = nil
    )
    {
        self.crossAccountAuthorization = crossAccountAuthorization
    }
}

struct CreateCrossAccountAuthorizationInputBody: Swift.Equatable {
    public let crossAccountAuthorization: Swift.String?
}

extension CreateCrossAccountAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorization = "crossAccountAuthorization"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossAccountAuthorizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crossAccountAuthorization)
        crossAccountAuthorization = crossAccountAuthorizationDecoded
    }
}

extension CreateCrossAccountAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCrossAccountAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCrossAccountAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCrossAccountAuthorizationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCrossAccountAuthorizationOutputResponse(crossAccountAuthorization: \(Swift.String(describing: crossAccountAuthorization)))"}
}

extension CreateCrossAccountAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCrossAccountAuthorizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccountAuthorization = output.crossAccountAuthorization
        } else {
            self.crossAccountAuthorization = nil
        }
    }
}

public struct CreateCrossAccountAuthorizationOutputResponse: Swift.Equatable {
    /// The cross account authorization
    public let crossAccountAuthorization: Swift.String?

    public init (
        crossAccountAuthorization: Swift.String? = nil
    )
    {
        self.crossAccountAuthorization = crossAccountAuthorization
    }
}

struct CreateCrossAccountAuthorizationOutputResponseBody: Swift.Equatable {
    public let crossAccountAuthorization: Swift.String?
}

extension CreateCrossAccountAuthorizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorization = "crossAccountAuthorization"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossAccountAuthorizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .crossAccountAuthorization)
        crossAccountAuthorization = crossAccountAuthorizationDecoded
    }
}

public struct CreateReadinessCheckInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReadinessCheckInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReadinessCheckOutputError>
}

extension CreateReadinessCheckInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReadinessCheckInput(readinessCheckName: \(Swift.String(describing: readinessCheckName)), resourceSetName: \(Swift.String(describing: resourceSetName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateReadinessCheckInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckName = "readinessCheckName"
        case resourceSetName = "resourceSetName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readinessCheckName = readinessCheckName {
            try encodeContainer.encode(readinessCheckName, forKey: .readinessCheckName)
        }
        if let resourceSetName = resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateReadinessCheckInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReadinessCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReadinessCheckOutputError>
}

public struct CreateReadinessCheckInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateReadinessCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateReadinessCheckOutputError>
}

/// The ReadinessCheck to create
public struct CreateReadinessCheckInput: Swift.Equatable {
    /// The name of the ReadinessCheck to create
    /// This member is required.
    public let readinessCheckName: Swift.String?
    /// The name of the ResourceSet to check
    /// This member is required.
    public let resourceSetName: Swift.String?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        readinessCheckName: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
        self.resourceSetName = resourceSetName
        self.tags = tags
    }
}

struct CreateReadinessCheckInputBody: Swift.Equatable {
    public let readinessCheckName: Swift.String?
    public let resourceSetName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateReadinessCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckName = "readinessCheckName"
        case resourceSetName = "resourceSetName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReadinessCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReadinessCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReadinessCheckOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReadinessCheckOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReadinessCheckOutputResponse(readinessCheckArn: \(Swift.String(describing: readinessCheckArn)), readinessCheckName: \(Swift.String(describing: readinessCheckName)), resourceSet: \(Swift.String(describing: resourceSet)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateReadinessCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateReadinessCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.readinessCheckArn = output.readinessCheckArn
            self.readinessCheckName = output.readinessCheckName
            self.resourceSet = output.resourceSet
            self.tags = output.tags
        } else {
            self.readinessCheckArn = nil
            self.readinessCheckName = nil
            self.resourceSet = nil
            self.tags = nil
        }
    }
}

public struct CreateReadinessCheckOutputResponse: Swift.Equatable {
    /// Arn associated with ReadinessCheck
    public let readinessCheckArn: Swift.String?
    /// Name for a ReadinessCheck
    public let readinessCheckName: Swift.String?
    /// Name of the ResourceSet to be checked
    public let resourceSet: Swift.String?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        readinessCheckArn: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceSet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckArn = readinessCheckArn
        self.readinessCheckName = readinessCheckName
        self.resourceSet = resourceSet
        self.tags = tags
    }
}

struct CreateReadinessCheckOutputResponseBody: Swift.Equatable {
    public let readinessCheckArn: Swift.String?
    public let readinessCheckName: Swift.String?
    public let resourceSet: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateReadinessCheckOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateRecoveryGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecoveryGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecoveryGroupOutputError>
}

extension CreateRecoveryGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRecoveryGroupInput(cells: \(Swift.String(describing: cells)), recoveryGroupName: \(Swift.String(describing: recoveryGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRecoveryGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __listof__string0 in cells {
                try cellsContainer.encode(__listof__string0)
            }
        }
        if let recoveryGroupName = recoveryGroupName {
            try encodeContainer.encode(recoveryGroupName, forKey: .recoveryGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRecoveryGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecoveryGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecoveryGroupOutputError>
}

public struct CreateRecoveryGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRecoveryGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRecoveryGroupOutputError>
}

/// The RecoveryGroup to create
public struct CreateRecoveryGroupInput: Swift.Equatable {
    /// A list of Cell arns
    public let cells: [Swift.String]?
    /// The name of the RecoveryGroup to create
    /// This member is required.
    public let recoveryGroupName: Swift.String?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct CreateRecoveryGroupInputBody: Swift.Equatable {
    public let cells: [Swift.String]?
    public let recoveryGroupName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateRecoveryGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRecoveryGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecoveryGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRecoveryGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecoveryGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRecoveryGroupOutputResponse(cells: \(Swift.String(describing: cells)), recoveryGroupArn: \(Swift.String(describing: recoveryGroupArn)), recoveryGroupName: \(Swift.String(describing: recoveryGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRecoveryGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRecoveryGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.recoveryGroupArn = output.recoveryGroupArn
            self.recoveryGroupName = output.recoveryGroupName
            self.tags = output.tags
        } else {
            self.cells = nil
            self.recoveryGroupArn = nil
            self.recoveryGroupName = nil
            self.tags = nil
        }
    }
}

public struct CreateRecoveryGroupOutputResponse: Swift.Equatable {
    /// A list of Cell arns
    public let cells: [Swift.String]?
    /// The arn for the RecoveryGroup
    public let recoveryGroupArn: Swift.String?
    /// The name of the RecoveryGroup
    public let recoveryGroupName: Swift.String?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupArn: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupArn = recoveryGroupArn
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct CreateRecoveryGroupOutputResponseBody: Swift.Equatable {
    public let cells: [Swift.String]?
    public let recoveryGroupArn: Swift.String?
    public let recoveryGroupName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateRecoveryGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateResourceSetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceSetOutputError>
}

extension CreateResourceSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceSetInput(resourceSetName: \(Swift.String(describing: resourceSetName)), resourceSetType: \(Swift.String(describing: resourceSetType)), resources: \(Swift.String(describing: resources)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateResourceSetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetName = resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
        if let resourceSetType = resourceSetType {
            try encodeContainer.encode(resourceSetType, forKey: .resourceSetType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for __listofresource0 in resources {
                try resourcesContainer.encode(__listofresource0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateResourceSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceSetOutputError>
}

public struct CreateResourceSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceSetOutputError>
}

/// The ResourceSet to create
public struct CreateResourceSetInput: Swift.Equatable {
    /// The name of the ResourceSet to create
    /// This member is required.
    public let resourceSetName: Swift.String?
    /// AWS Resource type of the resources in the ResourceSet
    /// This member is required.
    public let resourceSetType: Swift.String?
    /// A list of Resource objects
    /// This member is required.
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct CreateResourceSetInputBody: Swift.Equatable {
    public let resourceSetName: Swift.String?
    public let resourceSetType: Swift.String?
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateResourceSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceSetOutputResponse(resourceSetArn: \(Swift.String(describing: resourceSetArn)), resourceSetName: \(Swift.String(describing: resourceSetName)), resourceSetType: \(Swift.String(describing: resourceSetType)), resources: \(Swift.String(describing: resources)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResourceSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceSetArn = output.resourceSetArn
            self.resourceSetName = output.resourceSetName
            self.resourceSetType = output.resourceSetType
            self.resources = output.resources
            self.tags = output.tags
        } else {
            self.resourceSetArn = nil
            self.resourceSetName = nil
            self.resourceSetType = nil
            self.resources = nil
            self.tags = nil
        }
    }
}

public struct CreateResourceSetOutputResponse: Swift.Equatable {
    /// The arn for the ResourceSet
    public let resourceSetArn: Swift.String?
    /// The name of the ResourceSet
    public let resourceSetName: Swift.String?
    /// AWS Resource Type of the resources in the ResourceSet
    public let resourceSetType: Swift.String?
    /// A list of Resource objects
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceSetArn: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetArn = resourceSetArn
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct CreateResourceSetOutputResponseBody: Swift.Equatable {
    public let resourceSetArn: Swift.String?
    public let resourceSetName: Swift.String?
    public let resourceSetType: Swift.String?
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateResourceSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes.DNSTargetResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case hostedZoneArn = "hostedZoneArn"
        case recordSetId = "recordSetId"
        case recordType = "recordType"
        case targetResource = "targetResource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneArn = hostedZoneArn {
            try encodeContainer.encode(hostedZoneArn, forKey: .hostedZoneArn)
        }
        if let recordSetId = recordSetId {
            try encodeContainer.encode(recordSetId, forKey: .recordSetId)
        }
        if let recordType = recordType {
            try encodeContainer.encode(recordType, forKey: .recordType)
        }
        if let targetResource = targetResource {
            try encodeContainer.encode(targetResource, forKey: .targetResource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let hostedZoneArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneArn)
        hostedZoneArn = hostedZoneArnDecoded
        let recordSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordSetId)
        recordSetId = recordSetIdDecoded
        let recordTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordType)
        recordType = recordTypeDecoded
        let targetResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.TargetResource.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.DNSTargetResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DNSTargetResource(domainName: \(Swift.String(describing: domainName)), hostedZoneArn: \(Swift.String(describing: hostedZoneArn)), recordSetId: \(Swift.String(describing: recordSetId)), recordType: \(Swift.String(describing: recordType)), targetResource: \(Swift.String(describing: targetResource)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// A component for DNS/Routing Control Readiness Checks
    public struct DNSTargetResource: Swift.Equatable {
        /// The DNS Name that acts as ingress point to a portion of application
        public let domainName: Swift.String?
        /// The Hosted Zone ARN that contains the DNS record with the provided name of target resource.
        public let hostedZoneArn: Swift.String?
        /// The R53 Set Id to uniquely identify a record given a Name and a Type
        public let recordSetId: Swift.String?
        /// The Type of DNS Record of target resource
        public let recordType: Swift.String?
        /// The target resource the R53 record points to
        public let targetResource: Route53RecoveryReadinessClientTypes.TargetResource?

        public init (
            domainName: Swift.String? = nil,
            hostedZoneArn: Swift.String? = nil,
            recordSetId: Swift.String? = nil,
            recordType: Swift.String? = nil,
            targetResource: Route53RecoveryReadinessClientTypes.TargetResource? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneArn = hostedZoneArn
            self.recordSetId = recordSetId
            self.recordType = recordType
            self.targetResource = targetResource
        }
    }

}

extension DeleteCellInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCellInput(cellName: \(Swift.String(describing: cellName)))"}
}

extension DeleteCellInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCellInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCellInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCellOutputError>
}

public struct DeleteCellInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCellInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCellOutputError>
}

public struct DeleteCellInput: Swift.Equatable {
    /// The Cell to delete
    /// This member is required.
    public let cellName: Swift.String?

    public init (
        cellName: Swift.String? = nil
    )
    {
        self.cellName = cellName
    }
}

struct DeleteCellInputBody: Swift.Equatable {
}

extension DeleteCellInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCellOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCellOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCellOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCellOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCellOutputResponse()"}
}

extension DeleteCellOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCellOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCellOutputResponseBody: Swift.Equatable {
}

extension DeleteCellOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCrossAccountAuthorizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCrossAccountAuthorizationInput(crossAccountAuthorization: \(Swift.String(describing: crossAccountAuthorization)))"}
}

extension DeleteCrossAccountAuthorizationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteCrossAccountAuthorizationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCrossAccountAuthorizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCrossAccountAuthorizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCrossAccountAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCrossAccountAuthorizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCrossAccountAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCrossAccountAuthorizationOutputError>
}

public struct DeleteCrossAccountAuthorizationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCrossAccountAuthorizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCrossAccountAuthorizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCrossAccountAuthorizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCrossAccountAuthorizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCrossAccountAuthorizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCrossAccountAuthorizationOutputError>
}

public struct DeleteCrossAccountAuthorizationInput: Swift.Equatable {
    /// The cross account authorization
    /// This member is required.
    public let crossAccountAuthorization: Swift.String?

    public init (
        crossAccountAuthorization: Swift.String? = nil
    )
    {
        self.crossAccountAuthorization = crossAccountAuthorization
    }
}

struct DeleteCrossAccountAuthorizationInputBody: Swift.Equatable {
}

extension DeleteCrossAccountAuthorizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCrossAccountAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCrossAccountAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCrossAccountAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCrossAccountAuthorizationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCrossAccountAuthorizationOutputResponse()"}
}

extension DeleteCrossAccountAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCrossAccountAuthorizationOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCrossAccountAuthorizationOutputResponseBody: Swift.Equatable {
}

extension DeleteCrossAccountAuthorizationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReadinessCheckInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReadinessCheckInput(readinessCheckName: \(Swift.String(describing: readinessCheckName)))"}
}

extension DeleteReadinessCheckInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteReadinessCheckInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReadinessCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReadinessCheckOutputError>
}

public struct DeleteReadinessCheckInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteReadinessCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteReadinessCheckOutputError>
}

public struct DeleteReadinessCheckInput: Swift.Equatable {
    /// The ReadinessCheck to delete
    /// This member is required.
    public let readinessCheckName: Swift.String?

    public init (
        readinessCheckName: Swift.String? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
    }
}

struct DeleteReadinessCheckInputBody: Swift.Equatable {
}

extension DeleteReadinessCheckInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReadinessCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReadinessCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReadinessCheckOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReadinessCheckOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteReadinessCheckOutputResponse()"}
}

extension DeleteReadinessCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReadinessCheckOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteReadinessCheckOutputResponseBody: Swift.Equatable {
}

extension DeleteReadinessCheckOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecoveryGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecoveryGroupInput(recoveryGroupName: \(Swift.String(describing: recoveryGroupName)))"}
}

extension DeleteRecoveryGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRecoveryGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecoveryGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecoveryGroupOutputError>
}

public struct DeleteRecoveryGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRecoveryGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRecoveryGroupOutputError>
}

public struct DeleteRecoveryGroupInput: Swift.Equatable {
    /// The RecoveryGroup to delete
    /// This member is required.
    public let recoveryGroupName: Swift.String?

    public init (
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.recoveryGroupName = recoveryGroupName
    }
}

struct DeleteRecoveryGroupInputBody: Swift.Equatable {
}

extension DeleteRecoveryGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRecoveryGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecoveryGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecoveryGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecoveryGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRecoveryGroupOutputResponse()"}
}

extension DeleteRecoveryGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecoveryGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRecoveryGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteRecoveryGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceSetInput(resourceSetName: \(Swift.String(describing: resourceSetName)))"}
}

extension DeleteResourceSetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteResourceSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceSetOutputError>
}

public struct DeleteResourceSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceSetOutputError>
}

public struct DeleteResourceSetInput: Swift.Equatable {
    /// The ResourceSet to delete
    /// This member is required.
    public let resourceSetName: Swift.String?

    public init (
        resourceSetName: Swift.String? = nil
    )
    {
        self.resourceSetName = resourceSetName
    }
}

struct DeleteResourceSetInputBody: Swift.Equatable {
}

extension DeleteResourceSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceSetOutputResponse()"}
}

extension DeleteResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceSetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteResourceSetOutputResponseBody: Swift.Equatable {
}

extension DeleteResourceSetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetArchitectureRecommendationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetArchitectureRecommendationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), recoveryGroupName: \(Swift.String(describing: recoveryGroupName)))"}
}

extension GetArchitectureRecommendationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetArchitectureRecommendationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetArchitectureRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetArchitectureRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetArchitectureRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetArchitectureRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetArchitectureRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetArchitectureRecommendationsOutputError>
}

public struct GetArchitectureRecommendationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetArchitectureRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetArchitectureRecommendationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetArchitectureRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetArchitectureRecommendationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetArchitectureRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetArchitectureRecommendationsOutputError>
}

public struct GetArchitectureRecommendationsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?
    /// Name of RecoveryGroup (top level resource) to be analyzed.
    /// This member is required.
    public let recoveryGroupName: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recoveryGroupName = recoveryGroupName
    }
}

struct GetArchitectureRecommendationsInputBody: Swift.Equatable {
}

extension GetArchitectureRecommendationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetArchitectureRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetArchitectureRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetArchitectureRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetArchitectureRecommendationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetArchitectureRecommendationsOutputResponse(lastAuditTimestamp: \(Swift.String(describing: lastAuditTimestamp)), nextToken: \(Swift.String(describing: nextToken)), recommendations: \(Swift.String(describing: recommendations)))"}
}

extension GetArchitectureRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetArchitectureRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastAuditTimestamp = output.lastAuditTimestamp
            self.nextToken = output.nextToken
            self.recommendations = output.recommendations
        } else {
            self.lastAuditTimestamp = nil
            self.nextToken = nil
            self.recommendations = nil
        }
    }
}

public struct GetArchitectureRecommendationsOutputResponse: Swift.Equatable {
    /// The time a Recovery Group was last assessed for recommendations in UTC ISO-8601 format.
    public let lastAuditTimestamp: ClientRuntime.Date?
    /// A token that can be used to resume pagination from the end of the collection
    public let nextToken: Swift.String?
    /// A list of recommendations for the customer's application
    public let recommendations: [Route53RecoveryReadinessClientTypes.Recommendation]?

    public init (
        lastAuditTimestamp: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        recommendations: [Route53RecoveryReadinessClientTypes.Recommendation]? = nil
    )
    {
        self.lastAuditTimestamp = lastAuditTimestamp
        self.nextToken = nextToken
        self.recommendations = recommendations
    }
}

struct GetArchitectureRecommendationsOutputResponseBody: Swift.Equatable {
    public let lastAuditTimestamp: ClientRuntime.Date?
    public let nextToken: Swift.String?
    public let recommendations: [Route53RecoveryReadinessClientTypes.Recommendation]?
}

extension GetArchitectureRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastAuditTimestamp = "lastAuditTimestamp"
        case nextToken = "nextToken"
        case recommendations = "recommendations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastAuditTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastAuditTimestamp)
        lastAuditTimestamp = lastAuditTimestampDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[Route53RecoveryReadinessClientTypes.Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [Route53RecoveryReadinessClientTypes.Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
    }
}

extension GetCellInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCellInput(cellName: \(Swift.String(describing: cellName)))"}
}

extension GetCellInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCellInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCellInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCellOutputError>
}

public struct GetCellInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCellInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCellOutputError>
}

public struct GetCellInput: Swift.Equatable {
    /// The Cell to get
    /// This member is required.
    public let cellName: Swift.String?

    public init (
        cellName: Swift.String? = nil
    )
    {
        self.cellName = cellName
    }
}

struct GetCellInputBody: Swift.Equatable {
}

extension GetCellInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCellOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCellOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCellOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCellOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCellOutputResponse(cellArn: \(Swift.String(describing: cellArn)), cellName: \(Swift.String(describing: cellName)), cells: \(Swift.String(describing: cells)), parentReadinessScopes: \(Swift.String(describing: parentReadinessScopes)), tags: \(Swift.String(describing: tags)))"}
}

extension GetCellOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCellOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cellArn = output.cellArn
            self.cellName = output.cellName
            self.cells = output.cells
            self.parentReadinessScopes = output.parentReadinessScopes
            self.tags = output.tags
        } else {
            self.cellArn = nil
            self.cellName = nil
            self.cells = nil
            self.parentReadinessScopes = nil
            self.tags = nil
        }
    }
}

public struct GetCellOutputResponse: Swift.Equatable {
    /// The arn for the Cell
    public let cellArn: Swift.String?
    /// The name of the Cell
    public let cellName: Swift.String?
    /// A list of Cell arns
    public let cells: [Swift.String]?
    /// A list of Cell ARNs and/or RecoveryGroup ARNs
    public let parentReadinessScopes: [Swift.String]?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        cellArn: Swift.String? = nil,
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        parentReadinessScopes: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellArn = cellArn
        self.cellName = cellName
        self.cells = cells
        self.parentReadinessScopes = parentReadinessScopes
        self.tags = tags
    }
}

struct GetCellOutputResponseBody: Swift.Equatable {
    public let cellArn: Swift.String?
    public let cellName: Swift.String?
    public let cells: [Swift.String]?
    public let parentReadinessScopes: [Swift.String]?
    public let tags: [Swift.String:Swift.String]?
}

extension GetCellOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetCellReadinessSummaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCellReadinessSummaryInput(cellName: \(Swift.String(describing: cellName)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetCellReadinessSummaryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetCellReadinessSummaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCellReadinessSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCellReadinessSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCellReadinessSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCellReadinessSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCellReadinessSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCellReadinessSummaryOutputError>
}

public struct GetCellReadinessSummaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetCellReadinessSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetCellReadinessSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetCellReadinessSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetCellReadinessSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetCellReadinessSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetCellReadinessSummaryOutputError>
}

public struct GetCellReadinessSummaryInput: Swift.Equatable {
    /// The name of the Cell
    /// This member is required.
    public let cellName: Swift.String?
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?

    public init (
        cellName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.cellName = cellName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCellReadinessSummaryInputBody: Swift.Equatable {
}

extension GetCellReadinessSummaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCellReadinessSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCellReadinessSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCellReadinessSummaryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCellReadinessSummaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCellReadinessSummaryOutputResponse(nextToken: \(Swift.String(describing: nextToken)), readiness: \(Swift.String(describing: readiness)), readinessChecks: \(Swift.String(describing: readinessChecks)))"}
}

extension GetCellReadinessSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCellReadinessSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.readinessChecks = output.readinessChecks
        } else {
            self.nextToken = nil
            self.readiness = nil
            self.readinessChecks = nil
        }
    }
}

public struct GetCellReadinessSummaryOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?
    /// The readiness at Cell level.
    public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Summaries for the ReadinessChecks making up the Cell
    public let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?

    public init (
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.readiness = readiness
        self.readinessChecks = readinessChecks
    }
}

struct GetCellReadinessSummaryOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    public let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?
}

extension GetCellReadinessSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readiness = "readiness"
        case readinessChecks = "readinessChecks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let readinessChecksContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ReadinessCheckSummary?].self, forKey: .readinessChecks)
        var readinessChecksDecoded0:[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
        if let readinessChecksContainer = readinessChecksContainer {
            readinessChecksDecoded0 = [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]()
            for structure0 in readinessChecksContainer {
                if let structure0 = structure0 {
                    readinessChecksDecoded0?.append(structure0)
                }
            }
        }
        readinessChecks = readinessChecksDecoded0
    }
}

extension GetReadinessCheckInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReadinessCheckInput(readinessCheckName: \(Swift.String(describing: readinessCheckName)))"}
}

extension GetReadinessCheckInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetReadinessCheckInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReadinessCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReadinessCheckOutputError>
}

public struct GetReadinessCheckInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReadinessCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReadinessCheckOutputError>
}

public struct GetReadinessCheckInput: Swift.Equatable {
    /// The ReadinessCheck to get
    /// This member is required.
    public let readinessCheckName: Swift.String?

    public init (
        readinessCheckName: Swift.String? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
    }
}

struct GetReadinessCheckInputBody: Swift.Equatable {
}

extension GetReadinessCheckInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadinessCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadinessCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReadinessCheckOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadinessCheckOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReadinessCheckOutputResponse(readinessCheckArn: \(Swift.String(describing: readinessCheckArn)), readinessCheckName: \(Swift.String(describing: readinessCheckName)), resourceSet: \(Swift.String(describing: resourceSet)), tags: \(Swift.String(describing: tags)))"}
}

extension GetReadinessCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReadinessCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.readinessCheckArn = output.readinessCheckArn
            self.readinessCheckName = output.readinessCheckName
            self.resourceSet = output.resourceSet
            self.tags = output.tags
        } else {
            self.readinessCheckArn = nil
            self.readinessCheckName = nil
            self.resourceSet = nil
            self.tags = nil
        }
    }
}

public struct GetReadinessCheckOutputResponse: Swift.Equatable {
    /// Arn associated with ReadinessCheck
    public let readinessCheckArn: Swift.String?
    /// Name for a ReadinessCheck
    public let readinessCheckName: Swift.String?
    /// Name of the ResourceSet to be checked
    public let resourceSet: Swift.String?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        readinessCheckArn: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceSet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckArn = readinessCheckArn
        self.readinessCheckName = readinessCheckName
        self.resourceSet = resourceSet
        self.tags = tags
    }
}

struct GetReadinessCheckOutputResponseBody: Swift.Equatable {
    public let readinessCheckArn: Swift.String?
    public let readinessCheckName: Swift.String?
    public let resourceSet: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension GetReadinessCheckOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetReadinessCheckResourceStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReadinessCheckResourceStatusInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), readinessCheckName: \(Swift.String(describing: readinessCheckName)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)))"}
}

extension GetReadinessCheckResourceStatusInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetReadinessCheckResourceStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReadinessCheckResourceStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReadinessCheckResourceStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReadinessCheckResourceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReadinessCheckResourceStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReadinessCheckResourceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReadinessCheckResourceStatusOutputError>
}

public struct GetReadinessCheckResourceStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReadinessCheckResourceStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReadinessCheckResourceStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReadinessCheckResourceStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReadinessCheckResourceStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReadinessCheckResourceStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReadinessCheckResourceStatusOutputError>
}

public struct GetReadinessCheckResourceStatusInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?
    /// The ReadinessCheck to get
    /// This member is required.
    public let readinessCheckName: Swift.String?
    /// The resource ARN or component Id to get
    /// This member is required.
    public let resourceIdentifier: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.readinessCheckName = readinessCheckName
        self.resourceIdentifier = resourceIdentifier
    }
}

struct GetReadinessCheckResourceStatusInputBody: Swift.Equatable {
}

extension GetReadinessCheckResourceStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadinessCheckResourceStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadinessCheckResourceStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReadinessCheckResourceStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadinessCheckResourceStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReadinessCheckResourceStatusOutputResponse(nextToken: \(Swift.String(describing: nextToken)), readiness: \(Swift.String(describing: readiness)), rules: \(Swift.String(describing: rules)))"}
}

extension GetReadinessCheckResourceStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReadinessCheckResourceStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.readiness = nil
            self.rules = nil
        }
    }
}

public struct GetReadinessCheckResourceStatusOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?
    /// The readiness at rule level.
    public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Details of the rules's results
    public let rules: [Route53RecoveryReadinessClientTypes.RuleResult]?

    public init (
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        rules: [Route53RecoveryReadinessClientTypes.RuleResult]? = nil
    )
    {
        self.nextToken = nextToken
        self.readiness = readiness
        self.rules = rules
    }
}

struct GetReadinessCheckResourceStatusOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    public let rules: [Route53RecoveryReadinessClientTypes.RuleResult]?
}

extension GetReadinessCheckResourceStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readiness = "readiness"
        case rules = "rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.RuleResult?].self, forKey: .rules)
        var rulesDecoded0:[Route53RecoveryReadinessClientTypes.RuleResult]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Route53RecoveryReadinessClientTypes.RuleResult]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension GetReadinessCheckStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReadinessCheckStatusInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), readinessCheckName: \(Swift.String(describing: readinessCheckName)))"}
}

extension GetReadinessCheckStatusInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetReadinessCheckStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReadinessCheckStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReadinessCheckStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReadinessCheckStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReadinessCheckStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReadinessCheckStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReadinessCheckStatusOutputError>
}

public struct GetReadinessCheckStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetReadinessCheckStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetReadinessCheckStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetReadinessCheckStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetReadinessCheckStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetReadinessCheckStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetReadinessCheckStatusOutputError>
}

public struct GetReadinessCheckStatusInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?
    /// The ReadinessCheck to get
    /// This member is required.
    public let readinessCheckName: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.readinessCheckName = readinessCheckName
    }
}

struct GetReadinessCheckStatusInputBody: Swift.Equatable {
}

extension GetReadinessCheckStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadinessCheckStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadinessCheckStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReadinessCheckStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadinessCheckStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReadinessCheckStatusOutputResponse(messages: \(Swift.String(describing: messages)), nextToken: \(Swift.String(describing: nextToken)), readiness: \(Swift.String(describing: readiness)), resources: \(Swift.String(describing: resources)))"}
}

extension GetReadinessCheckStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReadinessCheckStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messages = output.messages
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.resources = output.resources
        } else {
            self.messages = nil
            self.nextToken = nil
            self.readiness = nil
            self.resources = nil
        }
    }
}

public struct GetReadinessCheckStatusOutputResponse: Swift.Equatable {
    /// Top level messages for readiness check status
    public let messages: [Route53RecoveryReadinessClientTypes.Message]?
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?
    /// The readiness at rule level.
    public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Summary of resources's readiness
    public let resources: [Route53RecoveryReadinessClientTypes.ResourceResult]?

    public init (
        messages: [Route53RecoveryReadinessClientTypes.Message]? = nil,
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        resources: [Route53RecoveryReadinessClientTypes.ResourceResult]? = nil
    )
    {
        self.messages = messages
        self.nextToken = nextToken
        self.readiness = readiness
        self.resources = resources
    }
}

struct GetReadinessCheckStatusOutputResponseBody: Swift.Equatable {
    public let messages: [Route53RecoveryReadinessClientTypes.Message]?
    public let nextToken: Swift.String?
    public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    public let resources: [Route53RecoveryReadinessClientTypes.ResourceResult]?
}

extension GetReadinessCheckStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages = "messages"
        case nextToken = "nextToken"
        case readiness = "readiness"
        case resources = "resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messagesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[Route53RecoveryReadinessClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Route53RecoveryReadinessClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ResourceResult?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.ResourceResult]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.ResourceResult]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension GetRecoveryGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecoveryGroupInput(recoveryGroupName: \(Swift.String(describing: recoveryGroupName)))"}
}

extension GetRecoveryGroupInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRecoveryGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecoveryGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecoveryGroupOutputError>
}

public struct GetRecoveryGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecoveryGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecoveryGroupOutputError>
}

public struct GetRecoveryGroupInput: Swift.Equatable {
    /// The RecoveryGroup to get
    /// This member is required.
    public let recoveryGroupName: Swift.String?

    public init (
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.recoveryGroupName = recoveryGroupName
    }
}

struct GetRecoveryGroupInputBody: Swift.Equatable {
}

extension GetRecoveryGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecoveryGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecoveryGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecoveryGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecoveryGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecoveryGroupOutputResponse(cells: \(Swift.String(describing: cells)), recoveryGroupArn: \(Swift.String(describing: recoveryGroupArn)), recoveryGroupName: \(Swift.String(describing: recoveryGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension GetRecoveryGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecoveryGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.recoveryGroupArn = output.recoveryGroupArn
            self.recoveryGroupName = output.recoveryGroupName
            self.tags = output.tags
        } else {
            self.cells = nil
            self.recoveryGroupArn = nil
            self.recoveryGroupName = nil
            self.tags = nil
        }
    }
}

public struct GetRecoveryGroupOutputResponse: Swift.Equatable {
    /// A list of Cell arns
    public let cells: [Swift.String]?
    /// The arn for the RecoveryGroup
    public let recoveryGroupArn: Swift.String?
    /// The name of the RecoveryGroup
    public let recoveryGroupName: Swift.String?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupArn: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupArn = recoveryGroupArn
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct GetRecoveryGroupOutputResponseBody: Swift.Equatable {
    public let cells: [Swift.String]?
    public let recoveryGroupArn: Swift.String?
    public let recoveryGroupName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension GetRecoveryGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetRecoveryGroupReadinessSummaryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecoveryGroupReadinessSummaryInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), recoveryGroupName: \(Swift.String(describing: recoveryGroupName)))"}
}

extension GetRecoveryGroupReadinessSummaryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRecoveryGroupReadinessSummaryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecoveryGroupReadinessSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecoveryGroupReadinessSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecoveryGroupReadinessSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecoveryGroupReadinessSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecoveryGroupReadinessSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecoveryGroupReadinessSummaryOutputError>
}

public struct GetRecoveryGroupReadinessSummaryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRecoveryGroupReadinessSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRecoveryGroupReadinessSummaryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRecoveryGroupReadinessSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRecoveryGroupReadinessSummaryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRecoveryGroupReadinessSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRecoveryGroupReadinessSummaryOutputError>
}

public struct GetRecoveryGroupReadinessSummaryInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?
    /// The name of the RecoveryGroup
    /// This member is required.
    public let recoveryGroupName: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recoveryGroupName = recoveryGroupName
    }
}

struct GetRecoveryGroupReadinessSummaryInputBody: Swift.Equatable {
}

extension GetRecoveryGroupReadinessSummaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRecoveryGroupReadinessSummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecoveryGroupReadinessSummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecoveryGroupReadinessSummaryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecoveryGroupReadinessSummaryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRecoveryGroupReadinessSummaryOutputResponse(nextToken: \(Swift.String(describing: nextToken)), readiness: \(Swift.String(describing: readiness)), readinessChecks: \(Swift.String(describing: readinessChecks)))"}
}

extension GetRecoveryGroupReadinessSummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRecoveryGroupReadinessSummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readiness = output.readiness
            self.readinessChecks = output.readinessChecks
        } else {
            self.nextToken = nil
            self.readiness = nil
            self.readinessChecks = nil
        }
    }
}

public struct GetRecoveryGroupReadinessSummaryOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?
    /// The readiness at RecoveryGroup level.
    public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    /// Summaries for the ReadinessChecks making up the RecoveryGroup
    public let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?

    public init (
        nextToken: Swift.String? = nil,
        readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
        readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.readiness = readiness
        self.readinessChecks = readinessChecks
    }
}

struct GetRecoveryGroupReadinessSummaryOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
    public let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]?
}

extension GetRecoveryGroupReadinessSummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readiness = "readiness"
        case readinessChecks = "readinessChecks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let readinessChecksContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ReadinessCheckSummary?].self, forKey: .readinessChecks)
        var readinessChecksDecoded0:[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]? = nil
        if let readinessChecksContainer = readinessChecksContainer {
            readinessChecksDecoded0 = [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]()
            for structure0 in readinessChecksContainer {
                if let structure0 = structure0 {
                    readinessChecksDecoded0?.append(structure0)
                }
            }
        }
        readinessChecks = readinessChecksDecoded0
    }
}

extension GetResourceSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceSetInput(resourceSetName: \(Swift.String(describing: resourceSetName)))"}
}

extension GetResourceSetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetResourceSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSetOutputError>
}

public struct GetResourceSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetResourceSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetResourceSetOutputError>
}

public struct GetResourceSetInput: Swift.Equatable {
    /// The ResourceSet to get
    /// This member is required.
    public let resourceSetName: Swift.String?

    public init (
        resourceSetName: Swift.String? = nil
    )
    {
        self.resourceSetName = resourceSetName
    }
}

struct GetResourceSetInputBody: Swift.Equatable {
}

extension GetResourceSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceSetOutputResponse(resourceSetArn: \(Swift.String(describing: resourceSetArn)), resourceSetName: \(Swift.String(describing: resourceSetName)), resourceSetType: \(Swift.String(describing: resourceSetType)), resources: \(Swift.String(describing: resources)), tags: \(Swift.String(describing: tags)))"}
}

extension GetResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceSetArn = output.resourceSetArn
            self.resourceSetName = output.resourceSetName
            self.resourceSetType = output.resourceSetType
            self.resources = output.resources
            self.tags = output.tags
        } else {
            self.resourceSetArn = nil
            self.resourceSetName = nil
            self.resourceSetType = nil
            self.resources = nil
            self.tags = nil
        }
    }
}

public struct GetResourceSetOutputResponse: Swift.Equatable {
    /// The arn for the ResourceSet
    public let resourceSetArn: Swift.String?
    /// The name of the ResourceSet
    public let resourceSetName: Swift.String?
    /// AWS Resource Type of the resources in the ResourceSet
    public let resourceSetType: Swift.String?
    /// A list of Resource objects
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceSetArn: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetArn = resourceSetArn
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct GetResourceSetOutputResponseBody: Swift.Equatable {
    public let resourceSetArn: Swift.String?
    public let resourceSetName: Swift.String?
    public let resourceSetType: Swift.String?
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    public let tags: [Swift.String:Swift.String]?
}

extension GetResourceSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCellsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCellsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCellsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCellsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCellsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCellsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCellsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCellsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCellsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCellsOutputError>
}

public struct ListCellsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCellsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCellsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCellsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCellsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCellsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCellsOutputError>
}

public struct ListCellsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCellsInputBody: Swift.Equatable {
}

extension ListCellsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCellsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCellsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCellsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCellsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCellsOutputResponse(cells: \(Swift.String(describing: cells)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCellsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCellsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.nextToken = output.nextToken
        } else {
            self.cells = nil
            self.nextToken = nil
        }
    }
}

public struct ListCellsOutputResponse: Swift.Equatable {
    /// A list of Cells
    public let cells: [Route53RecoveryReadinessClientTypes.CellOutput]?
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?

    public init (
        cells: [Route53RecoveryReadinessClientTypes.CellOutput]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.cells = cells
        self.nextToken = nextToken
    }
}

struct ListCellsOutputResponseBody: Swift.Equatable {
    public let cells: [Route53RecoveryReadinessClientTypes.CellOutput]?
    public let nextToken: Swift.String?
}

extension ListCellsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.CellOutput?].self, forKey: .cells)
        var cellsDecoded0:[Route53RecoveryReadinessClientTypes.CellOutput]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Route53RecoveryReadinessClientTypes.CellOutput]()
            for structure0 in cellsContainer {
                if let structure0 = structure0 {
                    cellsDecoded0?.append(structure0)
                }
            }
        }
        cells = cellsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCrossAccountAuthorizationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCrossAccountAuthorizationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCrossAccountAuthorizationsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListCrossAccountAuthorizationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCrossAccountAuthorizationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCrossAccountAuthorizationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCrossAccountAuthorizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCrossAccountAuthorizationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCrossAccountAuthorizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCrossAccountAuthorizationsOutputError>
}

public struct ListCrossAccountAuthorizationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListCrossAccountAuthorizationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListCrossAccountAuthorizationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListCrossAccountAuthorizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListCrossAccountAuthorizationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListCrossAccountAuthorizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListCrossAccountAuthorizationsOutputError>
}

public struct ListCrossAccountAuthorizationsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCrossAccountAuthorizationsInputBody: Swift.Equatable {
}

extension ListCrossAccountAuthorizationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCrossAccountAuthorizationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCrossAccountAuthorizationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCrossAccountAuthorizationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCrossAccountAuthorizationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCrossAccountAuthorizationsOutputResponse(crossAccountAuthorizations: \(Swift.String(describing: crossAccountAuthorizations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListCrossAccountAuthorizationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCrossAccountAuthorizationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.crossAccountAuthorizations = output.crossAccountAuthorizations
            self.nextToken = output.nextToken
        } else {
            self.crossAccountAuthorizations = nil
            self.nextToken = nil
        }
    }
}

public struct ListCrossAccountAuthorizationsOutputResponse: Swift.Equatable {
    /// A list of CrossAccountAuthorizations
    public let crossAccountAuthorizations: [Swift.String]?
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?

    public init (
        crossAccountAuthorizations: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.crossAccountAuthorizations = crossAccountAuthorizations
        self.nextToken = nextToken
    }
}

struct ListCrossAccountAuthorizationsOutputResponseBody: Swift.Equatable {
    public let crossAccountAuthorizations: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListCrossAccountAuthorizationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case crossAccountAuthorizations = "crossAccountAuthorizations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crossAccountAuthorizationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .crossAccountAuthorizations)
        var crossAccountAuthorizationsDecoded0:[Swift.String]? = nil
        if let crossAccountAuthorizationsContainer = crossAccountAuthorizationsContainer {
            crossAccountAuthorizationsDecoded0 = [Swift.String]()
            for string0 in crossAccountAuthorizationsContainer {
                if let string0 = string0 {
                    crossAccountAuthorizationsDecoded0?.append(string0)
                }
            }
        }
        crossAccountAuthorizations = crossAccountAuthorizationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReadinessChecksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReadinessChecksInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListReadinessChecksInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListReadinessChecksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReadinessChecksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReadinessChecksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReadinessChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReadinessChecksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReadinessChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReadinessChecksOutputError>
}

public struct ListReadinessChecksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListReadinessChecksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListReadinessChecksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListReadinessChecksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListReadinessChecksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListReadinessChecksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListReadinessChecksOutputError>
}

public struct ListReadinessChecksInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReadinessChecksInputBody: Swift.Equatable {
}

extension ListReadinessChecksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListReadinessChecksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReadinessChecksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReadinessChecksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReadinessChecksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListReadinessChecksOutputResponse(nextToken: \(Swift.String(describing: nextToken)), readinessChecks: \(Swift.String(describing: readinessChecks)))"}
}

extension ListReadinessChecksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReadinessChecksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readinessChecks = output.readinessChecks
        } else {
            self.nextToken = nil
            self.readinessChecks = nil
        }
    }
}

public struct ListReadinessChecksOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?
    /// A list of ReadinessCheck associated with the account
    public let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]?

    public init (
        nextToken: Swift.String? = nil,
        readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.readinessChecks = readinessChecks
    }
}

struct ListReadinessChecksOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let readinessChecks: [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]?
}

extension ListReadinessChecksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case readinessChecks = "readinessChecks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readinessChecksContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ReadinessCheckOutput?].self, forKey: .readinessChecks)
        var readinessChecksDecoded0:[Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]? = nil
        if let readinessChecksContainer = readinessChecksContainer {
            readinessChecksDecoded0 = [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]()
            for structure0 in readinessChecksContainer {
                if let structure0 = structure0 {
                    readinessChecksDecoded0?.append(structure0)
                }
            }
        }
        readinessChecks = readinessChecksDecoded0
    }
}

extension ListRecoveryGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecoveryGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListRecoveryGroupsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRecoveryGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecoveryGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecoveryGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryGroupsOutputError>
}

public struct ListRecoveryGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecoveryGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecoveryGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecoveryGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecoveryGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecoveryGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecoveryGroupsOutputError>
}

public struct ListRecoveryGroupsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecoveryGroupsInputBody: Swift.Equatable {
}

extension ListRecoveryGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRecoveryGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecoveryGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecoveryGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecoveryGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecoveryGroupsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), recoveryGroups: \(Swift.String(describing: recoveryGroups)))"}
}

extension ListRecoveryGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecoveryGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recoveryGroups = output.recoveryGroups
        } else {
            self.nextToken = nil
            self.recoveryGroups = nil
        }
    }
}

public struct ListRecoveryGroupsOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?
    /// A list of RecoveryGroups
    public let recoveryGroups: [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]?

    public init (
        nextToken: Swift.String? = nil,
        recoveryGroups: [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryGroups = recoveryGroups
    }
}

struct ListRecoveryGroupsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let recoveryGroups: [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]?
}

extension ListRecoveryGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case recoveryGroups = "recoveryGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recoveryGroupsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.RecoveryGroupOutput?].self, forKey: .recoveryGroups)
        var recoveryGroupsDecoded0:[Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]? = nil
        if let recoveryGroupsContainer = recoveryGroupsContainer {
            recoveryGroupsDecoded0 = [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]()
            for structure0 in recoveryGroupsContainer {
                if let structure0 = structure0 {
                    recoveryGroupsDecoded0?.append(structure0)
                }
            }
        }
        recoveryGroups = recoveryGroupsDecoded0
    }
}

extension ListResourceSetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceSetsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListResourceSetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListResourceSetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceSetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceSetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSetsOutputError>
}

public struct ListResourceSetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceSetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceSetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceSetsOutputError>
}

public struct ListResourceSetsInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceSetsInputBody: Swift.Equatable {
}

extension ListResourceSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResourceSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceSetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceSetsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resourceSets: \(Swift.String(describing: resourceSets)))"}
}

extension ListResourceSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceSets = output.resourceSets
        } else {
            self.nextToken = nil
            self.resourceSets = nil
        }
    }
}

public struct ListResourceSetsOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?
    /// A list of ResourceSets associated with the account
    public let resourceSets: [Route53RecoveryReadinessClientTypes.ResourceSetOutput]?

    public init (
        nextToken: Swift.String? = nil,
        resourceSets: [Route53RecoveryReadinessClientTypes.ResourceSetOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceSets = resourceSets
    }
}

struct ListResourceSetsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let resourceSets: [Route53RecoveryReadinessClientTypes.ResourceSetOutput]?
}

extension ListResourceSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case resourceSets = "resourceSets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceSetsContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ResourceSetOutput?].self, forKey: .resourceSets)
        var resourceSetsDecoded0:[Route53RecoveryReadinessClientTypes.ResourceSetOutput]? = nil
        if let resourceSetsContainer = resourceSetsContainer {
            resourceSetsDecoded0 = [Route53RecoveryReadinessClientTypes.ResourceSetOutput]()
            for structure0 in resourceSetsContainer {
                if let structure0 = structure0 {
                    resourceSetsDecoded0?.append(structure0)
                }
            }
        }
        resourceSets = resourceSetsDecoded0
    }
}

extension ListRulesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRulesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListRulesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRulesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRulesOutputError>
}

public struct ListRulesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRulesOutputError>
}

public struct ListRulesInput: Swift.Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Swift.Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: Swift.String?
    /// Filter parameter which specifies the rules to return given a resource type.
    public let resourceType: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListRulesInputBody: Swift.Equatable {
}

extension ListRulesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension Route53RecoveryReadinessClientTypes.ListRulesOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType = "resourceType"
        case ruleDescription = "ruleDescription"
        case ruleId = "ruleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let ruleDescription = ruleDescription {
            try encodeContainer.encode(ruleDescription, forKey: .ruleDescription)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let ruleDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleDescription)
        ruleDescription = ruleDescriptionDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.ListRulesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRulesOutput(resourceType: \(Swift.String(describing: resourceType)), ruleDescription: \(Swift.String(describing: ruleDescription)), ruleId: \(Swift.String(describing: ruleId)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// A collection of rules used in a readiness check
    public struct ListRulesOutput: Swift.Equatable {
        /// The resource type the rule applies to.
        /// This member is required.
        public let resourceType: Swift.String?
        /// A description of the rule
        /// This member is required.
        public let ruleDescription: Swift.String?
        /// The Rule's ID.
        /// This member is required.
        public let ruleId: Swift.String?

        public init (
            resourceType: Swift.String? = nil,
            ruleDescription: Swift.String? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
            self.ruleDescription = ruleDescription
            self.ruleId = ruleId
        }
    }

}

extension ListRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRulesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), rules: \(Swift.String(describing: rules)))"}
}

extension ListRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutputResponse: Swift.Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: Swift.String?
    /// A list of rules
    public let rules: [Route53RecoveryReadinessClientTypes.ListRulesOutput]?

    public init (
        nextToken: Swift.String? = nil,
        rules: [Route53RecoveryReadinessClientTypes.ListRulesOutput]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListRulesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let rules: [Route53RecoveryReadinessClientTypes.ListRulesOutput]?
}

extension ListRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case rules = "rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let rulesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.ListRulesOutput?].self, forKey: .rules)
        var rulesDecoded0:[Route53RecoveryReadinessClientTypes.ListRulesOutput]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Route53RecoveryReadinessClientTypes.ListRulesOutput]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension ListTagsForResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourcesInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourcesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourcesOutputError>
}

public struct ListTagsForResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourcesOutputError>
}

public struct ListTagsForResourcesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
    /// This member is required.
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourcesInputBody: Swift.Equatable {
}

extension ListTagsForResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourcesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourcesOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourcesOutputResponse: Swift.Equatable {
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourcesOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes.Message: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageText = "messageText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageText = messageText {
            try encodeContainer.encode(messageText, forKey: .messageText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageText)
        messageText = messageTextDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.Message: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Message(messageText: \(Swift.String(describing: messageText)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// Information relating to readiness check status
    public struct Message: Swift.Equatable {
        /// The text of a readiness check message
        public let messageText: Swift.String?

        public init (
            messageText: Swift.String? = nil
        )
        {
            self.messageText = messageText
        }
    }

}

extension Route53RecoveryReadinessClientTypes.NLBResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.NLBResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NLBResource(arn: \(Swift.String(describing: arn)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// The NLB resource a DNS Target Resource points to
    public struct NLBResource: Swift.Equatable {
        /// An NLB resource arn
        public let arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension Route53RecoveryReadinessClientTypes.R53ResourceRecord: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "domainName"
        case recordSetId = "recordSetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let recordSetId = recordSetId {
            try encodeContainer.encode(recordSetId, forKey: .recordSetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let recordSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordSetId)
        recordSetId = recordSetIdDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.R53ResourceRecord: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "R53ResourceRecord(domainName: \(Swift.String(describing: domainName)), recordSetId: \(Swift.String(describing: recordSetId)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// The Route 53 resource a DNS Target Resource record points to
    public struct R53ResourceRecord: Swift.Equatable {
        /// The DNS target name
        public let domainName: Swift.String?
        /// The Resource Record set id
        public let recordSetId: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            recordSetId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.recordSetId = recordSetId
        }
    }

}

extension Route53RecoveryReadinessClientTypes {
    /// The readiness of an entire ReadinessCheck or an individual resource ARN.
    public enum Readiness: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notAuthorized
        case notReady
        case ready
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [Readiness] {
            return [
                .notAuthorized,
                .notReady,
                .ready,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notAuthorized: return "NOT_AUTHORIZED"
            case .notReady: return "NOT_READY"
            case .ready: return "READY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Readiness(rawValue: rawValue) ?? Readiness.sdkUnknown(rawValue)
        }
    }
}

extension Route53RecoveryReadinessClientTypes.ReadinessCheckOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readinessCheckArn = readinessCheckArn {
            try encodeContainer.encode(readinessCheckArn, forKey: .readinessCheckArn)
        }
        if let readinessCheckName = readinessCheckName {
            try encodeContainer.encode(readinessCheckName, forKey: .readinessCheckName)
        }
        if let resourceSet = resourceSet {
            try encodeContainer.encode(resourceSet, forKey: .resourceSet)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes.ReadinessCheckOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReadinessCheckOutput(readinessCheckArn: \(Swift.String(describing: readinessCheckArn)), readinessCheckName: \(Swift.String(describing: readinessCheckName)), resourceSet: \(Swift.String(describing: resourceSet)), tags: \(Swift.String(describing: tags)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// A resource used for checking the readiness of a Resource Set
    public struct ReadinessCheckOutput: Swift.Equatable {
        /// Arn associated with ReadinessCheck
        /// This member is required.
        public let readinessCheckArn: Swift.String?
        /// Name for a ReadinessCheck
        public let readinessCheckName: Swift.String?
        /// Name of the ResourceSet to be checked
        /// This member is required.
        public let resourceSet: Swift.String?
        /// A collection of tags associated with a resource
        public let tags: [Swift.String:Swift.String]?

        public init (
            readinessCheckArn: Swift.String? = nil,
            readinessCheckName: Swift.String? = nil,
            resourceSet: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.readinessCheckArn = readinessCheckArn
            self.readinessCheckName = readinessCheckName
            self.resourceSet = resourceSet
            self.tags = tags
        }
    }

}

extension Route53RecoveryReadinessClientTypes.ReadinessCheckSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readiness = "readiness"
        case readinessCheckName = "readinessCheckName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readiness = readiness {
            try encodeContainer.encode(readiness.rawValue, forKey: .readiness)
        }
        if let readinessCheckName = readinessCheckName {
            try encodeContainer.encode(readinessCheckName, forKey: .readinessCheckName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.ReadinessCheckSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReadinessCheckSummary(readiness: \(Swift.String(describing: readiness)), readinessCheckName: \(Swift.String(describing: readinessCheckName)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// Summary of ReadinessCheck status, paginated in GetRecoveryGroupReadinessSummary and GetCellReadinessSummary
    public struct ReadinessCheckSummary: Swift.Equatable {
        /// The readiness of this ReadinessCheck
        public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
        /// The name of a ReadinessCheck which is part of the given RecoveryGroup or Cell
        public let readinessCheckName: Swift.String?

        public init (
            readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
            readinessCheckName: Swift.String? = nil
        )
        {
            self.readiness = readiness
            self.readinessCheckName = readinessCheckName
        }
    }

}

extension Route53RecoveryReadinessClientTypes.Recommendation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationText = "recommendationText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationText = recommendationText {
            try encodeContainer.encode(recommendationText, forKey: .recommendationText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationText)
        recommendationText = recommendationTextDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.Recommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Recommendation(recommendationText: \(Swift.String(describing: recommendationText)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// Guidance for improving Recovery Group resilliancy
    public struct Recommendation: Swift.Equatable {
        /// Guidance text for recommendation
        /// This member is required.
        public let recommendationText: Swift.String?

        public init (
            recommendationText: Swift.String? = nil
        )
        {
            self.recommendationText = recommendationText
        }
    }

}

extension Route53RecoveryReadinessClientTypes.RecoveryGroupOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __listof__string0 in cells {
                try cellsContainer.encode(__listof__string0)
            }
        }
        if let recoveryGroupArn = recoveryGroupArn {
            try encodeContainer.encode(recoveryGroupArn, forKey: .recoveryGroupArn)
        }
        if let recoveryGroupName = recoveryGroupName {
            try encodeContainer.encode(recoveryGroupName, forKey: .recoveryGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes.RecoveryGroupOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecoveryGroupOutput(cells: \(Swift.String(describing: cells)), recoveryGroupArn: \(Swift.String(describing: recoveryGroupArn)), recoveryGroupName: \(Swift.String(describing: recoveryGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// A Recovery Group generally containing multiple Cells
    public struct RecoveryGroupOutput: Swift.Equatable {
        /// A list of Cell arns
        /// This member is required.
        public let cells: [Swift.String]?
        /// The arn for the RecoveryGroup
        /// This member is required.
        public let recoveryGroupArn: Swift.String?
        /// The name of the RecoveryGroup
        /// This member is required.
        public let recoveryGroupName: Swift.String?
        /// A collection of tags associated with a resource
        public let tags: [Swift.String:Swift.String]?

        public init (
            cells: [Swift.String]? = nil,
            recoveryGroupArn: Swift.String? = nil,
            recoveryGroupName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.cells = cells
            self.recoveryGroupArn = recoveryGroupArn
            self.recoveryGroupName = recoveryGroupName
            self.tags = tags
        }
    }

}

extension Route53RecoveryReadinessClientTypes.Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentId = "componentId"
        case dnsTargetResource = "dnsTargetResource"
        case readinessScopes = "readinessScopes"
        case resourceArn = "resourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let dnsTargetResource = dnsTargetResource {
            try encodeContainer.encode(dnsTargetResource, forKey: .dnsTargetResource)
        }
        if let readinessScopes = readinessScopes {
            var readinessScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readinessScopes)
            for __listof__string0 in readinessScopes {
                try readinessScopesContainer.encode(__listof__string0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let dnsTargetResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.DNSTargetResource.self, forKey: .dnsTargetResource)
        dnsTargetResource = dnsTargetResourceDecoded
        let readinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .readinessScopes)
        var readinessScopesDecoded0:[Swift.String]? = nil
        if let readinessScopesContainer = readinessScopesContainer {
            readinessScopesDecoded0 = [Swift.String]()
            for string0 in readinessScopesContainer {
                if let string0 = string0 {
                    readinessScopesDecoded0?.append(string0)
                }
            }
        }
        readinessScopes = readinessScopesDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Resource(componentId: \(Swift.String(describing: componentId)), dnsTargetResource: \(Swift.String(describing: dnsTargetResource)), readinessScopes: \(Swift.String(describing: readinessScopes)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// The resource element of a ResourceSet
    public struct Resource: Swift.Equatable {
        /// The component id of the resource, generated by the service when dnsTargetResource is used
        public let componentId: Swift.String?
        /// A component for DNS/Routing Control Readiness Checks
        public let dnsTargetResource: Route53RecoveryReadinessClientTypes.DNSTargetResource?
        /// A list of RecoveryGroup ARNs and/or Cell ARNs that this resource is contained within.
        public let readinessScopes: [Swift.String]?
        /// The ARN of the AWS resource, can be skipped if dnsTargetResource is used
        public let resourceArn: Swift.String?

        public init (
            componentId: Swift.String? = nil,
            dnsTargetResource: Route53RecoveryReadinessClientTypes.DNSTargetResource? = nil,
            readinessScopes: [Swift.String]? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.componentId = componentId
            self.dnsTargetResource = dnsTargetResource
            self.readinessScopes = readinessScopes
            self.resourceArn = resourceArn
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.ResourceResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentId = "componentId"
        case lastCheckedTimestamp = "lastCheckedTimestamp"
        case readiness = "readiness"
        case resourceArn = "resourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let lastCheckedTimestamp = lastCheckedTimestamp {
            try encodeContainer.encode(lastCheckedTimestamp.timeIntervalSince1970, forKey: .lastCheckedTimestamp)
        }
        if let readiness = readiness {
            try encodeContainer.encode(readiness.rawValue, forKey: .readiness)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let lastCheckedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastCheckedTimestamp)
        lastCheckedTimestamp = lastCheckedTimestampDecoded
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.ResourceResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceResult(componentId: \(Swift.String(describing: componentId)), lastCheckedTimestamp: \(Swift.String(describing: lastCheckedTimestamp)), readiness: \(Swift.String(describing: readiness)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// Result with status for an individual resource.
    public struct ResourceResult: Swift.Equatable {
        /// The component id of the resource
        public let componentId: Swift.String?
        /// The time the resource was last checked for readiness, in ISO-8601 format, UTC.
        /// This member is required.
        public let lastCheckedTimestamp: ClientRuntime.Date?
        /// The readiness of the resource.
        /// This member is required.
        public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
        /// The ARN of the resource
        public let resourceArn: Swift.String?

        public init (
            componentId: Swift.String? = nil,
            lastCheckedTimestamp: ClientRuntime.Date? = nil,
            readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.componentId = componentId
            self.lastCheckedTimestamp = lastCheckedTimestamp
            self.readiness = readiness
            self.resourceArn = resourceArn
        }
    }

}

extension Route53RecoveryReadinessClientTypes.ResourceSetOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetArn = resourceSetArn {
            try encodeContainer.encode(resourceSetArn, forKey: .resourceSetArn)
        }
        if let resourceSetName = resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
        if let resourceSetType = resourceSetType {
            try encodeContainer.encode(resourceSetType, forKey: .resourceSetType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for __listofresource0 in resources {
                try resourcesContainer.encode(__listofresource0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Route53RecoveryReadinessClientTypes.ResourceSetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceSetOutput(resourceSetArn: \(Swift.String(describing: resourceSetArn)), resourceSetName: \(Swift.String(describing: resourceSetName)), resourceSetType: \(Swift.String(describing: resourceSetType)), resources: \(Swift.String(describing: resources)), tags: \(Swift.String(describing: tags)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// A collection of resources of the same type
    public struct ResourceSetOutput: Swift.Equatable {
        /// The arn for the ResourceSet
        /// This member is required.
        public let resourceSetArn: Swift.String?
        /// The name of the ResourceSet
        /// This member is required.
        public let resourceSetName: Swift.String?
        /// AWS Resource Type of the resources in the ResourceSet
        /// This member is required.
        public let resourceSetType: Swift.String?
        /// A list of Resource objects
        /// This member is required.
        public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
        /// A collection of tags associated with a resource
        public let tags: [Swift.String:Swift.String]?

        public init (
            resourceSetArn: Swift.String? = nil,
            resourceSetName: Swift.String? = nil,
            resourceSetType: Swift.String? = nil,
            resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.resourceSetArn = resourceSetArn
            self.resourceSetName = resourceSetName
            self.resourceSetType = resourceSetType
            self.resources = resources
            self.tags = tags
        }
    }

}

extension Route53RecoveryReadinessClientTypes.RuleResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastCheckedTimestamp = "lastCheckedTimestamp"
        case messages = "messages"
        case readiness = "readiness"
        case ruleId = "ruleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastCheckedTimestamp = lastCheckedTimestamp {
            try encodeContainer.encode(lastCheckedTimestamp.timeIntervalSince1970, forKey: .lastCheckedTimestamp)
        }
        if let messages = messages {
            var messagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .messages)
            for __listofmessage0 in messages {
                try messagesContainer.encode(__listofmessage0)
            }
        }
        if let readiness = readiness {
            try encodeContainer.encode(readiness.rawValue, forKey: .readiness)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastCheckedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastCheckedTimestamp)
        lastCheckedTimestamp = lastCheckedTimestampDecoded
        let messagesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Message?].self, forKey: .messages)
        var messagesDecoded0:[Route53RecoveryReadinessClientTypes.Message]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Route53RecoveryReadinessClientTypes.Message]()
            for structure0 in messagesContainer {
                if let structure0 = structure0 {
                    messagesDecoded0?.append(structure0)
                }
            }
        }
        messages = messagesDecoded0
        let readinessDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.Readiness.self, forKey: .readiness)
        readiness = readinessDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.RuleResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleResult(lastCheckedTimestamp: \(Swift.String(describing: lastCheckedTimestamp)), messages: \(Swift.String(describing: messages)), readiness: \(Swift.String(describing: readiness)), ruleId: \(Swift.String(describing: ruleId)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// Result with status for an individual rule..
    public struct RuleResult: Swift.Equatable {
        /// The time the resource was last checked for readiness, in ISO-8601 format, UTC.
        /// This member is required.
        public let lastCheckedTimestamp: ClientRuntime.Date?
        /// Details about the resource's readiness
        /// This member is required.
        public let messages: [Route53RecoveryReadinessClientTypes.Message]?
        /// The readiness at rule level.
        /// This member is required.
        public let readiness: Route53RecoveryReadinessClientTypes.Readiness?
        /// The identifier of the rule.
        /// This member is required.
        public let ruleId: Swift.String?

        public init (
            lastCheckedTimestamp: ClientRuntime.Date? = nil,
            messages: [Route53RecoveryReadinessClientTypes.Message]? = nil,
            readiness: Route53RecoveryReadinessClientTypes.Readiness? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.lastCheckedTimestamp = lastCheckedTimestamp
            self.messages = messages
            self.readiness = readiness
            self.ruleId = ruleId
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// A collection of tags associated with a resource
    /// This member is required.
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension Route53RecoveryReadinessClientTypes.TargetResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nLBResource = "nLBResource"
        case r53Resource = "r53Resource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nLBResource = nLBResource {
            try encodeContainer.encode(nLBResource, forKey: .nLBResource)
        }
        if let r53Resource = r53Resource {
            try encodeContainer.encode(r53Resource, forKey: .r53Resource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nLBResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.NLBResource.self, forKey: .nLBResource)
        nLBResource = nLBResourceDecoded
        let r53ResourceDecoded = try containerValues.decodeIfPresent(Route53RecoveryReadinessClientTypes.R53ResourceRecord.self, forKey: .r53Resource)
        r53Resource = r53ResourceDecoded
    }
}

extension Route53RecoveryReadinessClientTypes.TargetResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetResource(nLBResource: \(Swift.String(describing: nLBResource)), r53Resource: \(Swift.String(describing: r53Resource)))"}
}

extension Route53RecoveryReadinessClientTypes {
    /// The target resource the R53 record points to
    public struct TargetResource: Swift.Equatable {
        /// The NLB resource a DNS Target Resource points to
        public let nLBResource: Route53RecoveryReadinessClientTypes.NLBResource?
        /// The Route 53 resource a DNS Target Resource record points to
        public let r53Resource: Route53RecoveryReadinessClientTypes.R53ResourceRecord?

        public init (
            nLBResource: Route53RecoveryReadinessClientTypes.NLBResource? = nil,
            r53Resource: Route53RecoveryReadinessClientTypes.R53ResourceRecord? = nil
        )
        {
            self.nLBResource = nLBResource
            self.r53Resource = r53Resource
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// A comma-separated list of the tag keys to remove from the resource.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateCellInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCellInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCellOutputError>
}

extension UpdateCellInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCellInput(cellName: \(Swift.String(describing: cellName)), cells: \(Swift.String(describing: cells)))"}
}

extension UpdateCellInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __listof__string0 in cells {
                try cellsContainer.encode(__listof__string0)
            }
        }
    }
}

public struct UpdateCellInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCellInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCellOutputError>
}

public struct UpdateCellInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateCellInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateCellInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateCellOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateCellInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateCellOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateCellOutputError>
}

/// Parameters to update for the Cell
public struct UpdateCellInput: Swift.Equatable {
    /// The Cell to update
    /// This member is required.
    public let cellName: Swift.String?
    /// A list of Cell arns, completely replaces previous list
    /// This member is required.
    public let cells: [Swift.String]?

    public init (
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil
    )
    {
        self.cellName = cellName
        self.cells = cells
    }
}

struct UpdateCellInputBody: Swift.Equatable {
    public let cells: [Swift.String]?
}

extension UpdateCellInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension UpdateCellOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCellOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCellOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCellOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCellOutputResponse(cellArn: \(Swift.String(describing: cellArn)), cellName: \(Swift.String(describing: cellName)), cells: \(Swift.String(describing: cells)), parentReadinessScopes: \(Swift.String(describing: parentReadinessScopes)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateCellOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateCellOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cellArn = output.cellArn
            self.cellName = output.cellName
            self.cells = output.cells
            self.parentReadinessScopes = output.parentReadinessScopes
            self.tags = output.tags
        } else {
            self.cellArn = nil
            self.cellName = nil
            self.cells = nil
            self.parentReadinessScopes = nil
            self.tags = nil
        }
    }
}

public struct UpdateCellOutputResponse: Swift.Equatable {
    /// The arn for the Cell
    public let cellArn: Swift.String?
    /// The name of the Cell
    public let cellName: Swift.String?
    /// A list of Cell arns
    public let cells: [Swift.String]?
    /// A list of Cell ARNs and/or RecoveryGroup ARNs
    public let parentReadinessScopes: [Swift.String]?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        cellArn: Swift.String? = nil,
        cellName: Swift.String? = nil,
        cells: [Swift.String]? = nil,
        parentReadinessScopes: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cellArn = cellArn
        self.cellName = cellName
        self.cells = cells
        self.parentReadinessScopes = parentReadinessScopes
        self.tags = tags
    }
}

struct UpdateCellOutputResponseBody: Swift.Equatable {
    public let cellArn: Swift.String?
    public let cellName: Swift.String?
    public let cells: [Swift.String]?
    public let parentReadinessScopes: [Swift.String]?
    public let tags: [Swift.String:Swift.String]?
}

extension UpdateCellOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellArn = "cellArn"
        case cellName = "cellName"
        case cells = "cells"
        case parentReadinessScopes = "parentReadinessScopes"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellArn)
        cellArn = cellArnDecoded
        let cellNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellName)
        cellName = cellNameDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let parentReadinessScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .parentReadinessScopes)
        var parentReadinessScopesDecoded0:[Swift.String]? = nil
        if let parentReadinessScopesContainer = parentReadinessScopesContainer {
            parentReadinessScopesDecoded0 = [Swift.String]()
            for string0 in parentReadinessScopesContainer {
                if let string0 = string0 {
                    parentReadinessScopesDecoded0?.append(string0)
                }
            }
        }
        parentReadinessScopes = parentReadinessScopesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateReadinessCheckInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReadinessCheckInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReadinessCheckOutputError>
}

extension UpdateReadinessCheckInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReadinessCheckInput(readinessCheckName: \(Swift.String(describing: readinessCheckName)), resourceSetName: \(Swift.String(describing: resourceSetName)))"}
}

extension UpdateReadinessCheckInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetName = resourceSetName {
            try encodeContainer.encode(resourceSetName, forKey: .resourceSetName)
        }
    }
}

public struct UpdateReadinessCheckInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReadinessCheckInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReadinessCheckOutputError>
}

public struct UpdateReadinessCheckInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateReadinessCheckInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateReadinessCheckInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateReadinessCheckOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateReadinessCheckInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateReadinessCheckOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateReadinessCheckOutputError>
}

/// The new Readiness Check values
public struct UpdateReadinessCheckInput: Swift.Equatable {
    /// The ReadinessCheck to update
    /// This member is required.
    public let readinessCheckName: Swift.String?
    /// The name of the ResourceSet to check
    /// This member is required.
    public let resourceSetName: Swift.String?

    public init (
        readinessCheckName: Swift.String? = nil,
        resourceSetName: Swift.String? = nil
    )
    {
        self.readinessCheckName = readinessCheckName
        self.resourceSetName = resourceSetName
    }
}

struct UpdateReadinessCheckInputBody: Swift.Equatable {
    public let resourceSetName: Swift.String?
}

extension UpdateReadinessCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetName = "resourceSetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
    }
}

extension UpdateReadinessCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReadinessCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReadinessCheckOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReadinessCheckOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReadinessCheckOutputResponse(readinessCheckArn: \(Swift.String(describing: readinessCheckArn)), readinessCheckName: \(Swift.String(describing: readinessCheckName)), resourceSet: \(Swift.String(describing: resourceSet)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateReadinessCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateReadinessCheckOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.readinessCheckArn = output.readinessCheckArn
            self.readinessCheckName = output.readinessCheckName
            self.resourceSet = output.resourceSet
            self.tags = output.tags
        } else {
            self.readinessCheckArn = nil
            self.readinessCheckName = nil
            self.resourceSet = nil
            self.tags = nil
        }
    }
}

public struct UpdateReadinessCheckOutputResponse: Swift.Equatable {
    /// Arn associated with ReadinessCheck
    public let readinessCheckArn: Swift.String?
    /// Name for a ReadinessCheck
    public let readinessCheckName: Swift.String?
    /// Name of the ResourceSet to be checked
    public let resourceSet: Swift.String?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        readinessCheckArn: Swift.String? = nil,
        readinessCheckName: Swift.String? = nil,
        resourceSet: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.readinessCheckArn = readinessCheckArn
        self.readinessCheckName = readinessCheckName
        self.resourceSet = resourceSet
        self.tags = tags
    }
}

struct UpdateReadinessCheckOutputResponseBody: Swift.Equatable {
    public let readinessCheckArn: Swift.String?
    public let readinessCheckName: Swift.String?
    public let resourceSet: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension UpdateReadinessCheckOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readinessCheckArn = "readinessCheckArn"
        case readinessCheckName = "readinessCheckName"
        case resourceSet = "resourceSet"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readinessCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckArn)
        readinessCheckArn = readinessCheckArnDecoded
        let readinessCheckNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readinessCheckName)
        readinessCheckName = readinessCheckNameDecoded
        let resourceSetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSet)
        resourceSet = resourceSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateRecoveryGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecoveryGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecoveryGroupOutputError>
}

extension UpdateRecoveryGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRecoveryGroupInput(cells: \(Swift.String(describing: cells)), recoveryGroupName: \(Swift.String(describing: recoveryGroupName)))"}
}

extension UpdateRecoveryGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for __listof__string0 in cells {
                try cellsContainer.encode(__listof__string0)
            }
        }
    }
}

public struct UpdateRecoveryGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecoveryGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecoveryGroupOutputError>
}

public struct UpdateRecoveryGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateRecoveryGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateRecoveryGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateRecoveryGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateRecoveryGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateRecoveryGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateRecoveryGroupOutputError>
}

/// Parameters to update for the RecoveryGroup
public struct UpdateRecoveryGroupInput: Swift.Equatable {
    /// A list of Cell arns, completely replaces previous list
    /// This member is required.
    public let cells: [Swift.String]?
    /// The RecoveryGroup to update
    /// This member is required.
    public let recoveryGroupName: Swift.String?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupName: Swift.String? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupName = recoveryGroupName
    }
}

struct UpdateRecoveryGroupInputBody: Swift.Equatable {
    public let cells: [Swift.String]?
}

extension UpdateRecoveryGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension UpdateRecoveryGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecoveryGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRecoveryGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecoveryGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRecoveryGroupOutputResponse(cells: \(Swift.String(describing: cells)), recoveryGroupArn: \(Swift.String(describing: recoveryGroupArn)), recoveryGroupName: \(Swift.String(describing: recoveryGroupName)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateRecoveryGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRecoveryGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cells = output.cells
            self.recoveryGroupArn = output.recoveryGroupArn
            self.recoveryGroupName = output.recoveryGroupName
            self.tags = output.tags
        } else {
            self.cells = nil
            self.recoveryGroupArn = nil
            self.recoveryGroupName = nil
            self.tags = nil
        }
    }
}

public struct UpdateRecoveryGroupOutputResponse: Swift.Equatable {
    /// A list of Cell arns
    public let cells: [Swift.String]?
    /// The arn for the RecoveryGroup
    public let recoveryGroupArn: Swift.String?
    /// The name of the RecoveryGroup
    public let recoveryGroupName: Swift.String?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        cells: [Swift.String]? = nil,
        recoveryGroupArn: Swift.String? = nil,
        recoveryGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.cells = cells
        self.recoveryGroupArn = recoveryGroupArn
        self.recoveryGroupName = recoveryGroupName
        self.tags = tags
    }
}

struct UpdateRecoveryGroupOutputResponseBody: Swift.Equatable {
    public let cells: [Swift.String]?
    public let recoveryGroupArn: Swift.String?
    public let recoveryGroupName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension UpdateRecoveryGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "cells"
        case recoveryGroupArn = "recoveryGroupArn"
        case recoveryGroupName = "recoveryGroupName"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cellsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cells)
        var cellsDecoded0:[Swift.String]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Swift.String]()
            for string0 in cellsContainer {
                if let string0 = string0 {
                    cellsDecoded0?.append(string0)
                }
            }
        }
        cells = cellsDecoded0
        let recoveryGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupArn)
        recoveryGroupArn = recoveryGroupArnDecoded
        let recoveryGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryGroupName)
        recoveryGroupName = recoveryGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateResourceSetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceSetOutputError>
}

extension UpdateResourceSetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceSetInput(resourceSetName: \(Swift.String(describing: resourceSetName)), resourceSetType: \(Swift.String(describing: resourceSetType)), resources: \(Swift.String(describing: resources)))"}
}

extension UpdateResourceSetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetType = "resourceSetType"
        case resources = "resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceSetType = resourceSetType {
            try encodeContainer.encode(resourceSetType, forKey: .resourceSetType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for __listofresource0 in resources {
                try resourcesContainer.encode(__listofresource0)
            }
        }
    }
}

public struct UpdateResourceSetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceSetOutputError>
}

public struct UpdateResourceSetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceSetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceSetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceSetOutputError>
}

/// configuration for the desired
public struct UpdateResourceSetInput: Swift.Equatable {
    /// The ResourceSet to update
    /// This member is required.
    public let resourceSetName: Swift.String?
    /// AWS Resource Type of the resources in the ResourceSet
    /// This member is required.
    public let resourceSetType: Swift.String?
    /// A list of Resource objects
    /// This member is required.
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?

    public init (
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil
    )
    {
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
    }
}

struct UpdateResourceSetInputBody: Swift.Equatable {
    public let resourceSetType: Swift.String?
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
}

extension UpdateResourceSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetType = "resourceSetType"
        case resources = "resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension UpdateResourceSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceSetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceSetOutputResponse(resourceSetArn: \(Swift.String(describing: resourceSetArn)), resourceSetName: \(Swift.String(describing: resourceSetName)), resourceSetType: \(Swift.String(describing: resourceSetType)), resources: \(Swift.String(describing: resources)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateResourceSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResourceSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceSetArn = output.resourceSetArn
            self.resourceSetName = output.resourceSetName
            self.resourceSetType = output.resourceSetType
            self.resources = output.resources
            self.tags = output.tags
        } else {
            self.resourceSetArn = nil
            self.resourceSetName = nil
            self.resourceSetType = nil
            self.resources = nil
            self.tags = nil
        }
    }
}

public struct UpdateResourceSetOutputResponse: Swift.Equatable {
    /// The arn for the ResourceSet
    public let resourceSetArn: Swift.String?
    /// The name of the ResourceSet
    public let resourceSetName: Swift.String?
    /// AWS Resource Type of the resources in the ResourceSet
    public let resourceSetType: Swift.String?
    /// A list of Resource objects
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    /// A collection of tags associated with a resource
    public let tags: [Swift.String:Swift.String]?

    public init (
        resourceSetArn: Swift.String? = nil,
        resourceSetName: Swift.String? = nil,
        resourceSetType: Swift.String? = nil,
        resources: [Route53RecoveryReadinessClientTypes.Resource]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceSetArn = resourceSetArn
        self.resourceSetName = resourceSetName
        self.resourceSetType = resourceSetType
        self.resources = resources
        self.tags = tags
    }
}

struct UpdateResourceSetOutputResponseBody: Swift.Equatable {
    public let resourceSetArn: Swift.String?
    public let resourceSetName: Swift.String?
    public let resourceSetType: Swift.String?
    public let resources: [Route53RecoveryReadinessClientTypes.Resource]?
    public let tags: [Swift.String:Swift.String]?
}

extension UpdateResourceSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceSetArn = "resourceSetArn"
        case resourceSetName = "resourceSetName"
        case resourceSetType = "resourceSetType"
        case resources = "resources"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetArn)
        resourceSetArn = resourceSetArnDecoded
        let resourceSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetName)
        resourceSetName = resourceSetNameDecoded
        let resourceSetTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceSetType)
        resourceSetType = resourceSetTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Route53RecoveryReadinessClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Route53RecoveryReadinessClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Route53RecoveryReadinessClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
