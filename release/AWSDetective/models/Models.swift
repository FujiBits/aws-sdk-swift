// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptInvitationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptInvitationOutputError>
}

extension AcceptInvitationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptInvitationInput(graphArn: \(Swift.String(describing: graphArn)))"}
}

extension AcceptInvitationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct AcceptInvitationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptInvitationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AcceptInvitationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/invitation"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptInvitationInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInput: Swift.Equatable {
    /// The ARN of the behavior graph that the member account is accepting the invitation
    ///          for.
    ///          The member account status in the behavior graph must be INVITED.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct AcceptInvitationInputBody: Swift.Equatable {
    public let graphArn: Swift.String?
}

extension AcceptInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension AcceptInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptInvitationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInvitationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptInvitationOutputResponse()"}
}

extension AcceptInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptInvitationOutputResponse: Swift.Equatable {

    public init() {}
}

struct AcceptInvitationOutputResponseBody: Swift.Equatable {
}

extension AcceptInvitationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DetectiveClientTypes.Account: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case emailAddress = "EmailAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension DetectiveClientTypes.Account: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Account(accountId: \(Swift.String(describing: accountId)), emailAddress: \(Swift.String(describing: emailAddress)))"}
}

extension DetectiveClientTypes {
    /// An AWS account that is the administrator account of or a member of a behavior
    ///          graph.
    public struct Account: Swift.Equatable {
        /// The account identifier of the AWS account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The AWS account root user email address for the AWS account.
        /// This member is required.
        public var emailAddress: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            emailAddress: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.emailAddress = emailAddress
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request attempted an invalid action.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateGraphInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGraphInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGraphInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGraphInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGraphOutputError>
}

extension CreateGraphInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGraphInput(tags: \(Swift.String(describing: tags)))"}
}

extension CreateGraphInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateGraphInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGraphInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGraphInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGraphInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGraphOutputError>
}

public struct CreateGraphInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGraphInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGraphInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGraphInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGraphOutputError>
}

public struct CreateGraphInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGraphInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateGraphInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/graph"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGraphInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGraphOutputError>
}

public struct CreateGraphInput: Swift.Equatable {
    /// The tags to assign to the new behavior graph. You can add up to 50 tags. For each tag,
    ///          you provide the tag key and the tag value. Each tag key can contain up to 128 characters.
    ///          Each tag value can contain up to 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct CreateGraphInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension CreateGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGraphOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGraphOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGraphOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGraphOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGraphOutputResponse(graphArn: \(Swift.String(describing: graphArn)))"}
}

extension CreateGraphOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGraphOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphArn = output.graphArn
        } else {
            self.graphArn = nil
        }
    }
}

public struct CreateGraphOutputResponse: Swift.Equatable {
    /// The ARN of the new behavior graph.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct CreateGraphOutputResponseBody: Swift.Equatable {
    public let graphArn: Swift.String?
}

extension CreateGraphOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

public struct CreateMembersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMembersOutputError>
}

extension CreateMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMembersInput(accounts: \(Swift.String(describing: accounts)), disableEmailNotification: \(Swift.String(describing: disableEmailNotification)), graphArn: \(Swift.String(describing: graphArn)), message: \(Swift.String(describing: message)))"}
}

extension CreateMembersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case disableEmailNotification = "DisableEmailNotification"
        case graphArn = "GraphArn"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for accountlist0 in accounts {
                try accountsContainer.encode(accountlist0)
            }
        }
        if disableEmailNotification != false {
            try encodeContainer.encode(disableEmailNotification, forKey: .disableEmailNotification)
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }
}

public struct CreateMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMembersOutputError>
}

public struct CreateMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMembersOutputError>
}

public struct CreateMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMembersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/graph/members"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMembersOutputError>
}

public struct CreateMembersInput: Swift.Equatable {
    /// The list of AWS accounts to invite to become member accounts in the behavior graph.
    ///          You can invite up to 50 accounts at a time. For each invited account, the account list
    ///          contains the account identifier and the AWS account root user email address.
    /// This member is required.
    public var accounts: [DetectiveClientTypes.Account]?
    /// if set to true, then the member accounts do not receive email
    ///          notifications. By default, this is set to false, and the member accounts
    ///          receive email notifications.
    public var disableEmailNotification: Swift.Bool
    /// The ARN of the behavior graph to invite the member accounts to contribute their data
    ///          to.
    /// This member is required.
    public var graphArn: Swift.String?
    /// Customized message text to include in the invitation email message to the invited member
    ///          accounts.
    public var message: Swift.String?

    public init (
        accounts: [DetectiveClientTypes.Account]? = nil,
        disableEmailNotification: Swift.Bool = false,
        graphArn: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.accounts = accounts
        self.disableEmailNotification = disableEmailNotification
        self.graphArn = graphArn
        self.message = message
    }
}

struct CreateMembersInputBody: Swift.Equatable {
    public let graphArn: Swift.String?
    public let message: Swift.String?
    public let disableEmailNotification: Swift.Bool
    public let accounts: [DetectiveClientTypes.Account]?
}

extension CreateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case disableEmailNotification = "DisableEmailNotification"
        case graphArn = "GraphArn"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let disableEmailNotificationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableEmailNotification)
        disableEmailNotification = disableEmailNotificationDecoded
        let accountsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.Account?].self, forKey: .accounts)
        var accountsDecoded0:[DetectiveClientTypes.Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [DetectiveClientTypes.Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
    }
}

extension CreateMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMembersOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMembersOutputResponse(members: \(Swift.String(describing: members)), unprocessedAccounts: \(Swift.String(describing: unprocessedAccounts)))"}
}

extension CreateMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.members = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateMembersOutputResponse: Swift.Equatable {
    /// The set of member account invitation requests that Detective was able to process. This
    ///          includes accounts that are being verified, that failed verification, and that passed
    ///          verification and are being sent an invitation.
    public var members: [DetectiveClientTypes.MemberDetail]?
    /// The list of accounts for which Detective was unable to process the invitation request. For
    ///          each account, the list provides the reason why the request could not be processed. The list
    ///          includes accounts that are already member accounts in the behavior graph.
    public var unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?

    public init (
        members: [DetectiveClientTypes.MemberDetail]? = nil,
        unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateMembersOutputResponseBody: Swift.Equatable {
    public let members: [DetectiveClientTypes.MemberDetail]?
    public let unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?
}

extension CreateMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "Members"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MemberDetail?].self, forKey: .members)
        var membersDecoded0:[DetectiveClientTypes.MemberDetail]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [DetectiveClientTypes.MemberDetail]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[DetectiveClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [DetectiveClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct DeleteGraphInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGraphInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGraphInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGraphInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGraphOutputError>
}

extension DeleteGraphInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGraphInput(graphArn: \(Swift.String(describing: graphArn)))"}
}

extension DeleteGraphInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct DeleteGraphInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGraphInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGraphInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGraphInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGraphOutputError>
}

public struct DeleteGraphInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGraphInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGraphInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGraphInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGraphOutputError>
}

public struct DeleteGraphInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGraphInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteGraphInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/graph/removal"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGraphInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGraphOutputError>
}

public struct DeleteGraphInput: Swift.Equatable {
    /// The ARN of the behavior graph to disable.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct DeleteGraphInputBody: Swift.Equatable {
    public let graphArn: Swift.String?
}

extension DeleteGraphInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension DeleteGraphOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGraphOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGraphOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGraphOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGraphOutputResponse()"}
}

extension DeleteGraphOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGraphOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteGraphOutputResponseBody: Swift.Equatable {
}

extension DeleteGraphOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteMembersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMembersOutputError>
}

extension DeleteMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMembersInput(accountIds: \(Swift.String(describing: accountIds)), graphArn: \(Swift.String(describing: graphArn)))"}
}

extension DeleteMembersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct DeleteMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMembersOutputError>
}

public struct DeleteMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMembersOutputError>
}

public struct DeleteMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMembersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/graph/members/removal"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMembersOutputError>
}

public struct DeleteMembersInput: Swift.Equatable {
    /// The list of AWS account identifiers for the member accounts to delete from the
    ///          behavior graph. You can delete up to 50 member accounts at a time.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The ARN of the behavior graph to delete members from.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        graphArn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.graphArn = graphArn
    }
}

struct DeleteMembersInputBody: Swift.Equatable {
    public let graphArn: Swift.String?
    public let accountIds: [Swift.String]?
}

extension DeleteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMembersOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMembersOutputResponse(accountIds: \(Swift.String(describing: accountIds)), unprocessedAccounts: \(Swift.String(describing: unprocessedAccounts)))"}
}

extension DeleteMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.accountIds = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteMembersOutputResponse: Swift.Equatable {
    /// The list of AWS account identifiers for the member accounts that Detective successfully
    ///          deleted from the behavior graph.
    public var accountIds: [Swift.String]?
    /// The list of member accounts that Detective was not able to delete from the behavior graph.
    ///          For each member account, provides the reason that the deletion could not be
    ///          processed.
    public var unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?

    public init (
        accountIds: [Swift.String]? = nil,
        unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.accountIds = accountIds
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteMembersOutputResponseBody: Swift.Equatable {
    public let accountIds: [Swift.String]?
    public let unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?
}

extension DeleteMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[DetectiveClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [DetectiveClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct DisassociateMembershipInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMembershipInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMembershipOutputError>
}

extension DisassociateMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateMembershipInput(graphArn: \(Swift.String(describing: graphArn)))"}
}

extension DisassociateMembershipInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct DisassociateMembershipInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMembershipInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMembershipOutputError>
}

public struct DisassociateMembershipInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMembershipInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateMembershipInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateMembershipInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMembershipOutputError>
}

public struct DisassociateMembershipInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMembershipInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateMembershipInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMembershipOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/membership/removal"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateMembershipInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMembershipOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMembershipOutputError>
}

public struct DisassociateMembershipInput: Swift.Equatable {
    /// The ARN of the behavior graph to remove the member account from.
    ///          The member account's member status in the behavior graph must be
    ///          ENABLED.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct DisassociateMembershipInputBody: Swift.Equatable {
    public let graphArn: Swift.String?
}

extension DisassociateMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension DisassociateMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMembershipOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMembershipOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateMembershipOutputResponse()"}
}

extension DisassociateMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMembershipOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateMembershipOutputResponseBody: Swift.Equatable {
}

extension DisassociateMembershipOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct GetMembersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMembersOutputError>
}

extension GetMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMembersInput(accountIds: \(Swift.String(describing: accountIds)), graphArn: \(Swift.String(describing: graphArn)))"}
}

extension GetMembersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidlist0 in accountIds {
                try accountIdsContainer.encode(accountidlist0)
            }
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct GetMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMembersOutputError>
}

public struct GetMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMembersOutputError>
}

public struct GetMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMembersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/graph/members/get"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMembersOutputError>
}

public struct GetMembersInput: Swift.Equatable {
    /// The list of AWS account identifiers for the member account for which to return member
    ///          details. You can request details for up to 50 member accounts at a time.
    ///          You cannot use GetMembers to retrieve information about member accounts
    ///          that were removed from the behavior graph.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The ARN of the behavior graph for which to request the member details.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        graphArn: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.graphArn = graphArn
    }
}

struct GetMembersInputBody: Swift.Equatable {
    public let graphArn: Swift.String?
    public let accountIds: [Swift.String]?
}

extension GetMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMembersOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMembersOutputResponse(memberDetails: \(Swift.String(describing: memberDetails)), unprocessedAccounts: \(Swift.String(describing: unprocessedAccounts)))"}
}

extension GetMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberDetails = output.memberDetails
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.memberDetails = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMembersOutputResponse: Swift.Equatable {
    /// The member account details that Detective is returning in response to the request.
    public var memberDetails: [DetectiveClientTypes.MemberDetail]?
    /// The requested member accounts for which Detective was unable to return member
    ///          details.
    ///          For each account, provides the reason why the request could not be processed.
    public var unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?

    public init (
        memberDetails: [DetectiveClientTypes.MemberDetail]? = nil,
        unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.memberDetails = memberDetails
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMembersOutputResponseBody: Swift.Equatable {
    public let memberDetails: [DetectiveClientTypes.MemberDetail]?
    public let unprocessedAccounts: [DetectiveClientTypes.UnprocessedAccount]?
}

extension GetMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberDetails = "MemberDetails"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDetailsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MemberDetail?].self, forKey: .memberDetails)
        var memberDetailsDecoded0:[DetectiveClientTypes.MemberDetail]? = nil
        if let memberDetailsContainer = memberDetailsContainer {
            memberDetailsDecoded0 = [DetectiveClientTypes.MemberDetail]()
            for structure0 in memberDetailsContainer {
                if let structure0 = structure0 {
                    memberDetailsDecoded0?.append(structure0)
                }
            }
        }
        memberDetails = memberDetailsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[DetectiveClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [DetectiveClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DetectiveClientTypes.Graph: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension DetectiveClientTypes.Graph: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Graph(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)))"}
}

extension DetectiveClientTypes {
    /// A behavior graph in Detective.
    public struct Graph: Swift.Equatable {
        /// The ARN of the behavior graph.
        public var arn: Swift.String?
        /// The date and time that the behavior graph was created. The value is in milliseconds
        ///          since the epoch.
        public var createdTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
        }
    }

}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was valid but failed because of a problem with the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListGraphsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGraphsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGraphsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGraphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGraphsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGraphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGraphsOutputError>
}

extension ListGraphsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGraphsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGraphsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListGraphsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGraphsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGraphsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGraphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGraphsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGraphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGraphsOutputError>
}

public struct ListGraphsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGraphsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGraphsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGraphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGraphsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGraphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGraphsOutputError>
}

public struct ListGraphsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGraphsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListGraphsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGraphsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/graphs/list"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGraphsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGraphsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGraphsOutputError>
}

public struct ListGraphsInput: Swift.Equatable {
    /// The maximum number of graphs to return at a time. The total must be less than the
    ///          overall limit on the number of results to return, which is currently 200.
    public var maxResults: Swift.Int?
    /// For requests to get the next page of results, the pagination token that was returned
    ///          with the previous set of results. The initial request does not include a pagination
    ///          token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListGraphsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGraphsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGraphsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGraphsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGraphsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGraphsOutputResponse(graphList: \(Swift.String(describing: graphList)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGraphsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGraphsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.graphList = output.graphList
            self.nextToken = output.nextToken
        } else {
            self.graphList = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphsOutputResponse: Swift.Equatable {
    /// A list of behavior graphs that the account is an administrator account for.
    public var graphList: [DetectiveClientTypes.Graph]?
    /// If there are more behavior graphs remaining in the results, then this is the pagination
    ///          token to use to request the next page of behavior graphs.
    public var nextToken: Swift.String?

    public init (
        graphList: [DetectiveClientTypes.Graph]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphList = graphList
        self.nextToken = nextToken
    }
}

struct ListGraphsOutputResponseBody: Swift.Equatable {
    public let graphList: [DetectiveClientTypes.Graph]?
    public let nextToken: Swift.String?
}

extension ListGraphsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphList = "GraphList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphListContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.Graph?].self, forKey: .graphList)
        var graphListDecoded0:[DetectiveClientTypes.Graph]? = nil
        if let graphListContainer = graphListContainer {
            graphListDecoded0 = [DetectiveClientTypes.Graph]()
            for structure0 in graphListContainer {
                if let structure0 = structure0 {
                    graphListDecoded0?.append(structure0)
                }
            }
        }
        graphList = graphListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInvitationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvitationsOutputError>
}

extension ListInvitationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInvitationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInvitationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInvitationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInvitationsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListInvitationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/invitations/list"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInvitationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInput: Swift.Equatable {
    /// The maximum number of behavior graph invitations to return in the response. The total
    ///          must be less than the overall limit on the number of results to return, which is currently
    ///          200.
    public var maxResults: Swift.Int?
    /// For requests to retrieve the next page of results, the pagination token that was
    ///          returned with the previous page of results. The initial request does not include a
    ///          pagination token.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvitationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvitationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInvitationsOutputResponse(invitations: \(Swift.String(describing: invitations)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutputResponse: Swift.Equatable {
    /// The list of behavior graphs for which the member account has open or accepted
    ///          invitations.
    public var invitations: [DetectiveClientTypes.MemberDetail]?
    /// If there are more behavior graphs remaining in the results, then this is the pagination
    ///          token to use to request the next page of behavior graphs.
    public var nextToken: Swift.String?

    public init (
        invitations: [DetectiveClientTypes.MemberDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputResponseBody: Swift.Equatable {
    public let invitations: [DetectiveClientTypes.MemberDetail]?
    public let nextToken: Swift.String?
}

extension ListInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitations = "Invitations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MemberDetail?].self, forKey: .invitations)
        var invitationsDecoded0:[DetectiveClientTypes.MemberDetail]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [DetectiveClientTypes.MemberDetail]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMembersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMembersOutputError>
}

extension ListMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMembersInput(graphArn: \(Swift.String(describing: graphArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMembersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMembersOutputError>
}

public struct ListMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMembersOutputError>
}

public struct ListMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMembersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/graph/members/list"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMembersOutputError>
}

public struct ListMembersInput: Swift.Equatable {
    /// The ARN of the behavior graph for which to retrieve the list of member accounts.
    /// This member is required.
    public var graphArn: Swift.String?
    /// The maximum number of member accounts to include in the response. The total must be less
    ///          than the overall limit on the number of results to return, which is currently 200.
    public var maxResults: Swift.Int?
    /// For requests to retrieve the next page of member account results, the pagination token
    ///          that was returned with the previous page of results. The initial request does not include a
    ///          pagination token.
    public var nextToken: Swift.String?

    public init (
        graphArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMembersInputBody: Swift.Equatable {
    public let graphArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMembersOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMembersOutputResponse(memberDetails: \(Swift.String(describing: memberDetails)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberDetails = output.memberDetails
            self.nextToken = output.nextToken
        } else {
            self.memberDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Swift.Equatable {
    /// The list of member accounts in the behavior graph.
    ///          The results include member accounts that did not pass verification and member accounts
    ///          that have not yet accepted the invitation to the behavior graph. The results do not include
    ///          member accounts that were removed from the behavior graph.
    public var memberDetails: [DetectiveClientTypes.MemberDetail]?
    /// If there are more member accounts remaining in the results, then this is the pagination
    ///          token to use to request the next page of member accounts.
    public var nextToken: Swift.String?

    public init (
        memberDetails: [DetectiveClientTypes.MemberDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberDetails = memberDetails
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Swift.Equatable {
    public let memberDetails: [DetectiveClientTypes.MemberDetail]?
    public let nextToken: Swift.String?
}

extension ListMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberDetails = "MemberDetails"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDetailsContainer = try containerValues.decodeIfPresent([DetectiveClientTypes.MemberDetail?].self, forKey: .memberDetails)
        var memberDetailsDecoded0:[DetectiveClientTypes.MemberDetail]? = nil
        if let memberDetailsContainer = memberDetailsContainer {
            memberDetailsDecoded0 = [DetectiveClientTypes.MemberDetail]()
            for structure0 in memberDetailsContainer {
                if let structure0 = structure0 {
                    memberDetailsDecoded0?.append(structure0)
                }
            }
        }
        memberDetails = memberDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the behavior graph for which to retrieve the tag values.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tag values that are assigned to the behavior graph. The request returns up to 50 tag
    ///          values.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DetectiveClientTypes.MemberDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case administratorId = "AdministratorId"
        case disabledReason = "DisabledReason"
        case emailAddress = "EmailAddress"
        case graphArn = "GraphArn"
        case invitedTime = "InvitedTime"
        case masterId = "MasterId"
        case percentOfGraphUtilization = "PercentOfGraphUtilization"
        case percentOfGraphUtilizationUpdatedTime = "PercentOfGraphUtilizationUpdatedTime"
        case status = "Status"
        case updatedTime = "UpdatedTime"
        case volumeUsageInBytes = "VolumeUsageInBytes"
        case volumeUsageUpdatedTime = "VolumeUsageUpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let administratorId = administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let disabledReason = disabledReason {
            try encodeContainer.encode(disabledReason.rawValue, forKey: .disabledReason)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
        if let invitedTime = invitedTime {
            try encodeContainer.encode(invitedTime.timeIntervalSince1970, forKey: .invitedTime)
        }
        if let masterId = masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
        if let percentOfGraphUtilization = percentOfGraphUtilization {
            try encodeContainer.encode(percentOfGraphUtilization, forKey: .percentOfGraphUtilization)
        }
        if let percentOfGraphUtilizationUpdatedTime = percentOfGraphUtilizationUpdatedTime {
            try encodeContainer.encode(percentOfGraphUtilizationUpdatedTime.timeIntervalSince1970, forKey: .percentOfGraphUtilizationUpdatedTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime.timeIntervalSince1970, forKey: .updatedTime)
        }
        if let volumeUsageInBytes = volumeUsageInBytes {
            try encodeContainer.encode(volumeUsageInBytes, forKey: .volumeUsageInBytes)
        }
        if let volumeUsageUpdatedTime = volumeUsageUpdatedTime {
            try encodeContainer.encode(volumeUsageUpdatedTime.timeIntervalSince1970, forKey: .volumeUsageUpdatedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let administratorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetectiveClientTypes.MemberStatus.self, forKey: .status)
        status = statusDecoded
        let disabledReasonDecoded = try containerValues.decodeIfPresent(DetectiveClientTypes.MemberDisabledReason.self, forKey: .disabledReason)
        disabledReason = disabledReasonDecoded
        let invitedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .invitedTime)
        invitedTime = invitedTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let volumeUsageInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeUsageInBytes)
        volumeUsageInBytes = volumeUsageInBytesDecoded
        let volumeUsageUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .volumeUsageUpdatedTime)
        volumeUsageUpdatedTime = volumeUsageUpdatedTimeDecoded
        let percentOfGraphUtilizationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentOfGraphUtilization)
        percentOfGraphUtilization = percentOfGraphUtilizationDecoded
        let percentOfGraphUtilizationUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .percentOfGraphUtilizationUpdatedTime)
        percentOfGraphUtilizationUpdatedTime = percentOfGraphUtilizationUpdatedTimeDecoded
    }
}

extension DetectiveClientTypes.MemberDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MemberDetail(accountId: \(Swift.String(describing: accountId)), administratorId: \(Swift.String(describing: administratorId)), disabledReason: \(Swift.String(describing: disabledReason)), emailAddress: \(Swift.String(describing: emailAddress)), graphArn: \(Swift.String(describing: graphArn)), invitedTime: \(Swift.String(describing: invitedTime)), masterId: \(Swift.String(describing: masterId)), percentOfGraphUtilization: \(Swift.String(describing: percentOfGraphUtilization)), percentOfGraphUtilizationUpdatedTime: \(Swift.String(describing: percentOfGraphUtilizationUpdatedTime)), status: \(Swift.String(describing: status)), updatedTime: \(Swift.String(describing: updatedTime)), volumeUsageInBytes: \(Swift.String(describing: volumeUsageInBytes)), volumeUsageUpdatedTime: \(Swift.String(describing: volumeUsageUpdatedTime)))"}
}

extension DetectiveClientTypes {
    /// Details about a member account that was invited to contribute to a behavior
    ///          graph.
    public struct MemberDetail: Swift.Equatable {
        /// The AWS account identifier for the member account.
        public var accountId: Swift.String?
        /// The AWS account identifier of the administrator account for the behavior graph.
        public var administratorId: Swift.String?
        /// For member accounts with a status of ACCEPTED_BUT_DISABLED, the reason that
        ///          the member account is not enabled.
        ///          The reason can have one of the following values:
        ///
        ///
        ///
        ///                   VOLUME_TOO_HIGH - Indicates that adding the member account would
        ///                cause the data volume for the behavior graph to be too high.
        ///
        ///
        ///
        ///                   VOLUME_UNKNOWN - Indicates that Detective is unable to verify the data
        ///                volume for the member account. This is usually because the member account is not
        ///                enrolled in Amazon GuardDuty.
        ///
        ///
        public var disabledReason: DetectiveClientTypes.MemberDisabledReason?
        /// The AWS account root user email address for the member account.
        public var emailAddress: Swift.String?
        /// The ARN of the behavior graph that the member account was invited to.
        public var graphArn: Swift.String?
        /// The date and time that Detective sent the invitation to the member account. The value is in
        ///          milliseconds since the epoch.
        public var invitedTime: ClientRuntime.Date?
        /// The AWS account identifier of the administrator account for the behavior graph.
        @available(*, deprecated, message: "This property is deprecated. Use AdministratorId instead.")
        public var masterId: Swift.String?
        /// The member account data volume as a percentage of the maximum allowed data volume. 0
        ///          indicates 0 percent, and 100 indicates 100 percent.
        ///          Note that this is not the percentage of the behavior graph data volume.
        ///          For example, the data volume for the behavior graph is 80 GB per day. The maximum data
        ///          volume is 160 GB per day. If the data volume for the member account is 40 GB per day, then
        ///             PercentOfGraphUtilization is 25. It represents 25% of the maximum allowed
        ///          data volume.
        @available(*, deprecated, message: "This property is deprecated. Use VolumeUsageInBytes instead.")
        public var percentOfGraphUtilization: Swift.Double?
        /// The date and time when the graph utilization percentage was last updated.
        @available(*, deprecated, message: "This property is deprecated. Use VolumeUsageUpdatedTime instead.")
        public var percentOfGraphUtilizationUpdatedTime: ClientRuntime.Date?
        /// The current membership status of the member account. The status can have one of the
        ///          following values:
        ///
        ///
        ///
        ///                   INVITED - Indicates that the member was sent an invitation but has
        ///                not yet responded.
        ///
        ///
        ///
        ///                   VERIFICATION_IN_PROGRESS - Indicates that Detective is verifying that the
        ///                account identifier and email address provided for the member account match. If they
        ///                do match, then Detective sends the invitation. If the email address and account
        ///                identifier don't match, then the member cannot be added to the behavior graph.
        ///
        ///
        ///
        ///                   VERIFICATION_FAILED - Indicates that the account and email address
        ///                provided for the member account do not match, and Detective did not send an invitation to
        ///                the account.
        ///
        ///
        ///
        ///                   ENABLED - Indicates that the member account accepted the invitation
        ///                to contribute to the behavior graph.
        ///
        ///
        ///
        ///                   ACCEPTED_BUT_DISABLED - Indicates that the member account accepted
        ///                the invitation but is prevented from contributing data to the behavior graph.
        ///                   DisabledReason provides the reason why the member account is not
        ///                enabled.
        ///
        ///
        ///          Member accounts that declined an invitation or that were removed from the behavior graph
        ///          are not included.
        public var status: DetectiveClientTypes.MemberStatus?
        /// The date and time that the member account was last updated. The value is in milliseconds
        ///          since the epoch.
        public var updatedTime: ClientRuntime.Date?
        /// The data volume in bytes per day for the member account.
        public var volumeUsageInBytes: Swift.Int?
        /// The data and time when the member account data volume was last updated.
        public var volumeUsageUpdatedTime: ClientRuntime.Date?

        public init (
            accountId: Swift.String? = nil,
            administratorId: Swift.String? = nil,
            disabledReason: DetectiveClientTypes.MemberDisabledReason? = nil,
            emailAddress: Swift.String? = nil,
            graphArn: Swift.String? = nil,
            invitedTime: ClientRuntime.Date? = nil,
            masterId: Swift.String? = nil,
            percentOfGraphUtilization: Swift.Double? = nil,
            percentOfGraphUtilizationUpdatedTime: ClientRuntime.Date? = nil,
            status: DetectiveClientTypes.MemberStatus? = nil,
            updatedTime: ClientRuntime.Date? = nil,
            volumeUsageInBytes: Swift.Int? = nil,
            volumeUsageUpdatedTime: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.administratorId = administratorId
            self.disabledReason = disabledReason
            self.emailAddress = emailAddress
            self.graphArn = graphArn
            self.invitedTime = invitedTime
            self.masterId = masterId
            self.percentOfGraphUtilization = percentOfGraphUtilization
            self.percentOfGraphUtilizationUpdatedTime = percentOfGraphUtilizationUpdatedTime
            self.status = status
            self.updatedTime = updatedTime
            self.volumeUsageInBytes = volumeUsageInBytes
            self.volumeUsageUpdatedTime = volumeUsageUpdatedTime
        }
    }

}

extension DetectiveClientTypes {
    public enum MemberDisabledReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case volumeTooHigh
        case volumeUnknown
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberDisabledReason] {
            return [
                .volumeTooHigh,
                .volumeUnknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .volumeTooHigh: return "VOLUME_TOO_HIGH"
            case .volumeUnknown: return "VOLUME_UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberDisabledReason(rawValue: rawValue) ?? MemberDisabledReason.sdkUnknown(rawValue)
        }
    }
}

extension DetectiveClientTypes {
    public enum MemberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acceptedButDisabled
        case enabled
        case invited
        case verificationFailed
        case verificationInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberStatus] {
            return [
                .acceptedButDisabled,
                .enabled,
                .invited,
                .verificationFailed,
                .verificationInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acceptedButDisabled: return "ACCEPTED_BUT_DISABLED"
            case .enabled: return "ENABLED"
            case .invited: return "INVITED"
            case .verificationFailed: return "VERIFICATION_FAILED"
            case .verificationInProgress: return "VERIFICATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberStatus(rawValue: rawValue) ?? MemberStatus.sdkUnknown(rawValue)
        }
    }
}

public struct RejectInvitationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectInvitationOutputError>
}

extension RejectInvitationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectInvitationInput(graphArn: \(Swift.String(describing: graphArn)))"}
}

extension RejectInvitationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct RejectInvitationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectInvitationOutputError>
}

public struct RejectInvitationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectInvitationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectInvitationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectInvitationOutputError>
}

public struct RejectInvitationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectInvitationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RejectInvitationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/invitation/removal"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectInvitationInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectInvitationOutputError>
}

public struct RejectInvitationInput: Swift.Equatable {
    /// The ARN of the behavior graph to reject the invitation to.
    ///          The member account's current member status in the behavior graph must be
    ///             INVITED.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        graphArn: Swift.String? = nil
    )
    {
        self.graphArn = graphArn
    }
}

struct RejectInvitationInputBody: Swift.Equatable {
    public let graphArn: Swift.String?
}

extension RejectInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
    }
}

extension RejectInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectInvitationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectInvitationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectInvitationOutputResponse()"}
}

extension RejectInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RejectInvitationOutputResponse: Swift.Equatable {

    public init() {}
}

struct RejectInvitationOutputResponseBody: Swift.Equatable {
}

extension RejectInvitationOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request refers to a nonexistent resource.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This request cannot be completed for one of the following reasons.
///
///
///                The request would cause the number of member accounts in the behavior graph to
///                exceed the maximum allowed. A behavior graph cannot have more than 1000 member
///                accounts.
///
///
///                The request would cause the data rate for the behavior graph to exceed the maximum
///                allowed.
///
///
///                Detective is unable to verify the data rate for the member account. This is usually
///                because the member account is not enrolled in Amazon GuardDuty.
///
///
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartMonitoringMemberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMonitoringMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMonitoringMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMonitoringMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMonitoringMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMonitoringMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMonitoringMemberOutputError>
}

extension StartMonitoringMemberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMonitoringMemberInput(accountId: \(Swift.String(describing: accountId)), graphArn: \(Swift.String(describing: graphArn)))"}
}

extension StartMonitoringMemberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case graphArn = "GraphArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let graphArn = graphArn {
            try encodeContainer.encode(graphArn, forKey: .graphArn)
        }
    }
}

public struct StartMonitoringMemberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMonitoringMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMonitoringMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMonitoringMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMonitoringMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMonitoringMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMonitoringMemberOutputError>
}

public struct StartMonitoringMemberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMonitoringMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMonitoringMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMonitoringMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMonitoringMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMonitoringMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMonitoringMemberOutputError>
}

public struct StartMonitoringMemberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMonitoringMemberInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartMonitoringMemberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMonitoringMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/graph/member/monitoringstate"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartMonitoringMemberInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartMonitoringMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMonitoringMemberOutputError>
}

public struct StartMonitoringMemberInput: Swift.Equatable {
    /// The account ID of the member account to try to enable.
    ///          The account must be an invited member account with a status of
    ///             ACCEPTED_BUT_DISABLED.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the behavior graph.
    /// This member is required.
    public var graphArn: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        graphArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.graphArn = graphArn
    }
}

struct StartMonitoringMemberInputBody: Swift.Equatable {
    public let graphArn: Swift.String?
    public let accountId: Swift.String?
}

extension StartMonitoringMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case graphArn = "GraphArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .graphArn)
        graphArn = graphArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension StartMonitoringMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMonitoringMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMonitoringMemberOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMonitoringMemberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMonitoringMemberOutputResponse()"}
}

extension StartMonitoringMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartMonitoringMemberOutputResponse: Swift.Equatable {

    public init() {}
}

struct StartMonitoringMemberOutputResponseBody: Swift.Equatable {
}

extension StartMonitoringMemberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the behavior graph to assign the tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to assign to the behavior graph. You can add up to 50 tags. For each tag, you
    ///          provide the tag key and the tag value. Each tag key can contain up to 128 characters. Each
    ///          tag value can contain up to 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DetectiveClientTypes.UnprocessedAccount: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DetectiveClientTypes.UnprocessedAccount: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnprocessedAccount(accountId: \(Swift.String(describing: accountId)), reason: \(Swift.String(describing: reason)))"}
}

extension DetectiveClientTypes {
    /// A member account that was included in a request but for which the request could not be
    ///          processed.
    public struct UnprocessedAccount: Swift.Equatable {
        /// The AWS account identifier of the member account that was not processed.
        public var accountId: Swift.String?
        /// The reason that the member account request could not be processed.
        public var reason: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.reason = reason
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the behavior graph to remove the tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove from the behavior graph. You can remove up to 50 tags
    ///          at a time.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request parameters are invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
