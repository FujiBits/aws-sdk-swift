// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException()"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

public struct CreateEnvironmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

extension CreateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentInput(dataBundles: \(Swift.String(describing: dataBundles)), description: \(Swift.String(describing: description)), federationMode: \(Swift.String(describing: federationMode)), federationParameters: \(Swift.String(describing: federationParameters)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), superuserParameters: \(Swift.String(describing: superuserParameters)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataBundles
        case description
        case federationMode
        case federationParameters
        case kmsKeyId
        case name
        case superuserParameters
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataBundles = dataBundles {
            var dataBundlesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataBundles)
            for databundlearns0 in dataBundles {
                try dataBundlesContainer.encode(databundlearns0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let federationMode = federationMode {
            try encodeContainer.encode(federationMode.rawValue, forKey: .federationMode)
        }
        if let federationParameters = federationParameters {
            try encodeContainer.encode(federationParameters, forKey: .federationParameters)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let superuserParameters = superuserParameters {
            try encodeContainer.encode(superuserParameters, forKey: .superuserParameters)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/environment"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// The list of Amazon Resource Names (ARN) of the data bundles to install. Currently supported data bundle ARNs:
    ///
    /// * arn:aws:finspace:${Region}::data-bundle/capital-markets-sample - Contains sample Capital Markets datasets, categories and controlled vocabularies.
    ///
    /// * arn:aws:finspace:${Region}::data-bundle/taq (default) - Contains trades and quotes data in addition to sample Capital Markets data.
    public var dataBundles: [Swift.String]?
    /// The description of the FinSpace environment to be created.
    public var description: Swift.String?
    /// Authentication mode for the environment.
    ///
    /// * FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.
    ///
    /// * LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
    public var federationMode: FinspaceClientTypes.FederationMode?
    /// Configuration information when authentication mode is FEDERATED.
    public var federationParameters: FinspaceClientTypes.FederationParameters?
    /// The KMS key id to encrypt your data in the FinSpace environment.
    public var kmsKeyId: Swift.String?
    /// The name of the FinSpace environment to be created.
    /// This member is required.
    public var name: Swift.String?
    /// Configuration information for the superuser.
    public var superuserParameters: FinspaceClientTypes.SuperuserParameters?
    /// Add tags to your FinSpace environment.
    public var tags: [Swift.String:Swift.String]?

    public init (
        dataBundles: [Swift.String]? = nil,
        description: Swift.String? = nil,
        federationMode: FinspaceClientTypes.FederationMode? = nil,
        federationParameters: FinspaceClientTypes.FederationParameters? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        superuserParameters: FinspaceClientTypes.SuperuserParameters? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataBundles = dataBundles
        self.description = description
        self.federationMode = federationMode
        self.federationParameters = federationParameters
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.superuserParameters = superuserParameters
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let kmsKeyId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let federationMode: FinspaceClientTypes.FederationMode?
    public let federationParameters: FinspaceClientTypes.FederationParameters?
    public let superuserParameters: FinspaceClientTypes.SuperuserParameters?
    public let dataBundles: [Swift.String]?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataBundles
        case description
        case federationMode
        case federationParameters
        case kmsKeyId
        case name
        case superuserParameters
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let federationModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationMode.self, forKey: .federationMode)
        federationMode = federationModeDecoded
        let federationParametersDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationParameters.self, forKey: .federationParameters)
        federationParameters = federationParametersDecoded
        let superuserParametersDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.SuperuserParameters.self, forKey: .superuserParameters)
        superuserParameters = superuserParametersDecoded
        let dataBundlesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataBundles)
        var dataBundlesDecoded0:[Swift.String]? = nil
        if let dataBundlesContainer = dataBundlesContainer {
            dataBundlesDecoded0 = [Swift.String]()
            for string0 in dataBundlesContainer {
                if let string0 = string0 {
                    dataBundlesDecoded0?.append(string0)
                }
            }
        }
        dataBundles = dataBundlesDecoded0
    }
}

extension CreateEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentOutputResponse(environmentArn: \(Swift.String(describing: environmentArn)), environmentId: \(Swift.String(describing: environmentId)), environmentUrl: \(Swift.String(describing: environmentUrl)))"}
}

extension CreateEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environmentArn = output.environmentArn
            self.environmentId = output.environmentId
            self.environmentUrl = output.environmentUrl
        } else {
            self.environmentArn = nil
            self.environmentId = nil
            self.environmentUrl = nil
        }
    }
}

public struct CreateEnvironmentOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the FinSpace environment that you created.
    public var environmentArn: Swift.String?
    /// The unique identifier for FinSpace environment that you created.
    public var environmentId: Swift.String?
    /// The sign-in url for the web application of the FinSpace environment you created.
    public var environmentUrl: Swift.String?

    public init (
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        environmentUrl: Swift.String? = nil
    )
    {
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.environmentUrl = environmentUrl
    }
}

struct CreateEnvironmentOutputResponseBody: Swift.Equatable {
    public let environmentId: Swift.String?
    public let environmentArn: Swift.String?
    public let environmentUrl: Swift.String?
}

extension CreateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentArn
        case environmentId
        case environmentUrl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let environmentUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentUrl)
        environmentUrl = environmentUrlDecoded
    }
}

extension DeleteEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentInput(environmentId: \(Swift.String(describing: environmentId)))"}
}

extension DeleteEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/environment/\(environmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The identifier for the FinSpace environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteEnvironmentOutputResponse()"}
}

extension DeleteEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEnvironmentOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteEnvironmentOutputResponseBody: Swift.Equatable {
}

extension DeleteEnvironmentOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension FinspaceClientTypes.Environment: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case dedicatedServiceAccountId
        case description
        case environmentArn
        case environmentId
        case environmentUrl
        case federationMode
        case federationParameters
        case kmsKeyId
        case name
        case sageMakerStudioDomainUrl
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let dedicatedServiceAccountId = dedicatedServiceAccountId {
            try encodeContainer.encode(dedicatedServiceAccountId, forKey: .dedicatedServiceAccountId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentArn = environmentArn {
            try encodeContainer.encode(environmentArn, forKey: .environmentArn)
        }
        if let environmentId = environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let environmentUrl = environmentUrl {
            try encodeContainer.encode(environmentUrl, forKey: .environmentUrl)
        }
        if let federationMode = federationMode {
            try encodeContainer.encode(federationMode.rawValue, forKey: .federationMode)
        }
        if let federationParameters = federationParameters {
            try encodeContainer.encode(federationParameters, forKey: .federationParameters)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sageMakerStudioDomainUrl = sageMakerStudioDomainUrl {
            try encodeContainer.encode(sageMakerStudioDomainUrl, forKey: .sageMakerStudioDomainUrl)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let environmentUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentUrl)
        environmentUrl = environmentUrlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let sageMakerStudioDomainUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sageMakerStudioDomainUrl)
        sageMakerStudioDomainUrl = sageMakerStudioDomainUrlDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dedicatedServiceAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedServiceAccountId)
        dedicatedServiceAccountId = dedicatedServiceAccountIdDecoded
        let federationModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationMode.self, forKey: .federationMode)
        federationMode = federationModeDecoded
        let federationParametersDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationParameters.self, forKey: .federationParameters)
        federationParameters = federationParametersDecoded
    }
}

extension FinspaceClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(awsAccountId: \(Swift.String(describing: awsAccountId)), dedicatedServiceAccountId: \(Swift.String(describing: dedicatedServiceAccountId)), description: \(Swift.String(describing: description)), environmentArn: \(Swift.String(describing: environmentArn)), environmentId: \(Swift.String(describing: environmentId)), environmentUrl: \(Swift.String(describing: environmentUrl)), federationMode: \(Swift.String(describing: federationMode)), federationParameters: \(Swift.String(describing: federationParameters)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), sageMakerStudioDomainUrl: \(Swift.String(describing: sageMakerStudioDomainUrl)), status: \(Swift.String(describing: status)))"}
}

extension FinspaceClientTypes {
    /// Represents an FinSpace environment.
    public struct Environment: Swift.Equatable {
        /// The ID of the AWS account in which the FinSpace environment is created.
        public var awsAccountId: Swift.String?
        /// The AWS account ID of the dedicated service account associated with your FinSpace environment.
        public var dedicatedServiceAccountId: Swift.String?
        /// The description of the FinSpace environment.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of your FinSpace environment.
        public var environmentArn: Swift.String?
        /// The identifier of the FinSpace environment.
        public var environmentId: Swift.String?
        /// The sign-in url for the web application of your FinSpace environment.
        public var environmentUrl: Swift.String?
        /// The authentication mode for the environment.
        public var federationMode: FinspaceClientTypes.FederationMode?
        /// Configuration information when authentication mode is FEDERATED.
        public var federationParameters: FinspaceClientTypes.FederationParameters?
        /// The KMS key id used to encrypt in the FinSpace environment.
        public var kmsKeyId: Swift.String?
        /// The name of the FinSpace environment.
        public var name: Swift.String?
        /// The url of the integrated FinSpace notebook environment in your web application.
        public var sageMakerStudioDomainUrl: Swift.String?
        /// The current status of creation of the FinSpace environment.
        public var status: FinspaceClientTypes.EnvironmentStatus?

        public init (
            awsAccountId: Swift.String? = nil,
            dedicatedServiceAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            environmentUrl: Swift.String? = nil,
            federationMode: FinspaceClientTypes.FederationMode? = nil,
            federationParameters: FinspaceClientTypes.FederationParameters? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            sageMakerStudioDomainUrl: Swift.String? = nil,
            status: FinspaceClientTypes.EnvironmentStatus? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.dedicatedServiceAccountId = dedicatedServiceAccountId
            self.description = description
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentUrl = environmentUrl
            self.federationMode = federationMode
            self.federationParameters = federationParameters
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.sageMakerStudioDomainUrl = sageMakerStudioDomainUrl
            self.status = status
        }
    }

}

extension FinspaceClientTypes {
    public enum EnvironmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case createRequested
        case creating
        case deleted
        case deleteRequested
        case deleting
        case failedCreation
        case failedDeletion
        case retryDeletion
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentStatus] {
            return [
                .created,
                .createRequested,
                .creating,
                .deleted,
                .deleteRequested,
                .deleting,
                .failedCreation,
                .failedDeletion,
                .retryDeletion,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createRequested: return "CREATE_REQUESTED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteRequested: return "DELETE_REQUESTED"
            case .deleting: return "DELETING"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .retryDeletion: return "RETRY_DELETION"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentStatus(rawValue: rawValue) ?? EnvironmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes {
    public enum FederationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case federated
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [FederationMode] {
            return [
                .federated,
                .local,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .federated: return "FEDERATED"
            case .local: return "LOCAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FederationMode(rawValue: rawValue) ?? FederationMode.sdkUnknown(rawValue)
        }
    }
}

extension FinspaceClientTypes.FederationParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationCallBackURL
        case attributeMap
        case federationProviderName
        case federationURN
        case samlMetadataDocument
        case samlMetadataURL
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationCallBackURL = applicationCallBackURL {
            try encodeContainer.encode(applicationCallBackURL, forKey: .applicationCallBackURL)
        }
        if let attributeMap = attributeMap {
            var attributeMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributeMap)
            for (dictKey0, attributemap0) in attributeMap {
                try attributeMapContainer.encode(attributemap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let federationProviderName = federationProviderName {
            try encodeContainer.encode(federationProviderName, forKey: .federationProviderName)
        }
        if let federationURN = federationURN {
            try encodeContainer.encode(federationURN, forKey: .federationURN)
        }
        if let samlMetadataDocument = samlMetadataDocument {
            try encodeContainer.encode(samlMetadataDocument, forKey: .samlMetadataDocument)
        }
        if let samlMetadataURL = samlMetadataURL {
            try encodeContainer.encode(samlMetadataURL, forKey: .samlMetadataURL)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samlMetadataDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataDocument)
        samlMetadataDocument = samlMetadataDocumentDecoded
        let samlMetadataURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samlMetadataURL)
        samlMetadataURL = samlMetadataURLDecoded
        let applicationCallBackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationCallBackURL)
        applicationCallBackURL = applicationCallBackURLDecoded
        let federationURNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .federationURN)
        federationURN = federationURNDecoded
        let federationProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .federationProviderName)
        federationProviderName = federationProviderNameDecoded
        let attributeMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributeMap)
        var attributeMapDecoded0: [Swift.String:Swift.String]? = nil
        if let attributeMapContainer = attributeMapContainer {
            attributeMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, url0) in attributeMapContainer {
                if let url0 = url0 {
                    attributeMapDecoded0?[key0] = url0
                }
            }
        }
        attributeMap = attributeMapDecoded0
    }
}

extension FinspaceClientTypes.FederationParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FederationParameters(applicationCallBackURL: \(Swift.String(describing: applicationCallBackURL)), attributeMap: \(Swift.String(describing: attributeMap)), federationProviderName: \(Swift.String(describing: federationProviderName)), federationURN: \(Swift.String(describing: federationURN)), samlMetadataDocument: \(Swift.String(describing: samlMetadataDocument)), samlMetadataURL: \(Swift.String(describing: samlMetadataURL)))"}
}

extension FinspaceClientTypes {
    /// Configuration information when authentication mode is FEDERATED.
    public struct FederationParameters: Swift.Equatable {
        /// The redirect or sign-in URL that should be entered into the SAML 2.0 compliant identity provider configuration (IdP).
        public var applicationCallBackURL: Swift.String?
        /// SAML attribute name and value. The name must always be Email and the value should be set to the attribute definition in which user email is set. For example, name would be Email and value http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress. Please check your SAML 2.0 compliant identity provider (IdP) documentation for details.
        public var attributeMap: [Swift.String:Swift.String]?
        /// Name of the identity provider (IdP).
        public var federationProviderName: Swift.String?
        /// The Uniform Resource Name (URN). Also referred as Service Provider URN or Audience URI or Service Provider Entity ID.
        public var federationURN: Swift.String?
        /// SAML 2.0 Metadata document from identity provider (IdP).
        public var samlMetadataDocument: Swift.String?
        /// Provide the metadata URL from your SAML 2.0 compliant identity provider (IdP).
        public var samlMetadataURL: Swift.String?

        public init (
            applicationCallBackURL: Swift.String? = nil,
            attributeMap: [Swift.String:Swift.String]? = nil,
            federationProviderName: Swift.String? = nil,
            federationURN: Swift.String? = nil,
            samlMetadataDocument: Swift.String? = nil,
            samlMetadataURL: Swift.String? = nil
        )
        {
            self.applicationCallBackURL = applicationCallBackURL
            self.attributeMap = attributeMap
            self.federationProviderName = federationProviderName
            self.federationURN = federationURN
            self.samlMetadataDocument = samlMetadataDocument
            self.samlMetadataURL = samlMetadataURL
        }
    }

}

extension GetEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentInput(environmentId: \(Swift.String(describing: environmentId)))"}
}

extension GetEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/environment/\(environmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The identifier of the FinSpace environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEnvironmentOutputResponse(environment: \(Swift.String(describing: environment)))"}
}

extension GetEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct GetEnvironmentOutputResponse: Swift.Equatable {
    /// The name of the FinSpace environment.
    public var environment: FinspaceClientTypes.Environment?

    public init (
        environment: FinspaceClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct GetEnvironmentOutputResponseBody: Swift.Equatable {
    public let environment: FinspaceClientTypes.Environment?
}

extension GetEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is invalid. Something is wrong with the input to the request.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A service limit or quota is exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListEnvironmentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListEnvironmentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEnvironmentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListEnvironmentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/environment"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEnvironmentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The maximum number of results to return in this request.
    public var maxResults: Swift.Int
    /// A token generated by FinSpace that specifies where to continue pagination if a previous request was truncated. To get the next set of pages, pass in the nextToken value from the response object of the previous page call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEnvironmentsOutputResponse(environments: \(Swift.String(describing: environments)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEnvironmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutputResponse: Swift.Equatable {
    /// A list of all of your FinSpace environments.
    public var environments: [FinspaceClientTypes.Environment]?
    /// A token that you can use in a subsequent call to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init (
        environments: [FinspaceClientTypes.Environment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputResponseBody: Swift.Equatable {
    public let environments: [FinspaceClientTypes.Environment]?
    public let nextToken: Swift.String?
}

extension ListEnvironmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([FinspaceClientTypes.Environment?].self, forKey: .environments)
        var environmentsDecoded0:[FinspaceClientTypes.Environment]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [FinspaceClientTypes.Environment]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of all tags for a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspaceClientTypes.SuperuserParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress
        case firstName
        case lastName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
    }
}

extension FinspaceClientTypes.SuperuserParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SuperuserParameters(emailAddress: \(Swift.String(describing: emailAddress)), firstName: \(Swift.String(describing: firstName)), lastName: \(Swift.String(describing: lastName)))"}
}

extension FinspaceClientTypes {
    /// Configuration information for the superuser.
    public struct SuperuserParameters: Swift.Equatable {
        /// The email address of the superuser.
        /// This member is required.
        public var emailAddress: Swift.String?
        /// The first name of the superuser.
        /// This member is required.
        public var firstName: Swift.String?
        /// The last name of the superuser.
        /// This member is required.
        public var lastName: Swift.String?

        public init (
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil
        )
        {
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be assigned to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException()"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// A FinSpace resource from which you want to remove a tag or tags. The value for this parameter is an Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys (names) of one or more tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateEnvironmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

extension UpdateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentInput(description: \(Swift.String(describing: description)), environmentId: \(Swift.String(describing: environmentId)), federationMode: \(Swift.String(describing: federationMode)), federationParameters: \(Swift.String(describing: federationParameters)), name: \(Swift.String(describing: name)))"}
}

extension UpdateEnvironmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case federationMode
        case federationParameters
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let federationMode = federationMode {
            try encodeContainer.encode(federationMode.rawValue, forKey: .federationMode)
        }
        if let federationParameters = federationParameters {
            try encodeContainer.encode(federationParameters, forKey: .federationParameters)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateEnvironmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateEnvironmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateEnvironmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let environmentId = input.environmentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("environmentId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/environment/\(environmentId.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateEnvironmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// The description of the environment.
    public var description: Swift.String?
    /// The identifier of the FinSpace environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Authentication mode for the environment.
    ///
    /// * FEDERATED - Users access FinSpace through Single Sign On (SSO) via your Identity provider.
    ///
    /// * LOCAL - Users access FinSpace via email and password managed within the FinSpace environment.
    public var federationMode: FinspaceClientTypes.FederationMode?
    /// Configuration information when authentication mode is FEDERATED.
    public var federationParameters: FinspaceClientTypes.FederationParameters?
    /// The name of the environment.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        federationMode: FinspaceClientTypes.FederationMode? = nil,
        federationParameters: FinspaceClientTypes.FederationParameters? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.environmentId = environmentId
        self.federationMode = federationMode
        self.federationParameters = federationParameters
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let federationMode: FinspaceClientTypes.FederationMode?
    public let federationParameters: FinspaceClientTypes.FederationParameters?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case federationMode
        case federationParameters
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let federationModeDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationMode.self, forKey: .federationMode)
        federationMode = federationModeDecoded
        let federationParametersDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.FederationParameters.self, forKey: .federationParameters)
        federationParameters = federationParametersDecoded
    }
}

extension UpdateEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentOutputResponse(environment: \(Swift.String(describing: environment)))"}
}

extension UpdateEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct UpdateEnvironmentOutputResponse: Swift.Equatable {
    /// Returns the FinSpace environment object.
    public var environment: FinspaceClientTypes.Environment?

    public init (
        environment: FinspaceClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct UpdateEnvironmentOutputResponseBody: Swift.Equatable {
    public let environment: FinspaceClientTypes.Environment?
}

extension UpdateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(FinspaceClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
