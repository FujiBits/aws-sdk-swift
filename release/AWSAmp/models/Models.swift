// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmpClientTypes.AlertManagerDefinitionDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case data
        case modifiedAt
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let modifiedAt = modifiedAt {
            try encodeContainer.encode(modifiedAt.timeIntervalSince1970, forKey: .modifiedAt)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionStatus.self, forKey: .status)
        status = statusDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension AmpClientTypes.AlertManagerDefinitionDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlertManagerDefinitionDescription(createdAt: \(Swift.String(describing: createdAt)), data: \(Swift.String(describing: data)), modifiedAt: \(Swift.String(describing: modifiedAt)), status: \(Swift.String(describing: status)))"}
}

extension AmpClientTypes {
    /// Represents the properties of an alert manager definition.
    public struct AlertManagerDefinitionDescription: Swift.Equatable {
        /// The time when the alert manager definition was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The alert manager definition.
        /// This member is required.
        public var data: ClientRuntime.Data?
        /// The time when the alert manager definition was modified.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?
        /// The status of alert manager definition.
        /// This member is required.
        public var status: AmpClientTypes.AlertManagerDefinitionStatus?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            data: ClientRuntime.Data? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            status: AmpClientTypes.AlertManagerDefinitionStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.status = status
        }
    }

}

extension AmpClientTypes.AlertManagerDefinitionStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AmpClientTypes.AlertManagerDefinitionStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlertManagerDefinitionStatus(statusCode: \(Swift.String(describing: statusCode)), statusReason: \(Swift.String(describing: statusReason)))"}
}

extension AmpClientTypes {
    /// Represents the status of a definition.
    public struct AlertManagerDefinitionStatus: Swift.Equatable {
        /// Status code of this definition.
        /// This member is required.
        public var statusCode: AmpClientTypes.AlertManagerDefinitionStatusCode?
        /// The reason for failure if any.
        public var statusReason: Swift.String?

        public init (
            statusCode: AmpClientTypes.AlertManagerDefinitionStatusCode? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }

}

extension AmpClientTypes {
    /// State of an alert manager definition.
    public enum AlertManagerDefinitionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Definition has been created/updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case active
        /// Definition is being created. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case creating
        /// Definition creation failed.
        case creationFailed
        /// Definition is being deleting. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case deleting
        /// Definition update failed.
        case updateFailed
        /// Definition is being updated. Update/Deletion is disallowed until definition is ACTIVE and workspace status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AlertManagerDefinitionStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlertManagerDefinitionStatusCode(rawValue: rawValue) ?? AlertManagerDefinitionStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource affected.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateAlertManagerDefinitionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAlertManagerDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAlertManagerDefinitionOutputError>
}

extension CreateAlertManagerDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAlertManagerDefinitionInput(clientToken: \(Swift.String(describing: clientToken)), data: \(Swift.String(describing: data)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension CreateAlertManagerDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }
}

public struct CreateAlertManagerDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAlertManagerDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAlertManagerDefinitionOutputError>
}

public struct CreateAlertManagerDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAlertManagerDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAlertManagerDefinitionOutputError>
}

public struct CreateAlertManagerDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAlertManagerDefinitionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAlertManagerDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAlertManagerDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAlertManagerDefinitionOutputError>
}

/// Represents the input of a CreateAlertManagerDefinition operation.
public struct CreateAlertManagerDefinitionInput: Swift.Equatable {
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The alert manager definition data.
    /// This member is required.
    public var data: ClientRuntime.Data?
    /// The ID of the workspace in which to create the alert manager definition.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        data: ClientRuntime.Data? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.workspaceId = workspaceId
    }
}

struct CreateAlertManagerDefinitionInputBody: Swift.Equatable {
    public let data: ClientRuntime.Data?
    public let clientToken: Swift.String?
}

extension CreateAlertManagerDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAlertManagerDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAlertManagerDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAlertManagerDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAlertManagerDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAlertManagerDefinitionOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension CreateAlertManagerDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAlertManagerDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Represents the output of a CreateAlertManagerDefinition operation.
public struct CreateAlertManagerDefinitionOutputResponse: Swift.Equatable {
    /// The status of alert manager definition.
    /// This member is required.
    public var status: AmpClientTypes.AlertManagerDefinitionStatus?

    public init (
        status: AmpClientTypes.AlertManagerDefinitionStatus? = nil
    )
    {
        self.status = status
    }
}

struct CreateAlertManagerDefinitionOutputResponseBody: Swift.Equatable {
    public let status: AmpClientTypes.AlertManagerDefinitionStatus?
}

extension CreateAlertManagerDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateRuleGroupsNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleGroupsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleGroupsNamespaceOutputError>
}

extension CreateRuleGroupsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRuleGroupsNamespaceInput(clientToken: \(Swift.String(describing: clientToken)), data: \(Swift.String(describing: data)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension CreateRuleGroupsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRuleGroupsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleGroupsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleGroupsNamespaceOutputError>
}

public struct CreateRuleGroupsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleGroupsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleGroupsNamespaceOutputError>
}

public struct CreateRuleGroupsNamespaceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRuleGroupsNamespaceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateRuleGroupsNamespaceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateRuleGroupsNamespaceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRuleGroupsNamespaceOutputError>
}

/// Represents the input of a CreateRuleGroupsNamespace operation.
public struct CreateRuleGroupsNamespaceInput: Swift.Equatable {
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The namespace data that define the rule groups.
    /// This member is required.
    public var data: ClientRuntime.Data?
    /// The rule groups namespace name.
    /// This member is required.
    public var name: Swift.String?
    /// Optional, user-provided tags for this rule groups namespace.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the workspace in which to create the rule group namespace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        data: ClientRuntime.Data? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.name = name
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateRuleGroupsNamespaceInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let data: ClientRuntime.Data?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateRuleGroupsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRuleGroupsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleGroupsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleGroupsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleGroupsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRuleGroupsNamespaceOutputResponse(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRuleGroupsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRuleGroupsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

/// Represents the output of a CreateRuleGroupsNamespace operation.
public struct CreateRuleGroupsNamespaceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of this rule groups namespace.
    /// This member is required.
    public var arn: Swift.String?
    /// The rule groups namespace name.
    /// This member is required.
    public var name: Swift.String?
    /// The status of rule groups namespace.
    /// This member is required.
    public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
    /// The tags of this rule groups namespace.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct CreateRuleGroupsNamespaceOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let arn: Swift.String?
    public let status: AmpClientTypes.RuleGroupsNamespaceStatus?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateRuleGroupsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateWorkspaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkspaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkspaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkspaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkspaceOutputError>
}

extension CreateWorkspaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkspaceInput(alias: \(Swift.String(describing: alias)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateWorkspaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateWorkspaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkspaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkspaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkspaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkspaceOutputError>
}

public struct CreateWorkspaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkspaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateWorkspaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateWorkspaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkspaceOutputError>
}

public struct CreateWorkspaceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateWorkspaceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateWorkspaceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/workspaces"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateWorkspaceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateWorkspaceOutputError>
}

/// Represents the input of a CreateWorkspace operation.
public struct CreateWorkspaceInput: Swift.Equatable {
    /// An optional user-assigned alias for this workspace. This alias is for user reference and does not need to be unique.
    public var alias: Swift.String?
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// Optional, user-provided tags for this workspace.
    public var tags: [Swift.String:Swift.String]?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateWorkspaceInputBody: Swift.Equatable {
    public let alias: Swift.String?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateWorkspaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkspaceOutputResponse(arn: \(Swift.String(describing: arn)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension CreateWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.status = output.status
            self.tags = output.tags
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.status = nil
            self.tags = nil
            self.workspaceId = nil
        }
    }
}

/// Represents the output of a CreateWorkspace operation.
public struct CreateWorkspaceOutputResponse: Swift.Equatable {
    /// The ARN of the workspace that was just created.
    /// This member is required.
    public var arn: Swift.String?
    /// The status of the workspace that was just created (usually CREATING).
    /// This member is required.
    public var status: AmpClientTypes.WorkspaceStatus?
    /// The tags of this workspace.
    public var tags: [Swift.String:Swift.String]?
    /// The generated ID of the workspace that was just created.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        status: AmpClientTypes.WorkspaceStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.status = status
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceOutputResponseBody: Swift.Equatable {
    public let workspaceId: Swift.String?
    public let arn: Swift.String?
    public let status: AmpClientTypes.WorkspaceStatus?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case status
        case tags
        case workspaceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteAlertManagerDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAlertManagerDefinitionInput(clientToken: \(Swift.String(describing: clientToken)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension DeleteAlertManagerDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAlertManagerDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAlertManagerDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAlertManagerDefinitionOutputError>
}

public struct DeleteAlertManagerDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAlertManagerDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAlertManagerDefinitionOutputError>
}

public struct DeleteAlertManagerDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAlertManagerDefinitionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAlertManagerDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAlertManagerDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAlertManagerDefinitionOutputError>
}

/// Represents the input of a DeleteAlertManagerDefinition operation.
public struct DeleteAlertManagerDefinitionInput: Swift.Equatable {
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the workspace in which to delete the alert manager definition.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

struct DeleteAlertManagerDefinitionInputBody: Swift.Equatable {
}

extension DeleteAlertManagerDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAlertManagerDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAlertManagerDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAlertManagerDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAlertManagerDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAlertManagerDefinitionOutputResponse()"}
}

extension DeleteAlertManagerDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAlertManagerDefinitionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAlertManagerDefinitionOutputResponseBody: Swift.Equatable {
}

extension DeleteAlertManagerDefinitionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRuleGroupsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRuleGroupsNamespaceInput(clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension DeleteRuleGroupsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRuleGroupsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleGroupsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleGroupsNamespaceOutputError>
}

public struct DeleteRuleGroupsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleGroupsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleGroupsNamespaceOutputError>
}

public struct DeleteRuleGroupsNamespaceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRuleGroupsNamespaceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteRuleGroupsNamespaceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces/\(name.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRuleGroupsNamespaceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRuleGroupsNamespaceOutputError>
}

/// Represents the input of a DeleteRuleGroupsNamespace operation.
public struct DeleteRuleGroupsNamespaceInput: Swift.Equatable {
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The rule groups namespace name.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace to delete rule group definition.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.workspaceId = workspaceId
    }
}

struct DeleteRuleGroupsNamespaceInputBody: Swift.Equatable {
}

extension DeleteRuleGroupsNamespaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRuleGroupsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleGroupsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleGroupsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleGroupsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRuleGroupsNamespaceOutputResponse()"}
}

extension DeleteRuleGroupsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleGroupsNamespaceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRuleGroupsNamespaceOutputResponseBody: Swift.Equatable {
}

extension DeleteRuleGroupsNamespaceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkspaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorkspaceInput(clientToken: \(Swift.String(describing: clientToken)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension DeleteWorkspaceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteWorkspaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkspaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorkspaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorkspaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkspaceOutputError>
}

public struct DeleteWorkspaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkspaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWorkspaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWorkspaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkspaceOutputError>
}

public struct DeleteWorkspaceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWorkspaceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteWorkspaceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteWorkspaceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWorkspaceOutputError>
}

/// Represents the input of a DeleteWorkspace operation.
public struct DeleteWorkspaceInput: Swift.Equatable {
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceInputBody: Swift.Equatable {
}

extension DeleteWorkspaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWorkspaceOutputResponse()"}
}

extension DeleteWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWorkspaceOutputResponseBody: Swift.Equatable {
}

extension DeleteWorkspaceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAlertManagerDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAlertManagerDefinitionInput(workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension DescribeAlertManagerDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAlertManagerDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlertManagerDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlertManagerDefinitionOutputError>
}

public struct DescribeAlertManagerDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlertManagerDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlertManagerDefinitionOutputError>
}

public struct DescribeAlertManagerDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAlertManagerDefinitionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAlertManagerDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAlertManagerDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAlertManagerDefinitionOutputError>
}

/// Represents the input of a DescribeAlertManagerDefinition operation.
public struct DescribeAlertManagerDefinitionInput: Swift.Equatable {
    /// The ID of the workspace to describe.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeAlertManagerDefinitionInputBody: Swift.Equatable {
}

extension DescribeAlertManagerDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAlertManagerDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAlertManagerDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAlertManagerDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAlertManagerDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAlertManagerDefinitionOutputResponse(alertManagerDefinition: \(Swift.String(describing: alertManagerDefinition)))"}
}

extension DescribeAlertManagerDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAlertManagerDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alertManagerDefinition = output.alertManagerDefinition
        } else {
            self.alertManagerDefinition = nil
        }
    }
}

/// Represents the output of a DescribeAlertManagerDefinition operation.
public struct DescribeAlertManagerDefinitionOutputResponse: Swift.Equatable {
    /// The properties of the selected workspace's alert manager definition.
    /// This member is required.
    public var alertManagerDefinition: AmpClientTypes.AlertManagerDefinitionDescription?

    public init (
        alertManagerDefinition: AmpClientTypes.AlertManagerDefinitionDescription? = nil
    )
    {
        self.alertManagerDefinition = alertManagerDefinition
    }
}

struct DescribeAlertManagerDefinitionOutputResponseBody: Swift.Equatable {
    public let alertManagerDefinition: AmpClientTypes.AlertManagerDefinitionDescription?
}

extension DescribeAlertManagerDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alertManagerDefinition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alertManagerDefinitionDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionDescription.self, forKey: .alertManagerDefinition)
        alertManagerDefinition = alertManagerDefinitionDecoded
    }
}

extension DescribeRuleGroupsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRuleGroupsNamespaceInput(name: \(Swift.String(describing: name)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension DescribeRuleGroupsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeRuleGroupsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRuleGroupsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRuleGroupsNamespaceOutputError>
}

public struct DescribeRuleGroupsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRuleGroupsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRuleGroupsNamespaceOutputError>
}

public struct DescribeRuleGroupsNamespaceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRuleGroupsNamespaceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeRuleGroupsNamespaceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces/\(name.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRuleGroupsNamespaceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRuleGroupsNamespaceOutputError>
}

/// Represents the input of a DescribeRuleGroupsNamespace operation.
public struct DescribeRuleGroupsNamespaceInput: Swift.Equatable {
    /// The rule groups namespace.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace to describe.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.name = name
        self.workspaceId = workspaceId
    }
}

struct DescribeRuleGroupsNamespaceInputBody: Swift.Equatable {
}

extension DescribeRuleGroupsNamespaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRuleGroupsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRuleGroupsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRuleGroupsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRuleGroupsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRuleGroupsNamespaceOutputResponse(ruleGroupsNamespace: \(Swift.String(describing: ruleGroupsNamespace)))"}
}

extension DescribeRuleGroupsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRuleGroupsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ruleGroupsNamespace = output.ruleGroupsNamespace
        } else {
            self.ruleGroupsNamespace = nil
        }
    }
}

/// Represents the output of a DescribeRuleGroupsNamespace operation.
public struct DescribeRuleGroupsNamespaceOutputResponse: Swift.Equatable {
    /// The selected rule groups namespace.
    /// This member is required.
    public var ruleGroupsNamespace: AmpClientTypes.RuleGroupsNamespaceDescription?

    public init (
        ruleGroupsNamespace: AmpClientTypes.RuleGroupsNamespaceDescription? = nil
    )
    {
        self.ruleGroupsNamespace = ruleGroupsNamespace
    }
}

struct DescribeRuleGroupsNamespaceOutputResponseBody: Swift.Equatable {
    public let ruleGroupsNamespace: AmpClientTypes.RuleGroupsNamespaceDescription?
}

extension DescribeRuleGroupsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleGroupsNamespace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupsNamespaceDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceDescription.self, forKey: .ruleGroupsNamespace)
        ruleGroupsNamespace = ruleGroupsNamespaceDecoded
    }
}

extension DescribeWorkspaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorkspaceInput(workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension DescribeWorkspaceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeWorkspaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorkspaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorkspaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorkspaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorkspaceOutputError>
}

public struct DescribeWorkspaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorkspaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeWorkspaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeWorkspaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorkspaceOutputError>
}

public struct DescribeWorkspaceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeWorkspaceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeWorkspaceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeWorkspaceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeWorkspaceOutputError>
}

/// Represents the input of a DescribeWorkspace operation.
public struct DescribeWorkspaceInput: Swift.Equatable {
    /// The ID of the workspace to describe.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceInputBody: Swift.Equatable {
}

extension DescribeWorkspaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeWorkspaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeWorkspaceOutputResponse(workspace: \(Swift.String(describing: workspace)))"}
}

extension DescribeWorkspaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

/// Represents the output of a DescribeWorkspace operation.
public struct DescribeWorkspaceOutputResponse: Swift.Equatable {
    /// The properties of the selected workspace.
    /// This member is required.
    public var workspace: AmpClientTypes.WorkspaceDescription?

    public init (
        workspace: AmpClientTypes.WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct DescribeWorkspaceOutputResponseBody: Swift.Equatable {
    public let workspace: AmpClientTypes.WorkspaceDescription?
}

extension DescribeWorkspaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workspace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListRuleGroupsNamespacesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRuleGroupsNamespacesInput(maxResults: \(Swift.String(describing: maxResults)), name: \(Swift.String(describing: name)), nextToken: \(Swift.String(describing: nextToken)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension ListRuleGroupsNamespacesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListRuleGroupsNamespacesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRuleGroupsNamespacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRuleGroupsNamespacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRuleGroupsNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRuleGroupsNamespacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRuleGroupsNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRuleGroupsNamespacesOutputError>
}

public struct ListRuleGroupsNamespacesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRuleGroupsNamespacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRuleGroupsNamespacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRuleGroupsNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let name = input.operationInput.name {
            let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            input.builder.withQueryItem(nameQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRuleGroupsNamespacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRuleGroupsNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRuleGroupsNamespacesOutputError>
}

public struct ListRuleGroupsNamespacesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRuleGroupsNamespacesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListRuleGroupsNamespacesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRuleGroupsNamespacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRuleGroupsNamespacesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRuleGroupsNamespacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRuleGroupsNamespacesOutputError>
}

/// Represents the input of a ListRuleGroupsNamespaces operation.
public struct ListRuleGroupsNamespacesInput: Swift.Equatable {
    /// Maximum results to return in response (default=100, maximum=1000).
    public var maxResults: Swift.Int?
    /// Optional filter for rule groups namespace name. Only the rule groups namespace that begin with this value will be returned.
    public var name: Swift.String?
    /// Pagination token to request the next page in a paginated list. This token is obtained from the output of the previous ListRuleGroupsNamespaces request.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

struct ListRuleGroupsNamespacesInputBody: Swift.Equatable {
}

extension ListRuleGroupsNamespacesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRuleGroupsNamespacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRuleGroupsNamespacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRuleGroupsNamespacesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRuleGroupsNamespacesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRuleGroupsNamespacesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), ruleGroupsNamespaces: \(Swift.String(describing: ruleGroupsNamespaces)))"}
}

extension ListRuleGroupsNamespacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRuleGroupsNamespacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.ruleGroupsNamespaces = output.ruleGroupsNamespaces
        } else {
            self.nextToken = nil
            self.ruleGroupsNamespaces = nil
        }
    }
}

/// Represents the output of a ListRuleGroupsNamespaces operation.
public struct ListRuleGroupsNamespacesOutputResponse: Swift.Equatable {
    /// Pagination token to use when requesting the next page in this list.
    public var nextToken: Swift.String?
    /// The list of the selected rule groups namespaces.
    /// This member is required.
    public var ruleGroupsNamespaces: [AmpClientTypes.RuleGroupsNamespaceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        ruleGroupsNamespaces: [AmpClientTypes.RuleGroupsNamespaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleGroupsNamespaces = ruleGroupsNamespaces
    }
}

struct ListRuleGroupsNamespacesOutputResponseBody: Swift.Equatable {
    public let ruleGroupsNamespaces: [AmpClientTypes.RuleGroupsNamespaceSummary]?
    public let nextToken: Swift.String?
}

extension ListRuleGroupsNamespacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case ruleGroupsNamespaces
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupsNamespacesContainer = try containerValues.decodeIfPresent([AmpClientTypes.RuleGroupsNamespaceSummary?].self, forKey: .ruleGroupsNamespaces)
        var ruleGroupsNamespacesDecoded0:[AmpClientTypes.RuleGroupsNamespaceSummary]? = nil
        if let ruleGroupsNamespacesContainer = ruleGroupsNamespacesContainer {
            ruleGroupsNamespacesDecoded0 = [AmpClientTypes.RuleGroupsNamespaceSummary]()
            for structure0 in ruleGroupsNamespacesContainer {
                if let structure0 = structure0 {
                    ruleGroupsNamespacesDecoded0?.append(structure0)
                }
            }
        }
        ruleGroupsNamespaces = ruleGroupsNamespacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags assigned to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWorkspacesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkspacesInput(alias: \(Swift.String(describing: alias)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWorkspacesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListWorkspacesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkspacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkspacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkspacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkspacesOutputError>
}

public struct ListWorkspacesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkspacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWorkspacesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let alias = input.operationInput.alias {
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            input.builder.withQueryItem(aliasQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWorkspacesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkspacesOutputError>
}

public struct ListWorkspacesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWorkspacesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListWorkspacesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/workspaces"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListWorkspacesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWorkspacesOutputError>
}

/// Represents the input of a ListWorkspaces operation.
public struct ListWorkspacesInput: Swift.Equatable {
    /// Optional filter for workspace alias. Only the workspaces with aliases that begin with this value will be returned.
    public var alias: Swift.String?
    /// Maximum results to return in response (default=100, maximum=1000).
    public var maxResults: Swift.Int?
    /// Pagination token to request the next page in a paginated list. This token is obtained from the output of the previous ListWorkspaces request.
    public var nextToken: Swift.String?

    public init (
        alias: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.alias = alias
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkspacesInputBody: Swift.Equatable {
}

extension ListWorkspacesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkspacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkspacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkspacesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkspacesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkspacesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), workspaces: \(Swift.String(describing: workspaces)))"}
}

extension ListWorkspacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workspaces = output.workspaces
        } else {
            self.nextToken = nil
            self.workspaces = nil
        }
    }
}

/// Represents the output of a ListWorkspaces operation.
public struct ListWorkspacesOutputResponse: Swift.Equatable {
    /// Pagination token to use when requesting the next page in this list.
    public var nextToken: Swift.String?
    /// The list of existing workspaces, including those undergoing creation or deletion.
    /// This member is required.
    public var workspaces: [AmpClientTypes.WorkspaceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        workspaces: [AmpClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

struct ListWorkspacesOutputResponseBody: Swift.Equatable {
    public let workspaces: [AmpClientTypes.WorkspaceSummary]?
    public let nextToken: Swift.String?
}

extension ListWorkspacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workspaces
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([AmpClientTypes.WorkspaceSummary?].self, forKey: .workspaces)
        var workspacesDecoded0:[AmpClientTypes.WorkspaceSummary]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [AmpClientTypes.WorkspaceSummary]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct PutAlertManagerDefinitionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAlertManagerDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAlertManagerDefinitionOutputError>
}

extension PutAlertManagerDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAlertManagerDefinitionInput(clientToken: \(Swift.String(describing: clientToken)), data: \(Swift.String(describing: data)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension PutAlertManagerDefinitionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }
}

public struct PutAlertManagerDefinitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAlertManagerDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAlertManagerDefinitionOutputError>
}

public struct PutAlertManagerDefinitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAlertManagerDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAlertManagerDefinitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAlertManagerDefinitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAlertManagerDefinitionOutputError>
}

public struct PutAlertManagerDefinitionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAlertManagerDefinitionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutAlertManagerDefinitionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAlertManagerDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/alertmanager/definition"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAlertManagerDefinitionInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAlertManagerDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAlertManagerDefinitionOutputError>
}

/// Represents the input of a PutAlertManagerDefinition operation.
public struct PutAlertManagerDefinitionInput: Swift.Equatable {
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The alert manager definition data.
    /// This member is required.
    public var data: ClientRuntime.Data?
    /// The ID of the workspace in which to update the alert manager definition.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        data: ClientRuntime.Data? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.workspaceId = workspaceId
    }
}

struct PutAlertManagerDefinitionInputBody: Swift.Equatable {
    public let data: ClientRuntime.Data?
    public let clientToken: Swift.String?
}

extension PutAlertManagerDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension PutAlertManagerDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAlertManagerDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAlertManagerDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAlertManagerDefinitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAlertManagerDefinitionOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension PutAlertManagerDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutAlertManagerDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// Represents the output of a PutAlertManagerDefinition operation.
public struct PutAlertManagerDefinitionOutputResponse: Swift.Equatable {
    /// The status of alert manager definition.
    /// This member is required.
    public var status: AmpClientTypes.AlertManagerDefinitionStatus?

    public init (
        status: AmpClientTypes.AlertManagerDefinitionStatus? = nil
    )
    {
        self.status = status
    }
}

struct PutAlertManagerDefinitionOutputResponseBody: Swift.Equatable {
    public let status: AmpClientTypes.AlertManagerDefinitionStatus?
}

extension PutAlertManagerDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.AlertManagerDefinitionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct PutRuleGroupsNamespaceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRuleGroupsNamespaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRuleGroupsNamespaceOutputError>
}

extension PutRuleGroupsNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRuleGroupsNamespaceInput(clientToken: \(Swift.String(describing: clientToken)), data: \(Swift.String(describing: data)), name: \(Swift.String(describing: name)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension PutRuleGroupsNamespaceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }
}

public struct PutRuleGroupsNamespaceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRuleGroupsNamespaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRuleGroupsNamespaceOutputError>
}

public struct PutRuleGroupsNamespaceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRuleGroupsNamespaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRuleGroupsNamespaceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRuleGroupsNamespaceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRuleGroupsNamespaceOutputError>
}

public struct PutRuleGroupsNamespaceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRuleGroupsNamespaceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutRuleGroupsNamespaceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRuleGroupsNamespaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        guard let name = input.name else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("name is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/rulegroupsnamespaces/\(name.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRuleGroupsNamespaceInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRuleGroupsNamespaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRuleGroupsNamespaceOutputError>
}

/// Represents the input of a PutRuleGroupsNamespace operation.
public struct PutRuleGroupsNamespaceInput: Swift.Equatable {
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The namespace data that define the rule groups.
    /// This member is required.
    public var data: ClientRuntime.Data?
    /// The rule groups namespace name.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the workspace in which to update the rule group namespace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        data: ClientRuntime.Data? = nil,
        name: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.name = name
        self.workspaceId = workspaceId
    }
}

struct PutRuleGroupsNamespaceInputBody: Swift.Equatable {
    public let data: ClientRuntime.Data?
    public let clientToken: Swift.String?
}

extension PutRuleGroupsNamespaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension PutRuleGroupsNamespaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRuleGroupsNamespaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRuleGroupsNamespaceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRuleGroupsNamespaceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRuleGroupsNamespaceOutputResponse(arn: \(Swift.String(describing: arn)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension PutRuleGroupsNamespaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRuleGroupsNamespaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

/// Represents the output of a PutRuleGroupsNamespace operation.
public struct PutRuleGroupsNamespaceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of this rule groups namespace.
    /// This member is required.
    public var arn: Swift.String?
    /// The rule groups namespace name.
    /// This member is required.
    public var name: Swift.String?
    /// The status of rule groups namespace.
    /// This member is required.
    public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
    /// The tags of this rule groups namespace.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct PutRuleGroupsNamespaceOutputResponseBody: Swift.Equatable {
    public let name: Swift.String?
    public let arn: Swift.String?
    public let status: AmpClientTypes.RuleGroupsNamespaceStatus?
    public let tags: [Swift.String:Swift.String]?
}

extension PutRuleGroupsNamespaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Identifier of the resource affected.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AmpClientTypes.RuleGroupsNamespaceDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case data
        case modifiedAt
        case name
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let modifiedAt = modifiedAt {
            try encodeContainer.encode(modifiedAt.timeIntervalSince1970, forKey: .modifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmpClientTypes.RuleGroupsNamespaceDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleGroupsNamespaceDescription(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), data: \(Swift.String(describing: data)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension AmpClientTypes {
    /// Represents a description of the rule groups namespace.
    public struct RuleGroupsNamespaceDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the rule groups namespace was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The rule groups namespace data.
        /// This member is required.
        public var data: ClientRuntime.Data?
        /// The time when the rule groups namespace was modified.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?
        /// The rule groups namespace name.
        /// This member is required.
        public var name: Swift.String?
        /// The status of rule groups namespace.
        /// This member is required.
        public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
        /// The tags of this rule groups namespace.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            data: ClientRuntime.Data? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.data = data
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

extension AmpClientTypes.RuleGroupsNamespaceStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AmpClientTypes.RuleGroupsNamespaceStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleGroupsNamespaceStatus(statusCode: \(Swift.String(describing: statusCode)), statusReason: \(Swift.String(describing: statusReason)))"}
}

extension AmpClientTypes {
    /// Represents the status of a namespace.
    public struct RuleGroupsNamespaceStatus: Swift.Equatable {
        /// Status code of this namespace.
        /// This member is required.
        public var statusCode: AmpClientTypes.RuleGroupsNamespaceStatusCode?
        /// The reason for failure if any.
        public var statusReason: Swift.String?

        public init (
            statusCode: AmpClientTypes.RuleGroupsNamespaceStatusCode? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.statusCode = statusCode
            self.statusReason = statusReason
        }
    }

}

extension AmpClientTypes {
    /// State of a namespace.
    public enum RuleGroupsNamespaceStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Namespace has been created/updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case active
        /// Namespace is being created. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case creating
        /// Namespace creation failed.
        case creationFailed
        /// Namespace is being deleting. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case deleting
        /// Namespace update failed.
        case updateFailed
        /// Namespace is being updated. Update/Deletion is disallowed until namespace is ACTIVE and workspace status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleGroupsNamespaceStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updateFailed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleGroupsNamespaceStatusCode(rawValue: rawValue) ?? RuleGroupsNamespaceStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AmpClientTypes.RuleGroupsNamespaceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case modifiedAt
        case name
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let modifiedAt = modifiedAt {
            try encodeContainer.encode(modifiedAt.timeIntervalSince1970, forKey: .modifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.RuleGroupsNamespaceStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmpClientTypes.RuleGroupsNamespaceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleGroupsNamespaceSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension AmpClientTypes {
    /// Represents a summary of the rule groups namespace.
    public struct RuleGroupsNamespaceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this rule groups namespace.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the rule groups namespace was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The time when the rule groups namespace was modified.
        /// This member is required.
        public var modifiedAt: ClientRuntime.Date?
        /// The rule groups namespace name.
        /// This member is required.
        public var name: Swift.String?
        /// The status of rule groups namespace.
        /// This member is required.
        public var status: AmpClientTypes.RuleGroupsNamespaceStatus?
        /// The tags of this rule groups namespace.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: AmpClientTypes.RuleGroupsNamespaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
            self.tags = tags
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating quota.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// Identifier of the resource affected.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Type of the resource affected.
    /// This member is required.
    public var resourceType: Swift.String?
    /// Service Quotas requirement to identify originating service.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceType: Swift.String?
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags assigned to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)), quotaCode: \(Swift.String(describing: quotaCode)), retryAfterSeconds: \(Swift.String(describing: retryAfterSeconds)), serviceCode: \(Swift.String(describing: serviceCode)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Service Quotas requirement to identify originating quota.
    public var quotaCode: Swift.String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Swift.Int?
    /// Service Quotas requirement to identify originating service.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let serviceCode: Swift.String?
    public let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tag keys
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateWorkspaceAliasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkspaceAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorkspaceAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkspaceAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorkspaceAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkspaceAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkspaceAliasOutputError>
}

extension UpdateWorkspaceAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkspaceAliasInput(alias: \(Swift.String(describing: alias)), clientToken: \(Swift.String(describing: clientToken)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension UpdateWorkspaceAliasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateWorkspaceAliasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkspaceAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorkspaceAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkspaceAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorkspaceAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkspaceAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkspaceAliasOutputError>
}

public struct UpdateWorkspaceAliasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkspaceAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateWorkspaceAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkspaceAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateWorkspaceAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkspaceAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkspaceAliasOutputError>
}

public struct UpdateWorkspaceAliasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateWorkspaceAliasInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateWorkspaceAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateWorkspaceAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let workspaceId = input.workspaceId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("workspaceId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/workspaces/\(workspaceId.urlPercentEncoding())/alias"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateWorkspaceAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateWorkspaceAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateWorkspaceAliasOutputError>
}

/// Represents the input of an UpdateWorkspaceAlias operation.
public struct UpdateWorkspaceAliasInput: Swift.Equatable {
    /// The new alias of the workspace.
    public var alias: Swift.String?
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The ID of the workspace being updated.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

struct UpdateWorkspaceAliasInputBody: Swift.Equatable {
    public let alias: Swift.String?
    public let clientToken: Swift.String?
}

extension UpdateWorkspaceAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateWorkspaceAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkspaceAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceAliasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWorkspaceAliasOutputResponse()"}
}

extension UpdateWorkspaceAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkspaceAliasOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateWorkspaceAliasOutputResponseBody: Swift.Equatable {
}

extension UpdateWorkspaceAliasOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fieldList: \(Swift.String(describing: fieldList)), message: \(Swift.String(describing: message)), reason: \(Swift.String(describing: reason)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The field that caused the error, if applicable. If more than one field caused the error, pick one and elaborate in the message.
    public var fieldList: [AmpClientTypes.ValidationExceptionField]?
    /// Description of the error.
    /// This member is required.
    public var message: Swift.String?
    /// Reason the request failed validation.
    /// This member is required.
    public var reason: AmpClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [AmpClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AmpClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let reason: AmpClientTypes.ValidationExceptionReason?
    public let fieldList: [AmpClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AmpClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([AmpClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[AmpClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [AmpClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension AmpClientTypes.ValidationExceptionField: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmpClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(message: \(Swift.String(describing: message)), name: \(Swift.String(describing: name)))"}
}

extension AmpClientTypes {
    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The field name.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension AmpClientTypes {
    /// Possible reasons a request failed validation.
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension AmpClientTypes.WorkspaceDescription: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case arn
        case createdAt
        case prometheusEndpoint
        case status
        case tags
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let prometheusEndpoint = prometheusEndpoint {
            try encodeContainer.encode(prometheusEndpoint, forKey: .prometheusEndpoint)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let prometheusEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prometheusEndpoint)
        prometheusEndpoint = prometheusEndpointDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmpClientTypes.WorkspaceDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkspaceDescription(alias: \(Swift.String(describing: alias)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), prometheusEndpoint: \(Swift.String(describing: prometheusEndpoint)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension AmpClientTypes {
    /// Represents the properties of a workspace.
    public struct WorkspaceDescription: Swift.Equatable {
        /// Alias of this workspace.
        public var alias: Swift.String?
        /// The Amazon Resource Name (ARN) of this workspace.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the workspace was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Prometheus endpoint URI.
        public var prometheusEndpoint: Swift.String?
        /// The status of this workspace.
        /// This member is required.
        public var status: AmpClientTypes.WorkspaceStatus?
        /// The tags of this workspace.
        public var tags: [Swift.String:Swift.String]?
        /// Unique string identifying this workspace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            prometheusEndpoint: Swift.String? = nil,
            status: AmpClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.prometheusEndpoint = prometheusEndpoint
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }
    }

}

extension AmpClientTypes.WorkspaceStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension AmpClientTypes.WorkspaceStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkspaceStatus(statusCode: \(Swift.String(describing: statusCode)))"}
}

extension AmpClientTypes {
    /// Represents the status of a workspace.
    public struct WorkspaceStatus: Swift.Equatable {
        /// Status code of this workspace.
        /// This member is required.
        public var statusCode: AmpClientTypes.WorkspaceStatusCode?

        public init (
            statusCode: AmpClientTypes.WorkspaceStatusCode? = nil
        )
        {
            self.statusCode = statusCode
        }
    }

}

extension AmpClientTypes {
    /// State of a workspace.
    public enum WorkspaceStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Workspace has been created and is usable.
        case active
        /// Workspace is being created. Deletion is disallowed until status is ACTIVE.
        case creating
        /// Workspace creation failed. Refer to WorkspaceStatus.failureReason for more details.
        case creationFailed
        /// Workspace is being deleted. Deletions are allowed only when status is ACTIVE.
        case deleting
        /// Workspace is being updated. Updates are allowed only when status is ACTIVE.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkspaceStatusCode] {
            return [
                .active,
                .creating,
                .creationFailed,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkspaceStatusCode(rawValue: rawValue) ?? WorkspaceStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension AmpClientTypes.WorkspaceSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case arn
        case createdAt
        case status
        case tags
        case workspaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmpClientTypes.WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmpClientTypes.WorkspaceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkspaceSummary(alias: \(Swift.String(describing: alias)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), workspaceId: \(Swift.String(describing: workspaceId)))"}
}

extension AmpClientTypes {
    /// Represents a summary of the properties of a workspace.
    public struct WorkspaceSummary: Swift.Equatable {
        /// Alias of this workspace.
        public var alias: Swift.String?
        /// The AmazonResourceName of this workspace.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the workspace was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The status of this workspace.
        /// This member is required.
        public var status: AmpClientTypes.WorkspaceStatus?
        /// The tags of this workspace.
        public var tags: [Swift.String:Swift.String]?
        /// Unique string identifying this workspace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init (
            alias: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            status: AmpClientTypes.WorkspaceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.alias = alias
            self.arn = arn
            self.createdAt = createdAt
            self.status = status
            self.tags = tags
            self.workspaceId = workspaceId
        }
    }

}
