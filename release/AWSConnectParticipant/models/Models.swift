// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes {
    public enum ArtifactStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case inProgress
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactStatus] {
            return [
                .approved,
                .inProgress,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .inProgress: return "IN_PROGRESS"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactStatus(rawValue: rawValue) ?? ArtifactStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectParticipantClientTypes.AttachmentItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case attachmentName = "AttachmentName"
        case contentType = "ContentType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let attachmentName = attachmentName {
            try encodeContainer.encode(attachmentName, forKey: .attachmentName)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let attachmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentName)
        attachmentName = attachmentNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ArtifactStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConnectParticipantClientTypes.AttachmentItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AttachmentItem(attachmentId: \(Swift.String(describing: attachmentId)), attachmentName: \(Swift.String(describing: attachmentName)), contentType: \(Swift.String(describing: contentType)), status: \(Swift.String(describing: status)))"}
}

extension ConnectParticipantClientTypes {
    /// The case-insensitive input to indicate standard MIME type that describes the format of the file that will be uploaded.
    public struct AttachmentItem: Swift.Equatable {
        /// A unique identifier for the attachment.
        public var attachmentId: Swift.String?
        /// A case-sensitive name of the attachment being uploaded.
        public var attachmentName: Swift.String?
        /// Describes the MIME file type of the attachment. For a list of supported file types, see [Feature specifications](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#feature-limits) in the Amazon Connect Administrator Guide.
        public var contentType: Swift.String?
        /// Status of the attachment.
        public var status: ConnectParticipantClientTypes.ArtifactStatus?

        public init (
            attachmentId: Swift.String? = nil,
            attachmentName: Swift.String? = nil,
            contentType: Swift.String? = nil,
            status: ConnectParticipantClientTypes.ArtifactStatus? = nil
        )
        {
            self.attachmentId = attachmentId
            self.attachmentName = attachmentName
            self.contentType = contentType
            self.status = status
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ChatItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachment
        case chatEnded
        case connectionAck
        case event
        case message
        case participantJoined
        case participantLeft
        case transferFailed
        case transferSucceeded
        case typing
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatItemType] {
            return [
                .attachment,
                .chatEnded,
                .connectionAck,
                .event,
                .message,
                .participantJoined,
                .participantLeft,
                .transferFailed,
                .transferSucceeded,
                .typing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case .chatEnded: return "CHAT_ENDED"
            case .connectionAck: return "CONNECTION_ACK"
            case .event: return "EVENT"
            case .message: return "MESSAGE"
            case .participantJoined: return "PARTICIPANT_JOINED"
            case .participantLeft: return "PARTICIPANT_LEFT"
            case .transferFailed: return "TRANSFER_FAILED"
            case .transferSucceeded: return "TRANSFER_SUCCEEDED"
            case .typing: return "TYPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChatItemType(rawValue: rawValue) ?? ChatItemType.sdkUnknown(rawValue)
        }
    }
}

public struct CompleteAttachmentUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteAttachmentUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteAttachmentUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteAttachmentUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteAttachmentUploadOutputError>
}

extension CompleteAttachmentUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteAttachmentUploadInput(attachmentIds: \(Swift.String(describing: attachmentIds)), clientToken: \(Swift.String(describing: clientToken)), connectionToken: \(Swift.String(describing: connectionToken)))"}
}

extension CompleteAttachmentUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentIds = "AttachmentIds"
        case clientToken = "ClientToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentIds = attachmentIds {
            var attachmentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentIds)
            for attachmentidlist0 in attachmentIds {
                try attachmentIdsContainer.encode(attachmentidlist0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct CompleteAttachmentUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteAttachmentUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteAttachmentUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: Swift.String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteAttachmentUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteAttachmentUploadOutputError>
}

public struct CompleteAttachmentUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteAttachmentUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteAttachmentUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteAttachmentUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteAttachmentUploadOutputError>
}

public struct CompleteAttachmentUploadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteAttachmentUploadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CompleteAttachmentUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CompleteAttachmentUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteAttachmentUploadOutputError>
}

public struct CompleteAttachmentUploadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteAttachmentUploadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CompleteAttachmentUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/participant/complete-attachment-upload"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CompleteAttachmentUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteAttachmentUploadOutputError>
}

public struct CompleteAttachmentUploadInput: Swift.Equatable {
    /// A list of unique identifiers for the attachments.
    /// This member is required.
    public var attachmentIds: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?

    public init (
        attachmentIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil
    )
    {
        self.attachmentIds = attachmentIds
        self.clientToken = clientToken
        self.connectionToken = connectionToken
    }
}

struct CompleteAttachmentUploadInputBody: Swift.Equatable {
    public let attachmentIds: [Swift.String]?
    public let clientToken: Swift.String?
}

extension CompleteAttachmentUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentIds = "AttachmentIds"
        case clientToken = "ClientToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attachmentIds)
        var attachmentIdsDecoded0:[Swift.String]? = nil
        if let attachmentIdsContainer = attachmentIdsContainer {
            attachmentIdsDecoded0 = [Swift.String]()
            for string0 in attachmentIdsContainer {
                if let string0 = string0 {
                    attachmentIdsDecoded0?.append(string0)
                }
            }
        }
        attachmentIds = attachmentIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CompleteAttachmentUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteAttachmentUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteAttachmentUploadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteAttachmentUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteAttachmentUploadOutputResponse()"}
}

extension CompleteAttachmentUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CompleteAttachmentUploadOutputResponse: Swift.Equatable {

    public init() {}
}

struct CompleteAttachmentUploadOutputResponseBody: Swift.Equatable {
}

extension CompleteAttachmentUploadOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An attachment with that identifier is already being uploaded.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.ConnectionCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionToken = "ConnectionToken"
        case expiry = "Expiry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionToken = connectionToken {
            try encodeContainer.encode(connectionToken, forKey: .connectionToken)
        }
        if let expiry = expiry {
            try encodeContainer.encode(expiry, forKey: .expiry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionToken)
        connectionToken = connectionTokenDecoded
        let expiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiry)
        expiry = expiryDecoded
    }
}

extension ConnectParticipantClientTypes.ConnectionCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionCredentials(connectionToken: \(Swift.String(describing: connectionToken)), expiry: \(Swift.String(describing: expiry)))"}
}

extension ConnectParticipantClientTypes {
    /// Connection credentials.
    public struct ConnectionCredentials: Swift.Equatable {
        /// The connection token.
        public var connectionToken: Swift.String?
        /// The expiration of the token. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var expiry: Swift.String?

        public init (
            connectionToken: Swift.String? = nil,
            expiry: Swift.String? = nil
        )
        {
            self.connectionToken = connectionToken
            self.expiry = expiry
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionCredentials
        case websocket
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .connectionCredentials,
                .websocket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionCredentials: return "CONNECTION_CREDENTIALS"
            case .websocket: return "WEBSOCKET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateParticipantConnectionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParticipantConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParticipantConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParticipantConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParticipantConnectionOutputError>
}

extension CreateParticipantConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateParticipantConnectionInput(participantToken: \(Swift.String(describing: participantToken)), type: \(Swift.String(describing: type)))"}
}

extension CreateParticipantConnectionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for connectiontypelist0 in type {
                try typeContainer.encode(connectiontypelist0.rawValue)
            }
        }
    }
}

public struct CreateParticipantConnectionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParticipantConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParticipantConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let participantToken = input.operationInput.participantToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: Swift.String(participantToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParticipantConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParticipantConnectionOutputError>
}

public struct CreateParticipantConnectionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParticipantConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateParticipantConnectionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateParticipantConnectionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParticipantConnectionOutputError>
}

public struct CreateParticipantConnectionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParticipantConnectionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateParticipantConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateParticipantConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParticipantConnectionOutputError>
}

public struct CreateParticipantConnectionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateParticipantConnectionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateParticipantConnectionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/participant/connection"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateParticipantConnectionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateParticipantConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateParticipantConnectionOutputError>
}

public struct CreateParticipantConnectionInput: Swift.Equatable {
    /// This is a header parameter. The Participant Token as obtained from [StartChatContact](https://docs.aws.amazon.com/connect/latest/APIReference/API_StartChatContact.html) API response.
    /// This member is required.
    public var participantToken: Swift.String?
    /// Type of connection information required.
    /// This member is required.
    public var type: [ConnectParticipantClientTypes.ConnectionType]?

    public init (
        participantToken: Swift.String? = nil,
        type: [ConnectParticipantClientTypes.ConnectionType]? = nil
    )
    {
        self.participantToken = participantToken
        self.type = type
    }
}

struct CreateParticipantConnectionInputBody: Swift.Equatable {
    public let type: [ConnectParticipantClientTypes.ConnectionType]?
}

extension CreateParticipantConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.ConnectionType?].self, forKey: .type)
        var typeDecoded0:[ConnectParticipantClientTypes.ConnectionType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [ConnectParticipantClientTypes.ConnectionType]()
            for string0 in typeContainer {
                if let string0 = string0 {
                    typeDecoded0?.append(string0)
                }
            }
        }
        type = typeDecoded0
    }
}

extension CreateParticipantConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateParticipantConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateParticipantConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateParticipantConnectionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateParticipantConnectionOutputResponse(connectionCredentials: \(Swift.String(describing: connectionCredentials)), websocket: \(Swift.String(describing: websocket)))"}
}

extension CreateParticipantConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateParticipantConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionCredentials = output.connectionCredentials
            self.websocket = output.websocket
        } else {
            self.connectionCredentials = nil
            self.websocket = nil
        }
    }
}

public struct CreateParticipantConnectionOutputResponse: Swift.Equatable {
    /// Creates the participant's connection credentials. The authentication token associated with the participant's connection.
    public var connectionCredentials: ConnectParticipantClientTypes.ConnectionCredentials?
    /// Creates the participant's websocket connection.
    public var websocket: ConnectParticipantClientTypes.Websocket?

    public init (
        connectionCredentials: ConnectParticipantClientTypes.ConnectionCredentials? = nil,
        websocket: ConnectParticipantClientTypes.Websocket? = nil
    )
    {
        self.connectionCredentials = connectionCredentials
        self.websocket = websocket
    }
}

struct CreateParticipantConnectionOutputResponseBody: Swift.Equatable {
    public let websocket: ConnectParticipantClientTypes.Websocket?
    public let connectionCredentials: ConnectParticipantClientTypes.ConnectionCredentials?
}

extension CreateParticipantConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionCredentials = "ConnectionCredentials"
        case websocket = "Websocket"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websocketDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.Websocket.self, forKey: .websocket)
        websocket = websocketDecoded
        let connectionCredentialsDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ConnectionCredentials.self, forKey: .connectionCredentials)
        connectionCredentials = connectionCredentialsDecoded
    }
}

public struct DisconnectParticipantInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisconnectParticipantInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisconnectParticipantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisconnectParticipantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisconnectParticipantOutputError>
}

extension DisconnectParticipantInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisconnectParticipantInput(clientToken: \(Swift.String(describing: clientToken)), connectionToken: \(Swift.String(describing: connectionToken)))"}
}

extension DisconnectParticipantInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct DisconnectParticipantInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisconnectParticipantInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisconnectParticipantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: Swift.String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisconnectParticipantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisconnectParticipantOutputError>
}

public struct DisconnectParticipantInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisconnectParticipantInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisconnectParticipantInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisconnectParticipantInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisconnectParticipantOutputError>
}

public struct DisconnectParticipantInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisconnectParticipantInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisconnectParticipantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisconnectParticipantInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisconnectParticipantOutputError>
}

public struct DisconnectParticipantInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisconnectParticipantInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisconnectParticipantInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/participant/disconnect"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisconnectParticipantInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisconnectParticipantOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisconnectParticipantOutputError>
}

public struct DisconnectParticipantInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
    }
}

struct DisconnectParticipantInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
}

extension DisconnectParticipantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisconnectParticipantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectParticipantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisconnectParticipantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectParticipantOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisconnectParticipantOutputResponse()"}
}

extension DisconnectParticipantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisconnectParticipantOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisconnectParticipantOutputResponseBody: Swift.Equatable {
}

extension DisconnectParticipantOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct GetAttachmentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttachmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttachmentOutputError>
}

extension GetAttachmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAttachmentInput(attachmentId: \(Swift.String(describing: attachmentId)), connectionToken: \(Swift.String(describing: connectionToken)))"}
}

extension GetAttachmentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
    }
}

public struct GetAttachmentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttachmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: Swift.String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttachmentOutputError>
}

public struct GetAttachmentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttachmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAttachmentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAttachmentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttachmentOutputError>
}

public struct GetAttachmentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttachmentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttachmentOutputError>
}

public struct GetAttachmentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAttachmentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAttachmentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAttachmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/participant/attachment"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAttachmentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAttachmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAttachmentOutputError>
}

public struct GetAttachmentInput: Swift.Equatable {
    /// A unique identifier for the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?

    public init (
        attachmentId: Swift.String? = nil,
        connectionToken: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
        self.connectionToken = connectionToken
    }
}

struct GetAttachmentInputBody: Swift.Equatable {
    public let attachmentId: Swift.String?
}

extension GetAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
    }
}

extension GetAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAttachmentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAttachmentOutputResponse(url: \(Swift.String(describing: url)), urlExpiry: \(Swift.String(describing: urlExpiry)))"}
}

extension GetAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.url = output.url
            self.urlExpiry = output.urlExpiry
        } else {
            self.url = nil
            self.urlExpiry = nil
        }
    }
}

public struct GetAttachmentOutputResponse: Swift.Equatable {
    /// The pre-signed URL using which file would be downloaded from Amazon S3 by the API caller.
    public var url: Swift.String?
    /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
    public var urlExpiry: Swift.String?

    public init (
        url: Swift.String? = nil,
        urlExpiry: Swift.String? = nil
    )
    {
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

struct GetAttachmentOutputResponseBody: Swift.Equatable {
    public let url: Swift.String?
    public let urlExpiry: Swift.String?
}

extension GetAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
        case urlExpiry = "UrlExpiry"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
    }
}

public struct GetTranscriptInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTranscriptInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTranscriptInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTranscriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTranscriptInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTranscriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTranscriptOutputError>
}

extension GetTranscriptInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTranscriptInput(connectionToken: \(Swift.String(describing: connectionToken)), contactId: \(Swift.String(describing: contactId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), scanDirection: \(Swift.String(describing: scanDirection)), sortOrder: \(Swift.String(describing: sortOrder)), startPosition: \(Swift.String(describing: startPosition)))"}
}

extension GetTranscriptInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scanDirection = "ScanDirection"
        case sortOrder = "SortOrder"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let scanDirection = scanDirection {
            try encodeContainer.encode(scanDirection.rawValue, forKey: .scanDirection)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let startPosition = startPosition {
            try encodeContainer.encode(startPosition, forKey: .startPosition)
        }
    }
}

public struct GetTranscriptInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTranscriptInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTranscriptInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTranscriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: Swift.String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTranscriptInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTranscriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTranscriptOutputError>
}

public struct GetTranscriptInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTranscriptInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetTranscriptInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTranscriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetTranscriptInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetTranscriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTranscriptOutputError>
}

public struct GetTranscriptInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTranscriptInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetTranscriptInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTranscriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTranscriptInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTranscriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTranscriptOutputError>
}

public struct GetTranscriptInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetTranscriptInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetTranscriptInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetTranscriptOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/participant/transcript"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetTranscriptInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetTranscriptOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetTranscriptOutputError>
}

public struct GetTranscriptInput: Swift.Equatable {
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// The contactId from the current contact chain for which transcript is needed.
    public var contactId: Swift.String?
    /// The maximum number of results to return in the page. Default: 10.
    public var maxResults: Swift.Int
    /// The pagination token. Use the value returned previously in the next subsequent request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The direction from StartPosition from which to retrieve message. Default: BACKWARD when no StartPosition is provided, FORWARD with StartPosition.
    public var scanDirection: ConnectParticipantClientTypes.ScanDirection?
    /// The sort order for the records. Default: DESCENDING.
    public var sortOrder: ConnectParticipantClientTypes.SortKey?
    /// A filtering option for where to start.
    public var startPosition: ConnectParticipantClientTypes.StartPosition?

    public init (
        connectionToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        scanDirection: ConnectParticipantClientTypes.ScanDirection? = nil,
        sortOrder: ConnectParticipantClientTypes.SortKey? = nil,
        startPosition: ConnectParticipantClientTypes.StartPosition? = nil
    )
    {
        self.connectionToken = connectionToken
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scanDirection = scanDirection
        self.sortOrder = sortOrder
        self.startPosition = startPosition
    }
}

struct GetTranscriptInputBody: Swift.Equatable {
    public let contactId: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let scanDirection: ConnectParticipantClientTypes.ScanDirection?
    public let sortOrder: ConnectParticipantClientTypes.SortKey?
    public let startPosition: ConnectParticipantClientTypes.StartPosition?
}

extension GetTranscriptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scanDirection = "ScanDirection"
        case sortOrder = "SortOrder"
        case startPosition = "StartPosition"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let scanDirectionDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ScanDirection.self, forKey: .scanDirection)
        scanDirection = scanDirectionDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.SortKey.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let startPositionDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.StartPosition.self, forKey: .startPosition)
        startPosition = startPositionDecoded
    }
}

extension GetTranscriptOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTranscriptOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTranscriptOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTranscriptOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTranscriptOutputResponse(initialContactId: \(Swift.String(describing: initialContactId)), nextToken: \(Swift.String(describing: nextToken)), transcript: \(Swift.String(describing: transcript)))"}
}

extension GetTranscriptOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTranscriptOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initialContactId = output.initialContactId
            self.nextToken = output.nextToken
            self.transcript = output.transcript
        } else {
            self.initialContactId = nil
            self.nextToken = nil
            self.transcript = nil
        }
    }
}

public struct GetTranscriptOutputResponse: Swift.Equatable {
    /// The initial contact ID for the contact.
    public var initialContactId: Swift.String?
    /// The pagination token. Use the value returned previously in the next subsequent request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of messages in the session.
    public var transcript: [ConnectParticipantClientTypes.Item]?

    public init (
        initialContactId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        transcript: [ConnectParticipantClientTypes.Item]? = nil
    )
    {
        self.initialContactId = initialContactId
        self.nextToken = nextToken
        self.transcript = transcript
    }
}

struct GetTranscriptOutputResponseBody: Swift.Equatable {
    public let initialContactId: Swift.String?
    public let transcript: [ConnectParticipantClientTypes.Item]?
    public let nextToken: Swift.String?
}

extension GetTranscriptOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialContactId = "InitialContactId"
        case nextToken = "NextToken"
        case transcript = "Transcript"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let transcriptContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.Item?].self, forKey: .transcript)
        var transcriptDecoded0:[ConnectParticipantClientTypes.Item]? = nil
        if let transcriptContainer = transcriptContainer {
            transcriptDecoded0 = [ConnectParticipantClientTypes.Item]()
            for structure0 in transcriptContainer {
                if let structure0 = structure0 {
                    transcriptDecoded0?.append(structure0)
                }
            }
        }
        transcript = transcriptDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerException(message: \(Swift.String(describing: message)))"}
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception occurs when there is an internal failure in the Amazon Connect service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.Item: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case attachments = "Attachments"
        case content = "Content"
        case contentType = "ContentType"
        case displayName = "DisplayName"
        case id = "Id"
        case participantId = "ParticipantId"
        case participantRole = "ParticipantRole"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTime = absoluteTime {
            try encodeContainer.encode(absoluteTime, forKey: .absoluteTime)
        }
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachments0 in attachments {
                try attachmentsContainer.encode(attachments0)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let participantId = participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let participantRole = participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ChatItemType.self, forKey: .type)
        type = typeDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.AttachmentItem?].self, forKey: .attachments)
        var attachmentsDecoded0:[ConnectParticipantClientTypes.AttachmentItem]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [ConnectParticipantClientTypes.AttachmentItem]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
    }
}

extension ConnectParticipantClientTypes.Item: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Item(absoluteTime: \(Swift.String(describing: absoluteTime)), attachments: \(Swift.String(describing: attachments)), content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)), displayName: \(Swift.String(describing: displayName)), id: \(Swift.String(describing: id)), participantId: \(Swift.String(describing: participantId)), participantRole: \(Swift.String(describing: participantRole)), type: \(Swift.String(describing: type)))"}
}

extension ConnectParticipantClientTypes {
    /// An item - message or event - that has been sent.
    public struct Item: Swift.Equatable {
        /// The time when the message or event was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var absoluteTime: Swift.String?
        /// Provides information about the attachments.
        public var attachments: [ConnectParticipantClientTypes.AttachmentItem]?
        /// The content of the message or event.
        public var content: Swift.String?
        /// The type of content of the item.
        public var contentType: Swift.String?
        /// The chat display name of the sender.
        public var displayName: Swift.String?
        /// The ID of the item.
        public var id: Swift.String?
        /// The ID of the sender in the session.
        public var participantId: Swift.String?
        /// The role of the sender. For example, is it a customer, agent, or system.
        public var participantRole: ConnectParticipantClientTypes.ParticipantRole?
        /// Type of the item: message or event.
        public var type: ConnectParticipantClientTypes.ChatItemType?

        public init (
            absoluteTime: Swift.String? = nil,
            attachments: [ConnectParticipantClientTypes.AttachmentItem]? = nil,
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            participantId: Swift.String? = nil,
            participantRole: ConnectParticipantClientTypes.ParticipantRole? = nil,
            type: ConnectParticipantClientTypes.ChatItemType? = nil
        )
        {
            self.absoluteTime = absoluteTime
            self.attachments = attachments
            self.content = content
            self.contentType = contentType
            self.displayName = displayName
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.type = type
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ParticipantRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case customer
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRole] {
            return [
                .agent,
                .customer,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantRole(rawValue: rawValue) ?? ParticipantRole.sdkUnknown(rawValue)
        }
    }
}

extension ConnectParticipantClientTypes {
    public enum ScanDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backward
        case forward
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanDirection] {
            return [
                .backward,
                .forward,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backward: return "BACKWARD"
            case .forward: return "FORWARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanDirection(rawValue: rawValue) ?? ScanDirection.sdkUnknown(rawValue)
        }
    }
}

public struct SendEventInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendEventOutputError>
}

extension SendEventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendEventInput(clientToken: \(Swift.String(describing: clientToken)), connectionToken: \(Swift.String(describing: connectionToken)), content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)))"}
}

extension SendEventInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

public struct SendEventInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: Swift.String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendEventOutputError>
}

public struct SendEventInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendEventInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendEventInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendEventOutputError>
}

public struct SendEventInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendEventInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SendEventInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendEventInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendEventOutputError>
}

public struct SendEventInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendEventInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SendEventInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/participant/event"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendEventInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendEventOutputError>
}

public struct SendEventInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// The content of the event to be sent (for example, message text). This is not yet supported.
    public var content: Swift.String?
    /// The content type of the request. Supported types are:
    ///
    /// * application/vnd.amazonaws.connect.event.typing
    ///
    /// * application/vnd.amazonaws.connect.event.connection.acknowledged
    /// This member is required.
    public var contentType: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil,
        content: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.content = content
        self.contentType = contentType
    }
}

struct SendEventInputBody: Swift.Equatable {
    public let contentType: Swift.String?
    public let content: Swift.String?
    public let clientToken: Swift.String?
}

extension SendEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension SendEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendEventOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendEventOutputResponse(absoluteTime: \(Swift.String(describing: absoluteTime)), id: \(Swift.String(describing: id)))"}
}

extension SendEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendEventOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.absoluteTime = output.absoluteTime
            self.id = output.id
        } else {
            self.absoluteTime = nil
            self.id = nil
        }
    }
}

public struct SendEventOutputResponse: Swift.Equatable {
    /// The time when the event was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
    public var absoluteTime: Swift.String?
    /// The ID of the response.
    public var id: Swift.String?

    public init (
        absoluteTime: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.absoluteTime = absoluteTime
        self.id = id
    }
}

struct SendEventOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let absoluteTime: Swift.String?
}

extension SendEventOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
    }
}

public struct SendMessageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendMessageOutputError>
}

extension SendMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendMessageInput(clientToken: \(Swift.String(describing: clientToken)), connectionToken: \(Swift.String(describing: connectionToken)), content: \(Swift.String(describing: content)), contentType: \(Swift.String(describing: contentType)))"}
}

extension SendMessageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

public struct SendMessageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: Swift.String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendMessageOutputError>
}

public struct SendMessageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SendMessageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SendMessageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SendMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendMessageOutputError>
}

public struct SendMessageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendMessageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: SendMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendMessageOutputError>
}

public struct SendMessageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SendMessageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: SendMessageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SendMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/participant/message"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SendMessageInput
    public typealias MOutput = ClientRuntime.OperationOutput<SendMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SendMessageOutputError>
}

public struct SendMessageInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The authentication token associated with the connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// The content of the message.
    /// This member is required.
    public var content: Swift.String?
    /// The type of the content. Supported types are text/plain.
    /// This member is required.
    public var contentType: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil,
        content: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.content = content
        self.contentType = contentType
    }
}

struct SendMessageInputBody: Swift.Equatable {
    public let contentType: Swift.String?
    public let content: Swift.String?
    public let clientToken: Swift.String?
}

extension SendMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension SendMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendMessageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendMessageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendMessageOutputResponse(absoluteTime: \(Swift.String(describing: absoluteTime)), id: \(Swift.String(describing: id)))"}
}

extension SendMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.absoluteTime = output.absoluteTime
            self.id = output.id
        } else {
            self.absoluteTime = nil
            self.id = nil
        }
    }
}

public struct SendMessageOutputResponse: Swift.Equatable {
    /// The time when the message was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
    public var absoluteTime: Swift.String?
    /// The ID of the message.
    public var id: Swift.String?

    public init (
        absoluteTime: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.absoluteTime = absoluteTime
        self.id = id
    }
}

struct SendMessageOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let absoluteTime: Swift.String?
}

extension SendMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of attachments per contact exceeds the quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes {
    public enum SortKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKey] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortKey(rawValue: rawValue) ?? SortKey.sdkUnknown(rawValue)
        }
    }
}

public struct StartAttachmentUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAttachmentUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAttachmentUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAttachmentUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAttachmentUploadOutputError>
}

extension StartAttachmentUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAttachmentUploadInput(attachmentName: \(Swift.String(describing: attachmentName)), attachmentSizeInBytes: \(Swift.String(describing: attachmentSizeInBytes)), clientToken: \(Swift.String(describing: clientToken)), connectionToken: \(Swift.String(describing: connectionToken)), contentType: \(Swift.String(describing: contentType)))"}
}

extension StartAttachmentUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentName = "AttachmentName"
        case attachmentSizeInBytes = "AttachmentSizeInBytes"
        case clientToken = "ClientToken"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentName = attachmentName {
            try encodeContainer.encode(attachmentName, forKey: .attachmentName)
        }
        if attachmentSizeInBytes != 0 {
            try encodeContainer.encode(attachmentSizeInBytes, forKey: .attachmentSizeInBytes)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

public struct StartAttachmentUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAttachmentUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAttachmentUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let connectionToken = input.operationInput.connectionToken {
            input.builder.withHeader(name: "X-Amz-Bearer", value: Swift.String(connectionToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAttachmentUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAttachmentUploadOutputError>
}

public struct StartAttachmentUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAttachmentUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartAttachmentUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartAttachmentUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAttachmentUploadOutputError>
}

public struct StartAttachmentUploadInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAttachmentUploadInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartAttachmentUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAttachmentUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAttachmentUploadOutputError>
}

public struct StartAttachmentUploadInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartAttachmentUploadInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartAttachmentUploadInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/participant/start-attachment-upload"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartAttachmentUploadInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartAttachmentUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartAttachmentUploadOutputError>
}

public struct StartAttachmentUploadInput: Swift.Equatable {
    /// A case-sensitive name of the attachment being uploaded.
    /// This member is required.
    public var attachmentName: Swift.String?
    /// The size of the attachment in bytes.
    /// This member is required.
    public var attachmentSizeInBytes: Swift.Int
    /// A unique case sensitive identifier to support idempotency of request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// Describes the MIME file type of the attachment. For a list of supported file types, see [Feature specifications](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#feature-limits) in the Amazon Connect Administrator Guide.
    /// This member is required.
    public var contentType: Swift.String?

    public init (
        attachmentName: Swift.String? = nil,
        attachmentSizeInBytes: Swift.Int = 0,
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.attachmentName = attachmentName
        self.attachmentSizeInBytes = attachmentSizeInBytes
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.contentType = contentType
    }
}

struct StartAttachmentUploadInputBody: Swift.Equatable {
    public let contentType: Swift.String?
    public let attachmentSizeInBytes: Swift.Int
    public let attachmentName: Swift.String?
    public let clientToken: Swift.String?
}

extension StartAttachmentUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentName = "AttachmentName"
        case attachmentSizeInBytes = "AttachmentSizeInBytes"
        case clientToken = "ClientToken"
        case contentType = "ContentType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let attachmentSizeInBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .attachmentSizeInBytes)
        attachmentSizeInBytes = attachmentSizeInBytesDecoded
        let attachmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentName)
        attachmentName = attachmentNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartAttachmentUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAttachmentUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAttachmentUploadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAttachmentUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartAttachmentUploadOutputResponse(attachmentId: \(Swift.String(describing: attachmentId)), uploadMetadata: \(Swift.String(describing: uploadMetadata)))"}
}

extension StartAttachmentUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartAttachmentUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachmentId = output.attachmentId
            self.uploadMetadata = output.uploadMetadata
        } else {
            self.attachmentId = nil
            self.uploadMetadata = nil
        }
    }
}

public struct StartAttachmentUploadOutputResponse: Swift.Equatable {
    /// A unique identifier for the attachment.
    public var attachmentId: Swift.String?
    /// Fields to be used while uploading the attachment.
    public var uploadMetadata: ConnectParticipantClientTypes.UploadMetadata?

    public init (
        attachmentId: Swift.String? = nil,
        uploadMetadata: ConnectParticipantClientTypes.UploadMetadata? = nil
    )
    {
        self.attachmentId = attachmentId
        self.uploadMetadata = uploadMetadata
    }
}

struct StartAttachmentUploadOutputResponseBody: Swift.Equatable {
    public let attachmentId: Swift.String?
    public let uploadMetadata: ConnectParticipantClientTypes.UploadMetadata?
}

extension StartAttachmentUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case uploadMetadata = "UploadMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let uploadMetadataDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.UploadMetadata.self, forKey: .uploadMetadata)
        uploadMetadata = uploadMetadataDecoded
    }
}

extension ConnectParticipantClientTypes.StartPosition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
        case mostRecent = "MostRecent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTime = absoluteTime {
            try encodeContainer.encode(absoluteTime, forKey: .absoluteTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if mostRecent != 0 {
            try encodeContainer.encode(mostRecent, forKey: .mostRecent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
        let mostRecentDecoded = try containerValues.decode(Swift.Int.self, forKey: .mostRecent)
        mostRecent = mostRecentDecoded
    }
}

extension ConnectParticipantClientTypes.StartPosition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartPosition(absoluteTime: \(Swift.String(describing: absoluteTime)), id: \(Swift.String(describing: id)), mostRecent: \(Swift.String(describing: mostRecent)))"}
}

extension ConnectParticipantClientTypes {
    /// A filtering option for where to start. For example, if you sent 100 messages, start with message 50.
    public struct StartPosition: Swift.Equatable {
        /// The time in ISO format where to start. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var absoluteTime: Swift.String?
        /// The ID of the message or event where to start.
        public var id: Swift.String?
        /// The start position of the most recent message where you want to start.
        public var mostRecent: Swift.Int

        public init (
            absoluteTime: Swift.String? = nil,
            id: Swift.String? = nil,
            mostRecent: Swift.Int = 0
        )
        {
            self.absoluteTime = absoluteTime
            self.id = id
            self.mostRecent = mostRecent
        }
    }

}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.UploadMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headersToInclude = "HeadersToInclude"
        case url = "Url"
        case urlExpiry = "UrlExpiry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headersToInclude = headersToInclude {
            var headersToIncludeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headersToInclude)
            for (dictKey0, uploadmetadatasignedheaders0) in headersToInclude {
                try headersToIncludeContainer.encode(uploadmetadatasignedheaders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let urlExpiry = urlExpiry {
            try encodeContainer.encode(urlExpiry, forKey: .urlExpiry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
        let headersToIncludeContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headersToInclude)
        var headersToIncludeDecoded0: [Swift.String:Swift.String]? = nil
        if let headersToIncludeContainer = headersToIncludeContainer {
            headersToIncludeDecoded0 = [Swift.String:Swift.String]()
            for (key0, uploadmetadatasignedheadersvalue0) in headersToIncludeContainer {
                if let uploadmetadatasignedheadersvalue0 = uploadmetadatasignedheadersvalue0 {
                    headersToIncludeDecoded0?[key0] = uploadmetadatasignedheadersvalue0
                }
            }
        }
        headersToInclude = headersToIncludeDecoded0
    }
}

extension ConnectParticipantClientTypes.UploadMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadMetadata(headersToInclude: \(Swift.String(describing: headersToInclude)), url: \(Swift.String(describing: url)), urlExpiry: \(Swift.String(describing: urlExpiry)))"}
}

extension ConnectParticipantClientTypes {
    /// Fields to be used while uploading the attachment.
    public struct UploadMetadata: Swift.Equatable {
        /// The headers to be provided while uploading the file to the URL.
        public var headersToInclude: [Swift.String:Swift.String]?
        /// The pre-signed URL using which file would be downloaded from Amazon S3 by the API caller.
        public var url: Swift.String?
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var urlExpiry: Swift.String?

        public init (
            headersToInclude: [Swift.String:Swift.String]? = nil,
            url: Swift.String? = nil,
            urlExpiry: Swift.String? = nil
        )
        {
            self.headersToInclude = headersToInclude
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by Amazon Connect.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.Websocket: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionExpiry = "ConnectionExpiry"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionExpiry = connectionExpiry {
            try encodeContainer.encode(connectionExpiry, forKey: .connectionExpiry)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let connectionExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionExpiry)
        connectionExpiry = connectionExpiryDecoded
    }
}

extension ConnectParticipantClientTypes.Websocket: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Websocket(connectionExpiry: \(Swift.String(describing: connectionExpiry)), url: \(Swift.String(describing: url)))"}
}

extension ConnectParticipantClientTypes {
    /// The websocket for the participant's connection.
    public struct Websocket: Swift.Equatable {
        /// The URL expiration timestamp in ISO date format. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var connectionExpiry: Swift.String?
        /// The URL of the websocket.
        public var url: Swift.String?

        public init (
            connectionExpiry: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.connectionExpiry = connectionExpiry
            self.url = url
        }
    }

}
