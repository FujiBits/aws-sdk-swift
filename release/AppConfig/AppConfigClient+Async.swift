// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension AppConfigClient {
    /// <p>An application in AppConfig is a logical unit of code that provides capabilities for your
    ///          customers. For example, an application can be a microservice that runs on Amazon EC2 instances,
    ///          a mobile application installed by your users, a serverless application using Amazon API
    ///          Gateway and AWS Lambda, or any system you run on behalf of others.</p>
    func createApplication(input: CreateApplicationInput) async throws -> CreateApplicationOutputResponse
    {
        typealias createApplicationContinuation = CheckedContinuation<CreateApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createApplicationContinuation) in
            createApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Information that enables AppConfig to access the configuration source. Valid
    ///          configuration sources include Systems Manager (SSM) documents, SSM Parameter Store parameters, and
    ///          Amazon S3 objects. A configuration profile includes the following information.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The Uri location of the configuration data.</p>
    ///             </li>
    ///             <li>
    ///                <p>The AWS Identity and Access Management (IAM) role that provides access to the configuration data.</p>
    ///             </li>
    ///             <li>
    ///                <p>A validator for the configuration data. Available validators include either a JSON
    ///                Schema or an AWS Lambda function.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/appconfig-creating-configuration-and-profile.html">Create a
    ///             Configuration and a Configuration Profile</a> in the
    ///             <i>AWS AppConfig User Guide</i>.</p>
    func createConfigurationProfile(input: CreateConfigurationProfileInput) async throws -> CreateConfigurationProfileOutputResponse
    {
        typealias createConfigurationProfileContinuation = CheckedContinuation<CreateConfigurationProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createConfigurationProfileContinuation) in
            createConfigurationProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>A deployment strategy defines important criteria for rolling out your configuration to
    ///          the designated targets. A deployment strategy includes: the overall duration required, a
    ///          percentage of targets to receive the deployment during each interval, an algorithm that
    ///          defines how percentage grows, and bake time.</p>
    func createDeploymentStrategy(input: CreateDeploymentStrategyInput) async throws -> CreateDeploymentStrategyOutputResponse
    {
        typealias createDeploymentStrategyContinuation = CheckedContinuation<CreateDeploymentStrategyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeploymentStrategyContinuation) in
            createDeploymentStrategy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>For each application, you define one or more environments. An environment is a logical
    ///          deployment group of AppConfig targets, such as applications in a <code>Beta</code> or
    ///             <code>Production</code> environment. You can also define environments for application
    ///          subcomponents such as the <code>Web</code>, <code>Mobile</code> and <code>Back-end</code>
    ///          components for your application. You can configure Amazon CloudWatch alarms for each environment.
    ///          The system monitors alarms during a configuration deployment. If an alarm is triggered, the
    ///          system rolls back the configuration.</p>
    func createEnvironment(input: CreateEnvironmentInput) async throws -> CreateEnvironmentOutputResponse
    {
        typealias createEnvironmentContinuation = CheckedContinuation<CreateEnvironmentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createEnvironmentContinuation) in
            createEnvironment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Create a new configuration in the AppConfig configuration store.</p>
    func createHostedConfigurationVersion(input: CreateHostedConfigurationVersionInput) async throws -> CreateHostedConfigurationVersionOutputResponse
    {
        typealias createHostedConfigurationVersionContinuation = CheckedContinuation<CreateHostedConfigurationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createHostedConfigurationVersionContinuation) in
            createHostedConfigurationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Delete an application. Deleting an application does not delete a configuration from a
    ///          host.</p>
    func deleteApplication(input: DeleteApplicationInput) async throws -> DeleteApplicationOutputResponse
    {
        typealias deleteApplicationContinuation = CheckedContinuation<DeleteApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteApplicationContinuation) in
            deleteApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Delete a configuration profile. Deleting a configuration profile does not delete a
    ///          configuration from a host.</p>
    func deleteConfigurationProfile(input: DeleteConfigurationProfileInput) async throws -> DeleteConfigurationProfileOutputResponse
    {
        typealias deleteConfigurationProfileContinuation = CheckedContinuation<DeleteConfigurationProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteConfigurationProfileContinuation) in
            deleteConfigurationProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Delete a deployment strategy. Deleting a deployment strategy does not delete a
    ///          configuration from a host.</p>
    func deleteDeploymentStrategy(input: DeleteDeploymentStrategyInput) async throws -> DeleteDeploymentStrategyOutputResponse
    {
        typealias deleteDeploymentStrategyContinuation = CheckedContinuation<DeleteDeploymentStrategyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDeploymentStrategyContinuation) in
            deleteDeploymentStrategy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Delete an environment. Deleting an environment does not delete a configuration from a
    ///          host.</p>
    func deleteEnvironment(input: DeleteEnvironmentInput) async throws -> DeleteEnvironmentOutputResponse
    {
        typealias deleteEnvironmentContinuation = CheckedContinuation<DeleteEnvironmentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteEnvironmentContinuation) in
            deleteEnvironment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Delete a version of a configuration from the AppConfig configuration store.</p>
    func deleteHostedConfigurationVersion(input: DeleteHostedConfigurationVersionInput) async throws -> DeleteHostedConfigurationVersionOutputResponse
    {
        typealias deleteHostedConfigurationVersionContinuation = CheckedContinuation<DeleteHostedConfigurationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteHostedConfigurationVersionContinuation) in
            deleteHostedConfigurationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieve information about an application.</p>
    func getApplication(input: GetApplicationInput) async throws -> GetApplicationOutputResponse
    {
        typealias getApplicationContinuation = CheckedContinuation<GetApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getApplicationContinuation) in
            getApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Receive information about a configuration.</p>
    ///          <important>
    ///             <p>AWS AppConfig uses the value of the <code>ClientConfigurationVersion</code> parameter
    ///             to identify the configuration version on your clients. If you don’t send
    ///                <code>ClientConfigurationVersion</code> with each call to
    ///                <code>GetConfiguration</code>, your clients receive the current configuration. You
    ///             are charged each time your clients receive a configuration.</p>
    ///             <p>To avoid excess charges, we recommend that you include the
    ///                <code>ClientConfigurationVersion</code> value with every call to
    ///                <code>GetConfiguration</code>. This value must be saved on your client. Subsequent
    ///             calls to <code>GetConfiguration</code> must pass this value by using the
    ///                <code>ClientConfigurationVersion</code> parameter. </p>
    ///          </important>
    func getConfiguration(input: GetConfigurationInput) async throws -> GetConfigurationOutputResponse
    {
        typealias getConfigurationContinuation = CheckedContinuation<GetConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConfigurationContinuation) in
            getConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieve information about a configuration profile.</p>
    func getConfigurationProfile(input: GetConfigurationProfileInput) async throws -> GetConfigurationProfileOutputResponse
    {
        typealias getConfigurationProfileContinuation = CheckedContinuation<GetConfigurationProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConfigurationProfileContinuation) in
            getConfigurationProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieve information about a configuration deployment.</p>
    func getDeployment(input: GetDeploymentInput) async throws -> GetDeploymentOutputResponse
    {
        typealias getDeploymentContinuation = CheckedContinuation<GetDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentContinuation) in
            getDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieve information about a deployment strategy. A deployment strategy defines
    ///          important criteria for rolling out your configuration to the designated targets. A
    ///          deployment strategy includes: the overall duration required, a percentage of targets to
    ///          receive the deployment during each interval, an algorithm that defines how percentage
    ///          grows, and bake time.</p>
    func getDeploymentStrategy(input: GetDeploymentStrategyInput) async throws -> GetDeploymentStrategyOutputResponse
    {
        typealias getDeploymentStrategyContinuation = CheckedContinuation<GetDeploymentStrategyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentStrategyContinuation) in
            getDeploymentStrategy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieve information about an environment. An environment is a logical deployment group
    ///          of AppConfig applications, such as applications in a <code>Production</code> environment or
    ///          in an <code>EU_Region</code> environment. Each configuration deployment targets an
    ///          environment. You can enable one or more Amazon CloudWatch alarms for an environment. If an alarm is
    ///          triggered during a deployment, AppConfig roles back the configuration.</p>
    func getEnvironment(input: GetEnvironmentInput) async throws -> GetEnvironmentOutputResponse
    {
        typealias getEnvironmentContinuation = CheckedContinuation<GetEnvironmentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getEnvironmentContinuation) in
            getEnvironment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Get information about a specific configuration version.</p>
    func getHostedConfigurationVersion(input: GetHostedConfigurationVersionInput) async throws -> GetHostedConfigurationVersionOutputResponse
    {
        typealias getHostedConfigurationVersionContinuation = CheckedContinuation<GetHostedConfigurationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getHostedConfigurationVersionContinuation) in
            getHostedConfigurationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List all applications in your AWS account.</p>
    func listApplications(input: ListApplicationsInput) async throws -> ListApplicationsOutputResponse
    {
        typealias listApplicationsContinuation = CheckedContinuation<ListApplicationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listApplicationsContinuation) in
            listApplications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the configuration profiles for an application.</p>
    func listConfigurationProfiles(input: ListConfigurationProfilesInput) async throws -> ListConfigurationProfilesOutputResponse
    {
        typealias listConfigurationProfilesContinuation = CheckedContinuation<ListConfigurationProfilesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listConfigurationProfilesContinuation) in
            listConfigurationProfiles(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List deployment strategies.</p>
    func listDeploymentStrategies(input: ListDeploymentStrategiesInput) async throws -> ListDeploymentStrategiesOutputResponse
    {
        typealias listDeploymentStrategiesContinuation = CheckedContinuation<ListDeploymentStrategiesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentStrategiesContinuation) in
            listDeploymentStrategies(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Lists the deployments for an environment.</p>
    func listDeployments(input: ListDeploymentsInput) async throws -> ListDeploymentsOutputResponse
    {
        typealias listDeploymentsContinuation = CheckedContinuation<ListDeploymentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentsContinuation) in
            listDeployments(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>List the environments for an application.</p>
    func listEnvironments(input: ListEnvironmentsInput) async throws -> ListEnvironmentsOutputResponse
    {
        typealias listEnvironmentsContinuation = CheckedContinuation<ListEnvironmentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listEnvironmentsContinuation) in
            listEnvironments(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>View a list of configurations stored in the AppConfig configuration store by
    ///          version.</p>
    func listHostedConfigurationVersions(input: ListHostedConfigurationVersionsInput) async throws -> ListHostedConfigurationVersionsOutputResponse
    {
        typealias listHostedConfigurationVersionsContinuation = CheckedContinuation<ListHostedConfigurationVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listHostedConfigurationVersionsContinuation) in
            listHostedConfigurationVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Retrieves the list of key-value tags assigned to the resource.</p>
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Starts a deployment.</p>
    func startDeployment(input: StartDeploymentInput) async throws -> StartDeploymentOutputResponse
    {
        typealias startDeploymentContinuation = CheckedContinuation<StartDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startDeploymentContinuation) in
            startDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Stops a deployment. This API action works only on deployments that have a status of
    ///             <code>DEPLOYING</code>. This action moves the deployment to a status of
    ///             <code>ROLLED_BACK</code>.</p>
    func stopDeployment(input: StopDeploymentInput) async throws -> StopDeploymentOutputResponse
    {
        typealias stopDeploymentContinuation = CheckedContinuation<StopDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopDeploymentContinuation) in
            stopDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Metadata to assign to an AppConfig resource. Tags help organize and categorize your
    ///          AppConfig resources. Each tag consists of a key and an optional value, both of which you
    ///          define. You can specify a maximum of 50 tags for a resource.</p>
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Deletes a tag key and value from an AppConfig resource.</p>
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an application.</p>
    func updateApplication(input: UpdateApplicationInput) async throws -> UpdateApplicationOutputResponse
    {
        typealias updateApplicationContinuation = CheckedContinuation<UpdateApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateApplicationContinuation) in
            updateApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a configuration profile.</p>
    func updateConfigurationProfile(input: UpdateConfigurationProfileInput) async throws -> UpdateConfigurationProfileOutputResponse
    {
        typealias updateConfigurationProfileContinuation = CheckedContinuation<UpdateConfigurationProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateConfigurationProfileContinuation) in
            updateConfigurationProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates a deployment strategy.</p>
    func updateDeploymentStrategy(input: UpdateDeploymentStrategyInput) async throws -> UpdateDeploymentStrategyOutputResponse
    {
        typealias updateDeploymentStrategyContinuation = CheckedContinuation<UpdateDeploymentStrategyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateDeploymentStrategyContinuation) in
            updateDeploymentStrategy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Updates an environment.</p>
    func updateEnvironment(input: UpdateEnvironmentInput) async throws -> UpdateEnvironmentOutputResponse
    {
        typealias updateEnvironmentContinuation = CheckedContinuation<UpdateEnvironmentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateEnvironmentContinuation) in
            updateEnvironment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// <p>Uses the validators in a configuration profile to validate a configuration.</p>
    func validateConfiguration(input: ValidateConfigurationInput) async throws -> ValidateConfigurationOutputResponse
    {
        typealias validateConfigurationContinuation = CheckedContinuation<ValidateConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: validateConfigurationContinuation) in
            validateConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
